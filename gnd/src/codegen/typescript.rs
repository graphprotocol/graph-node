//! TypeScript/AssemblyScript code generation utilities.
//!
//! This module provides builder types for generating TypeScript/AssemblyScript code,
//! matching the output format of the TS CLI's `codegen/typescript.ts`.

use std::fmt::{self, Display};

/// Note prepended to all generated files.
pub const GENERATED_FILE_NOTE: &str = r#"
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
"#;

/// A function/method parameter.
#[derive(Debug, Clone)]
pub struct Param {
    pub name: String,
    pub param_type: Box<TypeExpr>,
}

impl Param {
    pub fn new(name: impl Into<String>, param_type: impl Into<TypeExpr>) -> Self {
        Self {
            name: name.into(),
            param_type: Box::new(param_type.into()),
        }
    }
}

impl Display for Param {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}: {}", self.name, self.param_type)
    }
}

/// A type expression (named type, array type, or nullable type).
#[derive(Debug, Clone)]
pub enum TypeExpr {
    Named(NamedType),
    Array(ArrayType),
    Nullable(NullableType),
    /// Raw string type (for complex types like `ethereum.CallResult<T>`)
    Raw(String),
}

impl From<NamedType> for TypeExpr {
    fn from(t: NamedType) -> Self {
        TypeExpr::Named(t)
    }
}

impl From<ArrayType> for TypeExpr {
    fn from(t: ArrayType) -> Self {
        TypeExpr::Array(t)
    }
}

impl From<NullableType> for TypeExpr {
    fn from(t: NullableType) -> Self {
        TypeExpr::Nullable(t)
    }
}

impl From<&str> for TypeExpr {
    fn from(s: &str) -> Self {
        TypeExpr::Named(NamedType::new(s))
    }
}

impl From<String> for TypeExpr {
    fn from(s: String) -> Self {
        TypeExpr::Named(NamedType::new(s))
    }
}

impl Display for TypeExpr {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            TypeExpr::Named(t) => write!(f, "{}", t),
            TypeExpr::Array(t) => write!(f, "{}", t),
            TypeExpr::Nullable(t) => write!(f, "{}", t),
            TypeExpr::Raw(s) => write!(f, "{}", s),
        }
    }
}

/// A named type (e.g., `string`, `BigInt`, `MyEntity`).
#[derive(Debug, Clone)]
pub struct NamedType {
    pub name: String,
}

impl NamedType {
    pub fn new(name: impl Into<String>) -> Self {
        Self { name: name.into() }
    }

    /// Capitalize the first letter of the type name.
    pub fn capitalize(&mut self) -> &mut Self {
        if let Some(c) = self.name.chars().next() {
            self.name = c.to_uppercase().collect::<String>() + &self.name[c.len_utf8()..];
        }
        self
    }

    /// Returns true if this is a primitive AssemblyScript type.
    pub fn is_primitive(&self) -> bool {
        matches!(
            self.name.as_str(),
            "boolean"
                | "u8"
                | "i8"
                | "u16"
                | "i16"
                | "u32"
                | "i32"
                | "u64"
                | "i64"
                | "f32"
                | "f64"
                | "usize"
                | "isize"
        )
    }

    /// Returns the default value for primitive types, or None if not a primitive.
    pub fn get_primitive_default(&self) -> Option<&'static str> {
        if !self.is_primitive() {
            return None;
        }
        match self.name.as_str() {
            "boolean" => Some("false"),
            "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "u64" | "i64" | "f32" | "f64"
            | "usize" | "isize" => Some("0"),
            _ => None,
        }
    }
}

impl Display for NamedType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.name)
    }
}

/// An array type (e.g., `Array<string>`).
#[derive(Debug, Clone)]
pub struct ArrayType {
    pub inner: NamedType,
}

impl ArrayType {
    pub fn new(inner: NamedType) -> Self {
        Self { inner }
    }
}

impl Display for ArrayType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Array<{}>", self.inner)
    }
}

/// A nullable type (e.g., `string | null`).
#[derive(Debug, Clone)]
pub struct NullableType {
    pub inner: Box<TypeExpr>,
}

impl NullableType {
    pub fn new(inner: impl Into<TypeExpr>) -> Self {
        Self {
            inner: Box::new(inner.into()),
        }
    }
}

impl Display for NullableType {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} | null", self.inner)
    }
}

/// A class method.
#[derive(Debug, Clone)]
pub struct Method {
    pub name: String,
    pub params: Vec<Param>,
    pub return_type: Option<TypeExpr>,
    pub body: String,
}

impl Method {
    pub fn new(
        name: impl Into<String>,
        params: Vec<Param>,
        return_type: Option<TypeExpr>,
        body: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            params,
            return_type,
            body: body.into(),
        }
    }
}

impl Display for Method {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let params = self
            .params
            .iter()
            .map(|p| p.to_string())
            .collect::<Vec<_>>()
            .join(", ");
        let return_type = self
            .return_type
            .as_ref()
            .map(|t| format!(": {}", t))
            .unwrap_or_default();
        write!(
            f,
            "\n  {}({}){} {{{}\n  }}\n",
            self.name, params, return_type, self.body
        )
    }
}

/// A static class method.
#[derive(Debug, Clone)]
pub struct StaticMethod {
    pub name: String,
    pub params: Vec<Param>,
    pub return_type: TypeExpr,
    pub body: String,
}

impl StaticMethod {
    pub fn new(
        name: impl Into<String>,
        params: Vec<Param>,
        return_type: impl Into<TypeExpr>,
        body: impl Into<String>,
    ) -> Self {
        Self {
            name: name.into(),
            params,
            return_type: return_type.into(),
            body: body.into(),
        }
    }
}

impl Display for StaticMethod {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let params = self
            .params
            .iter()
            .map(|p| p.to_string())
            .collect::<Vec<_>>()
            .join(", ");
        write!(
            f,
            "\n  static {}({}): {} {{{}\n  }}\n",
            self.name, params, self.return_type, self.body
        )
    }
}

/// A class member (field).
#[derive(Debug, Clone)]
pub struct ClassMember {
    pub name: String,
    pub member_type: String,
}

impl ClassMember {
    pub fn new(name: impl Into<String>, member_type: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            member_type: member_type.into(),
        }
    }
}

impl Display for ClassMember {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "  {}: {}", self.name, self.member_type)
    }
}

/// Code that can be part of a class body (method or static method).
#[allow(dead_code)]
pub enum ClassCode {
    Method(Method),
    StaticMethod(StaticMethod),
}

impl Display for ClassCode {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ClassCode::Method(m) => write!(f, "{}", m),
            ClassCode::StaticMethod(m) => write!(f, "{}", m),
        }
    }
}

/// A TypeScript/AssemblyScript class.
#[derive(Debug, Clone)]
pub struct Class {
    pub name: String,
    pub extends: Option<String>,
    pub export: bool,
    pub members: Vec<ClassMember>,
    pub methods: Vec<Method>,
    pub static_methods: Vec<StaticMethod>,
}

impl Class {
    pub fn new(name: impl Into<String>) -> Self {
        Self {
            name: name.into(),
            extends: None,
            export: false,
            members: Vec::new(),
            methods: Vec::new(),
            static_methods: Vec::new(),
        }
    }

    pub fn exported(mut self) -> Self {
        self.export = true;
        self
    }

    pub fn extends(mut self, base: impl Into<String>) -> Self {
        self.extends = Some(base.into());
        self
    }

    pub fn add_member(&mut self, member: ClassMember) {
        self.members.push(member);
    }

    pub fn add_method(&mut self, method: Method) {
        self.methods.push(method);
    }

    pub fn add_static_method(&mut self, method: StaticMethod) {
        self.static_methods.push(method);
    }
}

impl Display for Class {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let export = if self.export { "export " } else { "" };
        let extends = self
            .extends
            .as_ref()
            .map(|e| format!(" extends {}", e))
            .unwrap_or_default();

        writeln!(f, "\n{}class {}{} {{", export, self.name, extends)?;

        // Write members
        for member in &self.members {
            writeln!(f, "{}", member)?;
        }

        // Write methods (regular and static)
        for method in &self.static_methods {
            write!(f, "{}", method)?;
        }
        for method in &self.methods {
            write!(f, "{}", method)?;
        }

        writeln!(f, "}}")
    }
}

/// An import statement.
#[derive(Debug, Clone)]
pub struct ModuleImports {
    pub names: Vec<String>,
    pub module: String,
}

impl ModuleImports {
    pub fn new(names: Vec<String>, module: impl Into<String>) -> Self {
        Self {
            names,
            module: module.into(),
        }
    }

    pub fn single(name: impl Into<String>, module: impl Into<String>) -> Self {
        Self {
            names: vec![name.into()],
            module: module.into(),
        }
    }
}

impl Display for ModuleImports {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let names = self.names.join(", ");
        write!(f, "import {{ {} }} from \"{}\"", names, self.module)
    }
}

/// Helper functions matching the TS CLI API.
pub fn klass(name: impl Into<String>) -> Class {
    Class::new(name)
}

pub fn klass_member(name: impl Into<String>, member_type: impl Into<String>) -> ClassMember {
    ClassMember::new(name, member_type)
}

#[cfg(test)]
mod tests {
    use super::*;

    pub fn named_type(name: impl Into<String>) -> NamedType {
        NamedType::new(name)
    }

    pub fn param(name: impl Into<String>, param_type: impl Into<TypeExpr>) -> Param {
        Param::new(name, param_type)
    }

    pub fn method(
        name: impl Into<String>,
        params: Vec<Param>,
        return_type: Option<TypeExpr>,
        body: impl Into<String>,
    ) -> Method {
        Method::new(name, params, return_type, body)
    }

    #[test]
    fn test_method() {
        let m = method(
            "save",
            vec![],
            Some(named_type("void").into()),
            "\n    store.set('Entity', this.id, this)\n  ",
        );
        let output = m.to_string();
        assert!(output.contains("save()"));
        assert!(output.contains(": void"));
        assert!(output.contains("store.set"));
    }

    #[test]
    fn test_class() {
        let mut c = klass("MyEntity").exported().extends("Entity");
        c.add_method(method(
            "constructor",
            vec![param("id", named_type("string"))],
            None,
            "\n    super()\n    this.set('id', Value.fromString(id))\n  ",
        ));
        let output = c.to_string();
        assert!(output.contains("export class MyEntity extends Entity"));
        assert!(output.contains("constructor(id: string)"));
    }

    #[test]
    fn test_is_primitive() {
        assert!(named_type("boolean").is_primitive());
        assert!(named_type("i32").is_primitive());
        assert!(!named_type("string").is_primitive());
        assert!(!named_type("BigInt").is_primitive());
    }
}

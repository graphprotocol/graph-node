-- This file was generated by generate.sh in this directory
set search_path = public;
create type public.text_and_value as (
  arg text,
  value int8
);

create or replace function arg_min_agg_text (a text_and_value, b text_and_value)
  returns text_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value <= b.value then a
             else b end';

create or replace function arg_max_agg_text (a text_and_value, b text_and_value)
  returns text_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value > b.value then a
             else b end';

create function arg_from_text_and_value(a text_and_value)
  returns text
  language sql immutable strict parallel safe as
'select a.arg';

create aggregate arg_min_text (text_and_value) (
  sfunc    = arg_min_agg_text,
  stype    = text_and_value,
  finalfunc = arg_from_text_and_value,
  parallel = safe
);

comment on aggregate arg_min_text(text_and_value) is
'For ''select arg_min_text((arg, value)) from ..'' return the arg for the smallest value';

create aggregate arg_max_text (text_and_value) (
  sfunc    = arg_max_agg_text,
  stype    = text_and_value,
  finalfunc = arg_from_text_and_value,
  parallel = safe
);

comment on aggregate arg_max_text(text_and_value) is
'For ''select arg_max_text((arg, value)) from ..'' return the arg for the largest value';
create type public.bytea_and_value as (
  arg bytea,
  value int8
);

create or replace function arg_min_agg_bytea (a bytea_and_value, b bytea_and_value)
  returns bytea_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value <= b.value then a
             else b end';

create or replace function arg_max_agg_bytea (a bytea_and_value, b bytea_and_value)
  returns bytea_and_value
  language sql immutable strict parallel safe as
'select case when a.arg is null then b
             when b.arg is null then a
             when a.value > b.value then a
             else b end';

create function arg_from_bytea_and_value(a bytea_and_value)
  returns bytea
  language sql immutable strict parallel safe as
'select a.arg';

create aggregate arg_min_bytea (bytea_and_value) (
  sfunc    = arg_min_agg_bytea,
  stype    = bytea_and_value,
  finalfunc = arg_from_bytea_and_value,
  parallel = safe
);

comment on aggregate arg_min_bytea(bytea_and_value) is
'For ''select arg_min_bytea((arg, value)) from ..'' return the arg for the smallest value';

create aggregate arg_max_bytea (bytea_and_value) (
  sfunc    = arg_max_agg_bytea,
  stype    = bytea_and_value,
  finalfunc = arg_from_bytea_and_value,
  parallel = safe
);

comment on aggregate arg_max_bytea(bytea_and_value) is
'For ''select arg_max_bytea((arg, value)) from ..'' return the arg for the largest value';

use http::status::StatusCode;
use hyper::{Body, Response};
use serde::ser::*;

use graph::components::server::query::GraphQLServerError;
use graph::data::query::QueryResult;

use graph::prelude::*;

use serde_json;

/// Future for HTTP responses to GraphQL query requests.
pub struct IndexNodeResponse {
    result: Result<QueryResult, GraphQLServerError>,
}

impl IndexNodeResponse {
    /// Creates a new IndexNodeResponse future based on the result generated by
    /// running a query.
    pub fn new(result: Result<QueryResult, GraphQLServerError>) -> Self {
        IndexNodeResponse { result }
    }

    fn status_code_from_result(&self) -> StatusCode {
        match self.result {
            Ok(_) => StatusCode::OK,
            Err(GraphQLServerError::ClientError(_)) | Err(GraphQLServerError::QueryError(_)) => {
                StatusCode::BAD_REQUEST
            }
            Err(GraphQLServerError::Canceled(_)) | Err(GraphQLServerError::InternalError(_)) => {
                StatusCode::INTERNAL_SERVER_ERROR
            }
        }
    }
}

impl Serialize for IndexNodeResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self.result {
            Ok(ref result) => result.serialize(serializer),
            Err(ref e) => {
                let mut map = serializer.serialize_map(Some(1))?;
                let errors = vec![e];
                map.serialize_entry("errors", &errors)?;
                map.end()
            }
        }
    }
}

impl Future for IndexNodeResponse {
    type Item = Response<Body>;
    type Error = GraphQLServerError;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        let status_code = self.status_code_from_result();
        let json =
            serde_json::to_string(self).expect("Failed to serialize GraphQL response to JSON");
        let response = Response::builder()
            .status(status_code)
            .header("Access-Control-Allow-Origin", "*")
            .header("Access-Control-Allow-Headers", "Content-Type, User-Agent")
            .header("Access-Control-Allow-Methods", "GET, OPTIONS, POST")
            .header("Content-Type", "application/json")
            .body(Body::from(json))
            .unwrap();
        Ok(Async::Ready(response))
    }
}

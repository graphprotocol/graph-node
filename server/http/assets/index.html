<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8"/>
        <title>Yoga GraphiQL</title>
        <link rel="icon" href="https://www.graphql-yoga.com/favicon.ico"/>
        <style>
            .graphiql-container,.graphiql-container button,.graphiql-container input {
                color: #141823;
                font-family: system,-apple-system,San Francisco,".SFNSDisplay-Regular",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;
                font-size: 14px
            }

            .graphiql-container {
                display: flex;
                flex-direction: row;
                height: 100%;
                margin: 0;
                overflow: hidden;
                width: 100%
            }

            .graphiql-container .editorWrap {
                display: flex;
                flex-direction: column;
                flex: 1;
                overflow-x: hidden
            }

            .graphiql-container .title {
                font-size: 18px
            }

            .graphiql-container .title em {
                font-family: georgia;
                font-size: 19px
            }

            .graphiql-container .topBarWrap {
                display: flex;
                flex-direction: row
            }

            .graphiql-container .topBar {
                align-items: center;
                background: linear-gradient(#f7f7f7,#e2e2e2);
                border-bottom: 1px solid #d0d0d0;
                cursor: default;
                display: flex;
                flex-direction: row;
                flex: 1;
                height: 34px;
                overflow-y: visible;
                padding: 7px 14px 6px;
                user-select: none
            }

            .graphiql-container .toolbar {
                overflow-x: visible;
                display: flex
            }

            .graphiql-container .docExplorerShow,.graphiql-container .historyShow {
                background: linear-gradient(#f7f7f7,#e2e2e2);
                border-radius: 0;
                border-bottom: 1px solid #d0d0d0;
                border-right: none;
                border-top: none;
                color: #3b5998;
                cursor: pointer;
                font-size: 14px;
                margin: 0;
                padding: 2px 20px 0 18px
            }

            .graphiql-container .docExplorerShow {
                border-left: 1px solid rgba(0,0,0,.2)
            }

            .graphiql-container .historyShow {
                border-right: 1px solid rgba(0,0,0,.2);
                border-left: 0
            }

            .graphiql-container .docExplorerShow:before {
                border-left: 2px solid #3B5998;
                border-top: 2px solid #3B5998;
                content: "";
                display: inline-block;
                height: 9px;
                margin: 0 3px -1px 0;
                position: relative;
                transform: rotate(-45deg);
                width: 9px
            }

            .graphiql-container .editorBar {
                display: flex;
                flex-direction: row;
                flex: 1
            }

            .graphiql-container .queryWrap {
                display: flex;
                flex-direction: column;
                flex: 1
            }

            .graphiql-container .resultWrap {
                border-left: solid 1px #e0e0e0;
                display: flex;
                flex-direction: column;
                flex: 1;
                flex-basis: 1em;
                position: relative
            }

            .graphiql-container .docExplorerWrap,.graphiql-container .historyPaneWrap {
                background: white;
                box-shadow: 0 0 8px #00000026;
                position: relative;
                z-index: 3
            }

            .graphiql-container .historyPaneWrap {
                min-width: 230px;
                z-index: 5
            }

            .graphiql-container .docExplorerResizer {
                cursor: col-resize;
                height: 100%;
                left: -5px;
                position: absolute;
                top: 0;
                width: 10px;
                z-index: 10
            }

            .graphiql-container .docExplorerHide {
                cursor: pointer;
                font-size: 18px;
                margin: -7px -8px -6px 0;
                padding: 18px 16px 15px 12px;
                background: 0;
                border: 0;
                line-height: 14px
            }

            .graphiql-container div .query-editor {
                flex: 1;
                position: relative
            }

            .graphiql-container .secondary-editor {
                display: flex;
                flex-direction: column;
                height: 30px;
                position: relative
            }

            .graphiql-container .secondary-editor-title {
                background: #eeeeee;
                border-bottom: 1px solid #d6d6d6;
                border-top: 1px solid #e0e0e0;
                color: #777;
                font-variant: small-caps;
                font-weight: 700;
                letter-spacing: 1px;
                line-height: 14px;
                padding: 6px 0 8px 43px;
                text-transform: lowercase;
                user-select: none
            }

            .graphiql-container .codemirrorWrap,.graphiql-container .result-window {
                flex: 1;
                height: 100%;
                position: relative
            }

            .graphiql-container .footer {
                background: #f6f7f8;
                border-left: 1px solid #e0e0e0;
                border-top: 1px solid #e0e0e0;
                margin-left: 12px;
                position: relative
            }

            .graphiql-container .footer:before {
                background: #eeeeee;
                bottom: 0;
                content: " ";
                left: -13px;
                position: absolute;
                top: -1px;
                width: 12px
            }

            .result-window .CodeMirror.cm-s-graphiql {
                background: #f6f7f8
            }

            .graphiql-container .result-window .CodeMirror-gutters {
                background-color: #eee;
                border-color: #e0e0e0;
                cursor: col-resize
            }

            .graphiql-container .result-window .CodeMirror-foldgutter,.graphiql-container .result-window .CodeMirror-foldgutter-open:after,.graphiql-container .result-window .CodeMirror-foldgutter-folded:after {
                padding-left: 3px
            }

            .graphiql-container .toolbar-button {
                background: #fdfdfd;
                background: linear-gradient(#f9f9f9,#ececec);
                border: 0;
                border-radius: 3px;
                box-shadow: inset 0 0 0 1px #0003,0 1px #ffffffb3,inset 0 1px #fff;
                color: #555;
                cursor: pointer;
                display: inline-block;
                margin: 0 5px;
                padding: 3px 11px 5px;
                text-decoration: none;
                text-overflow: ellipsis;
                white-space: nowrap;
                max-width: 150px
            }

            .graphiql-container .toolbar-button:active {
                background: linear-gradient(#ececec,#d5d5d5);
                box-shadow: 0 1px #ffffffb3,inset 0 0 0 1px #0000001a,inset 0 1px 1px 1px #0000001f,inset 0 0 5px #0000001a
            }

            .graphiql-container .toolbar-button.error {
                background: linear-gradient(#fdf3f3,#e6d6d7);
                color: #b00
            }

            .graphiql-container .toolbar-button-group {
                margin: 0 5px;
                white-space: nowrap
            }

            .graphiql-container .toolbar-button-group>* {
                margin: 0
            }

            .graphiql-container .toolbar-button-group>*:not(:last-child) {
                border-top-right-radius: 0;
                border-bottom-right-radius: 0
            }

            .graphiql-container .toolbar-button-group>*:not(:first-child) {
                border-top-left-radius: 0;
                border-bottom-left-radius: 0;
                margin-left: -1px
            }

            .graphiql-container .execute-button-wrap {
                height: 34px;
                margin: 0 14px 0 28px;
                position: relative
            }

            .graphiql-container .execute-button {
                background: linear-gradient(#fdfdfd,#d2d3d6);
                border-radius: 17px;
                border: 1px solid rgba(0,0,0,.25);
                box-shadow: 0 1px #fff;
                cursor: pointer;
                fill: #444;
                height: 34px;
                margin: 0;
                padding: 0;
                width: 34px
            }

            .graphiql-container .execute-button svg {
                pointer-events: none
            }

            .graphiql-container .execute-button:active {
                background: linear-gradient(#e6e6e6,#c3c3c3);
                box-shadow: 0 1px #fff,inset 0 0 2px #0003,inset 0 0 6px #0000001a
            }

            .graphiql-container .toolbar-menu,.graphiql-container .toolbar-select {
                position: relative
            }

            .graphiql-container .execute-options,.graphiql-container .toolbar-menu-items,.graphiql-container .toolbar-select-options {
                background: #fff;
                box-shadow: 0 0 0 1px #0000001a,0 2px 4px #00000040;
                margin: 0;
                padding: 6px 0;
                position: absolute;
                z-index: 100
            }

            .graphiql-container .execute-options {
                min-width: 100px;
                top: 37px;
                left: -1px
            }

            .graphiql-container .toolbar-menu-items {
                left: 1px;
                margin-top: -1px;
                min-width: 110%;
                top: 100%;
                visibility: hidden
            }

            .graphiql-container .toolbar-menu-items.open {
                visibility: visible
            }

            .graphiql-container .toolbar-select-options {
                left: 0;
                min-width: 100%;
                top: -5px;
                visibility: hidden
            }

            .graphiql-container .toolbar-select-options.open {
                visibility: visible
            }

            .graphiql-container .execute-options>li,.graphiql-container .toolbar-menu-items>li,.graphiql-container .toolbar-select-options>li {
                cursor: pointer;
                display: block;
                margin: none;
                max-width: 300px;
                overflow: hidden;
                padding: 2px 20px 4px 11px;
                white-space: nowrap
            }

            .graphiql-container .execute-options>li.selected,.graphiql-container .toolbar-menu-items>li.hover,.graphiql-container .toolbar-menu-items>li:active,.graphiql-container .toolbar-menu-items>li:hover,.graphiql-container .toolbar-select-options>li.hover,.graphiql-container .toolbar-select-options>li:active,.graphiql-container .toolbar-select-options>li:hover,.graphiql-container .history-contents>li:hover,.graphiql-container .history-contents>li:active {
                background: #e10098;
                color: #fff
            }

            .graphiql-container .toolbar-select-options>li>svg {
                display: inline;
                fill: #666;
                margin: 0 -6px 0 6px;
                pointer-events: none;
                vertical-align: middle
            }

            .graphiql-container .toolbar-select-options>li.hover>svg,.graphiql-container .toolbar-select-options>li:active>svg,.graphiql-container .toolbar-select-options>li:hover>svg {
                fill: #fff
            }

            .graphiql-container .CodeMirror-scroll {
                overflow-scrolling: touch
            }

            .graphiql-container .CodeMirror {
                color: #141823;
                font-family: Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;
                font-size: 13px;
                height: 100%;
                left: 0;
                position: absolute;
                top: 0;
                width: 100%
            }

            .graphiql-container .CodeMirror-lines {
                padding: 20px 0
            }

            .CodeMirror-hint-information .content {
                box-orient: vertical;
                color: #141823;
                display: flex;
                font-family: system,-apple-system,San Francisco,".SFNSDisplay-Regular",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;
                font-size: 13px;
                line-clamp: 3;
                line-height: 16px;
                max-height: 48px;
                overflow: hidden;
                text-overflow: -o-ellipsis-lastline
            }

            .CodeMirror-hint-information .content p:first-child {
                margin-top: 0
            }

            .CodeMirror-hint-information .content p:last-child {
                margin-bottom: 0
            }

            .CodeMirror-hint-information .infoType {
                color: #ca9800;
                cursor: pointer;
                display: inline;
                margin-right: .5em
            }

            .autoInsertedLeaf.cm-property {
                animation-duration: 6s;
                animation-name: insertionFade;
                border-bottom: 2px solid rgba(255,255,255,0);
                border-radius: 2px;
                margin: -2px -4px -1px;
                padding: 2px 4px 1px
            }

            @keyframes insertionFade {
                0%,to {
                    background: rgba(255,255,255,0);
                    border-color: #fff0
                }

                15%,85% {
                    background: #fbffc9;
                    border-color: #f0f3c0
                }
            }

            div.CodeMirror-lint-tooltip {
                background-color: #fff;
                border-radius: 2px;
                border: 0;
                color: #141823;
                box-shadow: 0 1px 3px #00000073;
                font-size: 13px;
                line-height: 16px;
                max-width: 430px;
                opacity: 0;
                padding: 8px 10px;
                transition: opacity .15s;
                white-space: pre-wrap
            }

            div.CodeMirror-lint-tooltip>* {
                padding-left: 23px
            }

            div.CodeMirror-lint-tooltip>*+* {
                margin-top: 12px
            }

            .graphiql-container .variable-editor-title-text {
                cursor: pointer;
                display: inline-block;
                color: gray
            }

            .graphiql-container .variable-editor-title-text.active {
                color: #000
            }

            .graphiql-container .CodeMirror-foldmarker {
                border-radius: 4px;
                background: #08f;
                background: linear-gradient(#43A8FF,#0F83E8);
                box-shadow: 0 1px 1px #0003,inset 0 0 0 1px #0000001a;
                color: #fff;
                font-family: arial;
                font-size: 12px;
                line-height: 0;
                margin: 0 3px;
                padding: 0 4px 1px;
                text-shadow: 0 -1px rgba(0,0,0,.1)
            }

            .graphiql-container div.CodeMirror span.CodeMirror-matchingbracket {
                color: #555;
                text-decoration: underline
            }

            .graphiql-container div.CodeMirror span.CodeMirror-nonmatchingbracket {
                color: red
            }

            .cm-comment {
                color: #666
            }

            .cm-punctuation {
                color: #555
            }

            .cm-keyword {
                color: #b11a04
            }

            .cm-def {
                color: #d2054e
            }

            .cm-property {
                color: #1f61a0
            }

            .cm-qualifier {
                color: #1c92a9
            }

            .cm-attribute {
                color: #8b2bb9
            }

            .cm-number {
                color: #2882f9
            }

            .cm-string {
                color: #d64292
            }

            .cm-builtin {
                color: #d47509
            }

            .cm-string-2 {
                color: #0b7fc7
            }

            .cm-variable {
                color: #397d13
            }

            .cm-meta {
                color: #b33086
            }

            .cm-atom {
                color: #ca9800
            }

            .CodeMirror {
                color: #000;
                font-family: monospace;
                height: 300px
            }

            .CodeMirror-lines {
                padding: 4px 0
            }

            .CodeMirror pre {
                padding: 0 4px
            }

            .CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler {
                background-color: #fff
            }

            .CodeMirror-gutters {
                border-right: 1px solid #ddd;
                background-color: #f7f7f7;
                white-space: nowrap
            }

            .CodeMirror-linenumber {
                color: #666;
                min-width: 20px;
                padding: 0 3px 0 5px;
                text-align: right;
                white-space: nowrap
            }

            .CodeMirror-guttermarker {
                color: #000
            }

            .CodeMirror-guttermarker-subtle {
                color: #666
            }

            .CodeMirror .CodeMirror-cursor {
                border-left: 1px solid black
            }

            .CodeMirror div.CodeMirror-secondarycursor {
                border-left: 1px solid silver
            }

            .CodeMirror.cm-fat-cursor div.CodeMirror-cursor {
                background: #7e7;
                border: 0;
                width: auto
            }

            .CodeMirror.cm-fat-cursor div.CodeMirror-cursors {
                z-index: 1
            }

            .cm-animate-fat-cursor {
                animation: blink 1.06s steps(1) infinite;
                border: 0;
                width: auto
            }

            @keyframes blink {
                0% {
                    background: #7e7
                }

                50% {
                    background: none
                }

                to {
                    background: #7e7
                }
            }

            .cm-tab {
                display: inline-block;
                text-decoration: inherit
            }

            .CodeMirror-ruler {
                border-left: 1px solid #ccc;
                position: absolute
            }

            .cm-s-default .cm-keyword {
                color: #708
            }

            .cm-s-default .cm-atom {
                color: #219
            }

            .cm-s-default .cm-number {
                color: #164
            }

            .cm-s-default .cm-def {
                color: #00f
            }

            .cm-s-default .cm-variable-2 {
                color: #05a
            }

            .cm-s-default .cm-variable-3 {
                color: #085
            }

            .cm-s-default .cm-comment {
                color: #a50
            }

            .cm-s-default .cm-string {
                color: #a11
            }

            .cm-s-default .cm-string-2 {
                color: #f50
            }

            .cm-s-default .cm-meta,.cm-s-default .cm-qualifier {
                color: #555
            }

            .cm-s-default .cm-builtin {
                color: #30a
            }

            .cm-s-default .cm-bracket {
                color: #666
            }

            .cm-s-default .cm-tag {
                color: #170
            }

            .cm-s-default .cm-attribute {
                color: #00c
            }

            .cm-s-default .cm-header {
                color: #00f
            }

            .cm-s-default .cm-quote {
                color: #090
            }

            .cm-s-default .cm-hr {
                color: #666
            }

            .cm-s-default .cm-link {
                color: #00c
            }

            .cm-negative {
                color: #d44
            }

            .cm-positive {
                color: #292
            }

            .cm-header,.cm-strong {
                font-weight: 700
            }

            .cm-em {
                font-style: italic
            }

            .cm-link {
                text-decoration: underline
            }

            .cm-strikethrough {
                text-decoration: line-through
            }

            .cm-s-default .cm-error,.cm-invalidchar {
                color: red
            }

            .CodeMirror-composing {
                border-bottom: 2px solid
            }

            div.CodeMirror span.CodeMirror-matchingbracket {
                color: #0f0
            }

            div.CodeMirror span.CodeMirror-nonmatchingbracket {
                color: #f22
            }

            .CodeMirror-matchingtag {
                background: rgba(255,150,0,.3)
            }

            .CodeMirror-activeline-background {
                background: #e8f2ff
            }

            .CodeMirror {
                background: white;
                overflow: hidden;
                position: relative
            }

            .CodeMirror-scroll {
                height: 100%;
                margin-bottom: -30px;
                margin-right: -30px;
                outline: none;
                overflow: scroll!important;
                padding-bottom: 30px;
                position: relative
            }

            .CodeMirror-sizer {
                border-right: 30px solid transparent;
                position: relative
            }

            .CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler {
                display: none;
                position: absolute;
                z-index: 6
            }

            .CodeMirror-vscrollbar {
                overflow-x: hidden;
                overflow-y: scroll;
                right: 0;
                top: 0
            }

            .CodeMirror-hscrollbar {
                bottom: 0;
                left: 0;
                overflow-x: scroll;
                overflow-y: hidden
            }

            .CodeMirror-scrollbar-filler {
                right: 0;
                bottom: 0
            }

            .CodeMirror-gutter-filler {
                left: 0;
                bottom: 0
            }

            .CodeMirror-gutters {
                min-height: 100%;
                position: absolute;
                left: 0;
                top: 0;
                z-index: 3
            }

            .CodeMirror-gutter {
                display: inline-block;
                height: 100%;
                margin-bottom: -30px;
                vertical-align: top;
                white-space: normal;
                *zoom:1;*display: inline
            }

            .CodeMirror-gutter-wrapper {
                background: none!important;
                border: none!important;
                position: absolute;
                z-index: 4
            }

            .CodeMirror-gutter-background {
                position: absolute;
                top: 0;
                bottom: 0;
                z-index: 4
            }

            .CodeMirror-gutter-elt {
                cursor: default;
                position: absolute;
                z-index: 4
            }

            .CodeMirror-gutter-wrapper {
                user-select: none
            }

            .CodeMirror-lines {
                cursor: text;
                min-height: 1px
            }

            .CodeMirror pre {
                -webkit-tap-highlight-color: transparent;
                background: transparent;
                border-radius: 0;
                border-width: 0;
                color: inherit;
                font-family: inherit;
                font-size: inherit;
                font-variant-ligatures: none;
                line-height: inherit;
                margin: 0;
                overflow: visible;
                position: relative;
                white-space: pre;
                word-wrap: normal;
                z-index: 2
            }

            .CodeMirror-wrap pre {
                word-wrap: break-word;
                white-space: pre-wrap;
                word-break: normal
            }

            .CodeMirror-linebackground {
                position: absolute;
                left: 0;
                right: 0;
                top: 0;
                bottom: 0;
                z-index: 0
            }

            .CodeMirror-linewidget {
                overflow: auto;
                position: relative;
                z-index: 2
            }

            .CodeMirror-code {
                outline: none
            }

            .CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber {
                box-sizing: content-box
            }

            .CodeMirror-measure {
                height: 0;
                overflow: hidden;
                position: absolute;
                visibility: hidden;
                width: 100%
            }

            .CodeMirror-cursor {
                position: absolute
            }

            .CodeMirror-measure pre {
                position: static
            }

            div.CodeMirror-cursors {
                position: relative;
                visibility: hidden;
                z-index: 3
            }

            div.CodeMirror-dragcursors,.CodeMirror-focused div.CodeMirror-cursors {
                visibility: visible
            }

            .CodeMirror-selected {
                background: #d9d9d9
            }

            .CodeMirror-focused .CodeMirror-selected {
                background: #d7d4f0
            }

            .CodeMirror-crosshair {
                cursor: crosshair
            }

            .CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection {
                background: #d7d4f0
            }

            .CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection {
                background: #d7d4f0
            }

            .cm-searching {
                background: #ffa;
                background: rgba(255,255,0,.4)
            }

            .CodeMirror span {
                *vertical-align: text-bottom
            }

            .cm-force-border {
                padding-right: .1px
            }

            @media print {
                .CodeMirror div.CodeMirror-cursors {
                    visibility: hidden
                }
            }

            .cm-tab-wrap-hack:after {
                content: ""
            }

            span.CodeMirror-selectedtext {
                background: none
            }

            .CodeMirror-dialog {
                background: inherit;
                color: inherit;
                left: 0;
                right: 0;
                overflow: hidden;
                padding: .1em .8em;
                position: absolute;
                z-index: 15
            }

            .CodeMirror-dialog-top {
                border-bottom: 1px solid #eee;
                top: 0
            }

            .CodeMirror-dialog-bottom {
                border-top: 1px solid #eee;
                bottom: 0
            }

            .CodeMirror-dialog input {
                background: transparent;
                border: 1px solid #d3d6db;
                color: inherit;
                font-family: monospace;
                outline: none;
                width: 20em
            }

            .CodeMirror-dialog button {
                font-size: 70%
            }

            .CodeMirror-foldmarker {
                color: #00f;
                cursor: pointer;
                font-family: arial;
                line-height: .3;
                text-shadow: #b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px
            }

            .CodeMirror-foldgutter {
                width: .7em
            }

            .CodeMirror-foldgutter-open,.CodeMirror-foldgutter-folded {
                cursor: pointer
            }

            .CodeMirror-foldgutter-open:after {
                content: "\25be"
            }

            .CodeMirror-foldgutter-folded:after {
                content: "\25b8"
            }

            .CodeMirror-info {
                background: white;
                border-radius: 2px;
                box-shadow: 0 1px 3px #00000073;
                box-sizing: border-box;
                color: #555;
                font-family: system,-apple-system,San Francisco,".SFNSDisplay-Regular",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;
                font-size: 13px;
                line-height: 16px;
                margin: 8px -8px;
                max-width: 400px;
                opacity: 0;
                overflow: hidden;
                padding: 8px;
                position: fixed;
                transition: opacity .15s;
                z-index: 50
            }

            .CodeMirror-info :first-child {
                margin-top: 0
            }

            .CodeMirror-info :last-child {
                margin-bottom: 0
            }

            .CodeMirror-info p {
                margin: 1em 0
            }

            .CodeMirror-info .info-description {
                color: #777;
                line-height: 16px;
                margin-top: 1em;
                max-height: 80px;
                overflow: hidden
            }

            .CodeMirror-info .info-deprecation {
                background: #fffae8;
                box-shadow: inset 0 1px 1px -1px #bfb063;
                color: #867f70;
                line-height: 16px;
                margin: 8px -8px -8px;
                max-height: 80px;
                overflow: hidden;
                padding: 8px
            }

            .CodeMirror-info .info-deprecation-label {
                color: #c79b2e;
                cursor: default;
                display: block;
                font-size: 9px;
                font-weight: 700;
                letter-spacing: 1px;
                line-height: 1;
                padding-bottom: 5px;
                text-transform: uppercase;
                user-select: none
            }

            .CodeMirror-info .info-deprecation-label+* {
                margin-top: 0
            }

            .CodeMirror-info a {
                text-decoration: none
            }

            .CodeMirror-info a:hover {
                text-decoration: underline
            }

            .CodeMirror-info .type-name {
                color: #ca9800
            }

            .CodeMirror-info .field-name {
                color: #1f61a0
            }

            .CodeMirror-info .enum-value {
                color: #0b7fc7
            }

            .CodeMirror-info .arg-name {
                color: #8b2bb9
            }

            .CodeMirror-info .directive-name {
                color: #b33086
            }

            .CodeMirror-jump-token {
                text-decoration: underline;
                cursor: pointer
            }

            .CodeMirror-lint-markers {
                width: 16px
            }

            .CodeMirror-lint-tooltip {
                background-color: infobackground;
                border-radius: 4px;
                border: 1px solid black;
                color: infotext;
                font-family: monospace;
                font-size: 10pt;
                max-width: 600px;
                opacity: 0;
                overflow: hidden;
                padding: 2px 5px;
                position: fixed;
                transition: opacity .4s;
                white-space: pre-wrap;
                z-index: 100
            }

            .CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning {
                background-position: left bottom;
                background-repeat: repeat-x
            }

            .CodeMirror-lint-mark-error {
                background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==)
            }

            .CodeMirror-lint-mark-warning {
                background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=)
            }

            .CodeMirror-lint-marker-error,.CodeMirror-lint-marker-warning {
                background-position: center center;
                background-repeat: no-repeat;
                cursor: pointer;
                display: inline-block;
                height: 16px;
                position: relative;
                vertical-align: middle;
                width: 16px
            }

            .CodeMirror-lint-message-error,.CodeMirror-lint-message-warning {
                background-position: top left;
                background-repeat: no-repeat;
                padding-left: 18px
            }

            .CodeMirror-lint-marker-error,.CodeMirror-lint-message-error {
                background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=)
            }

            .CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning {
                background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=)
            }

            .CodeMirror-lint-marker-multiple {
                background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC);
                background-position: right bottom;
                background-repeat: no-repeat;
                width: 100%;
                height: 100%
            }

            .graphiql-container .spinner-container {
                height: 36px;
                left: 50%;
                position: absolute;
                top: 50%;
                transform: translate(-50%,-50%);
                width: 36px;
                z-index: 10
            }

            .graphiql-container .spinner {
                animation: rotation .6s infinite linear;
                border-bottom: 6px solid rgba(150,150,150,.15);
                border-left: 6px solid rgba(150,150,150,.15);
                border-radius: 100%;
                border-right: 6px solid rgba(150,150,150,.15);
                border-top: 6px solid rgba(150,150,150,.8);
                display: inline-block;
                height: 24px;
                position: absolute;
                vertical-align: middle;
                width: 24px
            }

            @keyframes rotation {
                0% {
                    transform: rotate(0)
                }

                to {
                    transform: rotate(359deg)
                }
            }

            .CodeMirror-hints {
                background: white;
                box-shadow: 0 1px 3px #00000073;
                font-family: Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace;
                font-size: 13px;
                list-style: none;
                margin: 0;
                max-height: 14.5em;
                overflow: hidden;
                overflow-y: auto;
                padding: 0;
                position: absolute;
                z-index: 10
            }

            .CodeMirror-hint {
                border-top: solid 1px #f7f7f7;
                color: #141823;
                cursor: pointer;
                margin: 0;
                max-width: 300px;
                overflow: hidden;
                padding: 2px 6px;
                white-space: pre
            }

            li.CodeMirror-hint-active {
                background-color: #08f;
                border-top-color: #fff;
                color: #fff
            }

            .CodeMirror-hint-information {
                border-top: solid 1px #c0c0c0;
                max-width: 300px;
                padding: 4px 6px;
                position: relative;
                z-index: 1
            }

            .CodeMirror-hint-information:first-child {
                border-bottom: solid 1px #c0c0c0;
                border-top: none;
                margin-bottom: -1px
            }

            .CodeMirror-hint-deprecation {
                background: #fffae8;
                box-shadow: inset 0 1px 1px -1px #bfb063;
                color: #867f70;
                font-family: system,-apple-system,San Francisco,".SFNSDisplay-Regular",Segoe UI,Segoe,Segoe WP,Helvetica Neue,helvetica,Lucida Grande,arial,sans-serif;
                font-size: 13px;
                line-height: 16px;
                margin-top: 4px;
                max-height: 80px;
                overflow: hidden;
                padding: 6px
            }

            .CodeMirror-hint-deprecation .deprecation-label {
                color: #c79b2e;
                cursor: default;
                display: block;
                font-size: 9px;
                font-weight: 700;
                letter-spacing: 1px;
                line-height: 1;
                padding-bottom: 5px;
                text-transform: uppercase;
                user-select: none
            }

            .CodeMirror-hint-deprecation .deprecation-label+* {
                margin-top: 0
            }

            .CodeMirror-hint-deprecation :last-child {
                margin-bottom: 0
            }

            .graphiql-container .doc-explorer {
                background: white
            }

            .graphiql-container .doc-explorer-title-bar,.graphiql-container .history-title-bar {
                cursor: default;
                display: flex;
                height: 34px;
                line-height: 14px;
                padding: 8px 8px 5px;
                position: relative;
                user-select: none
            }

            .graphiql-container .doc-explorer-title,.graphiql-container .history-title {
                flex: 1;
                font-weight: 700;
                overflow-x: hidden;
                padding: 10px 0 10px 10px;
                text-align: center;
                text-overflow: ellipsis;
                user-select: text;
                white-space: nowrap
            }

            .graphiql-container .doc-explorer-back {
                color: #3b5998;
                cursor: pointer;
                margin: -7px 0 -6px -8px;
                overflow-x: hidden;
                padding: 17px 12px 16px 16px;
                text-overflow: ellipsis;
                white-space: nowrap;
                background: 0;
                border: 0;
                line-height: 14px
            }

            .doc-explorer-narrow .doc-explorer-back {
                width: 0
            }

            .graphiql-container .doc-explorer-back:before {
                border-left: 2px solid #3B5998;
                border-top: 2px solid #3B5998;
                content: "";
                display: inline-block;
                height: 9px;
                margin: 0 3px -1px 0;
                position: relative;
                transform: rotate(-45deg);
                width: 9px
            }

            .graphiql-container .doc-explorer-rhs {
                position: relative
            }

            .graphiql-container .doc-explorer-contents,.graphiql-container .history-contents {
                background-color: #fff;
                border-top: 1px solid #d6d6d6;
                bottom: 0;
                left: 0;
                overflow-y: auto;
                padding: 20px 15px;
                position: absolute;
                right: 0;
                top: 47px
            }

            .graphiql-container .doc-explorer-contents {
                min-width: 300px
            }

            .graphiql-container .doc-type-description p:first-child,.graphiql-container .doc-type-description blockquote:first-child {
                margin-top: 0
            }

            .graphiql-container .doc-explorer-contents a {
                cursor: pointer;
                text-decoration: none
            }

            .graphiql-container .doc-explorer-contents a:hover {
                text-decoration: underline
            }

            .graphiql-container .doc-value-description>:first-child {
                margin-top: 4px
            }

            .graphiql-container .doc-value-description>:last-child {
                margin-bottom: 4px
            }

            .graphiql-container .doc-type-description code,.graphiql-container .doc-type-description pre,.graphiql-container .doc-category code,.graphiql-container .doc-category pre {
                --saf-0: rgba(var(--sk_foreground_low,29,28,29),.13);
                font-size: 12px;
                line-height: 1.50001;
                font-variant-ligatures: none;
                white-space: pre;
                white-space: pre-wrap;
                word-wrap: break-word;
                word-break: normal;
                -webkit-tab-size: 4;
                -moz-tab-size: 4;
                tab-size: 4
            }

            .graphiql-container .doc-type-description code,.graphiql-container .doc-category code {
                padding: 2px 3px 1px;
                border: 1px solid var(--saf-0);
                border-radius: 3px;
                background-color: rgba(var(--sk_foreground_min,29,28,29),.04);
                color: #e01e5a;
                background-color: #fff
            }

            .graphiql-container .doc-category {
                margin: 20px 0
            }

            .graphiql-container .doc-category-title {
                border-bottom: 1px solid #e0e0e0;
                color: #777;
                cursor: default;
                font-size: 14px;
                font-variant: small-caps;
                font-weight: 700;
                letter-spacing: 1px;
                margin: 0 -15px 10px 0;
                padding: 10px 0;
                user-select: none
            }

            .graphiql-container .doc-category-item {
                margin: 12px 0;
                color: #555
            }

            .graphiql-container .keyword {
                color: #b11a04
            }

            .graphiql-container .type-name {
                color: #ca9800
            }

            .graphiql-container .field-name {
                color: #1f61a0
            }

            .graphiql-container .field-short-description {
                color: #666;
                margin-left: 5px;
                overflow: hidden;
                text-overflow: ellipsis
            }

            .graphiql-container .enum-value {
                color: #0b7fc7
            }

            .graphiql-container .arg-name {
                color: #8b2bb9
            }

            .graphiql-container .arg {
                display: block;
                margin-left: 1em
            }

            .graphiql-container .arg:first-child:last-child,.graphiql-container .arg:first-child:nth-last-child(2),.graphiql-container .arg:first-child:nth-last-child(2)~.arg {
                display: inherit;
                margin: inherit
            }

            .graphiql-container .arg:first-child:nth-last-child(2):after {
                content: ", "
            }

            .graphiql-container .arg-default-value {
                color: #43a047
            }

            .graphiql-container .doc-deprecation {
                background: #fffae8;
                box-shadow: inset 0 0 1px #bfb063;
                color: #867f70;
                line-height: 16px;
                margin: 8px -8px;
                max-height: 80px;
                overflow: hidden;
                padding: 8px;
                border-radius: 3px
            }

            .graphiql-container .doc-deprecation:before {
                content: "Deprecated:";
                color: #c79b2e;
                cursor: default;
                display: block;
                font-size: 9px;
                font-weight: 700;
                letter-spacing: 1px;
                line-height: 1;
                padding-bottom: 5px;
                text-transform: uppercase;
                user-select: none
            }

            .graphiql-container .doc-deprecation>:first-child {
                margin-top: 0
            }

            .graphiql-container .doc-deprecation>:last-child {
                margin-bottom: 0
            }

            .graphiql-container .show-btn {
                -webkit-appearance: initial;
                display: block;
                border-radius: 3px;
                border: solid 1px #ccc;
                text-align: center;
                padding: 8px 12px 10px;
                width: 100%;
                box-sizing: border-box;
                background: #fbfcfc;
                color: #555;
                cursor: pointer
            }

            .graphiql-container .search-box {
                border-bottom: 1px solid #d3d6db;
                display: flex;
                align-items: center;
                font-size: 14px;
                margin: -15px -15px 12px 0;
                position: relative
            }

            .graphiql-container .search-box-icon {
                cursor: pointer;
                display: block;
                font-size: 24px;
                transform: rotate(-45deg);
                user-select: none
            }

            .graphiql-container .search-box .search-box-clear {
                background-color: #d0d0d0;
                border-radius: 12px;
                color: #fff;
                cursor: pointer;
                font-size: 11px;
                padding: 1px 5px 2px;
                position: absolute;
                right: 3px;
                user-select: none;
                border: 0
            }

            .graphiql-container .search-box .search-box-clear:hover {
                background-color: #b9b9b9
            }

            .graphiql-container .search-box>input {
                border: none;
                box-sizing: border-box;
                font-size: 14px;
                outline: none;
                padding: 6px 24px 8px 20px;
                width: 100%
            }

            .graphiql-container .error-container {
                font-weight: 700;
                left: 0;
                letter-spacing: 1px;
                opacity: .5;
                position: absolute;
                right: 0;
                text-align: center;
                text-transform: uppercase;
                top: 50%;
                transform: translateY(-50%)
            }

            .graphiql-container .history-contents {
                font-family: Consolas,Inconsolata,Droid Sans Mono,Monaco,monospace
            }

            .graphiql-container .history-contents {
                margin: 0;
                padding: 0
            }

            .graphiql-container .history-contents li {
                align-items: center;
                display: flex;
                font-size: 12px;
                overflow: hidden;
                text-overflow: ellipsis;
                white-space: nowrap;
                margin: 0;
                padding: 8px;
                border-bottom: 1px solid #e0e0e0
            }

            .graphiql-container .history-contents li button:not(.history-label) {
                display: none;
                margin-left: 10px
            }

            .graphiql-container .history-contents li:hover button:not(.history-label),.graphiql-container .history-contents li:focus-within button:not(.history-label) {
                display: inline-block
            }

            .graphiql-container .history-contents input,.graphiql-container .history-contents button {
                padding: 0;
                background: 0;
                border: 0;
                font-size: inherit;
                font-family: inherit;
                line-height: 14px;
                color: inherit
            }

            .graphiql-container .history-contents input {
                flex-grow: 1
            }

            .graphiql-container .history-contents input::placeholder {
                color: inherit
            }

            .graphiql-container .history-contents button {
                cursor: pointer;
                text-align: left
            }

            .graphiql-container .history-contents .history-label {
                flex-grow: 1;
                overflow: hidden;
                text-overflow: ellipsis
            }

            body,html {
                margin: 0
            }

            .graphiql-container {
                height: 100vh;
                width: 100vw
            }

            .graphiql-explorer-node {
                margin-left: 3px
            }

            .graphiql-explorer-root .graphiql-operation-title-bar {
                display: flex;
                align-items: center
            }

            .graphiql-explorer-root .graphiql-operation-title-bar input {
                min-width: 11ch
            }

            .graphiql-container .docExplorerShowReverse {
                border-right: 1px solid rgba(0,0,0,.2)!important
            }

            .docExplorerShowReverse:before {
                display: none!important
            }

            .docExplorerShowReverse:after {
                border-left: 2px solid #3b5998;
                border-top: 2px solid #3b5998;
                content: "";
                display: inline-block;
                height: 9px;
                margin: 0 0 -1px 3px;
                position: relative;
                transform: rotate(135deg);
                width: 9px
            }

            .graphiql-explorer-root input {
                background-color: #282d34!important;
                padding-left: 5px
            }

            .graphiql-explorer-actions select {
                background-color: #282d34!important;
                color: #fff;
                margin-left: 5px
            }

            .graphiql-explorer-root div:first-child {
                overflow: auto!important
            }

            .graphiql-operation-title-bar {
                background-color: transparent
            }

            .CodeMirror {
                background: #282d34!important
            }

            .graphiql-container .doc-explorer-contents,.graphiql-container .history-contents {
                background-color: #21262b;
                border-top: 1px solid #181a1f
            }

            .graphiql-container .doc-explorer-contents .graphiql-explorer-node svg {
                margin-right: 5px!important
            }

            .graphiql-container .doc-explorer-contents .graphiql-explorer-node path {
                fill: #e0dddd!important
            }

            .graphiql-container .toolbar-button {
                background: #1c2125!important;
                box-shadow: none!important;
                color: #fff!important;
                border: 1px solid #181a1f!important
            }

            .graphiql-container .toolbar-button:hover {
                color: #c7c7c7!important
            }

            .graphiql-container .result-window .CodeMirror-gutters {
                background: #282d33;
                border: none!important
            }

            .graphiql-container .resultWrap {
                border-left: solid 1px #181a1f
            }

            .graphiql-container .variable-editor-title {
                background: #21262b;
                border-bottom: 1px solid #181a1f;
                border-top: 1px solid #181a1f;
                color: #cacdd3
            }

            .graphiql-container .topBar {
                background: #21262b;
                border-color: #181a1f
            }

            .graphiql-container .docExplorerHide {
                color: #fff
            }

            .graphiql-container .docExplorerHide:hover {
                color: #c7c7c7
            }

            .graphiql-container .doc-explorer-title,.graphiql-container .history-title,.doc-explorer-back {
                color: #cacdd3!important
            }

            .graphiql-container .doc-explorer {
                background: #21262b
            }

            .graphiql-container .docExplorerWrap,.graphiql-container .historyPaneWrap {
                box-shadow: none
            }

            .graphiql-container .docExplorerShow {
                border-left: none
            }

            .graphiql-container .docExplorerShow,.graphiql-container .historyShow {
                background: #21262b;
                border-bottom: 1px solid #181a1e;
                color: #cacdd3
            }

            .graphiql-container .docExplorerShow:before,.graphiql-container .doc-explorer-back:before {
                border-color: #cacdd3
            }

            .graphiql-container .search-box {
                margin: auto auto 10px;
                border: none
            }

            .graphiql-container .search-box input {
                background: #1e2127;
                padding-left: 28px
            }

            .graphiql-container .search-box .search-box-clear,.graphiql-container .search-box .search-box-clear:hover {
                background: #1d2126
            }

            .graphiql-container .search-box:before {
                color: #c1c4ca;
                font-size: 21px;
                left: 8px
            }

            .search-box-icon {
                position: absolute;
                padding-left: 5px
            }

            .graphiql-container,.graphiql-container button,.graphiql-container input {
                color: #9299a7
            }

            .CodeMirror-gutters {
                border: none!important;
                background-color: #282d33
            }

            .graphiql-container .execute-button {
                background: #21262b;
                border: 1px solid rgb(91,98,107);
                box-shadow: none!important;
                fill: #c9ccd2
            }

            .graphiql-container .execute-button:hover {
                fill: #999ba0
            }

            .graphiql-container .history-contents p {
                border: none
            }

            .graphiql-container .historyPaneWrap {
                background: #21262b
            }

            .graphiql-container .execute-options>li.selected,.graphiql-container .toolbar-menu-items>li.hover,.graphiql-container .toolbar-menu-items>li:active,.graphiql-container .toolbar-menu-items>li:hover,.graphiql-container .toolbar-select-options>li.hover,.graphiql-container .toolbar-select-options>li:active,.graphiql-container .toolbar-select-options>li:hover,.graphiql-container .history-contents>p:hover,.graphiql-container .history-contents>p:active {
                background: #383c41
            }

            .graphiql-container .doc-category-title {
                border-bottom: 1px solid #181a1f;
                color: #cacdd3
            }

            .graphiql-container .field-name {
                color: #0083c7
            }

            .graphiql-container .type-name {
                color: #ff6d5d
            }

            .graphiql-container .keyword {
                color: #9ea5b0
            }

            .graphiql-container .arg-name {
                color: #0083c7
            }

            .graphiql-container .doc-category-item {
                color: #ff9f4c
            }

            .graphiql-container .variable-editor-title-text.active {
                color: #fff
            }

            .cm-property {
                color: #0083c7
            }

            .cm-number {
                color: #97b1aa
            }

            .cm-string {
                color: #00917d
            }

            .cm-builtin {
                color: #da8aff
            }

            .cm-variable {
                color: #f9f871
            }

            .cm-attribute {
                color: #00b8ff
            }

            .cm-def {
                color: #9f51d9
            }

            .cm-punctuation {
                color: #c7c7c7!important
            }

            .doc-type-description code {
                color: #cc3932;
                background-color: #383c41!important
            }

            .cm-keyword {
                color: #ff6d5d
            }

            .cm-atom {
                color: #ff9f4c
            }

            a {
                color: #7b9ad4
            }

            .CodeMirror .CodeMirror-cursor {
                border-left: 1px solid white
            }

            .CodeMirror-lint-tooltip {
                background: #1a1e22!important;
                color: red
            }

            .CodeMirror-hints {
                background: #21262a;
                box-shadow: 0 16px 13px -10px #0000004d
            }

            .CodeMirror-hint {
                border-top: solid 1px #212629;
                color: #a45300
            }

            .CodeMirror-hint-information {
                border-top: solid 1px #181a1e
            }

            li.CodeMirror-hint-active {
                background-color: #262c2f;
                border-top-color: #212629;
                color: #d17825
            }

            .CodeMirror-hint-information .content {
                color: #a4abb7
            }
        </style>
    </head>
    <body id="body" class="no-focus-outline">
        <noscript>You need to enable JavaScript to run this app.</noscript>
        <div id="root"></div>
        <script>
            // Polyfills until we can change DataLoader
            if (globalThis.window?.setImmediate == null) {
                //@ts-ignore
                globalThis.window.setImmediate = setTimeout
                globalThis.global = globalThis
            }
        </script>
        <!-- Pull in the GraphiQL subscriptions fetcher -->
        <script src="//unpkg.com/subscriptions-transport-ws@0.8.2/browser/client.js"></script>
        <script src="//unpkg.com/graphiql-subscriptions-fetcher@0.0.2/browser/client.js"></script>
        <script type="module">
            
        var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop2 in b || (b = {}))
    if (__hasOwnProp.call(b, prop2))
      __defNormalProp(a, prop2, b[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop2))
        __defNormalProp(a, prop2, b[prop2]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n2, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n2[k];
      }
    });
  });
  return a;
}
var react = { exports: {} };
var react_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
var objectAssign = shouldUseNative() ? Object.assign : function(target2, source) {
  var from;
  var to = toObject(target2);
  var symbols;
  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);
    for (var key in from) {
      if (hasOwnProperty$2.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l = objectAssign, n = 60103, p$1 = 60106;
react_production_min.Fragment = 60107;
react_production_min.StrictMode = 60108;
react_production_min.Profiler = 60114;
var q = 60109, r$1 = 60110, t$1 = 60112;
react_production_min.Suspense = 60113;
var u = 60115, v = 60116;
if (typeof Symbol === "function" && Symbol.for) {
  var w = Symbol.for;
  n = w("react.element");
  p$1 = w("react.portal");
  react_production_min.Fragment = w("react.fragment");
  react_production_min.StrictMode = w("react.strict_mode");
  react_production_min.Profiler = w("react.profiler");
  q = w("react.provider");
  r$1 = w("react.context");
  t$1 = w("react.forward_ref");
  react_production_min.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}
var x = typeof Symbol === "function" && Symbol.iterator;
function y$1(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = x && a[x] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var A = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, B$1 = {};
function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
C.prototype.isReactComponent = {};
C.prototype.setState = function(a, b) {
  if (typeof a !== "object" && typeof a !== "function" && a != null)
    throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};
C.prototype.forceUpdate = function(a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function D$1() {
}
D$1.prototype = C.prototype;
function E$1(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B$1;
  this.updater = c || A;
}
var F$1 = E$1.prototype = new D$1();
F$1.constructor = E$1;
l(F$1, C.prototype);
F$1.isPureReactComponent = true;
var G$1 = { current: null }, H$1 = Object.prototype.hasOwnProperty, I$1 = { key: true, ref: true, __self: true, __source: true };
function J(a, b, c) {
  var e, d = {}, k = null, h = null;
  if (b != null)
    for (e in b.ref !== void 0 && (h = b.ref), b.key !== void 0 && (k = "" + b.key), b)
      H$1.call(b, e) && !I$1.hasOwnProperty(e) && (d[e] = b[e]);
  var g = arguments.length - 2;
  if (g === 1)
    d.children = c;
  else if (1 < g) {
    for (var f = Array(g), m2 = 0; m2 < g; m2++)
      f[m2] = arguments[m2 + 2];
    d.children = f;
  }
  if (a && a.defaultProps)
    for (e in g = a.defaultProps, g)
      d[e] === void 0 && (d[e] = g[e]);
  return { $$typeof: n, type: a, key: k, ref: h, props: d, _owner: G$1.current };
}
function K(a, b) {
  return { $$typeof: n, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner };
}
function L(a) {
  return typeof a === "object" && a !== null && a.$$typeof === n;
}
function escape(a) {
  var b = { "=": "=0", ":": "=2" };
  return "$" + a.replace(/[=:]/g, function(a2) {
    return b[a2];
  });
}
var M$1 = /\/+/g;
function N$1(a, b) {
  return typeof a === "object" && a !== null && a.key != null ? escape("" + a.key) : b.toString(36);
}
function O$1(a, b, c, e, d) {
  var k = typeof a;
  if (k === "undefined" || k === "boolean")
    a = null;
  var h = false;
  if (a === null)
    h = true;
  else
    switch (k) {
      case "string":
      case "number":
        h = true;
        break;
      case "object":
        switch (a.$$typeof) {
          case n:
          case p$1:
            h = true;
        }
    }
  if (h)
    return h = a, d = d(h), a = e === "" ? "." + N$1(h, 0) : e, Array.isArray(d) ? (c = "", a != null && (c = a.replace(M$1, "$&/") + "/"), O$1(d, b, c, "", function(a2) {
      return a2;
    })) : d != null && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M$1, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = e === "" ? "." : e + ":";
  if (Array.isArray(a))
    for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = e + N$1(k, g);
      h += O$1(k, b, c, f, d);
    }
  else if (f = y$1(a), typeof f === "function")
    for (a = f.call(a), g = 0; !(k = a.next()).done; )
      k = k.value, f = e + N$1(k, g++), h += O$1(k, b, c, f, d);
  else if (k === "object")
    throw b = "" + a, Error(z(31, b === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}
function P$1(a, b, c) {
  if (a == null)
    return a;
  var e = [], d = 0;
  O$1(a, e, "", "", function(a2) {
    return b.call(c, a2, d++);
  });
  return e;
}
function Q(a) {
  if (a._status === -1) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function(b2) {
      a._status === 0 && (b2 = b2.default, a._status = 1, a._result = b2);
    }, function(b2) {
      a._status === 0 && (a._status = 2, a._result = b2);
    });
  }
  if (a._status === 1)
    return a._result;
  throw a._result;
}
var R$1 = { current: null };
function S$1() {
  var a = R$1.current;
  if (a === null)
    throw Error(z(321));
  return a;
}
var T$1 = { ReactCurrentDispatcher: R$1, ReactCurrentBatchConfig: { transition: 0 }, ReactCurrentOwner: G$1, IsSomeRendererActing: { current: false }, assign: l };
react_production_min.Children = { map: P$1, forEach: function(a, b, c) {
  P$1(a, function() {
    b.apply(this, arguments);
  }, c);
}, count: function(a) {
  var b = 0;
  P$1(a, function() {
    b++;
  });
  return b;
}, toArray: function(a) {
  return P$1(a, function(a2) {
    return a2;
  }) || [];
}, only: function(a) {
  if (!L(a))
    throw Error(z(143));
  return a;
} };
react_production_min.Component = C;
react_production_min.PureComponent = E$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;
react_production_min.cloneElement = function(a, b, c) {
  if (a === null || a === void 0)
    throw Error(z(267, a));
  var e = l({}, a.props), d = a.key, k = a.ref, h = a._owner;
  if (b != null) {
    b.ref !== void 0 && (k = b.ref, h = G$1.current);
    b.key !== void 0 && (d = "" + b.key);
    if (a.type && a.type.defaultProps)
      var g = a.type.defaultProps;
    for (f in b)
      H$1.call(b, f) && !I$1.hasOwnProperty(f) && (e[f] = b[f] === void 0 && g !== void 0 ? g[f] : b[f]);
  }
  var f = arguments.length - 2;
  if (f === 1)
    e.children = c;
  else if (1 < f) {
    g = Array(f);
    for (var m2 = 0; m2 < f; m2++)
      g[m2] = arguments[m2 + 2];
    e.children = g;
  }
  return {
    $$typeof: n,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};
react_production_min.createContext = function(a, b) {
  b === void 0 && (b = null);
  a = { $$typeof: r$1, _calculateChangedBits: b, _currentValue: a, _currentValue2: a, _threadCount: 0, Provider: null, Consumer: null };
  a.Provider = { $$typeof: q, _context: a };
  return a.Consumer = a;
};
react_production_min.createElement = J;
react_production_min.createFactory = function(a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a) {
  return { $$typeof: t$1, render: a };
};
react_production_min.isValidElement = L;
react_production_min.lazy = function(a) {
  return { $$typeof: v, _payload: { _status: -1, _result: a }, _init: Q };
};
react_production_min.memo = function(a, b) {
  return { $$typeof: u, type: a, compare: b === void 0 ? null : b };
};
react_production_min.useCallback = function(a, b) {
  return S$1().useCallback(a, b);
};
react_production_min.useContext = function(a, b) {
  return S$1().useContext(a, b);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useEffect = function(a, b) {
  return S$1().useEffect(a, b);
};
react_production_min.useImperativeHandle = function(a, b, c) {
  return S$1().useImperativeHandle(a, b, c);
};
react_production_min.useLayoutEffect = function(a, b) {
  return S$1().useLayoutEffect(a, b);
};
react_production_min.useMemo = function(a, b) {
  return S$1().useMemo(a, b);
};
react_production_min.useReducer = function(a, b, c) {
  return S$1().useReducer(a, b, c);
};
react_production_min.useRef = function(a) {
  return S$1().useRef(a);
};
react_production_min.useState = function(a) {
  return S$1().useState(a);
};
react_production_min.version = "17.0.2";
{
  react.exports = react_production_min;
}
var React$1 = react.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/** @license React v0.20.2
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  var f, g, h, k;
  if (typeof performance === "object" && typeof performance.now === "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  if (typeof window === "undefined" || typeof MessageChannel !== "function") {
    var t2 = null, u2 = null, w = function() {
      if (t2 !== null)
        try {
          var a = exports.unstable_now();
          t2(true, a);
          t2 = null;
        } catch (b) {
          throw setTimeout(w, 0), b;
        }
    };
    f = function(a) {
      t2 !== null ? setTimeout(f, 0, a) : (t2 = a, setTimeout(w, 0));
    };
    g = function(a, b) {
      u2 = setTimeout(a, b);
    };
    h = function() {
      clearTimeout(u2);
    };
    exports.unstable_shouldYield = function() {
      return false;
    };
    k = exports.unstable_forceFrameRate = function() {
    };
  } else {
    var x2 = window.setTimeout, y2 = window.clearTimeout;
    if (typeof console !== "undefined") {
      var z2 = window.cancelAnimationFrame;
      typeof window.requestAnimationFrame !== "function" && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      typeof z2 !== "function" && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }
    var A2 = false, B2 = null, C2 = -1, D2 = 5, E = 0;
    exports.unstable_shouldYield = function() {
      return exports.unstable_now() >= E;
    };
    k = function() {
    };
    exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D2 = 0 < a ? Math.floor(1e3 / a) : 5;
    };
    var F2 = new MessageChannel(), G2 = F2.port2;
    F2.port1.onmessage = function() {
      if (B2 !== null) {
        var a = exports.unstable_now();
        E = a + D2;
        try {
          B2(true, a) ? G2.postMessage(null) : (A2 = false, B2 = null);
        } catch (b) {
          throw G2.postMessage(null), b;
        }
      } else
        A2 = false;
    };
    f = function(a) {
      B2 = a;
      A2 || (A2 = true, G2.postMessage(null));
    };
    g = function(a, b) {
      C2 = x2(function() {
        a(exports.unstable_now());
      }, b);
    };
    h = function() {
      y2(C2);
      C2 = -1;
    };
  }
  function H2(a, b) {
    var c = a.length;
    a.push(b);
    a:
      for (; ; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (e !== void 0 && 0 < I2(e, b))
          a[d] = b, a[c] = e, c = d;
        else
          break a;
      }
  }
  function J2(a) {
    a = a[0];
    return a === void 0 ? null : a;
  }
  function K2(a) {
    var b = a[0];
    if (b !== void 0) {
      var c = a.pop();
      if (c !== b) {
        a[0] = c;
        a:
          for (var d = 0, e = a.length; d < e; ) {
            var m2 = 2 * (d + 1) - 1, n2 = a[m2], v2 = m2 + 1, r2 = a[v2];
            if (n2 !== void 0 && 0 > I2(n2, c))
              r2 !== void 0 && 0 > I2(r2, n2) ? (a[d] = r2, a[v2] = c, d = v2) : (a[d] = n2, a[m2] = c, d = m2);
            else if (r2 !== void 0 && 0 > I2(r2, c))
              a[d] = r2, a[v2] = c, d = v2;
            else
              break a;
          }
      }
      return b;
    }
    return null;
  }
  function I2(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return c !== 0 ? c : a.id - b.id;
  }
  var L2 = [], M2 = [], N2 = 1, O2 = null, P2 = 3, Q2 = false, R2 = false, S2 = false;
  function T2(a) {
    for (var b = J2(M2); b !== null; ) {
      if (b.callback === null)
        K2(M2);
      else if (b.startTime <= a)
        K2(M2), b.sortIndex = b.expirationTime, H2(L2, b);
      else
        break;
      b = J2(M2);
    }
  }
  function U2(a) {
    S2 = false;
    T2(a);
    if (!R2)
      if (J2(L2) !== null)
        R2 = true, f(V2);
      else {
        var b = J2(M2);
        b !== null && g(U2, b.startTime - a);
      }
  }
  function V2(a, b) {
    R2 = false;
    S2 && (S2 = false, h());
    Q2 = true;
    var c = P2;
    try {
      T2(b);
      for (O2 = J2(L2); O2 !== null && (!(O2.expirationTime > b) || a && !exports.unstable_shouldYield()); ) {
        var d = O2.callback;
        if (typeof d === "function") {
          O2.callback = null;
          P2 = O2.priorityLevel;
          var e = d(O2.expirationTime <= b);
          b = exports.unstable_now();
          typeof e === "function" ? O2.callback = e : O2 === J2(L2) && K2(L2);
          T2(b);
        } else
          K2(L2);
        O2 = J2(L2);
      }
      if (O2 !== null)
        var m2 = true;
      else {
        var n2 = J2(M2);
        n2 !== null && g(U2, n2.startTime - b);
        m2 = false;
      }
      return m2;
    } finally {
      O2 = null, P2 = c, Q2 = false;
    }
  }
  var W2 = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a) {
    a.callback = null;
  };
  exports.unstable_continueExecution = function() {
    R2 || Q2 || (R2 = true, f(V2));
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return P2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return J2(L2);
  };
  exports.unstable_next = function(a) {
    switch (P2) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;
      default:
        b = P2;
    }
    var c = P2;
    P2 = b;
    try {
      return a();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = W2;
  exports.unstable_runWithPriority = function(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a = 3;
    }
    var c = P2;
    P2 = a;
    try {
      return b();
    } finally {
      P2 = c;
    }
  };
  exports.unstable_scheduleCallback = function(a, b, c) {
    var d = exports.unstable_now();
    typeof c === "object" && c !== null ? (c = c.delay, c = typeof c === "number" && 0 < c ? d + c : d) : c = d;
    switch (a) {
      case 1:
        var e = -1;
        break;
      case 2:
        e = 250;
        break;
      case 5:
        e = 1073741823;
        break;
      case 4:
        e = 1e4;
        break;
      default:
        e = 5e3;
    }
    e = c + e;
    a = { id: N2++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 };
    c > d ? (a.sortIndex = c, H2(M2, a), J2(L2) === null && a === J2(M2) && (S2 ? h() : S2 = true, g(U2, c - d))) : (a.sortIndex = e, H2(L2, a), R2 || Q2 || (R2 = true, f(V2)));
    return a;
  };
  exports.unstable_wrapCallback = function(a) {
    var b = P2;
    return function() {
      var c = P2;
      P2 = b;
      try {
        return a.apply(this, arguments);
      } finally {
        P2 = c;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
/** @license React v17.0.2
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = react.exports, m = objectAssign, r = scheduler.exports;
function y(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++)
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
if (!aa)
  throw Error(y(227));
var ba = /* @__PURE__ */ new Set(), ca = {};
function da(a, b) {
  ea(a, b);
  ea(a + "Capture", b);
}
function ea(a, b) {
  ca[a] = b;
  for (a = 0; a < b.length; a++)
    ba.add(b[a]);
}
var fa = !(typeof window === "undefined" || typeof window.document === "undefined" || typeof window.document.createElement === "undefined"), ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, ia = Object.prototype.hasOwnProperty, ja = {}, ka = {};
function la(a) {
  if (ia.call(ka, a))
    return true;
  if (ia.call(ja, a))
    return false;
  if (ha.test(a))
    return ka[a] = true;
  ja[a] = true;
  return false;
}
function ma(a, b, c, d) {
  if (c !== null && c.type === 0)
    return false;
  switch (typeof b) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d)
        return false;
      if (c !== null)
        return !c.acceptsBooleans;
      a = a.toLowerCase().slice(0, 5);
      return a !== "data-" && a !== "aria-";
    default:
      return false;
  }
}
function na(a, b, c, d) {
  if (b === null || typeof b === "undefined" || ma(a, b, c, d))
    return true;
  if (d)
    return false;
  if (c !== null)
    switch (c.type) {
      case 3:
        return !b;
      case 4:
        return b === false;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
  return false;
}
function B(a, b, c, d, e, f, g) {
  this.acceptsBooleans = b === 2 || b === 3 || b === 4;
  this.attributeName = d;
  this.attributeNamespace = e;
  this.mustUseProperty = c;
  this.propertyName = a;
  this.type = b;
  this.sanitizeURL = f;
  this.removeEmptyString = g;
}
var D = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
  D[a] = new B(a, 0, false, a, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
  var b = a[0];
  D[b] = new B(b, 1, false, a[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
  D[a] = new B(a, 2, false, a.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
  D[a] = new B(a, 2, false, a, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
  D[a] = new B(a, 3, false, a.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a) {
  D[a] = new B(a, 3, true, a, null, false, false);
});
["capture", "download"].forEach(function(a) {
  D[a] = new B(a, 4, false, a, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a) {
  D[a] = new B(a, 6, false, a, null, false, false);
});
["rowSpan", "start"].forEach(function(a) {
  D[a] = new B(a, 5, false, a.toLowerCase(), null, false, false);
});
var oa = /[\-:]([a-z])/g;
function pa(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
  var b = a.replace(oa, pa);
  D[b] = new B(b, 1, false, a, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, false, false);
});
D.xlinkHref = new B("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a) {
  D[a] = new B(a, 1, false, a.toLowerCase(), null, true, true);
});
function qa(a, b, c, d) {
  var e = D.hasOwnProperty(b) ? D[b] : null;
  var f = e !== null ? e.type === 0 : d ? false : !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N" ? false : true;
  f || (na(b, c, e, d) && (c = null), d || e === null ? la(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? false : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === true ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
}
var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, sa = 60103, ta = 60106, ua = 60107, wa = 60108, xa = 60114, ya = 60109, za = 60110, Aa = 60112, Ba = 60113, Ca = 60120, Da = 60115, Ea = 60116, Fa = 60121, Ga = 60128, Ha = 60129, Ia = 60130, Ja = 60131;
if (typeof Symbol === "function" && Symbol.for) {
  var E = Symbol.for;
  sa = E("react.element");
  ta = E("react.portal");
  ua = E("react.fragment");
  wa = E("react.strict_mode");
  xa = E("react.profiler");
  ya = E("react.provider");
  za = E("react.context");
  Aa = E("react.forward_ref");
  Ba = E("react.suspense");
  Ca = E("react.suspense_list");
  Da = E("react.memo");
  Ea = E("react.lazy");
  Fa = E("react.block");
  E("react.scope");
  Ga = E("react.opaque.id");
  Ha = E("react.debug_trace_mode");
  Ia = E("react.offscreen");
  Ja = E("react.legacy_hidden");
}
var Ka = typeof Symbol === "function" && Symbol.iterator;
function La(a) {
  if (a === null || typeof a !== "object")
    return null;
  a = Ka && a[Ka] || a["@@iterator"];
  return typeof a === "function" ? a : null;
}
var Ma;
function Na(a) {
  if (Ma === void 0)
    try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
  return "\n" + Ma + a;
}
var Oa = false;
function Pa(a, b) {
  if (!a || Oa)
    return "";
  Oa = true;
  var c = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b)
      if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect === "object" && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (k) {
          var d = k;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (k) {
          d = k;
        }
        a.call(b.prototype);
      }
    else {
      try {
        throw Error();
      } catch (k) {
        d = k;
      }
      a();
    }
  } catch (k) {
    if (k && d && typeof k.stack === "string") {
      for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h]; )
        h--;
      for (; 1 <= g && 0 <= h; g--, h--)
        if (e[g] !== f[h]) {
          if (g !== 1 || h !== 1) {
            do
              if (g--, h--, 0 > h || e[g] !== f[h])
                return "\n" + e[g].replace(" at new ", " at ");
            while (1 <= g && 0 <= h);
          }
          break;
        }
    }
  } finally {
    Oa = false, Error.prepareStackTrace = c;
  }
  return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
}
function Qa(a) {
  switch (a.tag) {
    case 5:
      return Na(a.type);
    case 16:
      return Na("Lazy");
    case 13:
      return Na("Suspense");
    case 19:
      return Na("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a = Pa(a.type, false), a;
    case 11:
      return a = Pa(a.type.render, false), a;
    case 22:
      return a = Pa(a.type._render, false), a;
    case 1:
      return a = Pa(a.type, true), a;
    default:
      return "";
  }
}
function Ra(a) {
  if (a == null)
    return null;
  if (typeof a === "function")
    return a.displayName || a.name || null;
  if (typeof a === "string")
    return a;
  switch (a) {
    case ua:
      return "Fragment";
    case ta:
      return "Portal";
    case xa:
      return "Profiler";
    case wa:
      return "StrictMode";
    case Ba:
      return "Suspense";
    case Ca:
      return "SuspenseList";
  }
  if (typeof a === "object")
    switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";
      case ya:
        return (a._context.displayName || "Context") + ".Provider";
      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || (b !== "" ? "ForwardRef(" + b + ")" : "ForwardRef");
      case Da:
        return Ra(a.type);
      case Fa:
        return Ra(a._render);
      case Ea:
        b = a._payload;
        a = a._init;
        try {
          return Ra(a(b));
        } catch (c) {
        }
    }
  return null;
}
function Sa(a) {
  switch (typeof a) {
    case "boolean":
    case "number":
    case "object":
    case "string":
    case "undefined":
      return a;
    default:
      return "";
  }
}
function Ta(a) {
  var b = a.type;
  return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
}
function Ua(a) {
  var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
  if (!a.hasOwnProperty(b) && typeof c !== "undefined" && typeof c.get === "function" && typeof c.set === "function") {
    var e = c.get, f = c.set;
    Object.defineProperty(a, b, { configurable: true, get: function() {
      return e.call(this);
    }, set: function(a2) {
      d = "" + a2;
      f.call(this, a2);
    } });
    Object.defineProperty(a, b, { enumerable: c.enumerable });
    return { getValue: function() {
      return d;
    }, setValue: function(a2) {
      d = "" + a2;
    }, stopTracking: function() {
      a._valueTracker = null;
      delete a[b];
    } };
  }
}
function Va(a) {
  a._valueTracker || (a._valueTracker = Ua(a));
}
function Wa(a) {
  if (!a)
    return false;
  var b = a._valueTracker;
  if (!b)
    return true;
  var c = b.getValue();
  var d = "";
  a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), true) : false;
}
function Xa(a) {
  a = a || (typeof document !== "undefined" ? document : void 0);
  if (typeof a === "undefined")
    return null;
  try {
    return a.activeElement || a.body;
  } catch (b) {
    return a.body;
  }
}
function Ya(a, b) {
  var c = b.checked;
  return m({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c != null ? c : a._wrapperState.initialChecked });
}
function Za(a, b) {
  var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
  c = Sa(b.value != null ? b.value : c);
  a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null };
}
function $a(a, b) {
  b = b.checked;
  b != null && qa(a, "checked", b, false);
}
function ab(a, b) {
  $a(a, b);
  var c = Sa(b.value), d = b.type;
  if (c != null)
    if (d === "number") {
      if (c === 0 && a.value === "" || a.value != c)
        a.value = "" + c;
    } else
      a.value !== "" + c && (a.value = "" + c);
  else if (d === "submit" || d === "reset") {
    a.removeAttribute("value");
    return;
  }
  b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
  b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
}
function cb(a, b, c) {
  if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
    var d = b.type;
    if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null))
      return;
    b = "" + a._wrapperState.initialValue;
    c || b === a.value || (a.value = b);
    a.defaultValue = b;
  }
  c = a.name;
  c !== "" && (a.name = "");
  a.defaultChecked = !!a._wrapperState.initialChecked;
  c !== "" && (a.name = c);
}
function bb(a, b, c) {
  if (b !== "number" || Xa(a.ownerDocument) !== a)
    c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
}
function db(a) {
  var b = "";
  aa.Children.forEach(a, function(a2) {
    a2 != null && (b += a2);
  });
  return b;
}
function eb(a, b) {
  a = m({ children: void 0 }, b);
  if (b = db(b.children))
    a.children = b;
  return a;
}
function fb(a, b, c, d) {
  a = a.options;
  if (b) {
    b = {};
    for (var e = 0; e < c.length; e++)
      b["$" + c[e]] = true;
    for (c = 0; c < a.length; c++)
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = true);
  } else {
    c = "" + Sa(c);
    b = null;
    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = true;
        d && (a[e].defaultSelected = true);
        return;
      }
      b !== null || a[e].disabled || (b = a[e]);
    }
    b !== null && (b.selected = true);
  }
}
function gb(a, b) {
  if (b.dangerouslySetInnerHTML != null)
    throw Error(y(91));
  return m({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}
function hb(a, b) {
  var c = b.value;
  if (c == null) {
    c = b.children;
    b = b.defaultValue;
    if (c != null) {
      if (b != null)
        throw Error(y(92));
      if (Array.isArray(c)) {
        if (!(1 >= c.length))
          throw Error(y(93));
        c = c[0];
      }
      b = c;
    }
    b == null && (b = "");
    c = b;
  }
  a._wrapperState = { initialValue: Sa(c) };
}
function ib(a, b) {
  var c = Sa(b.value), d = Sa(b.defaultValue);
  c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c));
  d != null && (a.defaultValue = "" + d);
}
function jb(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
}
var kb = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function lb(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mb(a, b) {
  return a == null || a === "http://www.w3.org/1999/xhtml" ? lb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
}
var nb, ob = function(a) {
  return typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function() {
      return a(b, c, d, e);
    });
  } : a;
}(function(a, b) {
  if (a.namespaceURI !== kb.svg || "innerHTML" in a)
    a.innerHTML = b;
  else {
    nb = nb || document.createElement("div");
    nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";
    for (b = nb.firstChild; a.firstChild; )
      a.removeChild(a.firstChild);
    for (; b.firstChild; )
      a.appendChild(b.firstChild);
  }
});
function pb(a, b) {
  if (b) {
    var c = a.firstChild;
    if (c && c === a.lastChild && c.nodeType === 3) {
      c.nodeValue = b;
      return;
    }
  }
  a.textContent = b;
}
var qb = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, rb = ["Webkit", "ms", "Moz", "O"];
Object.keys(qb).forEach(function(a) {
  rb.forEach(function(b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    qb[b] = qb[a];
  });
});
function sb(a, b, c) {
  return b == null || typeof b === "boolean" || b === "" ? "" : c || typeof b !== "number" || b === 0 || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
}
function tb(a, b) {
  a = a.style;
  for (var c in b)
    if (b.hasOwnProperty(c)) {
      var d = c.indexOf("--") === 0, e = sb(c, b[c], d);
      c === "float" && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
}
var ub = m({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function vb(a, b) {
  if (b) {
    if (ub[a] && (b.children != null || b.dangerouslySetInnerHTML != null))
      throw Error(y(137, a));
    if (b.dangerouslySetInnerHTML != null) {
      if (b.children != null)
        throw Error(y(60));
      if (!(typeof b.dangerouslySetInnerHTML === "object" && "__html" in b.dangerouslySetInnerHTML))
        throw Error(y(61));
    }
    if (b.style != null && typeof b.style !== "object")
      throw Error(y(62));
  }
}
function wb(a, b) {
  if (a.indexOf("-") === -1)
    return typeof b.is === "string";
  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
function xb(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return a.nodeType === 3 ? a.parentNode : a;
}
var yb = null, zb = null, Ab = null;
function Bb(a) {
  if (a = Cb(a)) {
    if (typeof yb !== "function")
      throw Error(y(280));
    var b = a.stateNode;
    b && (b = Db(b), yb(a.stateNode, a.type, b));
  }
}
function Eb(a) {
  zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
}
function Fb() {
  if (zb) {
    var a = zb, b = Ab;
    Ab = zb = null;
    Bb(a);
    if (b)
      for (a = 0; a < b.length; a++)
        Bb(b[a]);
  }
}
function Gb(a, b) {
  return a(b);
}
function Hb(a, b, c, d, e) {
  return a(b, c, d, e);
}
function Ib() {
}
var Jb = Gb, Kb = false, Lb = false;
function Mb() {
  if (zb !== null || Ab !== null)
    Ib(), Fb();
}
function Nb(a, b, c) {
  if (Lb)
    return a(b, c);
  Lb = true;
  try {
    return Jb(a, b, c);
  } finally {
    Lb = false, Mb();
  }
}
function Ob(a, b) {
  var c = a.stateNode;
  if (c === null)
    return null;
  var d = Db(c);
  if (d === null)
    return null;
  c = d[b];
  a:
    switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea"));
        a = !d;
        break a;
      default:
        a = false;
    }
  if (a)
    return null;
  if (c && typeof c !== "function")
    throw Error(y(231, b, typeof c));
  return c;
}
var Pb = false;
if (fa)
  try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", { get: function() {
      Pb = true;
    } });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = false;
  }
function Rb(a, b, c, d, e, f, g, h, k) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b.apply(c, l2);
  } catch (n2) {
    this.onError(n2);
  }
}
var Sb = false, Tb = null, Ub = false, Vb = null, Wb = { onError: function(a) {
  Sb = true;
  Tb = a;
} };
function Xb(a, b, c, d, e, f, g, h, k) {
  Sb = false;
  Tb = null;
  Rb.apply(Wb, arguments);
}
function Yb(a, b, c, d, e, f, g, h, k) {
  Xb.apply(this, arguments);
  if (Sb) {
    if (Sb) {
      var l2 = Tb;
      Sb = false;
      Tb = null;
    } else
      throw Error(y(198));
    Ub || (Ub = true, Vb = l2);
  }
}
function Zb(a) {
  var b = a, c = a;
  if (a.alternate)
    for (; b.return; )
      b = b.return;
  else {
    a = b;
    do
      b = a, (b.flags & 1026) !== 0 && (c = b.return), a = b.return;
    while (a);
  }
  return b.tag === 3 ? c : null;
}
function $b(a) {
  if (a.tag === 13) {
    var b = a.memoizedState;
    b === null && (a = a.alternate, a !== null && (b = a.memoizedState));
    if (b !== null)
      return b.dehydrated;
  }
  return null;
}
function ac$1(a) {
  if (Zb(a) !== a)
    throw Error(y(188));
}
function bc(a) {
  var b = a.alternate;
  if (!b) {
    b = Zb(a);
    if (b === null)
      throw Error(y(188));
    return b !== a ? null : a;
  }
  for (var c = a, d = b; ; ) {
    var e = c.return;
    if (e === null)
      break;
    var f = e.alternate;
    if (f === null) {
      d = e.return;
      if (d !== null) {
        c = d;
        continue;
      }
      break;
    }
    if (e.child === f.child) {
      for (f = e.child; f; ) {
        if (f === c)
          return ac$1(e), a;
        if (f === d)
          return ac$1(e), b;
        f = f.sibling;
      }
      throw Error(y(188));
    }
    if (c.return !== d.return)
      c = e, d = f;
    else {
      for (var g = false, h = e.child; h; ) {
        if (h === c) {
          g = true;
          c = e;
          d = f;
          break;
        }
        if (h === d) {
          g = true;
          d = e;
          c = f;
          break;
        }
        h = h.sibling;
      }
      if (!g) {
        for (h = f.child; h; ) {
          if (h === c) {
            g = true;
            c = f;
            d = e;
            break;
          }
          if (h === d) {
            g = true;
            d = f;
            c = e;
            break;
          }
          h = h.sibling;
        }
        if (!g)
          throw Error(y(189));
      }
    }
    if (c.alternate !== d)
      throw Error(y(190));
  }
  if (c.tag !== 3)
    throw Error(y(188));
  return c.stateNode.current === c ? a : b;
}
function cc(a) {
  a = bc(a);
  if (!a)
    return null;
  for (var b = a; ; ) {
    if (b.tag === 5 || b.tag === 6)
      return b;
    if (b.child)
      b.child.return = b, b = b.child;
    else {
      if (b === a)
        break;
      for (; !b.sibling; ) {
        if (!b.return || b.return === a)
          return null;
        b = b.return;
      }
      b.sibling.return = b.return;
      b = b.sibling;
    }
  }
  return null;
}
function dc(a, b) {
  for (var c = a.alternate; b !== null; ) {
    if (b === a || b === c)
      return true;
    b = b.return;
  }
  return false;
}
var ec, fc, gc, hc, ic$1 = false, jc = [], kc = null, lc = null, mc = null, nc = /* @__PURE__ */ new Map(), oc = /* @__PURE__ */ new Map(), pc = [], qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a, b, c, d, e) {
  return { blockedOn: a, domEventName: b, eventSystemFlags: c | 16, nativeEvent: e, targetContainers: [d] };
}
function sc$1(a, b) {
  switch (a) {
    case "focusin":
    case "focusout":
      kc = null;
      break;
    case "dragenter":
    case "dragleave":
      lc = null;
      break;
    case "mouseover":
    case "mouseout":
      mc = null;
      break;
    case "pointerover":
    case "pointerout":
      nc.delete(b.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      oc.delete(b.pointerId);
  }
}
function tc(a, b, c, d, e, f) {
  if (a === null || a.nativeEvent !== f)
    return a = rc(b, c, d, e, f), b !== null && (b = Cb(b), b !== null && fc(b)), a;
  a.eventSystemFlags |= d;
  b = a.targetContainers;
  e !== null && b.indexOf(e) === -1 && b.push(e);
  return a;
}
function uc(a, b, c, d, e) {
  switch (b) {
    case "focusin":
      return kc = tc(kc, a, b, c, d, e), true;
    case "dragenter":
      return lc = tc(lc, a, b, c, d, e), true;
    case "mouseover":
      return mc = tc(mc, a, b, c, d, e), true;
    case "pointerover":
      var f = e.pointerId;
      nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
      return true;
    case "gotpointercapture":
      return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), true;
  }
  return false;
}
function vc(a) {
  var b = wc(a.target);
  if (b !== null) {
    var c = Zb(b);
    if (c !== null) {
      if (b = c.tag, b === 13) {
        if (b = $b(c), b !== null) {
          a.blockedOn = b;
          hc(a.lanePriority, function() {
            r.unstable_runWithPriority(a.priority, function() {
              gc(c);
            });
          });
          return;
        }
      } else if (b === 3 && c.stateNode.hydrate) {
        a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a.blockedOn = null;
}
function xc(a) {
  if (a.blockedOn !== null)
    return false;
  for (var b = a.targetContainers; 0 < b.length; ) {
    var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
    if (c !== null)
      return b = Cb(c), b !== null && fc(b), a.blockedOn = c, false;
    b.shift();
  }
  return true;
}
function zc(a, b, c) {
  xc(a) && c.delete(b);
}
function Ac() {
  for (ic$1 = false; 0 < jc.length; ) {
    var a = jc[0];
    if (a.blockedOn !== null) {
      a = Cb(a.blockedOn);
      a !== null && ec(a);
      break;
    }
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (c !== null) {
        a.blockedOn = c;
        break;
      }
      b.shift();
    }
    a.blockedOn === null && jc.shift();
  }
  kc !== null && xc(kc) && (kc = null);
  lc !== null && xc(lc) && (lc = null);
  mc !== null && xc(mc) && (mc = null);
  nc.forEach(zc);
  oc.forEach(zc);
}
function Bc(a, b) {
  a.blockedOn === b && (a.blockedOn = null, ic$1 || (ic$1 = true, r.unstable_scheduleCallback(r.unstable_NormalPriority, Ac)));
}
function Cc(a) {
  function b(b2) {
    return Bc(b2, a);
  }
  if (0 < jc.length) {
    Bc(jc[0], a);
    for (var c = 1; c < jc.length; c++) {
      var d = jc[c];
      d.blockedOn === a && (d.blockedOn = null);
    }
  }
  kc !== null && Bc(kc, a);
  lc !== null && Bc(lc, a);
  mc !== null && Bc(mc, a);
  nc.forEach(b);
  oc.forEach(b);
  for (c = 0; c < pc.length; c++)
    d = pc[c], d.blockedOn === a && (d.blockedOn = null);
  for (; 0 < pc.length && (c = pc[0], c.blockedOn === null); )
    vc(c), c.blockedOn === null && pc.shift();
}
function Dc(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  return c;
}
var Ec = { animationend: Dc("Animation", "AnimationEnd"), animationiteration: Dc("Animation", "AnimationIteration"), animationstart: Dc("Animation", "AnimationStart"), transitionend: Dc("Transition", "TransitionEnd") }, Fc = {}, Gc = {};
fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);
function Hc(a) {
  if (Fc[a])
    return Fc[a];
  if (!Ec[a])
    return a;
  var b = Ec[a], c;
  for (c in b)
    if (b.hasOwnProperty(c) && c in Gc)
      return Fc[a] = b[c];
  return a;
}
var Ic = Hc("animationend"), Jc = Hc("animationiteration"), Kc = Hc("animationstart"), Lc = Hc("transitionend"), Mc = /* @__PURE__ */ new Map(), Nc = /* @__PURE__ */ new Map(), Oc = [
  "abort",
  "abort",
  Ic,
  "animationEnd",
  Jc,
  "animationIteration",
  Kc,
  "animationStart",
  "canplay",
  "canPlay",
  "canplaythrough",
  "canPlayThrough",
  "durationchange",
  "durationChange",
  "emptied",
  "emptied",
  "encrypted",
  "encrypted",
  "ended",
  "ended",
  "error",
  "error",
  "gotpointercapture",
  "gotPointerCapture",
  "load",
  "load",
  "loadeddata",
  "loadedData",
  "loadedmetadata",
  "loadedMetadata",
  "loadstart",
  "loadStart",
  "lostpointercapture",
  "lostPointerCapture",
  "playing",
  "playing",
  "progress",
  "progress",
  "seeking",
  "seeking",
  "stalled",
  "stalled",
  "suspend",
  "suspend",
  "timeupdate",
  "timeUpdate",
  Lc,
  "transitionEnd",
  "waiting",
  "waiting"
];
function Pc(a, b) {
  for (var c = 0; c < a.length; c += 2) {
    var d = a[c], e = a[c + 1];
    e = "on" + (e[0].toUpperCase() + e.slice(1));
    Nc.set(d, b);
    Mc.set(d, e);
    da(e, [d]);
  }
}
var Qc = r.unstable_now;
Qc();
var F = 8;
function Rc(a) {
  if ((1 & a) !== 0)
    return F = 15, 1;
  if ((2 & a) !== 0)
    return F = 14, 2;
  if ((4 & a) !== 0)
    return F = 13, 4;
  var b = 24 & a;
  if (b !== 0)
    return F = 12, b;
  if ((a & 32) !== 0)
    return F = 11, 32;
  b = 192 & a;
  if (b !== 0)
    return F = 10, b;
  if ((a & 256) !== 0)
    return F = 9, 256;
  b = 3584 & a;
  if (b !== 0)
    return F = 8, b;
  if ((a & 4096) !== 0)
    return F = 7, 4096;
  b = 4186112 & a;
  if (b !== 0)
    return F = 6, b;
  b = 62914560 & a;
  if (b !== 0)
    return F = 5, b;
  if (a & 67108864)
    return F = 4, 67108864;
  if ((a & 134217728) !== 0)
    return F = 3, 134217728;
  b = 805306368 & a;
  if (b !== 0)
    return F = 2, b;
  if ((1073741824 & a) !== 0)
    return F = 1, 1073741824;
  F = 8;
  return a;
}
function Sc$1(a) {
  switch (a) {
    case 99:
      return 15;
    case 98:
      return 10;
    case 97:
    case 96:
      return 8;
    case 95:
      return 2;
    default:
      return 0;
  }
}
function Tc(a) {
  switch (a) {
    case 15:
    case 14:
      return 99;
    case 13:
    case 12:
    case 11:
    case 10:
      return 98;
    case 9:
    case 8:
    case 7:
    case 6:
    case 4:
    case 5:
      return 97;
    case 3:
    case 2:
    case 1:
      return 95;
    case 0:
      return 90;
    default:
      throw Error(y(358, a));
  }
}
function Uc(a, b) {
  var c = a.pendingLanes;
  if (c === 0)
    return F = 0;
  var d = 0, e = 0, f = a.expiredLanes, g = a.suspendedLanes, h = a.pingedLanes;
  if (f !== 0)
    d = f, e = F = 15;
  else if (f = c & 134217727, f !== 0) {
    var k = f & ~g;
    k !== 0 ? (d = Rc(k), e = F) : (h &= f, h !== 0 && (d = Rc(h), e = F));
  } else
    f = c & ~g, f !== 0 ? (d = Rc(f), e = F) : h !== 0 && (d = Rc(h), e = F);
  if (d === 0)
    return 0;
  d = 31 - Vc(d);
  d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;
  if (b !== 0 && b !== d && (b & g) === 0) {
    Rc(b);
    if (e <= F)
      return b;
    F = e;
  }
  b = a.entangledLanes;
  if (b !== 0)
    for (a = a.entanglements, b &= d; 0 < b; )
      c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
  return d;
}
function Wc(a) {
  a = a.pendingLanes & -1073741825;
  return a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
}
function Xc(a, b) {
  switch (a) {
    case 15:
      return 1;
    case 14:
      return 2;
    case 12:
      return a = Yc(24 & ~b), a === 0 ? Xc(10, b) : a;
    case 10:
      return a = Yc(192 & ~b), a === 0 ? Xc(8, b) : a;
    case 8:
      return a = Yc(3584 & ~b), a === 0 && (a = Yc(4186112 & ~b), a === 0 && (a = 512)), a;
    case 2:
      return b = Yc(805306368 & ~b), b === 0 && (b = 268435456), b;
  }
  throw Error(y(358, a));
}
function Yc(a) {
  return a & -a;
}
function Zc(a) {
  for (var b = [], c = 0; 31 > c; c++)
    b.push(a);
  return b;
}
function $c(a, b, c) {
  a.pendingLanes |= b;
  var d = b - 1;
  a.suspendedLanes &= d;
  a.pingedLanes &= d;
  a = a.eventTimes;
  b = 31 - Vc(b);
  a[b] = c;
}
var Vc = Math.clz32 ? Math.clz32 : ad, bd = Math.log, cd = Math.LN2;
function ad(a) {
  return a === 0 ? 32 : 31 - (bd(a) / cd | 0) | 0;
}
var dd$1 = r.unstable_UserBlockingPriority, ed = r.unstable_runWithPriority, fd = true;
function gd(a, b, c, d) {
  Kb || Ib();
  var e = hd, f = Kb;
  Kb = true;
  try {
    Hb(e, a, b, c, d);
  } finally {
    (Kb = f) || Mb();
  }
}
function id(a, b, c, d) {
  ed(dd$1, hd.bind(null, a, b, c, d));
}
function hd(a, b, c, d) {
  if (fd) {
    var e;
    if ((e = (b & 4) === 0) && 0 < jc.length && -1 < qc.indexOf(a))
      a = rc(null, a, b, c, d), jc.push(a);
    else {
      var f = yc(a, b, c, d);
      if (f === null)
        e && sc$1(a, d);
      else {
        if (e) {
          if (-1 < qc.indexOf(a)) {
            a = rc(f, a, b, c, d);
            jc.push(a);
            return;
          }
          if (uc(f, a, b, c, d))
            return;
          sc$1(a, d);
        }
        jd(a, b, d, null, c);
      }
    }
  }
}
function yc(a, b, c, d) {
  var e = xb(d);
  e = wc(e);
  if (e !== null) {
    var f = Zb(e);
    if (f === null)
      e = null;
    else {
      var g = f.tag;
      if (g === 13) {
        e = $b(f);
        if (e !== null)
          return e;
        e = null;
      } else if (g === 3) {
        if (f.stateNode.hydrate)
          return f.tag === 3 ? f.stateNode.containerInfo : null;
        e = null;
      } else
        f !== e && (e = null);
    }
  }
  jd(a, b, d, e, c);
  return null;
}
var kd = null, ld = null, md$3 = null;
function nd() {
  if (md$3)
    return md$3;
  var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f = e.length;
  for (a = 0; a < c && b[a] === e[a]; a++)
    ;
  var g = c - a;
  for (d = 1; d <= g && b[c - d] === e[f - d]; d++)
    ;
  return md$3 = e.slice(a, 1 < d ? 1 - d : void 0);
}
function od(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b;
  a === 10 && (a = 13);
  return 32 <= a || a === 13 ? a : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a) {
  function b(b2, d, e, f, g) {
    this._reactName = b2;
    this._targetInst = e;
    this.type = d;
    this.nativeEvent = f;
    this.target = g;
    this.currentTarget = null;
    for (var c in a)
      a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f) : f[c]);
    this.isDefaultPrevented = (f.defaultPrevented != null ? f.defaultPrevented : f.returnValue === false) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  m(b.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a2 = this.nativeEvent;
    a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue !== "unknown" && (a2.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a2 = this.nativeEvent;
    a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble !== "unknown" && (a2.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
  return a.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = m({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = m({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
  return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
}, movementX: function(a) {
  if ("movementX" in a)
    return a.movementX;
  a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
  return wd;
}, movementY: function(a) {
  return "movementY" in a ? a.movementY : xd;
} }), Bd = rd(Ad), Cd = m({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = m({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = m({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = m({}, sd, { clipboardData: function(a) {
  return "clipboardData" in a ? a.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = m({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : false;
}
function zd() {
  return Pd;
}
var Qd = m({}, ud, { key: function(a) {
  if (a.key) {
    var b = Md[a.key] || a.key;
    if (b !== "Unidentified")
      return b;
  }
  return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
  return a.type === "keypress" ? od(a) : 0;
}, keyCode: function(a) {
  return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
}, which: function(a) {
  return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
} }), Rd = rd(Qd), Sd = m({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = m({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = m({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = m({}, Ad, {
  deltaX: function(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = fa && "CompositionEvent" in window, be = null;
fa && "documentMode" in document && (be = document.documentMode);
var ce = fa && "TextEvent" in window && !be, de = fa && (!ae || be && 8 < be && 11 >= be), ee$1 = String.fromCharCode(32), fe = false;
function ge$1(a, b) {
  switch (a) {
    case "keyup":
      return $d.indexOf(b.keyCode) !== -1;
    case "keydown":
      return b.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a) {
  a = a.detail;
  return typeof a === "object" && "data" in a ? a.data : null;
}
var ie = false;
function je(a, b) {
  switch (a) {
    case "compositionend":
      return he(b);
    case "keypress":
      if (b.which !== 32)
        return null;
      fe = true;
      return ee$1;
    case "textInput":
      return a = b.data, a === ee$1 && fe ? null : a;
    default:
      return null;
  }
}
function ke(a, b) {
  if (ie)
    return a === "compositionend" || !ae && ge$1(a, b) ? (a = nd(), md$3 = ld = kd = null, ie = false, a) : null;
  switch (a) {
    case "paste":
      return null;
    case "keypress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length)
          return b.char;
        if (b.which)
          return String.fromCharCode(b.which);
      }
      return null;
    case "compositionend":
      return de && b.locale !== "ko" ? null : b.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b === "input" ? !!le$1[a.type] : b === "textarea" ? true : false;
}
function ne$1(a, b, c, d) {
  Eb(d);
  b = oe(b, "onChange");
  0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
}
var pe = null, qe = null;
function re$1(a) {
  se(a, 0);
}
function te(a) {
  var b = ue(a);
  if (Wa(b))
    return a;
}
function ve(a, b) {
  if (a === "change")
    return b;
}
var we = false;
if (fa) {
  var xe;
  if (fa) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = typeof ze.oninput === "function";
    }
    xe = ye;
  } else
    xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a) {
  if (a.propertyName === "value" && te(qe)) {
    var b = [];
    ne$1(b, qe, a, xb(a));
    a = re$1;
    if (Kb)
      a(b);
    else {
      Kb = true;
      try {
        Gb(a, b);
      } finally {
        Kb = false, Mb();
      }
    }
  }
}
function Ce(a, b, c) {
  a === "focusin" ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae();
}
function De(a) {
  if (a === "selectionchange" || a === "keyup" || a === "keydown")
    return te(qe);
}
function Ee(a, b) {
  if (a === "click")
    return te(b);
}
function Fe(a, b) {
  if (a === "input" || a === "change")
    return te(b);
}
function Ge(a, b) {
  return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
}
var He = typeof Object.is === "function" ? Object.is : Ge, Ie = Object.prototype.hasOwnProperty;
function Je(a, b) {
  if (He(a, b))
    return true;
  if (typeof a !== "object" || a === null || typeof b !== "object" || b === null)
    return false;
  var c = Object.keys(a), d = Object.keys(b);
  if (c.length !== d.length)
    return false;
  for (d = 0; d < c.length; d++)
    if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]]))
      return false;
  return true;
}
function Ke(a) {
  for (; a && a.firstChild; )
    a = a.firstChild;
  return a;
}
function Le(a, b) {
  var c = Ke(a);
  a = 0;
  for (var d; c; ) {
    if (c.nodeType === 3) {
      d = a + c.textContent.length;
      if (a <= b && d >= b)
        return { node: c, offset: b - a };
      a = d;
    }
    a: {
      for (; c; ) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }
        c = c.parentNode;
      }
      c = void 0;
    }
    c = Ke(c);
  }
}
function Me(a, b) {
  return a && b ? a === b ? true : a && a.nodeType === 3 ? false : b && b.nodeType === 3 ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : false : false;
}
function Ne() {
  for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
    try {
      var c = typeof b.contentWindow.location.href === "string";
    } catch (d) {
      c = false;
    }
    if (c)
      a = b.contentWindow;
    else
      break;
    b = Xa(a.document);
  }
  return b;
}
function Oe(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
}
var Pe = fa && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re$1 = null, Se = null, Te = false;
function Ue(a, b, c) {
  var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
  Te || Qe == null || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se && Je(Se, d) || (Se = d, d = oe(Re$1, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe)));
}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
Pc(Oc, 2);
for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++)
  Nc.set(Ve[We], 0);
ea("onMouseEnter", ["mouseout", "mouseover"]);
ea("onMouseLeave", ["mouseout", "mouseover"]);
ea("onPointerEnter", ["pointerout", "pointerover"]);
ea("onPointerLeave", ["pointerout", "pointerover"]);
da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a, b, c) {
  var d = a.type || "unknown-event";
  a.currentTarget = c;
  Yb(d, b, void 0, a);
  a.currentTarget = null;
}
function se(a, b) {
  b = (b & 4) !== 0;
  for (var c = 0; c < a.length; c++) {
    var d = a[c], e = d.event;
    d = d.listeners;
    a: {
      var f = void 0;
      if (b)
        for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g], k = h.instance, l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
      else
        for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l2 = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped())
            break a;
          Ze(e, h, l2);
          f = k;
        }
    }
  }
  if (Ub)
    throw a = Vb, Ub = false, Vb = null, a;
}
function G(a, b) {
  var c = $e(b), d = a + "__bubble";
  c.has(d) || (af$1(b, a, 2, false), c.add(d));
}
var bf = "_reactListening" + Math.random().toString(36).slice(2);
function cf(a) {
  a[bf] || (a[bf] = true, ba.forEach(function(b) {
    Ye.has(b) || df(b, false, a, null);
    df(b, true, a, null);
  }));
}
function df(a, b, c, d) {
  var e = 4 < arguments.length && arguments[4] !== void 0 ? arguments[4] : 0, f = c;
  a === "selectionchange" && c.nodeType !== 9 && (f = c.ownerDocument);
  if (d !== null && !b && Ye.has(a)) {
    if (a !== "scroll")
      return;
    e |= 2;
    f = d;
  }
  var g = $e(f), h = a + "__" + (b ? "capture" : "bubble");
  g.has(h) || (b && (e |= 4), af$1(f, a, e, b), g.add(h));
}
function af$1(a, b, c, d) {
  var e = Nc.get(b);
  switch (e === void 0 ? 2 : e) {
    case 0:
      e = gd;
      break;
    case 1:
      e = id;
      break;
    default:
      e = hd;
  }
  c = e.bind(null, b, c, a);
  e = void 0;
  !Pb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = true);
  d ? e !== void 0 ? a.addEventListener(b, c, { capture: true, passive: e }) : a.addEventListener(b, c, true) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, false);
}
function jd(a, b, c, d, e) {
  var f = d;
  if ((b & 1) === 0 && (b & 2) === 0 && d !== null)
    a:
      for (; ; ) {
        if (d === null)
          return;
        var g = d.tag;
        if (g === 3 || g === 4) {
          var h = d.stateNode.containerInfo;
          if (h === e || h.nodeType === 8 && h.parentNode === e)
            break;
          if (g === 4)
            for (g = d.return; g !== null; ) {
              var k = g.tag;
              if (k === 3 || k === 4) {
                if (k = g.stateNode.containerInfo, k === e || k.nodeType === 8 && k.parentNode === e)
                  return;
              }
              g = g.return;
            }
          for (; h !== null; ) {
            g = wc(h);
            if (g === null)
              return;
            k = g.tag;
            if (k === 5 || k === 6) {
              d = f = g;
              continue a;
            }
            h = h.parentNode;
          }
        }
        d = d.return;
      }
  Nb(function() {
    var d2 = f, e2 = xb(c), g2 = [];
    a: {
      var h2 = Mc.get(a);
      if (h2 !== void 0) {
        var k2 = td, x2 = a;
        switch (a) {
          case "keypress":
            if (od(c) === 0)
              break a;
          case "keydown":
          case "keyup":
            k2 = Rd;
            break;
          case "focusin":
            x2 = "focus";
            k2 = Fd;
            break;
          case "focusout":
            x2 = "blur";
            k2 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k2 = Fd;
            break;
          case "click":
            if (c.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k2 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k2 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k2 = Vd;
            break;
          case Ic:
          case Jc:
          case Kc:
            k2 = Hd;
            break;
          case Lc:
            k2 = Xd;
            break;
          case "scroll":
            k2 = vd;
            break;
          case "wheel":
            k2 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k2 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k2 = Td;
        }
        var w = (b & 4) !== 0, z2 = !w && a === "scroll", u2 = w ? h2 !== null ? h2 + "Capture" : null : h2;
        w = [];
        for (var t2 = d2, q2; t2 !== null; ) {
          q2 = t2;
          var v2 = q2.stateNode;
          q2.tag === 5 && v2 !== null && (q2 = v2, u2 !== null && (v2 = Ob(t2, u2), v2 != null && w.push(ef(t2, v2, q2))));
          if (z2)
            break;
          t2 = t2.return;
        }
        0 < w.length && (h2 = new k2(h2, x2, null, c, e2), g2.push({ event: h2, listeners: w }));
      }
    }
    if ((b & 7) === 0) {
      a: {
        h2 = a === "mouseover" || a === "pointerover";
        k2 = a === "mouseout" || a === "pointerout";
        if (h2 && (b & 16) === 0 && (x2 = c.relatedTarget || c.fromElement) && (wc(x2) || x2[ff]))
          break a;
        if (k2 || h2) {
          h2 = e2.window === e2 ? e2 : (h2 = e2.ownerDocument) ? h2.defaultView || h2.parentWindow : window;
          if (k2) {
            if (x2 = c.relatedTarget || c.toElement, k2 = d2, x2 = x2 ? wc(x2) : null, x2 !== null && (z2 = Zb(x2), x2 !== z2 || x2.tag !== 5 && x2.tag !== 6))
              x2 = null;
          } else
            k2 = null, x2 = d2;
          if (k2 !== x2) {
            w = Bd;
            v2 = "onMouseLeave";
            u2 = "onMouseEnter";
            t2 = "mouse";
            if (a === "pointerout" || a === "pointerover")
              w = Td, v2 = "onPointerLeave", u2 = "onPointerEnter", t2 = "pointer";
            z2 = k2 == null ? h2 : ue(k2);
            q2 = x2 == null ? h2 : ue(x2);
            h2 = new w(v2, t2 + "leave", k2, c, e2);
            h2.target = z2;
            h2.relatedTarget = q2;
            v2 = null;
            wc(e2) === d2 && (w = new w(u2, t2 + "enter", x2, c, e2), w.target = q2, w.relatedTarget = z2, v2 = w);
            z2 = v2;
            if (k2 && x2)
              b: {
                w = k2;
                u2 = x2;
                t2 = 0;
                for (q2 = w; q2; q2 = gf(q2))
                  t2++;
                q2 = 0;
                for (v2 = u2; v2; v2 = gf(v2))
                  q2++;
                for (; 0 < t2 - q2; )
                  w = gf(w), t2--;
                for (; 0 < q2 - t2; )
                  u2 = gf(u2), q2--;
                for (; t2--; ) {
                  if (w === u2 || u2 !== null && w === u2.alternate)
                    break b;
                  w = gf(w);
                  u2 = gf(u2);
                }
                w = null;
              }
            else
              w = null;
            k2 !== null && hf(g2, h2, k2, w, false);
            x2 !== null && z2 !== null && hf(g2, z2, x2, w, true);
          }
        }
      }
      a: {
        h2 = d2 ? ue(d2) : window;
        k2 = h2.nodeName && h2.nodeName.toLowerCase();
        if (k2 === "select" || k2 === "input" && h2.type === "file")
          var J2 = ve;
        else if (me(h2))
          if (we)
            J2 = Fe;
          else {
            J2 = De;
            var K2 = Ce;
          }
        else
          (k2 = h2.nodeName) && k2.toLowerCase() === "input" && (h2.type === "checkbox" || h2.type === "radio") && (J2 = Ee);
        if (J2 && (J2 = J2(a, d2))) {
          ne$1(g2, J2, c, e2);
          break a;
        }
        K2 && K2(a, h2, d2);
        a === "focusout" && (K2 = h2._wrapperState) && K2.controlled && h2.type === "number" && bb(h2, "number", h2.value);
      }
      K2 = d2 ? ue(d2) : window;
      switch (a) {
        case "focusin":
          if (me(K2) || K2.contentEditable === "true")
            Qe = K2, Re$1 = d2, Se = null;
          break;
        case "focusout":
          Se = Re$1 = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g2, c, e2);
          break;
        case "selectionchange":
          if (Pe)
            break;
        case "keydown":
        case "keyup":
          Ue(g2, c, e2);
      }
      var Q2;
      if (ae)
        b: {
          switch (a) {
            case "compositionstart":
              var L2 = "onCompositionStart";
              break b;
            case "compositionend":
              L2 = "onCompositionEnd";
              break b;
            case "compositionupdate":
              L2 = "onCompositionUpdate";
              break b;
          }
          L2 = void 0;
        }
      else
        ie ? ge$1(a, c) && (L2 = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (L2 = "onCompositionStart");
      L2 && (de && c.locale !== "ko" && (ie || L2 !== "onCompositionStart" ? L2 === "onCompositionEnd" && ie && (Q2 = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), K2 = oe(d2, L2), 0 < K2.length && (L2 = new Ld(L2, a, null, c, e2), g2.push({ event: L2, listeners: K2 }), Q2 ? L2.data = Q2 : (Q2 = he(c), Q2 !== null && (L2.data = Q2))));
      if (Q2 = ce ? je(a, c) : ke(a, c))
        d2 = oe(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g2.push({ event: e2, listeners: d2 }), e2.data = Q2);
    }
    se(g2, b);
  });
}
function ef(a, b, c) {
  return { instance: a, listener: b, currentTarget: c };
}
function oe(a, b) {
  for (var c = b + "Capture", d = []; a !== null; ) {
    var e = a, f = e.stateNode;
    e.tag === 5 && f !== null && (e = f, f = Ob(a, c), f != null && d.unshift(ef(a, f, e)), f = Ob(a, b), f != null && d.push(ef(a, f, e)));
    a = a.return;
  }
  return d;
}
function gf(a) {
  if (a === null)
    return null;
  do
    a = a.return;
  while (a && a.tag !== 5);
  return a ? a : null;
}
function hf(a, b, c, d, e) {
  for (var f = b._reactName, g = []; c !== null && c !== d; ) {
    var h = c, k = h.alternate, l2 = h.stateNode;
    if (k !== null && k === d)
      break;
    h.tag === 5 && l2 !== null && (h = l2, e ? (k = Ob(c, f), k != null && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), k != null && g.push(ef(c, k, h))));
    c = c.return;
  }
  g.length !== 0 && a.push({ event: b, listeners: g });
}
function jf() {
}
var kf = null, lf = null;
function mf(a, b) {
  switch (a) {
    case "button":
    case "input":
    case "select":
    case "textarea":
      return !!b.autoFocus;
  }
  return false;
}
function nf(a, b) {
  return a === "textarea" || a === "option" || a === "noscript" || typeof b.children === "string" || typeof b.children === "number" || typeof b.dangerouslySetInnerHTML === "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
}
var of = typeof setTimeout === "function" ? setTimeout : void 0, pf = typeof clearTimeout === "function" ? clearTimeout : void 0;
function qf(a) {
  a.nodeType === 1 ? a.textContent = "" : a.nodeType === 9 && (a = a.body, a != null && (a.textContent = ""));
}
function rf(a) {
  for (; a != null; a = a.nextSibling) {
    var b = a.nodeType;
    if (b === 1 || b === 3)
      break;
  }
  return a;
}
function sf(a) {
  a = a.previousSibling;
  for (var b = 0; a; ) {
    if (a.nodeType === 8) {
      var c = a.data;
      if (c === "$" || c === "$!" || c === "$?") {
        if (b === 0)
          return a;
        b--;
      } else
        c === "/$" && b++;
    }
    a = a.previousSibling;
  }
  return null;
}
var tf = 0;
function uf(a) {
  return { $$typeof: Ga, toString: a, valueOf: a };
}
var vf = Math.random().toString(36).slice(2), wf = "__reactFiber$" + vf, xf = "__reactProps$" + vf, ff = "__reactContainer$" + vf, yf = "__reactEvents$" + vf;
function wc(a) {
  var b = a[wf];
  if (b)
    return b;
  for (var c = a.parentNode; c; ) {
    if (b = c[ff] || c[wf]) {
      c = b.alternate;
      if (b.child !== null || c !== null && c.child !== null)
        for (a = sf(a); a !== null; ) {
          if (c = a[wf])
            return c;
          a = sf(a);
        }
      return b;
    }
    a = c;
    c = a.parentNode;
  }
  return null;
}
function Cb(a) {
  a = a[wf] || a[ff];
  return !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
}
function ue(a) {
  if (a.tag === 5 || a.tag === 6)
    return a.stateNode;
  throw Error(y(33));
}
function Db(a) {
  return a[xf] || null;
}
function $e(a) {
  var b = a[yf];
  b === void 0 && (b = a[yf] = /* @__PURE__ */ new Set());
  return b;
}
var zf = [], Af = -1;
function Bf(a) {
  return { current: a };
}
function H(a) {
  0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
}
function I(a, b) {
  Af++;
  zf[Af] = a.current;
  a.current = b;
}
var Cf = {}, M = Bf(Cf), N = Bf(false), Df = Cf;
function Ef(a, b) {
  var c = a.type.contextTypes;
  if (!c)
    return Cf;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b)
    return d.__reactInternalMemoizedMaskedChildContext;
  var e = {}, f;
  for (f in c)
    e[f] = b[f];
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}
function Ff(a) {
  a = a.childContextTypes;
  return a !== null && a !== void 0;
}
function Gf() {
  H(N);
  H(M);
}
function Hf(a, b, c) {
  if (M.current !== Cf)
    throw Error(y(168));
  I(M, b);
  I(N, c);
}
function If(a, b, c) {
  var d = a.stateNode;
  a = b.childContextTypes;
  if (typeof d.getChildContext !== "function")
    return c;
  d = d.getChildContext();
  for (var e in d)
    if (!(e in a))
      throw Error(y(108, Ra(b) || "Unknown", e));
  return m({}, c, d);
}
function Jf(a) {
  a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
  Df = M.current;
  I(M, a);
  I(N, N.current);
  return true;
}
function Kf(a, b, c) {
  var d = a.stateNode;
  if (!d)
    throw Error(y(169));
  c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H(N), H(M), I(M, a)) : H(N);
  I(N, c);
}
var Lf = null, Mf = null, Nf = r.unstable_runWithPriority, Of = r.unstable_scheduleCallback, Pf = r.unstable_cancelCallback, Qf = r.unstable_shouldYield, Rf = r.unstable_requestPaint, Sf = r.unstable_now, Tf = r.unstable_getCurrentPriorityLevel, Uf = r.unstable_ImmediatePriority, Vf = r.unstable_UserBlockingPriority, Wf = r.unstable_NormalPriority, Xf = r.unstable_LowPriority, Yf = r.unstable_IdlePriority, Zf = {}, $f = Rf !== void 0 ? Rf : function() {
}, ag = null, bg = null, cg = false, dg = Sf(), O = 1e4 > dg ? Sf : function() {
  return Sf() - dg;
};
function eg$1() {
  switch (Tf()) {
    case Uf:
      return 99;
    case Vf:
      return 98;
    case Wf:
      return 97;
    case Xf:
      return 96;
    case Yf:
      return 95;
    default:
      throw Error(y(332));
  }
}
function fg(a) {
  switch (a) {
    case 99:
      return Uf;
    case 98:
      return Vf;
    case 97:
      return Wf;
    case 96:
      return Xf;
    case 95:
      return Yf;
    default:
      throw Error(y(332));
  }
}
function gg$1(a, b) {
  a = fg(a);
  return Nf(a, b);
}
function hg(a, b, c) {
  a = fg(a);
  return Of(a, b, c);
}
function ig() {
  if (bg !== null) {
    var a = bg;
    bg = null;
    Pf(a);
  }
  jg();
}
function jg() {
  if (!cg && ag !== null) {
    cg = true;
    var a = 0;
    try {
      var b = ag;
      gg$1(99, function() {
        for (; a < b.length; a++) {
          var c = b[a];
          do
            c = c(true);
          while (c !== null);
        }
      });
      ag = null;
    } catch (c) {
      throw ag !== null && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
    } finally {
      cg = false;
    }
  }
}
var kg = ra.ReactCurrentBatchConfig;
function lg$1(a, b) {
  if (a && a.defaultProps) {
    b = m({}, b);
    a = a.defaultProps;
    for (var c in a)
      b[c] === void 0 && (b[c] = a[c]);
    return b;
  }
  return b;
}
var mg = Bf(null), ng = null, og = null, pg = null;
function qg() {
  pg = og = ng = null;
}
function rg(a) {
  var b = mg.current;
  H(mg);
  a.type._context._currentValue = b;
}
function sg(a, b) {
  for (; a !== null; ) {
    var c = a.alternate;
    if ((a.childLanes & b) === b)
      if (c === null || (c.childLanes & b) === b)
        break;
      else
        c.childLanes |= b;
    else
      a.childLanes |= b, c !== null && (c.childLanes |= b);
    a = a.return;
  }
}
function tg(a, b) {
  ng = a;
  pg = og = null;
  a = a.dependencies;
  a !== null && a.firstContext !== null && ((a.lanes & b) !== 0 && (ug = true), a.firstContext = null);
}
function vg(a, b) {
  if (pg !== a && b !== false && b !== 0) {
    if (typeof b !== "number" || b === 1073741823)
      pg = a, b = 1073741823;
    b = { context: a, observedBits: b, next: null };
    if (og === null) {
      if (ng === null)
        throw Error(y(308));
      og = b;
      ng.dependencies = { lanes: 0, firstContext: b, responders: null };
    } else
      og = og.next = b;
  }
  return a._currentValue;
}
var wg = false;
function xg(a) {
  a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null }, effects: null };
}
function yg(a, b) {
  a = a.updateQueue;
  b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
}
function zg(a, b) {
  return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
}
function Ag(a, b) {
  a = a.updateQueue;
  if (a !== null) {
    a = a.shared;
    var c = a.pending;
    c === null ? b.next = b : (b.next = c.next, c.next = b);
    a.pending = b;
  }
}
function Bg(a, b) {
  var c = a.updateQueue, d = a.alternate;
  if (d !== null && (d = d.updateQueue, c === d)) {
    var e = null, f = null;
    c = c.firstBaseUpdate;
    if (c !== null) {
      do {
        var g = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
        f === null ? e = f = g : f = f.next = g;
        c = c.next;
      } while (c !== null);
      f === null ? e = f = b : f = f.next = b;
    } else
      e = f = b;
    c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f, shared: d.shared, effects: d.effects };
    a.updateQueue = c;
    return;
  }
  a = c.lastBaseUpdate;
  a === null ? c.firstBaseUpdate = b : a.next = b;
  c.lastBaseUpdate = b;
}
function Cg(a, b, c, d) {
  var e = a.updateQueue;
  wg = false;
  var f = e.firstBaseUpdate, g = e.lastBaseUpdate, h = e.shared.pending;
  if (h !== null) {
    e.shared.pending = null;
    var k = h, l2 = k.next;
    k.next = null;
    g === null ? f = l2 : g.next = l2;
    g = k;
    var n2 = a.alternate;
    if (n2 !== null) {
      n2 = n2.updateQueue;
      var A2 = n2.lastBaseUpdate;
      A2 !== g && (A2 === null ? n2.firstBaseUpdate = l2 : A2.next = l2, n2.lastBaseUpdate = k);
    }
  }
  if (f !== null) {
    A2 = e.baseState;
    g = 0;
    n2 = l2 = k = null;
    do {
      h = f.lane;
      var p2 = f.eventTime;
      if ((d & h) === h) {
        n2 !== null && (n2 = n2.next = {
          eventTime: p2,
          lane: 0,
          tag: f.tag,
          payload: f.payload,
          callback: f.callback,
          next: null
        });
        a: {
          var C2 = a, x2 = f;
          h = b;
          p2 = c;
          switch (x2.tag) {
            case 1:
              C2 = x2.payload;
              if (typeof C2 === "function") {
                A2 = C2.call(p2, A2, h);
                break a;
              }
              A2 = C2;
              break a;
            case 3:
              C2.flags = C2.flags & -4097 | 64;
            case 0:
              C2 = x2.payload;
              h = typeof C2 === "function" ? C2.call(p2, A2, h) : C2;
              if (h === null || h === void 0)
                break a;
              A2 = m({}, A2, h);
              break a;
            case 2:
              wg = true;
          }
        }
        f.callback !== null && (a.flags |= 32, h = e.effects, h === null ? e.effects = [f] : h.push(f));
      } else
        p2 = { eventTime: p2, lane: h, tag: f.tag, payload: f.payload, callback: f.callback, next: null }, n2 === null ? (l2 = n2 = p2, k = A2) : n2 = n2.next = p2, g |= h;
      f = f.next;
      if (f === null)
        if (h = e.shared.pending, h === null)
          break;
        else
          f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
    } while (1);
    n2 === null && (k = A2);
    e.baseState = k;
    e.firstBaseUpdate = l2;
    e.lastBaseUpdate = n2;
    Dg |= g;
    a.lanes = g;
    a.memoizedState = A2;
  }
}
function Eg(a, b, c) {
  a = b.effects;
  b.effects = null;
  if (a !== null)
    for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (e !== null) {
        d.callback = null;
        d = c;
        if (typeof e !== "function")
          throw Error(y(191, e));
        e.call(d);
      }
    }
}
var Fg = new aa.Component().refs;
function Gg$1(a, b, c, d) {
  b = a.memoizedState;
  c = c(d, b);
  c = c === null || c === void 0 ? b : m({}, b, c);
  a.memoizedState = c;
  a.lanes === 0 && (a.updateQueue.baseState = c);
}
var Kg = { isMounted: function(a) {
  return (a = a._reactInternals) ? Zb(a) === a : false;
}, enqueueSetState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.payload = b;
  c !== void 0 && c !== null && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueReplaceState: function(a, b, c) {
  a = a._reactInternals;
  var d = Hg(), e = Ig(a), f = zg(d, e);
  f.tag = 1;
  f.payload = b;
  c !== void 0 && c !== null && (f.callback = c);
  Ag(a, f);
  Jg(a, e, d);
}, enqueueForceUpdate: function(a, b) {
  a = a._reactInternals;
  var c = Hg(), d = Ig(a), e = zg(c, d);
  e.tag = 2;
  b !== void 0 && b !== null && (e.callback = b);
  Ag(a, e);
  Jg(a, d, c);
} };
function Lg(a, b, c, d, e, f, g) {
  a = a.stateNode;
  return typeof a.shouldComponentUpdate === "function" ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : true;
}
function Mg(a, b, c) {
  var d = false, e = Cf;
  var f = b.contextType;
  typeof f === "object" && f !== null ? f = vg(f) : (e = Ff(b) ? Df : M.current, d = b.contextTypes, f = (d = d !== null && d !== void 0) ? Ef(a, e) : Cf);
  b = new b(c, f);
  a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null;
  b.updater = Kg;
  a.stateNode = b;
  b._reactInternals = a;
  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
  return b;
}
function Ng(a, b, c, d) {
  a = b.state;
  typeof b.componentWillReceiveProps === "function" && b.componentWillReceiveProps(c, d);
  typeof b.UNSAFE_componentWillReceiveProps === "function" && b.UNSAFE_componentWillReceiveProps(c, d);
  b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
}
function Og(a, b, c, d) {
  var e = a.stateNode;
  e.props = c;
  e.state = a.memoizedState;
  e.refs = Fg;
  xg(a);
  var f = b.contextType;
  typeof f === "object" && f !== null ? e.context = vg(f) : (f = Ff(b) ? Df : M.current, e.context = Ef(a, f));
  Cg(a, c, e, d);
  e.state = a.memoizedState;
  f = b.getDerivedStateFromProps;
  typeof f === "function" && (Gg$1(a, b, f, c), e.state = a.memoizedState);
  typeof b.getDerivedStateFromProps === "function" || typeof e.getSnapshotBeforeUpdate === "function" || typeof e.UNSAFE_componentWillMount !== "function" && typeof e.componentWillMount !== "function" || (b = e.state, typeof e.componentWillMount === "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount === "function" && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
  typeof e.componentDidMount === "function" && (a.flags |= 4);
}
var Pg = Array.isArray;
function Qg(a, b, c) {
  a = c.ref;
  if (a !== null && typeof a !== "function" && typeof a !== "object") {
    if (c._owner) {
      c = c._owner;
      if (c) {
        if (c.tag !== 1)
          throw Error(y(309));
        var d = c.stateNode;
      }
      if (!d)
        throw Error(y(147, a));
      var e = "" + a;
      if (b !== null && b.ref !== null && typeof b.ref === "function" && b.ref._stringRef === e)
        return b.ref;
      b = function(a2) {
        var b2 = d.refs;
        b2 === Fg && (b2 = d.refs = {});
        a2 === null ? delete b2[e] : b2[e] = a2;
      };
      b._stringRef = e;
      return b;
    }
    if (typeof a !== "string")
      throw Error(y(284));
    if (!c._owner)
      throw Error(y(290, a));
  }
  return a;
}
function Rg(a, b) {
  if (a.type !== "textarea")
    throw Error(y(31, Object.prototype.toString.call(b) === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
}
function Sg(a) {
  function b(b2, c2) {
    if (a) {
      var d2 = b2.lastEffect;
      d2 !== null ? (d2.nextEffect = c2, b2.lastEffect = c2) : b2.firstEffect = b2.lastEffect = c2;
      c2.nextEffect = null;
      c2.flags = 8;
    }
  }
  function c(c2, d2) {
    if (!a)
      return null;
    for (; d2 !== null; )
      b(c2, d2), d2 = d2.sibling;
    return null;
  }
  function d(a2, b2) {
    for (a2 = /* @__PURE__ */ new Map(); b2 !== null; )
      b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
    return a2;
  }
  function e(a2, b2) {
    a2 = Tg(a2, b2);
    a2.index = 0;
    a2.sibling = null;
    return a2;
  }
  function f(b2, c2, d2) {
    b2.index = d2;
    if (!a)
      return c2;
    d2 = b2.alternate;
    if (d2 !== null)
      return d2 = d2.index, d2 < c2 ? (b2.flags = 2, c2) : d2;
    b2.flags = 2;
    return c2;
  }
  function g(b2) {
    a && b2.alternate === null && (b2.flags = 2);
    return b2;
  }
  function h(a2, b2, c2, d2) {
    if (b2 === null || b2.tag !== 6)
      return b2 = Ug(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function k(a2, b2, c2, d2) {
    if (b2 !== null && b2.elementType === c2.type)
      return d2 = e(b2, c2.props), d2.ref = Qg(a2, b2, c2), d2.return = a2, d2;
    d2 = Vg(c2.type, c2.key, c2.props, null, a2.mode, d2);
    d2.ref = Qg(a2, b2, c2);
    d2.return = a2;
    return d2;
  }
  function l2(a2, b2, c2, d2) {
    if (b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation)
      return b2 = Wg(c2, a2.mode, d2), b2.return = a2, b2;
    b2 = e(b2, c2.children || []);
    b2.return = a2;
    return b2;
  }
  function n2(a2, b2, c2, d2, f2) {
    if (b2 === null || b2.tag !== 7)
      return b2 = Xg(c2, a2.mode, d2, f2), b2.return = a2, b2;
    b2 = e(b2, c2);
    b2.return = a2;
    return b2;
  }
  function A2(a2, b2, c2) {
    if (typeof b2 === "string" || typeof b2 === "number")
      return b2 = Ug("" + b2, a2.mode, c2), b2.return = a2, b2;
    if (typeof b2 === "object" && b2 !== null) {
      switch (b2.$$typeof) {
        case sa:
          return c2 = Vg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Qg(a2, null, b2), c2.return = a2, c2;
        case ta:
          return b2 = Wg(b2, a2.mode, c2), b2.return = a2, b2;
      }
      if (Pg(b2) || La(b2))
        return b2 = Xg(b2, a2.mode, c2, null), b2.return = a2, b2;
      Rg(a2, b2);
    }
    return null;
  }
  function p2(a2, b2, c2, d2) {
    var e2 = b2 !== null ? b2.key : null;
    if (typeof c2 === "string" || typeof c2 === "number")
      return e2 !== null ? null : h(a2, b2, "" + c2, d2);
    if (typeof c2 === "object" && c2 !== null) {
      switch (c2.$$typeof) {
        case sa:
          return c2.key === e2 ? c2.type === ua ? n2(a2, b2, c2.props.children, d2, e2) : k(a2, b2, c2, d2) : null;
        case ta:
          return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
      }
      if (Pg(c2) || La(c2))
        return e2 !== null ? null : n2(a2, b2, c2, d2, null);
      Rg(a2, c2);
    }
    return null;
  }
  function C2(a2, b2, c2, d2, e2) {
    if (typeof d2 === "string" || typeof d2 === "number")
      return a2 = a2.get(c2) || null, h(b2, a2, "" + d2, e2);
    if (typeof d2 === "object" && d2 !== null) {
      switch (d2.$$typeof) {
        case sa:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, d2.type === ua ? n2(b2, a2, d2.props.children, e2, d2.key) : k(b2, a2, d2, e2);
        case ta:
          return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
      }
      if (Pg(d2) || La(d2))
        return a2 = a2.get(c2) || null, n2(b2, a2, d2, e2, null);
      Rg(b2, d2);
    }
    return null;
  }
  function x2(e2, g2, h2, k2) {
    for (var l3 = null, t2 = null, u2 = g2, z2 = g2 = 0, q2 = null; u2 !== null && z2 < h2.length; z2++) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var n3 = p2(e2, u2, h2[z2], k2);
      if (n3 === null) {
        u2 === null && (u2 = q2);
        break;
      }
      a && u2 && n3.alternate === null && b(e2, u2);
      g2 = f(n3, g2, z2);
      t2 === null ? l3 = n3 : t2.sibling = n3;
      t2 = n3;
      u2 = q2;
    }
    if (z2 === h2.length)
      return c(e2, u2), l3;
    if (u2 === null) {
      for (; z2 < h2.length; z2++)
        u2 = A2(e2, h2[z2], k2), u2 !== null && (g2 = f(u2, g2, z2), t2 === null ? l3 = u2 : t2.sibling = u2, t2 = u2);
      return l3;
    }
    for (u2 = d(e2, u2); z2 < h2.length; z2++)
      q2 = C2(u2, e2, z2, h2[z2], k2), q2 !== null && (a && q2.alternate !== null && u2.delete(q2.key === null ? z2 : q2.key), g2 = f(q2, g2, z2), t2 === null ? l3 = q2 : t2.sibling = q2, t2 = q2);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  function w(e2, g2, h2, k2) {
    var l3 = La(h2);
    if (typeof l3 !== "function")
      throw Error(y(150));
    h2 = l3.call(h2);
    if (h2 == null)
      throw Error(y(151));
    for (var t2 = l3 = null, u2 = g2, z2 = g2 = 0, q2 = null, n3 = h2.next(); u2 !== null && !n3.done; z2++, n3 = h2.next()) {
      u2.index > z2 ? (q2 = u2, u2 = null) : q2 = u2.sibling;
      var w2 = p2(e2, u2, n3.value, k2);
      if (w2 === null) {
        u2 === null && (u2 = q2);
        break;
      }
      a && u2 && w2.alternate === null && b(e2, u2);
      g2 = f(w2, g2, z2);
      t2 === null ? l3 = w2 : t2.sibling = w2;
      t2 = w2;
      u2 = q2;
    }
    if (n3.done)
      return c(e2, u2), l3;
    if (u2 === null) {
      for (; !n3.done; z2++, n3 = h2.next())
        n3 = A2(e2, n3.value, k2), n3 !== null && (g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
      return l3;
    }
    for (u2 = d(e2, u2); !n3.done; z2++, n3 = h2.next())
      n3 = C2(u2, e2, z2, n3.value, k2), n3 !== null && (a && n3.alternate !== null && u2.delete(n3.key === null ? z2 : n3.key), g2 = f(n3, g2, z2), t2 === null ? l3 = n3 : t2.sibling = n3, t2 = n3);
    a && u2.forEach(function(a2) {
      return b(e2, a2);
    });
    return l3;
  }
  return function(a2, d2, f2, h2) {
    var k2 = typeof f2 === "object" && f2 !== null && f2.type === ua && f2.key === null;
    k2 && (f2 = f2.props.children);
    var l3 = typeof f2 === "object" && f2 !== null;
    if (l3)
      switch (f2.$$typeof) {
        case sa:
          a: {
            l3 = f2.key;
            for (k2 = d2; k2 !== null; ) {
              if (k2.key === l3) {
                switch (k2.tag) {
                  case 7:
                    if (f2.type === ua) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props.children);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                    break;
                  default:
                    if (k2.elementType === f2.type) {
                      c(a2, k2.sibling);
                      d2 = e(k2, f2.props);
                      d2.ref = Qg(a2, k2, f2);
                      d2.return = a2;
                      a2 = d2;
                      break a;
                    }
                }
                c(a2, k2);
                break;
              } else
                b(a2, k2);
              k2 = k2.sibling;
            }
            f2.type === ua ? (d2 = Xg(f2.props.children, a2.mode, h2, f2.key), d2.return = a2, a2 = d2) : (h2 = Vg(f2.type, f2.key, f2.props, null, a2.mode, h2), h2.ref = Qg(a2, d2, f2), h2.return = a2, a2 = h2);
          }
          return g(a2);
        case ta:
          a: {
            for (k2 = f2.key; d2 !== null; ) {
              if (d2.key === k2)
                if (d2.tag === 4 && d2.stateNode.containerInfo === f2.containerInfo && d2.stateNode.implementation === f2.implementation) {
                  c(a2, d2.sibling);
                  d2 = e(d2, f2.children || []);
                  d2.return = a2;
                  a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
              else
                b(a2, d2);
              d2 = d2.sibling;
            }
            d2 = Wg(f2, a2.mode, h2);
            d2.return = a2;
            a2 = d2;
          }
          return g(a2);
      }
    if (typeof f2 === "string" || typeof f2 === "number")
      return f2 = "" + f2, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f2), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Ug(f2, a2.mode, h2), d2.return = a2, a2 = d2), g(a2);
    if (Pg(f2))
      return x2(a2, d2, f2, h2);
    if (La(f2))
      return w(a2, d2, f2, h2);
    l3 && Rg(a2, f2);
    if (typeof f2 === "undefined" && !k2)
      switch (a2.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y(152, Ra(a2.type) || "Component"));
      }
    return c(a2, d2);
  };
}
var Yg = Sg(true), Zg = Sg(false), $g = {}, ah = Bf($g), bh = Bf($g), ch$1 = Bf($g);
function dh(a) {
  if (a === $g)
    throw Error(y(174));
  return a;
}
function eh(a, b) {
  I(ch$1, b);
  I(bh, a);
  I(ah, $g);
  a = b.nodeType;
  switch (a) {
    case 9:
    case 11:
      b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
      break;
    default:
      a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
  }
  H(ah);
  I(ah, b);
}
function fh() {
  H(ah);
  H(bh);
  H(ch$1);
}
function gh(a) {
  dh(ch$1.current);
  var b = dh(ah.current);
  var c = mb(b, a.type);
  b !== c && (I(bh, a), I(ah, c));
}
function hh(a) {
  bh.current === a && (H(ah), H(bh));
}
var P = Bf(0);
function ih(a) {
  for (var b = a; b !== null; ) {
    if (b.tag === 13) {
      var c = b.memoizedState;
      if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!"))
        return b;
    } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
      if ((b.flags & 64) !== 0)
        return b;
    } else if (b.child !== null) {
      b.child.return = b;
      b = b.child;
      continue;
    }
    if (b === a)
      break;
    for (; b.sibling === null; ) {
      if (b.return === null || b.return === a)
        return null;
      b = b.return;
    }
    b.sibling.return = b.return;
    b = b.sibling;
  }
  return null;
}
var jh = null, kh = null, lh = false;
function mh(a, b) {
  var c = nh(5, null, null, 0);
  c.elementType = "DELETED";
  c.type = "DELETED";
  c.stateNode = b;
  c.return = a;
  c.flags = 8;
  a.lastEffect !== null ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
}
function oh(a, b) {
  switch (a.tag) {
    case 5:
      var c = a.type;
      b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
      return b !== null ? (a.stateNode = b, true) : false;
    case 6:
      return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, true) : false;
    case 13:
      return false;
    default:
      return false;
  }
}
function ph(a) {
  if (lh) {
    var b = kh;
    if (b) {
      var c = b;
      if (!oh(a, b)) {
        b = rf(c.nextSibling);
        if (!b || !oh(a, b)) {
          a.flags = a.flags & -1025 | 2;
          lh = false;
          jh = a;
          return;
        }
        mh(jh, c);
      }
      jh = a;
      kh = rf(b.firstChild);
    } else
      a.flags = a.flags & -1025 | 2, lh = false, jh = a;
  }
}
function qh(a) {
  for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; )
    a = a.return;
  jh = a;
}
function rh(a) {
  if (a !== jh)
    return false;
  if (!lh)
    return qh(a), lh = true, false;
  var b = a.type;
  if (a.tag !== 5 || b !== "head" && b !== "body" && !nf(b, a.memoizedProps))
    for (b = kh; b; )
      mh(a, b), b = rf(b.nextSibling);
  qh(a);
  if (a.tag === 13) {
    a = a.memoizedState;
    a = a !== null ? a.dehydrated : null;
    if (!a)
      throw Error(y(317));
    a: {
      a = a.nextSibling;
      for (b = 0; a; ) {
        if (a.nodeType === 8) {
          var c = a.data;
          if (c === "/$") {
            if (b === 0) {
              kh = rf(a.nextSibling);
              break a;
            }
            b--;
          } else
            c !== "$" && c !== "$!" && c !== "$?" || b++;
        }
        a = a.nextSibling;
      }
      kh = null;
    }
  } else
    kh = jh ? rf(a.stateNode.nextSibling) : null;
  return true;
}
function sh() {
  kh = jh = null;
  lh = false;
}
var th = [];
function uh() {
  for (var a = 0; a < th.length; a++)
    th[a]._workInProgressVersionPrimary = null;
  th.length = 0;
}
var vh = ra.ReactCurrentDispatcher, wh = ra.ReactCurrentBatchConfig, xh = 0, R = null, S = null, T = null, yh = false, zh = false;
function Ah() {
  throw Error(y(321));
}
function Bh(a, b) {
  if (b === null)
    return false;
  for (var c = 0; c < b.length && c < a.length; c++)
    if (!He(a[c], b[c]))
      return false;
  return true;
}
function Ch(a, b, c, d, e, f) {
  xh = f;
  R = b;
  b.memoizedState = null;
  b.updateQueue = null;
  b.lanes = 0;
  vh.current = a === null || a.memoizedState === null ? Dh : Eh;
  a = c(d, e);
  if (zh) {
    f = 0;
    do {
      zh = false;
      if (!(25 > f))
        throw Error(y(301));
      f += 1;
      T = S = null;
      b.updateQueue = null;
      vh.current = Fh;
      a = c(d, e);
    } while (zh);
  }
  vh.current = Gh;
  b = S !== null && S.next !== null;
  xh = 0;
  T = S = R = null;
  yh = false;
  if (b)
    throw Error(y(300));
  return a;
}
function Hh() {
  var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  T === null ? R.memoizedState = T = a : T = T.next = a;
  return T;
}
function Ih() {
  if (S === null) {
    var a = R.alternate;
    a = a !== null ? a.memoizedState : null;
  } else
    a = S.next;
  var b = T === null ? R.memoizedState : T.next;
  if (b !== null)
    T = b, S = a;
  else {
    if (a === null)
      throw Error(y(310));
    S = a;
    a = { memoizedState: S.memoizedState, baseState: S.baseState, baseQueue: S.baseQueue, queue: S.queue, next: null };
    T === null ? R.memoizedState = T = a : T = T.next = a;
  }
  return T;
}
function Jh(a, b) {
  return typeof b === "function" ? b(a) : b;
}
function Kh(a) {
  var b = Ih(), c = b.queue;
  if (c === null)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = S, e = d.baseQueue, f = c.pending;
  if (f !== null) {
    if (e !== null) {
      var g = e.next;
      e.next = f.next;
      f.next = g;
    }
    d.baseQueue = e = f;
    c.pending = null;
  }
  if (e !== null) {
    e = e.next;
    d = d.baseState;
    var h = g = f = null, k = e;
    do {
      var l2 = k.lane;
      if ((xh & l2) === l2)
        h !== null && (h = h.next = { lane: 0, action: k.action, eagerReducer: k.eagerReducer, eagerState: k.eagerState, next: null }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);
      else {
        var n2 = {
          lane: l2,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        };
        h === null ? (g = h = n2, f = d) : h = h.next = n2;
        R.lanes |= l2;
        Dg |= l2;
      }
      k = k.next;
    } while (k !== null && k !== e);
    h === null ? f = d : h.next = g;
    He(d, b.memoizedState) || (ug = true);
    b.memoizedState = d;
    b.baseState = f;
    b.baseQueue = h;
    c.lastRenderedState = d;
  }
  return [b.memoizedState, c.dispatch];
}
function Lh(a) {
  var b = Ih(), c = b.queue;
  if (c === null)
    throw Error(y(311));
  c.lastRenderedReducer = a;
  var d = c.dispatch, e = c.pending, f = b.memoizedState;
  if (e !== null) {
    c.pending = null;
    var g = e = e.next;
    do
      f = a(f, g.action), g = g.next;
    while (g !== e);
    He(f, b.memoizedState) || (ug = true);
    b.memoizedState = f;
    b.baseQueue === null && (b.baseState = f);
    c.lastRenderedState = f;
  }
  return [f, d];
}
function Mh(a, b, c) {
  var d = b._getVersion;
  d = d(b._source);
  var e = b._workInProgressVersionPrimary;
  if (e !== null)
    a = e === d;
  else if (a = a.mutableReadLanes, a = (xh & a) === a)
    b._workInProgressVersionPrimary = d, th.push(b);
  if (a)
    return c(b._source);
  th.push(b);
  throw Error(y(350));
}
function Nh(a, b, c, d) {
  var e = U;
  if (e === null)
    throw Error(y(349));
  var f = b._getVersion, g = f(b._source), h = vh.current, k = h.useState(function() {
    return Mh(e, b, c);
  }), l2 = k[1], n2 = k[0];
  k = T;
  var A2 = a.memoizedState, p2 = A2.refs, C2 = p2.getSnapshot, x2 = A2.source;
  A2 = A2.subscribe;
  var w = R;
  a.memoizedState = { refs: p2, source: b, subscribe: d };
  h.useEffect(function() {
    p2.getSnapshot = c;
    p2.setSnapshot = l2;
    var a2 = f(b._source);
    if (!He(g, a2)) {
      a2 = c(b._source);
      He(n2, a2) || (l2(a2), a2 = Ig(w), e.mutableReadLanes |= a2 & e.pendingLanes);
      a2 = e.mutableReadLanes;
      e.entangledLanes |= a2;
      for (var d2 = e.entanglements, h2 = a2; 0 < h2; ) {
        var k2 = 31 - Vc(h2), v2 = 1 << k2;
        d2[k2] |= a2;
        h2 &= ~v2;
      }
    }
  }, [c, b, d]);
  h.useEffect(function() {
    return d(b._source, function() {
      var a2 = p2.getSnapshot, c2 = p2.setSnapshot;
      try {
        c2(a2(b._source));
        var d2 = Ig(w);
        e.mutableReadLanes |= d2 & e.pendingLanes;
      } catch (q2) {
        c2(function() {
          throw q2;
        });
      }
    });
  }, [b, d]);
  He(C2, c) && He(x2, b) && He(A2, d) || (a = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: n2 }, a.dispatch = l2 = Oh.bind(null, R, a), k.queue = a, k.baseQueue = null, n2 = Mh(e, b, c), k.memoizedState = k.baseState = n2);
  return n2;
}
function Ph(a, b, c) {
  var d = Ih();
  return Nh(d, a, b, c);
}
function Qh(a) {
  var b = Hh();
  typeof a === "function" && (a = a());
  b.memoizedState = b.baseState = a;
  a = b.queue = { pending: null, dispatch: null, lastRenderedReducer: Jh, lastRenderedState: a };
  a = a.dispatch = Oh.bind(null, R, a);
  return [b.memoizedState, a];
}
function Rh(a, b, c, d) {
  a = { tag: a, create: b, destroy: c, deps: d, next: null };
  b = R.updateQueue;
  b === null ? (b = { lastEffect: null }, R.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
  return a;
}
function Sh(a) {
  var b = Hh();
  a = { current: a };
  return b.memoizedState = a;
}
function Th() {
  return Ih().memoizedState;
}
function Uh(a, b, c, d) {
  var e = Hh();
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, void 0, d === void 0 ? null : d);
}
function Vh(a, b, c, d) {
  var e = Ih();
  d = d === void 0 ? null : d;
  var f = void 0;
  if (S !== null) {
    var g = S.memoizedState;
    f = g.destroy;
    if (d !== null && Bh(d, g.deps)) {
      Rh(b, c, f, d);
      return;
    }
  }
  R.flags |= a;
  e.memoizedState = Rh(1 | b, c, f, d);
}
function Wh(a, b) {
  return Uh(516, 4, a, b);
}
function Xh(a, b) {
  return Vh(516, 4, a, b);
}
function Yh(a, b) {
  return Vh(4, 2, a, b);
}
function Zh(a, b) {
  if (typeof b === "function")
    return a = a(), b(a), function() {
      b(null);
    };
  if (b !== null && b !== void 0)
    return a = a(), b.current = a, function() {
      b.current = null;
    };
}
function $h(a, b, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return Vh(4, 2, Zh.bind(null, b, a), c);
}
function ai() {
}
function bi(a, b) {
  var c = Ih();
  b = b === void 0 ? null : b;
  var d = c.memoizedState;
  if (d !== null && b !== null && Bh(b, d[1]))
    return d[0];
  c.memoizedState = [a, b];
  return a;
}
function ci(a, b) {
  var c = Ih();
  b = b === void 0 ? null : b;
  var d = c.memoizedState;
  if (d !== null && b !== null && Bh(b, d[1]))
    return d[0];
  a = a();
  c.memoizedState = [a, b];
  return a;
}
function di(a, b) {
  var c = eg$1();
  gg$1(98 > c ? 98 : c, function() {
    a(true);
  });
  gg$1(97 < c ? 97 : c, function() {
    var c2 = wh.transition;
    wh.transition = 1;
    try {
      a(false), b();
    } finally {
      wh.transition = c2;
    }
  });
}
function Oh(a, b, c) {
  var d = Hg(), e = Ig(a), f = { lane: e, action: c, eagerReducer: null, eagerState: null, next: null }, g = b.pending;
  g === null ? f.next = f : (f.next = g.next, g.next = f);
  b.pending = f;
  g = a.alternate;
  if (a === R || g !== null && g === R)
    zh = yh = true;
  else {
    if (a.lanes === 0 && (g === null || g.lanes === 0) && (g = b.lastRenderedReducer, g !== null))
      try {
        var h = b.lastRenderedState, k = g(h, c);
        f.eagerReducer = g;
        f.eagerState = k;
        if (He(k, h))
          return;
      } catch (l2) {
      } finally {
      }
    Jg(a, e, d);
  }
}
var Gh = { readContext: vg, useCallback: Ah, useContext: Ah, useEffect: Ah, useImperativeHandle: Ah, useLayoutEffect: Ah, useMemo: Ah, useReducer: Ah, useRef: Ah, useState: Ah, useDebugValue: Ah, useDeferredValue: Ah, useTransition: Ah, useMutableSource: Ah, useOpaqueIdentifier: Ah, unstable_isNewReconciler: false }, Dh = { readContext: vg, useCallback: function(a, b) {
  Hh().memoizedState = [a, b === void 0 ? null : b];
  return a;
}, useContext: vg, useEffect: Wh, useImperativeHandle: function(a, b, c) {
  c = c !== null && c !== void 0 ? c.concat([a]) : null;
  return Uh(4, 2, Zh.bind(null, b, a), c);
}, useLayoutEffect: function(a, b) {
  return Uh(4, 2, a, b);
}, useMemo: function(a, b) {
  var c = Hh();
  b = b === void 0 ? null : b;
  a = a();
  c.memoizedState = [a, b];
  return a;
}, useReducer: function(a, b, c) {
  var d = Hh();
  b = c !== void 0 ? c(b) : b;
  d.memoizedState = d.baseState = b;
  a = d.queue = { pending: null, dispatch: null, lastRenderedReducer: a, lastRenderedState: b };
  a = a.dispatch = Oh.bind(null, R, a);
  return [d.memoizedState, a];
}, useRef: Sh, useState: Qh, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Qh(a), c = b[0], d = b[1];
  Wh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Qh(false), b = a[0];
  a = di.bind(null, a[1]);
  Sh(a);
  return [a, b];
}, useMutableSource: function(a, b, c) {
  var d = Hh();
  d.memoizedState = { refs: { getSnapshot: b, setSnapshot: null }, source: a, subscribe: c };
  return Nh(d, a, b, c);
}, useOpaqueIdentifier: function() {
  if (lh) {
    var a = false, b = uf(function() {
      a || (a = true, c("r:" + (tf++).toString(36)));
      throw Error(y(355));
    }), c = Qh(b)[1];
    (R.mode & 2) === 0 && (R.flags |= 516, Rh(5, function() {
      c("r:" + (tf++).toString(36));
    }, void 0, null));
    return b;
  }
  b = "r:" + (tf++).toString(36);
  Qh(b);
  return b;
}, unstable_isNewReconciler: false }, Eh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Kh, useRef: Th, useState: function() {
  return Kh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Kh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Kh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Kh(Jh)[0];
}, unstable_isNewReconciler: false }, Fh = { readContext: vg, useCallback: bi, useContext: vg, useEffect: Xh, useImperativeHandle: $h, useLayoutEffect: Yh, useMemo: ci, useReducer: Lh, useRef: Th, useState: function() {
  return Lh(Jh);
}, useDebugValue: ai, useDeferredValue: function(a) {
  var b = Lh(Jh), c = b[0], d = b[1];
  Xh(function() {
    var b2 = wh.transition;
    wh.transition = 1;
    try {
      d(a);
    } finally {
      wh.transition = b2;
    }
  }, [a]);
  return c;
}, useTransition: function() {
  var a = Lh(Jh)[0];
  return [
    Th().current,
    a
  ];
}, useMutableSource: Ph, useOpaqueIdentifier: function() {
  return Lh(Jh)[0];
}, unstable_isNewReconciler: false }, ei = ra.ReactCurrentOwner, ug = false;
function fi(a, b, c, d) {
  b.child = a === null ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
}
function gi(a, b, c, d, e) {
  c = c.render;
  var f = b.ref;
  tg(b, e);
  d = Ch(a, b, c, d, f, e);
  if (a !== null && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, d, e);
  return b.child;
}
function ii$1(a, b, c, d, e, f) {
  if (a === null) {
    var g = c.type;
    if (typeof g === "function" && !ji(g) && g.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0)
      return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
    a = Vg(c.type, null, d, b, b.mode, f);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }
  g = a.child;
  if ((e & f) === 0 && (e = g.memoizedProps, c = c.compare, c = c !== null ? c : Je, c(e, d) && a.ref === b.ref))
    return hi(a, b, f);
  b.flags |= 1;
  a = Tg(g, d);
  a.ref = b.ref;
  a.return = b;
  return b.child = a;
}
function ki(a, b, c, d, e, f) {
  if (a !== null && Je(a.memoizedProps, d) && a.ref === b.ref)
    if (ug = false, (f & e) !== 0)
      (a.flags & 16384) !== 0 && (ug = true);
    else
      return b.lanes = a.lanes, hi(a, b, f);
  return li(a, b, c, d, f);
}
function mi(a, b, c) {
  var d = b.pendingProps, e = d.children, f = a !== null ? a.memoizedState : null;
  if (d.mode === "hidden" || d.mode === "unstable-defer-without-hiding")
    if ((b.mode & 4) === 0)
      b.memoizedState = { baseLanes: 0 }, ni$1(b, c);
    else if ((c & 1073741824) !== 0)
      b.memoizedState = { baseLanes: 0 }, ni$1(b, f !== null ? f.baseLanes : c);
    else
      return a = f !== null ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a }, ni$1(b, a), null;
  else
    f !== null ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni$1(b, d);
  fi(a, b, e, c);
  return b.child;
}
function oi(a, b) {
  var c = b.ref;
  if (a === null && c !== null || a !== null && a.ref !== c)
    b.flags |= 128;
}
function li(a, b, c, d, e) {
  var f = Ff(c) ? Df : M.current;
  f = Ef(b, f);
  tg(b, e);
  c = Ch(a, b, c, d, f, e);
  if (a !== null && !ug)
    return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
  b.flags |= 1;
  fi(a, b, c, e);
  return b.child;
}
function pi$1(a, b, c, d, e) {
  if (Ff(c)) {
    var f = true;
    Jf(b);
  } else
    f = false;
  tg(b, e);
  if (b.stateNode === null)
    a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = true;
  else if (a === null) {
    var g = b.stateNode, h = b.memoizedProps;
    g.props = h;
    var k = g.context, l2 = c.contextType;
    typeof l2 === "object" && l2 !== null ? l2 = vg(l2) : (l2 = Ff(c) ? Df : M.current, l2 = Ef(b, l2));
    var n2 = c.getDerivedStateFromProps, A2 = typeof n2 === "function" || typeof g.getSnapshotBeforeUpdate === "function";
    A2 || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== d || k !== l2) && Ng(b, g, d, l2);
    wg = false;
    var p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    k = b.memoizedState;
    h !== d || p2 !== k || N.current || wg ? (typeof n2 === "function" && (Gg$1(b, c, n2, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p2, k, l2)) ? (A2 || typeof g.UNSAFE_componentWillMount !== "function" && typeof g.componentWillMount !== "function" || (typeof g.componentWillMount === "function" && g.componentWillMount(), typeof g.UNSAFE_componentWillMount === "function" && g.UNSAFE_componentWillMount()), typeof g.componentDidMount === "function" && (b.flags |= 4)) : (typeof g.componentDidMount === "function" && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l2, d = h) : (typeof g.componentDidMount === "function" && (b.flags |= 4), d = false);
  } else {
    g = b.stateNode;
    yg(a, b);
    h = b.memoizedProps;
    l2 = b.type === b.elementType ? h : lg$1(b.type, h);
    g.props = l2;
    A2 = b.pendingProps;
    p2 = g.context;
    k = c.contextType;
    typeof k === "object" && k !== null ? k = vg(k) : (k = Ff(c) ? Df : M.current, k = Ef(b, k));
    var C2 = c.getDerivedStateFromProps;
    (n2 = typeof C2 === "function" || typeof g.getSnapshotBeforeUpdate === "function") || typeof g.UNSAFE_componentWillReceiveProps !== "function" && typeof g.componentWillReceiveProps !== "function" || (h !== A2 || p2 !== k) && Ng(b, g, d, k);
    wg = false;
    p2 = b.memoizedState;
    g.state = p2;
    Cg(b, d, g, e);
    var x2 = b.memoizedState;
    h !== A2 || p2 !== x2 || N.current || wg ? (typeof C2 === "function" && (Gg$1(b, c, C2, d), x2 = b.memoizedState), (l2 = wg || Lg(b, c, l2, d, p2, x2, k)) ? (n2 || typeof g.UNSAFE_componentWillUpdate !== "function" && typeof g.componentWillUpdate !== "function" || (typeof g.componentWillUpdate === "function" && g.componentWillUpdate(d, x2, k), typeof g.UNSAFE_componentWillUpdate === "function" && g.UNSAFE_componentWillUpdate(d, x2, k)), typeof g.componentDidUpdate === "function" && (b.flags |= 4), typeof g.getSnapshotBeforeUpdate === "function" && (b.flags |= 256)) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x2), g.props = d, g.state = x2, g.context = k, d = l2) : (typeof g.componentDidUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 4), typeof g.getSnapshotBeforeUpdate !== "function" || h === a.memoizedProps && p2 === a.memoizedState || (b.flags |= 256), d = false);
  }
  return qi(a, b, c, d, f, e);
}
function qi(a, b, c, d, e, f) {
  oi(a, b);
  var g = (b.flags & 64) !== 0;
  if (!d && !g)
    return e && Kf(b, c, false), hi(a, b, f);
  d = b.stateNode;
  ei.current = b;
  var h = g && typeof c.getDerivedStateFromError !== "function" ? null : d.render();
  b.flags |= 1;
  a !== null && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
  b.memoizedState = d.state;
  e && Kf(b, c, true);
  return b.child;
}
function ri(a) {
  var b = a.stateNode;
  b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, false);
  eh(a, b.containerInfo);
}
var si = { dehydrated: null, retryLane: 0 };
function ti(a, b, c) {
  var d = b.pendingProps, e = P.current, f = false, g;
  (g = (b.flags & 64) !== 0) || (g = a !== null && a.memoizedState === null ? false : (e & 2) !== 0);
  g ? (f = true, b.flags &= -65) : a !== null && a.memoizedState === null || d.fallback === void 0 || d.unstable_avoidThisFallback === true || (e |= 1);
  I(P, e & 1);
  if (a === null) {
    d.fallback !== void 0 && ph(b);
    a = d.children;
    e = d.fallback;
    if (f)
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, a;
    if (typeof d.unstable_expectedLoadTime === "number")
      return a = ui(b, a, e, c), b.child.memoizedState = { baseLanes: c }, b.memoizedState = si, b.lanes = 33554432, a;
    c = vi({ mode: "visible", children: a }, b.mode, c, null);
    c.return = b;
    return b.child = c;
  }
  if (a.memoizedState !== null) {
    if (f)
      return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi$1(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }
  if (f)
    return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = e === null ? { baseLanes: c } : { baseLanes: e.baseLanes | c }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
  c = xi$1(a, b, d.children, c);
  b.memoizedState = null;
  return c;
}
function ui(a, b, c, d) {
  var e = a.mode, f = a.child;
  b = { mode: "hidden", children: b };
  (e & 2) === 0 && f !== null ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
  c = Xg(c, e, d, null);
  f.return = a;
  c.return = a;
  f.sibling = c;
  a.child = f;
  return c;
}
function xi$1(a, b, c, d) {
  var e = a.child;
  a = e.sibling;
  c = Tg(e, { mode: "visible", children: c });
  (b.mode & 2) === 0 && (c.lanes = d);
  c.return = b;
  c.sibling = null;
  a !== null && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
  return b.child = c;
}
function wi(a, b, c, d, e) {
  var f = b.mode, g = a.child;
  a = g.sibling;
  var h = { mode: "hidden", children: c };
  (f & 2) === 0 && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, g !== null ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
  a !== null ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
  d.return = b;
  c.return = b;
  c.sibling = d;
  b.child = c;
  return d;
}
function yi(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  c !== null && (c.lanes |= b);
  sg(a.return, b);
}
function zi(a, b, c, d, e, f) {
  var g = a.memoizedState;
  g === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e, lastEffect: f } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
}
function Ai(a, b, c) {
  var d = b.pendingProps, e = d.revealOrder, f = d.tail;
  fi(a, b, d.children, c);
  d = P.current;
  if ((d & 2) !== 0)
    d = d & 1 | 2, b.flags |= 64;
  else {
    if (a !== null && (a.flags & 64) !== 0)
      a:
        for (a = b.child; a !== null; ) {
          if (a.tag === 13)
            a.memoizedState !== null && yi(a, c);
          else if (a.tag === 19)
            yi(a, c);
          else if (a.child !== null) {
            a.child.return = a;
            a = a.child;
            continue;
          }
          if (a === b)
            break a;
          for (; a.sibling === null; ) {
            if (a.return === null || a.return === b)
              break a;
            a = a.return;
          }
          a.sibling.return = a.return;
          a = a.sibling;
        }
    d &= 1;
  }
  I(P, d);
  if ((b.mode & 2) === 0)
    b.memoizedState = null;
  else
    switch (e) {
      case "forwards":
        c = b.child;
        for (e = null; c !== null; )
          a = c.alternate, a !== null && ih(a) === null && (e = c), c = c.sibling;
        c = e;
        c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        zi(b, false, e, c, f, b.lastEffect);
        break;
      case "backwards":
        c = null;
        e = b.child;
        for (b.child = null; e !== null; ) {
          a = e.alternate;
          if (a !== null && ih(a) === null) {
            b.child = e;
            break;
          }
          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }
        zi(b, true, c, null, f, b.lastEffect);
        break;
      case "together":
        zi(b, false, null, null, void 0, b.lastEffect);
        break;
      default:
        b.memoizedState = null;
    }
  return b.child;
}
function hi(a, b, c) {
  a !== null && (b.dependencies = a.dependencies);
  Dg |= b.lanes;
  if ((c & b.childLanes) !== 0) {
    if (a !== null && b.child !== a.child)
      throw Error(y(153));
    if (b.child !== null) {
      a = b.child;
      c = Tg(a, a.pendingProps);
      b.child = c;
      for (c.return = b; a.sibling !== null; )
        a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  return null;
}
var Bi, Ci, Di, Ei;
Bi = function(a, b) {
  for (var c = b.child; c !== null; ) {
    if (c.tag === 5 || c.tag === 6)
      a.appendChild(c.stateNode);
    else if (c.tag !== 4 && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
};
Ci = function() {
};
Di = function(a, b, c, d) {
  var e = a.memoizedProps;
  if (e !== d) {
    a = b.stateNode;
    dh(ah.current);
    var f = null;
    switch (c) {
      case "input":
        e = Ya(a, e);
        d = Ya(a, d);
        f = [];
        break;
      case "option":
        e = eb(a, e);
        d = eb(a, d);
        f = [];
        break;
      case "select":
        e = m({}, e, { value: void 0 });
        d = m({}, d, { value: void 0 });
        f = [];
        break;
      case "textarea":
        e = gb(a, e);
        d = gb(a, d);
        f = [];
        break;
      default:
        typeof e.onClick !== "function" && typeof d.onClick === "function" && (a.onclick = jf);
    }
    vb(c, d);
    var g;
    c = null;
    for (l2 in e)
      if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && e[l2] != null)
        if (l2 === "style") {
          var h = e[l2];
          for (g in h)
            h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ca.hasOwnProperty(l2) ? f || (f = []) : (f = f || []).push(l2, null));
    for (l2 in d) {
      var k = d[l2];
      h = e != null ? e[l2] : void 0;
      if (d.hasOwnProperty(l2) && k !== h && (k != null || h != null))
        if (l2 === "style")
          if (h) {
            for (g in h)
              !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");
            for (g in k)
              k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else
            c || (f || (f = []), f.push(l2, c)), c = k;
        else
          l2 === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, k != null && h !== k && (f = f || []).push(l2, k)) : l2 === "children" ? typeof k !== "string" && typeof k !== "number" || (f = f || []).push(l2, "" + k) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ca.hasOwnProperty(l2) ? (k != null && l2 === "onScroll" && G("scroll", a), f || h === k || (f = [])) : typeof k === "object" && k !== null && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l2, k));
    }
    c && (f = f || []).push("style", c);
    var l2 = f;
    if (b.updateQueue = l2)
      b.flags |= 4;
  }
};
Ei = function(a, b, c, d) {
  c !== d && (b.flags |= 4);
};
function Fi(a, b) {
  if (!lh)
    switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; b !== null; )
          b.alternate !== null && (c = b), b = b.sibling;
        c === null ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; c !== null; )
          c.alternate !== null && (d = c), c = c.sibling;
        d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
}
function Gi(a, b, c) {
  var d = b.pendingProps;
  switch (b.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return null;
    case 1:
      return Ff(b.type) && Gf(), null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      d = b.stateNode;
      d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
      if (a === null || a.child === null)
        rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
      Ci(b);
      return null;
    case 5:
      hh(b);
      var e = dh(ch$1.current);
      c = b.type;
      if (a !== null && b.stateNode != null)
        Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);
      else {
        if (!d) {
          if (b.stateNode === null)
            throw Error(y(166));
          return null;
        }
        a = dh(ah.current);
        if (rh(b)) {
          d = b.stateNode;
          c = b.type;
          var f = b.memoizedProps;
          d[wf] = b;
          d[xf] = f;
          switch (c) {
            case "dialog":
              G("cancel", d);
              G("close", d);
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", d);
              break;
            case "video":
            case "audio":
              for (a = 0; a < Xe.length; a++)
                G(Xe[a], d);
              break;
            case "source":
              G("error", d);
              break;
            case "img":
            case "image":
            case "link":
              G("error", d);
              G("load", d);
              break;
            case "details":
              G("toggle", d);
              break;
            case "input":
              Za(d, f);
              G("invalid", d);
              break;
            case "select":
              d._wrapperState = { wasMultiple: !!f.multiple };
              G("invalid", d);
              break;
            case "textarea":
              hb(d, f), G("invalid", d);
          }
          vb(c, f);
          a = null;
          for (var g in f)
            f.hasOwnProperty(g) && (e = f[g], g === "children" ? typeof e === "string" ? d.textContent !== e && (a = ["children", e]) : typeof e === "number" && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && e != null && g === "onScroll" && G("scroll", d));
          switch (c) {
            case "input":
              Va(d);
              cb(d, f, true);
              break;
            case "textarea":
              Va(d);
              jb(d);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f.onClick === "function" && (d.onclick = jf);
          }
          d = a;
          b.updateQueue = d;
          d !== null && (b.flags |= 4);
        } else {
          g = e.nodeType === 9 ? e : e.ownerDocument;
          a === kb.html && (a = lb(c));
          a === kb.html ? c === "script" ? (a = g.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof d.is === "string" ? a = g.createElement(c, { is: d.is }) : (a = g.createElement(c), c === "select" && (g = a, d.multiple ? g.multiple = true : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
          a[wf] = b;
          a[xf] = d;
          Bi(a, b, false, false);
          b.stateNode = a;
          g = wb(c, d);
          switch (c) {
            case "dialog":
              G("cancel", a);
              G("close", a);
              e = d;
              break;
            case "iframe":
            case "object":
            case "embed":
              G("load", a);
              e = d;
              break;
            case "video":
            case "audio":
              for (e = 0; e < Xe.length; e++)
                G(Xe[e], a);
              e = d;
              break;
            case "source":
              G("error", a);
              e = d;
              break;
            case "img":
            case "image":
            case "link":
              G("error", a);
              G("load", a);
              e = d;
              break;
            case "details":
              G("toggle", a);
              e = d;
              break;
            case "input":
              Za(a, d);
              e = Ya(a, d);
              G("invalid", a);
              break;
            case "option":
              e = eb(a, d);
              break;
            case "select":
              a._wrapperState = { wasMultiple: !!d.multiple };
              e = m({}, d, { value: void 0 });
              G("invalid", a);
              break;
            case "textarea":
              hb(a, d);
              e = gb(a, d);
              G("invalid", a);
              break;
            default:
              e = d;
          }
          vb(c, e);
          var h = e;
          for (f in h)
            if (h.hasOwnProperty(f)) {
              var k = h[f];
              f === "style" ? tb(a, k) : f === "dangerouslySetInnerHTML" ? (k = k ? k.__html : void 0, k != null && ob(a, k)) : f === "children" ? typeof k === "string" ? (c !== "textarea" || k !== "") && pb(a, k) : typeof k === "number" && pb(a, "" + k) : f !== "suppressContentEditableWarning" && f !== "suppressHydrationWarning" && f !== "autoFocus" && (ca.hasOwnProperty(f) ? k != null && f === "onScroll" && G("scroll", a) : k != null && qa(a, f, k, g));
            }
          switch (c) {
            case "input":
              Va(a);
              cb(a, d, false);
              break;
            case "textarea":
              Va(a);
              jb(a);
              break;
            case "option":
              d.value != null && a.setAttribute("value", "" + Sa(d.value));
              break;
            case "select":
              a.multiple = !!d.multiple;
              f = d.value;
              f != null ? fb(a, !!d.multiple, f, false) : d.defaultValue != null && fb(a, !!d.multiple, d.defaultValue, true);
              break;
            default:
              typeof e.onClick === "function" && (a.onclick = jf);
          }
          mf(c, d) && (b.flags |= 4);
        }
        b.ref !== null && (b.flags |= 128);
      }
      return null;
    case 6:
      if (a && b.stateNode != null)
        Ei(a, b, a.memoizedProps, d);
      else {
        if (typeof d !== "string" && b.stateNode === null)
          throw Error(y(166));
        c = dh(ch$1.current);
        dh(ah.current);
        rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
      }
      return null;
    case 13:
      H(P);
      d = b.memoizedState;
      if ((b.flags & 64) !== 0)
        return b.lanes = c, b;
      d = d !== null;
      c = false;
      a === null ? b.memoizedProps.fallback !== void 0 && rh(b) : c = a.memoizedState !== null;
      if (d && !c && (b.mode & 2) !== 0)
        if (a === null && b.memoizedProps.unstable_avoidThisFallback !== true || (P.current & 1) !== 0)
          V === 0 && (V = 3);
        else {
          if (V === 0 || V === 3)
            V = 4;
          U === null || (Dg & 134217727) === 0 && (Hi & 134217727) === 0 || Ii(U, W);
        }
      if (d || c)
        b.flags |= 4;
      return null;
    case 4:
      return fh(), Ci(b), a === null && cf(b.stateNode.containerInfo), null;
    case 10:
      return rg(b), null;
    case 17:
      return Ff(b.type) && Gf(), null;
    case 19:
      H(P);
      d = b.memoizedState;
      if (d === null)
        return null;
      f = (b.flags & 64) !== 0;
      g = d.rendering;
      if (g === null)
        if (f)
          Fi(d, false);
        else {
          if (V !== 0 || a !== null && (a.flags & 64) !== 0)
            for (a = b.child; a !== null; ) {
              g = ih(a);
              if (g !== null) {
                b.flags |= 64;
                Fi(d, false);
                f = g.updateQueue;
                f !== null && (b.updateQueue = f, b.flags |= 4);
                d.lastEffect === null && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;
                for (c = b.child; c !== null; )
                  f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, g === null ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
                I(P, P.current & 1 | 2);
                return b.child;
              }
              a = a.sibling;
            }
          d.tail !== null && O() > Ji && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        }
      else {
        if (!f)
          if (a = ih(g), a !== null) {
            if (b.flags |= 64, f = true, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Fi(d, true), d.tail === null && d.tailMode === "hidden" && !g.alternate && !lh)
              return b = b.lastEffect = d.lastEffect, b !== null && (b.nextEffect = null), null;
          } else
            2 * O() - d.renderingStartTime > Ji && c !== 1073741824 && (b.flags |= 64, f = true, Fi(d, false), b.lanes = 33554432);
        d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, c !== null ? c.sibling = g : b.child = g, d.last = g);
      }
      return d.tail !== null ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O(), c.sibling = null, b = P.current, I(P, f ? b & 1 | 2 : b & 1), c) : null;
    case 23:
    case 24:
      return Ki(), a !== null && a.memoizedState !== null !== (b.memoizedState !== null) && d.mode !== "unstable-defer-without-hiding" && (b.flags |= 4), null;
  }
  throw Error(y(156, b.tag));
}
function Li(a) {
  switch (a.tag) {
    case 1:
      Ff(a.type) && Gf();
      var b = a.flags;
      return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 3:
      fh();
      H(N);
      H(M);
      uh();
      b = a.flags;
      if ((b & 64) !== 0)
        throw Error(y(285));
      a.flags = b & -4097 | 64;
      return a;
    case 5:
      return hh(a), null;
    case 13:
      return H(P), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;
    case 19:
      return H(P), null;
    case 4:
      return fh(), null;
    case 10:
      return rg(a), null;
    case 23:
    case 24:
      return Ki(), null;
    default:
      return null;
  }
}
function Mi(a, b) {
  try {
    var c = "", d = b;
    do
      c += Qa(d), d = d.return;
    while (d);
    var e = c;
  } catch (f) {
    e = "\nError generating stack: " + f.message + "\n" + f.stack;
  }
  return { value: a, source: b, stack: e };
}
function Ni(a, b) {
  try {
    console.error(b.value);
  } catch (c) {
    setTimeout(function() {
      throw c;
    });
  }
}
var Oi = typeof WeakMap === "function" ? WeakMap : Map;
function Pi$1(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  c.payload = { element: null };
  var d = b.value;
  c.callback = function() {
    Qi || (Qi = true, Ri = d);
    Ni(a, b);
  };
  return c;
}
function Si(a, b, c) {
  c = zg(-1, c);
  c.tag = 3;
  var d = a.type.getDerivedStateFromError;
  if (typeof d === "function") {
    var e = b.value;
    c.payload = function() {
      Ni(a, b);
      return d(e);
    };
  }
  var f = a.stateNode;
  f !== null && typeof f.componentDidCatch === "function" && (c.callback = function() {
    typeof d !== "function" && (Ti === null ? Ti = /* @__PURE__ */ new Set([this]) : Ti.add(this), Ni(a, b));
    var c2 = b.stack;
    this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
  });
  return c;
}
var Ui = typeof WeakSet === "function" ? WeakSet : Set;
function Vi(a) {
  var b = a.ref;
  if (b !== null)
    if (typeof b === "function")
      try {
        b(null);
      } catch (c) {
        Wi(a, c);
      }
    else
      b.current = null;
}
function Xi$1(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      return;
    case 1:
      if (b.flags & 256 && a !== null) {
        var c = a.memoizedProps, d = a.memoizedState;
        a = b.stateNode;
        b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg$1(b.type, c), d);
        a.__reactInternalSnapshotBeforeUpdate = b;
      }
      return;
    case 3:
      b.flags & 256 && qf(b.stateNode.containerInfo);
      return;
    case 5:
    case 6:
    case 4:
    case 17:
      return;
  }
  throw Error(y(163));
}
function Yi(a, b, c) {
  switch (c.tag) {
    case 0:
    case 11:
    case 15:
    case 22:
      b = c.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        a = b = b.next;
        do {
          if ((a.tag & 3) === 3) {
            var d = a.create;
            a.destroy = d();
          }
          a = a.next;
        } while (a !== b);
      }
      b = c.updateQueue;
      b = b !== null ? b.lastEffect : null;
      if (b !== null) {
        a = b = b.next;
        do {
          var e = a;
          d = e.next;
          e = e.tag;
          (e & 4) !== 0 && (e & 1) !== 0 && (Zi(c, a), $i(c, a));
          a = d;
        } while (a !== b);
      }
      return;
    case 1:
      a = c.stateNode;
      c.flags & 4 && (b === null ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg$1(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
      b = c.updateQueue;
      b !== null && Eg(c, b, a);
      return;
    case 3:
      b = c.updateQueue;
      if (b !== null) {
        a = null;
        if (c.child !== null)
          switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;
            case 1:
              a = c.child.stateNode;
          }
        Eg(c, b, a);
      }
      return;
    case 5:
      a = c.stateNode;
      b === null && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
      return;
    case 6:
      return;
    case 4:
      return;
    case 12:
      return;
    case 13:
      c.memoizedState === null && (c = c.alternate, c !== null && (c = c.memoizedState, c !== null && (c = c.dehydrated, c !== null && Cc(c))));
      return;
    case 19:
    case 17:
    case 20:
    case 21:
    case 23:
    case 24:
      return;
  }
  throw Error(y(163));
}
function aj(a, b) {
  for (var c = a; ; ) {
    if (c.tag === 5) {
      var d = c.stateNode;
      if (b)
        d = d.style, typeof d.setProperty === "function" ? d.setProperty("display", "none", "important") : d.display = "none";
      else {
        d = c.stateNode;
        var e = c.memoizedProps.style;
        e = e !== void 0 && e !== null && e.hasOwnProperty("display") ? e.display : null;
        d.style.display = sb("display", e);
      }
    } else if (c.tag === 6)
      c.stateNode.nodeValue = b ? "" : c.memoizedProps;
    else if ((c.tag !== 23 && c.tag !== 24 || c.memoizedState === null || c === a) && c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === a)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === a)
        return;
      c = c.return;
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function bj(a, b) {
  if (Mf && typeof Mf.onCommitFiberUnmount === "function")
    try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f) {
    }
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      a = b.updateQueue;
      if (a !== null && (a = a.lastEffect, a !== null)) {
        var c = a = a.next;
        do {
          var d = c, e = d.destroy;
          d = d.tag;
          if (e !== void 0)
            if ((d & 4) !== 0)
              Zi(b, c);
            else {
              d = b;
              try {
                e();
              } catch (f) {
                Wi(d, f);
              }
            }
          c = c.next;
        } while (c !== a);
      }
      break;
    case 1:
      Vi(b);
      a = b.stateNode;
      if (typeof a.componentWillUnmount === "function")
        try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f) {
          Wi(b, f);
        }
      break;
    case 5:
      Vi(b);
      break;
    case 4:
      cj(a, b);
  }
}
function dj(a) {
  a.alternate = null;
  a.child = null;
  a.dependencies = null;
  a.firstEffect = null;
  a.lastEffect = null;
  a.memoizedProps = null;
  a.memoizedState = null;
  a.pendingProps = null;
  a.return = null;
  a.updateQueue = null;
}
function ej(a) {
  return a.tag === 5 || a.tag === 3 || a.tag === 4;
}
function fj(a) {
  a: {
    for (var b = a.return; b !== null; ) {
      if (ej(b))
        break a;
      b = b.return;
    }
    throw Error(y(160));
  }
  var c = b;
  b = c.stateNode;
  switch (c.tag) {
    case 5:
      var d = false;
      break;
    case 3:
      b = b.containerInfo;
      d = true;
      break;
    case 4:
      b = b.containerInfo;
      d = true;
      break;
    default:
      throw Error(y(161));
  }
  c.flags & 16 && (pb(b, ""), c.flags &= -17);
  a:
    b:
      for (c = a; ; ) {
        for (; c.sibling === null; ) {
          if (c.return === null || ej(c.return)) {
            c = null;
            break a;
          }
          c = c.return;
        }
        c.sibling.return = c.return;
        for (c = c.sibling; c.tag !== 5 && c.tag !== 6 && c.tag !== 18; ) {
          if (c.flags & 2)
            continue b;
          if (c.child === null || c.tag === 4)
            continue b;
          else
            c.child.return = c, c = c.child;
        }
        if (!(c.flags & 2)) {
          c = c.stateNode;
          break a;
        }
      }
  d ? gj(a, c, b) : hj(a, c, b);
}
function gj(a, b, c) {
  var d = a.tag, e = d === 5 || d === 6;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c !== null && c !== void 0 || b.onclick !== null || (b.onclick = jf));
  else if (d !== 4 && (a = a.child, a !== null))
    for (gj(a, b, c), a = a.sibling; a !== null; )
      gj(a, b, c), a = a.sibling;
}
function hj(a, b, c) {
  var d = a.tag, e = d === 5 || d === 6;
  if (e)
    a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);
  else if (d !== 4 && (a = a.child, a !== null))
    for (hj(a, b, c), a = a.sibling; a !== null; )
      hj(a, b, c), a = a.sibling;
}
function cj(a, b) {
  for (var c = b, d = false, e, f; ; ) {
    if (!d) {
      d = c.return;
      a:
        for (; ; ) {
          if (d === null)
            throw Error(y(160));
          e = d.stateNode;
          switch (d.tag) {
            case 5:
              f = false;
              break a;
            case 3:
              e = e.containerInfo;
              f = true;
              break a;
            case 4:
              e = e.containerInfo;
              f = true;
              break a;
          }
          d = d.return;
        }
      d = true;
    }
    if (c.tag === 5 || c.tag === 6) {
      a:
        for (var g = a, h = c, k = h; ; )
          if (bj(g, k), k.child !== null && k.tag !== 4)
            k.child.return = k, k = k.child;
          else {
            if (k === h)
              break a;
            for (; k.sibling === null; ) {
              if (k.return === null || k.return === h)
                break a;
              k = k.return;
            }
            k.sibling.return = k.return;
            k = k.sibling;
          }
      f ? (g = e, h = c.stateNode, g.nodeType === 8 ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
    } else if (c.tag === 4) {
      if (c.child !== null) {
        e = c.stateNode.containerInfo;
        f = true;
        c.child.return = c;
        c = c.child;
        continue;
      }
    } else if (bj(a, c), c.child !== null) {
      c.child.return = c;
      c = c.child;
      continue;
    }
    if (c === b)
      break;
    for (; c.sibling === null; ) {
      if (c.return === null || c.return === b)
        return;
      c = c.return;
      c.tag === 4 && (d = false);
    }
    c.sibling.return = c.return;
    c = c.sibling;
  }
}
function ij(a, b) {
  switch (b.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
    case 22:
      var c = b.updateQueue;
      c = c !== null ? c.lastEffect : null;
      if (c !== null) {
        var d = c = c.next;
        do
          (d.tag & 3) === 3 && (a = d.destroy, d.destroy = void 0, a !== void 0 && a()), d = d.next;
        while (d !== c);
      }
      return;
    case 1:
      return;
    case 5:
      c = b.stateNode;
      if (c != null) {
        d = b.memoizedProps;
        var e = a !== null ? a.memoizedProps : d;
        a = b.type;
        var f = b.updateQueue;
        b.updateQueue = null;
        if (f !== null) {
          c[xf] = d;
          a === "input" && d.type === "radio" && d.name != null && $a(c, d);
          wb(a, e);
          b = wb(a, d);
          for (e = 0; e < f.length; e += 2) {
            var g = f[e], h = f[e + 1];
            g === "style" ? tb(c, h) : g === "dangerouslySetInnerHTML" ? ob(c, h) : g === "children" ? pb(c, h) : qa(c, g, h, b);
          }
          switch (a) {
            case "input":
              ab(c, d);
              break;
            case "textarea":
              ib(c, d);
              break;
            case "select":
              a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, f != null ? fb(c, !!d.multiple, f, false) : a !== !!d.multiple && (d.defaultValue != null ? fb(c, !!d.multiple, d.defaultValue, true) : fb(c, !!d.multiple, d.multiple ? [] : "", false));
          }
        }
      }
      return;
    case 6:
      if (b.stateNode === null)
        throw Error(y(162));
      b.stateNode.nodeValue = b.memoizedProps;
      return;
    case 3:
      c = b.stateNode;
      c.hydrate && (c.hydrate = false, Cc(c.containerInfo));
      return;
    case 12:
      return;
    case 13:
      b.memoizedState !== null && (jj = O(), aj(b.child, true));
      kj(b);
      return;
    case 19:
      kj(b);
      return;
    case 17:
      return;
    case 23:
    case 24:
      aj(b, b.memoizedState !== null);
      return;
  }
  throw Error(y(163));
}
function kj(a) {
  var b = a.updateQueue;
  if (b !== null) {
    a.updateQueue = null;
    var c = a.stateNode;
    c === null && (c = a.stateNode = new Ui());
    b.forEach(function(b2) {
      var d = lj.bind(null, a, b2);
      c.has(b2) || (c.add(b2), b2.then(d, d));
    });
  }
}
function mj(a, b) {
  return a !== null && (a = a.memoizedState, a === null || a.dehydrated !== null) ? (b = b.memoizedState, b !== null && b.dehydrated === null) : false;
}
var nj = Math.ceil, oj = ra.ReactCurrentDispatcher, pj = ra.ReactCurrentOwner, X = 0, U = null, Y = null, W = 0, qj = 0, rj = Bf(0), V = 0, sj = null, tj = 0, Dg = 0, Hi = 0, uj = 0, vj = null, jj = 0, Ji = Infinity;
function wj() {
  Ji = O() + 500;
}
var Z = null, Qi = false, Ri = null, Ti = null, xj = false, yj = null, zj = 90, Aj = [], Bj = [], Cj = null, Dj = 0, Ej = null, Fj = -1, Gj = 0, Hj = 0, Ij = null, Jj = false;
function Hg() {
  return (X & 48) !== 0 ? O() : Fj !== -1 ? Fj : Fj = O();
}
function Ig(a) {
  a = a.mode;
  if ((a & 2) === 0)
    return 1;
  if ((a & 4) === 0)
    return eg$1() === 99 ? 1 : 2;
  Gj === 0 && (Gj = tj);
  if (kg.transition !== 0) {
    Hj !== 0 && (Hj = vj !== null ? vj.pendingLanes : 0);
    a = Gj;
    var b = 4186112 & ~Hj;
    b &= -b;
    b === 0 && (a = 4186112 & ~a, b = a & -a, b === 0 && (b = 8192));
    return b;
  }
  a = eg$1();
  (X & 4) !== 0 && a === 98 ? a = Xc(12, Gj) : (a = Sc$1(a), a = Xc(a, Gj));
  return a;
}
function Jg(a, b, c) {
  if (50 < Dj)
    throw Dj = 0, Ej = null, Error(y(185));
  a = Kj(a, b);
  if (a === null)
    return null;
  $c(a, b, c);
  a === U && (Hi |= b, V === 4 && Ii(a, W));
  var d = eg$1();
  b === 1 ? (X & 8) !== 0 && (X & 48) === 0 ? Lj(a) : (Mj(a, c), X === 0 && (wj(), ig())) : ((X & 4) === 0 || d !== 98 && d !== 99 || (Cj === null ? Cj = /* @__PURE__ */ new Set([a]) : Cj.add(a)), Mj(a, c));
  vj = a;
}
function Kj(a, b) {
  a.lanes |= b;
  var c = a.alternate;
  c !== null && (c.lanes |= b);
  c = a;
  for (a = a.return; a !== null; )
    a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
  return c.tag === 3 ? c.stateNode : null;
}
function Mj(a, b) {
  for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g; ) {
    var h = 31 - Vc(g), k = 1 << h, l2 = f[h];
    if (l2 === -1) {
      if ((k & d) === 0 || (k & e) !== 0) {
        l2 = b;
        Rc(k);
        var n2 = F;
        f[h] = 10 <= n2 ? l2 + 250 : 6 <= n2 ? l2 + 5e3 : -1;
      }
    } else
      l2 <= b && (a.expiredLanes |= k);
    g &= ~k;
  }
  d = Uc(a, a === U ? W : 0);
  b = F;
  if (d === 0)
    c !== null && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);
  else {
    if (c !== null) {
      if (a.callbackPriority === b)
        return;
      c !== Zf && Pf(c);
    }
    b === 15 ? (c = Lj.bind(null, a), ag === null ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : b === 14 ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
    a.callbackPriority = b;
    a.callbackNode = c;
  }
}
function Nj(a) {
  Fj = -1;
  Hj = Gj = 0;
  if ((X & 48) !== 0)
    throw Error(y(327));
  var b = a.callbackNode;
  if (Oj() && a.callbackNode !== b)
    return null;
  var c = Uc(a, a === U ? W : 0);
  if (c === 0)
    return null;
  var d = c;
  var e = X;
  X |= 16;
  var f = Pj();
  if (U !== a || W !== d)
    wj(), Qj(a, d);
  do
    try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    }
  while (1);
  qg();
  oj.current = f;
  X = e;
  Y !== null ? d = 0 : (U = null, W = 0, d = V);
  if ((tj & Hi) !== 0)
    Qj(a, 0);
  else if (d !== 0) {
    d === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), c = Wc(a), c !== 0 && (d = Tj(a, c)));
    if (d === 1)
      throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O()), b;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = c;
    switch (d) {
      case 0:
      case 1:
        throw Error(y(345));
      case 2:
        Uj(a);
        break;
      case 3:
        Ii(a, c);
        if ((c & 62914560) === c && (d = jj + 500 - O(), 10 < d)) {
          if (Uc(a, 0) !== 0)
            break;
          e = a.suspendedLanes;
          if ((e & c) !== c) {
            Hg();
            a.pingedLanes |= a.suspendedLanes & e;
            break;
          }
          a.timeoutHandle = of(Uj.bind(null, a), d);
          break;
        }
        Uj(a);
        break;
      case 4:
        Ii(a, c);
        if ((c & 4186112) === c)
          break;
        d = a.eventTimes;
        for (e = -1; 0 < c; ) {
          var g = 31 - Vc(c);
          f = 1 << g;
          g = d[g];
          g > e && (e = g);
          c &= ~f;
        }
        c = e;
        c = O() - c;
        c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3e3 > c ? 3e3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;
        if (10 < c) {
          a.timeoutHandle = of(Uj.bind(null, a), c);
          break;
        }
        Uj(a);
        break;
      case 5:
        Uj(a);
        break;
      default:
        throw Error(y(329));
    }
  }
  Mj(a, O());
  return a.callbackNode === b ? Nj.bind(null, a) : null;
}
function Ii(a, b) {
  b &= ~uj;
  b &= ~Hi;
  a.suspendedLanes |= b;
  a.pingedLanes &= ~b;
  for (a = a.expirationTimes; 0 < b; ) {
    var c = 31 - Vc(b), d = 1 << c;
    a[c] = -1;
    b &= ~d;
  }
}
function Lj(a) {
  if ((X & 48) !== 0)
    throw Error(y(327));
  Oj();
  if (a === U && (a.expiredLanes & W) !== 0) {
    var b = W;
    var c = Tj(a, b);
    (tj & Hi) !== 0 && (b = Uc(a, b), c = Tj(a, b));
  } else
    b = Uc(a, 0), c = Tj(a, b);
  a.tag !== 0 && c === 2 && (X |= 64, a.hydrate && (a.hydrate = false, qf(a.containerInfo)), b = Wc(a), b !== 0 && (c = Tj(a, b)));
  if (c === 1)
    throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O()), c;
  a.finishedWork = a.current.alternate;
  a.finishedLanes = b;
  Uj(a);
  Mj(a, O());
  return null;
}
function Vj() {
  if (Cj !== null) {
    var a = Cj;
    Cj = null;
    a.forEach(function(a2) {
      a2.expiredLanes |= 24 & a2.pendingLanes;
      Mj(a2, O());
    });
  }
  ig();
}
function Wj(a, b) {
  var c = X;
  X |= 1;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
}
function Xj(a, b) {
  var c = X;
  X &= -2;
  X |= 8;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
}
function ni$1(a, b) {
  I(rj, qj);
  qj |= b;
  tj |= b;
}
function Ki() {
  qj = rj.current;
  H(rj);
}
function Qj(a, b) {
  a.finishedWork = null;
  a.finishedLanes = 0;
  var c = a.timeoutHandle;
  c !== -1 && (a.timeoutHandle = -1, pf(c));
  if (Y !== null)
    for (c = Y.return; c !== null; ) {
      var d = c;
      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          d !== null && d !== void 0 && Gf();
          break;
        case 3:
          fh();
          H(N);
          H(M);
          uh();
          break;
        case 5:
          hh(d);
          break;
        case 4:
          fh();
          break;
        case 13:
          H(P);
          break;
        case 19:
          H(P);
          break;
        case 10:
          rg(d);
          break;
        case 23:
        case 24:
          Ki();
      }
      c = c.return;
    }
  U = a;
  Y = Tg(a.current, null);
  W = qj = tj = b;
  V = 0;
  sj = null;
  uj = Hi = Dg = 0;
}
function Sj(a, b) {
  do {
    var c = Y;
    try {
      qg();
      vh.current = Gh;
      if (yh) {
        for (var d = R.memoizedState; d !== null; ) {
          var e = d.queue;
          e !== null && (e.pending = null);
          d = d.next;
        }
        yh = false;
      }
      xh = 0;
      T = S = R = null;
      zh = false;
      pj.current = null;
      if (c === null || c.return === null) {
        V = 1;
        sj = b;
        Y = null;
        break;
      }
      a: {
        var f = a, g = c.return, h = c, k = b;
        b = W;
        h.flags |= 2048;
        h.firstEffect = h.lastEffect = null;
        if (k !== null && typeof k === "object" && typeof k.then === "function") {
          var l2 = k;
          if ((h.mode & 2) === 0) {
            var n2 = h.alternate;
            n2 ? (h.updateQueue = n2.updateQueue, h.memoizedState = n2.memoizedState, h.lanes = n2.lanes) : (h.updateQueue = null, h.memoizedState = null);
          }
          var A2 = (P.current & 1) !== 0, p2 = g;
          do {
            var C2;
            if (C2 = p2.tag === 13) {
              var x2 = p2.memoizedState;
              if (x2 !== null)
                C2 = x2.dehydrated !== null ? true : false;
              else {
                var w = p2.memoizedProps;
                C2 = w.fallback === void 0 ? false : w.unstable_avoidThisFallback !== true ? true : A2 ? false : true;
              }
            }
            if (C2) {
              var z2 = p2.updateQueue;
              if (z2 === null) {
                var u2 = /* @__PURE__ */ new Set();
                u2.add(l2);
                p2.updateQueue = u2;
              } else
                z2.add(l2);
              if ((p2.mode & 2) === 0) {
                p2.flags |= 64;
                h.flags |= 16384;
                h.flags &= -2981;
                if (h.tag === 1)
                  if (h.alternate === null)
                    h.tag = 17;
                  else {
                    var t2 = zg(-1, 1);
                    t2.tag = 2;
                    Ag(h, t2);
                  }
                h.lanes |= 1;
                break a;
              }
              k = void 0;
              h = b;
              var q2 = f.pingCache;
              q2 === null ? (q2 = f.pingCache = new Oi(), k = /* @__PURE__ */ new Set(), q2.set(l2, k)) : (k = q2.get(l2), k === void 0 && (k = /* @__PURE__ */ new Set(), q2.set(l2, k)));
              if (!k.has(h)) {
                k.add(h);
                var v2 = Yj.bind(null, f, l2, h);
                l2.then(v2, v2);
              }
              p2.flags |= 4096;
              p2.lanes = b;
              break a;
            }
            p2 = p2.return;
          } while (p2 !== null);
          k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
        }
        V !== 5 && (V = 2);
        k = Mi(k, h);
        p2 = g;
        do {
          switch (p2.tag) {
            case 3:
              f = k;
              p2.flags |= 4096;
              b &= -b;
              p2.lanes |= b;
              var J2 = Pi$1(p2, f, b);
              Bg(p2, J2);
              break a;
            case 1:
              f = k;
              var K2 = p2.type, Q2 = p2.stateNode;
              if ((p2.flags & 64) === 0 && (typeof K2.getDerivedStateFromError === "function" || Q2 !== null && typeof Q2.componentDidCatch === "function" && (Ti === null || !Ti.has(Q2)))) {
                p2.flags |= 4096;
                b &= -b;
                p2.lanes |= b;
                var L2 = Si(p2, f, b);
                Bg(p2, L2);
                break a;
              }
          }
          p2 = p2.return;
        } while (p2 !== null);
      }
      Zj(c);
    } catch (va) {
      b = va;
      Y === c && c !== null && (Y = c = c.return);
      continue;
    }
    break;
  } while (1);
}
function Pj() {
  var a = oj.current;
  oj.current = Gh;
  return a === null ? Gh : a;
}
function Tj(a, b) {
  var c = X;
  X |= 16;
  var d = Pj();
  U === a && W === b || Qj(a, b);
  do
    try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    }
  while (1);
  qg();
  X = c;
  oj.current = d;
  if (Y !== null)
    throw Error(y(261));
  U = null;
  W = 0;
  return V;
}
function ak() {
  for (; Y !== null; )
    bk(Y);
}
function Rj() {
  for (; Y !== null && !Qf(); )
    bk(Y);
}
function bk(a) {
  var b = ck(a.alternate, a, qj);
  a.memoizedProps = a.pendingProps;
  b === null ? Zj(a) : Y = b;
  pj.current = null;
}
function Zj(a) {
  var b = a;
  do {
    var c = b.alternate;
    a = b.return;
    if ((b.flags & 2048) === 0) {
      c = Gi(c, b, qj);
      if (c !== null) {
        Y = c;
        return;
      }
      c = b;
      if (c.tag !== 24 && c.tag !== 23 || c.memoizedState === null || (qj & 1073741824) !== 0 || (c.mode & 4) === 0) {
        for (var d = 0, e = c.child; e !== null; )
          d |= e.lanes | e.childLanes, e = e.sibling;
        c.childLanes = d;
      }
      a !== null && (a.flags & 2048) === 0 && (a.firstEffect === null && (a.firstEffect = b.firstEffect), b.lastEffect !== null && (a.lastEffect !== null && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (a.lastEffect !== null ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
    } else {
      c = Li(b);
      if (c !== null) {
        c.flags &= 2047;
        Y = c;
        return;
      }
      a !== null && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
    }
    b = b.sibling;
    if (b !== null) {
      Y = b;
      return;
    }
    Y = b = a;
  } while (b !== null);
  V === 0 && (V = 5);
}
function Uj(a) {
  var b = eg$1();
  gg$1(99, dk.bind(null, a, b));
  return null;
}
function dk(a, b) {
  do
    Oj();
  while (yj !== null);
  if ((X & 48) !== 0)
    throw Error(y(327));
  var c = a.finishedWork;
  if (c === null)
    return null;
  a.finishedWork = null;
  a.finishedLanes = 0;
  if (c === a.current)
    throw Error(y(177));
  a.callbackNode = null;
  var d = c.lanes | c.childLanes, e = d, f = a.pendingLanes & ~e;
  a.pendingLanes = e;
  a.suspendedLanes = 0;
  a.pingedLanes = 0;
  a.expiredLanes &= e;
  a.mutableReadLanes &= e;
  a.entangledLanes &= e;
  e = a.entanglements;
  for (var g = a.eventTimes, h = a.expirationTimes; 0 < f; ) {
    var k = 31 - Vc(f), l2 = 1 << k;
    e[k] = 0;
    g[k] = -1;
    h[k] = -1;
    f &= ~l2;
  }
  Cj !== null && (d & 24) === 0 && Cj.has(a) && Cj.delete(a);
  a === U && (Y = U = null, W = 0);
  1 < c.flags ? c.lastEffect !== null ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;
  if (d !== null) {
    e = X;
    X |= 32;
    pj.current = null;
    kf = fd;
    g = Ne();
    if (Oe(g)) {
      if ("selectionStart" in g)
        h = { start: g.selectionStart, end: g.selectionEnd };
      else
        a:
          if (h = (h = g.ownerDocument) && h.defaultView || window, (l2 = h.getSelection && h.getSelection()) && l2.rangeCount !== 0) {
            h = l2.anchorNode;
            f = l2.anchorOffset;
            k = l2.focusNode;
            l2 = l2.focusOffset;
            try {
              h.nodeType, k.nodeType;
            } catch (va) {
              h = null;
              break a;
            }
            var n2 = 0, A2 = -1, p2 = -1, C2 = 0, x2 = 0, w = g, z2 = null;
            b:
              for (; ; ) {
                for (var u2; ; ) {
                  w !== h || f !== 0 && w.nodeType !== 3 || (A2 = n2 + f);
                  w !== k || l2 !== 0 && w.nodeType !== 3 || (p2 = n2 + l2);
                  w.nodeType === 3 && (n2 += w.nodeValue.length);
                  if ((u2 = w.firstChild) === null)
                    break;
                  z2 = w;
                  w = u2;
                }
                for (; ; ) {
                  if (w === g)
                    break b;
                  z2 === h && ++C2 === f && (A2 = n2);
                  z2 === k && ++x2 === l2 && (p2 = n2);
                  if ((u2 = w.nextSibling) !== null)
                    break;
                  w = z2;
                  z2 = w.parentNode;
                }
                w = u2;
              }
            h = A2 === -1 || p2 === -1 ? null : { start: A2, end: p2 };
          } else
            h = null;
      h = h || { start: 0, end: 0 };
    } else
      h = null;
    lf = { focusedElem: g, selectionRange: h };
    fd = false;
    Ij = null;
    Jj = false;
    Z = d;
    do
      try {
        ek();
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Ij = null;
    Z = d;
    do
      try {
        for (g = a; Z !== null; ) {
          var t2 = Z.flags;
          t2 & 16 && pb(Z.stateNode, "");
          if (t2 & 128) {
            var q2 = Z.alternate;
            if (q2 !== null) {
              var v2 = q2.ref;
              v2 !== null && (typeof v2 === "function" ? v2(null) : v2.current = null);
            }
          }
          switch (t2 & 1038) {
            case 2:
              fj(Z);
              Z.flags &= -3;
              break;
            case 6:
              fj(Z);
              Z.flags &= -3;
              ij(Z.alternate, Z);
              break;
            case 1024:
              Z.flags &= -1025;
              break;
            case 1028:
              Z.flags &= -1025;
              ij(Z.alternate, Z);
              break;
            case 4:
              ij(Z.alternate, Z);
              break;
            case 8:
              h = Z;
              cj(g, h);
              var J2 = h.alternate;
              dj(h);
              J2 !== null && dj(J2);
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    v2 = lf;
    q2 = Ne();
    t2 = v2.focusedElem;
    g = v2.selectionRange;
    if (q2 !== t2 && t2 && t2.ownerDocument && Me(t2.ownerDocument.documentElement, t2)) {
      g !== null && Oe(t2) && (q2 = g.start, v2 = g.end, v2 === void 0 && (v2 = q2), "selectionStart" in t2 ? (t2.selectionStart = q2, t2.selectionEnd = Math.min(v2, t2.value.length)) : (v2 = (q2 = t2.ownerDocument || document) && q2.defaultView || window, v2.getSelection && (v2 = v2.getSelection(), h = t2.textContent.length, J2 = Math.min(g.start, h), g = g.end === void 0 ? J2 : Math.min(g.end, h), !v2.extend && J2 > g && (h = g, g = J2, J2 = h), h = Le(t2, J2), f = Le(t2, g), h && f && (v2.rangeCount !== 1 || v2.anchorNode !== h.node || v2.anchorOffset !== h.offset || v2.focusNode !== f.node || v2.focusOffset !== f.offset) && (q2 = q2.createRange(), q2.setStart(h.node, h.offset), v2.removeAllRanges(), J2 > g ? (v2.addRange(q2), v2.extend(f.node, f.offset)) : (q2.setEnd(f.node, f.offset), v2.addRange(q2))))));
      q2 = [];
      for (v2 = t2; v2 = v2.parentNode; )
        v2.nodeType === 1 && q2.push({ element: v2, left: v2.scrollLeft, top: v2.scrollTop });
      typeof t2.focus === "function" && t2.focus();
      for (t2 = 0; t2 < q2.length; t2++)
        v2 = q2[t2], v2.element.scrollLeft = v2.left, v2.element.scrollTop = v2.top;
    }
    fd = !!kf;
    lf = kf = null;
    a.current = c;
    Z = d;
    do
      try {
        for (t2 = a; Z !== null; ) {
          var K2 = Z.flags;
          K2 & 36 && Yi(t2, Z.alternate, Z);
          if (K2 & 128) {
            q2 = void 0;
            var Q2 = Z.ref;
            if (Q2 !== null) {
              var L2 = Z.stateNode;
              switch (Z.tag) {
                case 5:
                  q2 = L2;
                  break;
                default:
                  q2 = L2;
              }
              typeof Q2 === "function" ? Q2(q2) : Q2.current = q2;
            }
          }
          Z = Z.nextEffect;
        }
      } catch (va) {
        if (Z === null)
          throw Error(y(330));
        Wi(Z, va);
        Z = Z.nextEffect;
      }
    while (Z !== null);
    Z = null;
    $f();
    X = e;
  } else
    a.current = c;
  if (xj)
    xj = false, yj = a, zj = b;
  else
    for (Z = d; Z !== null; )
      b = Z.nextEffect, Z.nextEffect = null, Z.flags & 8 && (K2 = Z, K2.sibling = null, K2.stateNode = null), Z = b;
  d = a.pendingLanes;
  d === 0 && (Ti = null);
  d === 1 ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
  c = c.stateNode;
  if (Mf && typeof Mf.onCommitFiberRoot === "function")
    try {
      Mf.onCommitFiberRoot(Lf, c, void 0, (c.current.flags & 64) === 64);
    } catch (va) {
    }
  Mj(a, O());
  if (Qi)
    throw Qi = false, a = Ri, Ri = null, a;
  if ((X & 8) !== 0)
    return null;
  ig();
  return null;
}
function ek() {
  for (; Z !== null; ) {
    var a = Z.alternate;
    Jj || Ij === null || ((Z.flags & 8) !== 0 ? dc(Z, Ij) && (Jj = true) : Z.tag === 13 && mj(a, Z) && dc(Z, Ij) && (Jj = true));
    var b = Z.flags;
    (b & 256) !== 0 && Xi$1(a, Z);
    (b & 512) === 0 || xj || (xj = true, hg(97, function() {
      Oj();
      return null;
    }));
    Z = Z.nextEffect;
  }
}
function Oj() {
  if (zj !== 90) {
    var a = 97 < zj ? 97 : zj;
    zj = 90;
    return gg$1(a, fk);
  }
  return false;
}
function $i(a, b) {
  Aj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function Zi(a, b) {
  Bj.push(b, a);
  xj || (xj = true, hg(97, function() {
    Oj();
    return null;
  }));
}
function fk() {
  if (yj === null)
    return false;
  var a = yj;
  yj = null;
  if ((X & 48) !== 0)
    throw Error(y(331));
  var b = X;
  X |= 32;
  var c = Bj;
  Bj = [];
  for (var d = 0; d < c.length; d += 2) {
    var e = c[d], f = c[d + 1], g = e.destroy;
    e.destroy = void 0;
    if (typeof g === "function")
      try {
        g();
      } catch (k) {
        if (f === null)
          throw Error(y(330));
        Wi(f, k);
      }
  }
  c = Aj;
  Aj = [];
  for (d = 0; d < c.length; d += 2) {
    e = c[d];
    f = c[d + 1];
    try {
      var h = e.create;
      e.destroy = h();
    } catch (k) {
      if (f === null)
        throw Error(y(330));
      Wi(f, k);
    }
  }
  for (h = a.current.firstEffect; h !== null; )
    a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;
  X = b;
  ig();
  return true;
}
function gk(a, b, c) {
  b = Mi(c, b);
  b = Pi$1(a, b, 1);
  Ag(a, b);
  b = Hg();
  a = Kj(a, 1);
  a !== null && ($c(a, 1, b), Mj(a, b));
}
function Wi(a, b) {
  if (a.tag === 3)
    gk(a, a, b);
  else
    for (var c = a.return; c !== null; ) {
      if (c.tag === 3) {
        gk(c, a, b);
        break;
      } else if (c.tag === 1) {
        var d = c.stateNode;
        if (typeof c.type.getDerivedStateFromError === "function" || typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d))) {
          a = Mi(b, a);
          var e = Si(c, a, 1);
          Ag(c, e);
          e = Hg();
          c = Kj(c, 1);
          if (c !== null)
            $c(c, 1, e), Mj(c, e);
          else if (typeof d.componentDidCatch === "function" && (Ti === null || !Ti.has(d)))
            try {
              d.componentDidCatch(b, a);
            } catch (f) {
            }
          break;
        }
      }
      c = c.return;
    }
}
function Yj(a, b, c) {
  var d = a.pingCache;
  d !== null && d.delete(b);
  b = Hg();
  a.pingedLanes |= a.suspendedLanes & c;
  U === a && (W & c) === c && (V === 4 || V === 3 && (W & 62914560) === W && 500 > O() - jj ? Qj(a, 0) : uj |= c);
  Mj(a, b);
}
function lj(a, b) {
  var c = a.stateNode;
  c !== null && c.delete(b);
  b = 0;
  b === 0 && (b = a.mode, (b & 2) === 0 ? b = 1 : (b & 4) === 0 ? b = eg$1() === 99 ? 1 : 2 : (Gj === 0 && (Gj = tj), b = Yc(62914560 & ~Gj), b === 0 && (b = 4194304)));
  c = Hg();
  a = Kj(a, b);
  a !== null && ($c(a, b, c), Mj(a, c));
}
var ck;
ck = function(a, b, c) {
  var d = b.lanes;
  if (a !== null)
    if (a.memoizedProps !== b.pendingProps || N.current)
      ug = true;
    else if ((c & d) !== 0)
      ug = (a.flags & 16384) !== 0 ? true : false;
    else {
      ug = false;
      switch (b.tag) {
        case 3:
          ri(b);
          sh();
          break;
        case 5:
          gh(b);
          break;
        case 1:
          Ff(b.type) && Jf(b);
          break;
        case 4:
          eh(b, b.stateNode.containerInfo);
          break;
        case 10:
          d = b.memoizedProps.value;
          var e = b.type._context;
          I(mg, e._currentValue);
          e._currentValue = d;
          break;
        case 13:
          if (b.memoizedState !== null) {
            if ((c & b.child.childLanes) !== 0)
              return ti(a, b, c);
            I(P, P.current & 1);
            b = hi(a, b, c);
            return b !== null ? b.sibling : null;
          }
          I(P, P.current & 1);
          break;
        case 19:
          d = (c & b.childLanes) !== 0;
          if ((a.flags & 64) !== 0) {
            if (d)
              return Ai(a, b, c);
            b.flags |= 64;
          }
          e = b.memoizedState;
          e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null);
          I(P, P.current);
          if (d)
            break;
          else
            return null;
        case 23:
        case 24:
          return b.lanes = 0, mi(a, b, c);
      }
      return hi(a, b, c);
    }
  else
    ug = false;
  b.lanes = 0;
  switch (b.tag) {
    case 2:
      d = b.type;
      a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
      a = b.pendingProps;
      e = Ef(b, M.current);
      tg(b, c);
      e = Ch(null, b, d, a, e, c);
      b.flags |= 1;
      if (typeof e === "object" && e !== null && typeof e.render === "function" && e.$$typeof === void 0) {
        b.tag = 1;
        b.memoizedState = null;
        b.updateQueue = null;
        if (Ff(d)) {
          var f = true;
          Jf(b);
        } else
          f = false;
        b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null;
        xg(b);
        var g = d.getDerivedStateFromProps;
        typeof g === "function" && Gg$1(b, d, g, a);
        e.updater = Kg;
        b.stateNode = e;
        e._reactInternals = b;
        Og(b, d, a, c);
        b = qi(null, b, d, true, f, c);
      } else
        b.tag = 0, fi(null, b, e, c), b = b.child;
      return b;
    case 16:
      e = b.elementType;
      a: {
        a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        f = e._init;
        e = f(e._payload);
        b.type = e;
        f = b.tag = hk(e);
        a = lg$1(e, a);
        switch (f) {
          case 0:
            b = li(null, b, e, a, c);
            break a;
          case 1:
            b = pi$1(null, b, e, a, c);
            break a;
          case 11:
            b = gi(null, b, e, a, c);
            break a;
          case 14:
            b = ii$1(null, b, e, lg$1(e.type, a), d, c);
            break a;
        }
        throw Error(y(306, e, ""));
      }
      return b;
    case 0:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), li(a, b, d, e, c);
    case 1:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), pi$1(a, b, d, e, c);
    case 3:
      ri(b);
      d = b.updateQueue;
      if (a === null || d === null)
        throw Error(y(282));
      d = b.pendingProps;
      e = b.memoizedState;
      e = e !== null ? e.element : null;
      yg(a, b);
      Cg(b, d, null, c);
      d = b.memoizedState.element;
      if (d === e)
        sh(), b = hi(a, b, c);
      else {
        e = b.stateNode;
        if (f = e.hydrate)
          kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = true;
        if (f) {
          a = e.mutableSourceEagerHydrationData;
          if (a != null)
            for (e = 0; e < a.length; e += 2)
              f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
          c = Zg(b, null, d, c);
          for (b.child = c; c; )
            c.flags = c.flags & -3 | 1024, c = c.sibling;
        } else
          fi(a, b, d, c), sh();
        b = b.child;
      }
      return b;
    case 5:
      return gh(b), a === null && ph(b), d = b.type, e = b.pendingProps, f = a !== null ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : f !== null && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;
    case 6:
      return a === null && ph(b), null;
    case 13:
      return ti(a, b, c);
    case 4:
      return eh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;
    case 11:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), gi(a, b, d, e, c);
    case 7:
      return fi(a, b, b.pendingProps, c), b.child;
    case 8:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 12:
      return fi(a, b, b.pendingProps.children, c), b.child;
    case 10:
      a: {
        d = b.type._context;
        e = b.pendingProps;
        g = b.memoizedProps;
        f = e.value;
        var h = b.type._context;
        I(mg, h._currentValue);
        h._currentValue = f;
        if (g !== null)
          if (h = g.value, f = He(h, f) ? 0 : (typeof d._calculateChangedBits === "function" ? d._calculateChangedBits(h, f) : 1073741823) | 0, f === 0) {
            if (g.children === e.children && !N.current) {
              b = hi(a, b, c);
              break a;
            }
          } else
            for (h = b.child, h !== null && (h.return = b); h !== null; ) {
              var k = h.dependencies;
              if (k !== null) {
                g = h.child;
                for (var l2 = k.firstContext; l2 !== null; ) {
                  if (l2.context === d && (l2.observedBits & f) !== 0) {
                    h.tag === 1 && (l2 = zg(-1, c & -c), l2.tag = 2, Ag(h, l2));
                    h.lanes |= c;
                    l2 = h.alternate;
                    l2 !== null && (l2.lanes |= c);
                    sg(h.return, c);
                    k.lanes |= c;
                    break;
                  }
                  l2 = l2.next;
                }
              } else
                g = h.tag === 10 ? h.type === b.type ? null : h.child : h.child;
              if (g !== null)
                g.return = h;
              else
                for (g = h; g !== null; ) {
                  if (g === b) {
                    g = null;
                    break;
                  }
                  h = g.sibling;
                  if (h !== null) {
                    h.return = g.return;
                    g = h;
                    break;
                  }
                  g = g.return;
                }
              h = g;
            }
        fi(a, b, e.children, c);
        b = b.child;
      }
      return b;
    case 9:
      return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;
    case 14:
      return e = b.type, f = lg$1(e, b.pendingProps), f = lg$1(e.type, f), ii$1(a, b, e, f, d, c);
    case 15:
      return ki(a, b, b.type, b.pendingProps, d, c);
    case 17:
      return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg$1(d, e), a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = true, Jf(b)) : a = false, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, true, a, c);
    case 19:
      return Ai(a, b, c);
    case 23:
      return mi(a, b, c);
    case 24:
      return mi(a, b, c);
  }
  throw Error(y(156, b.tag));
};
function ik(a, b, c, d) {
  this.tag = a;
  this.key = c;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d;
  this.flags = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function nh(a, b, c, d) {
  return new ik(a, b, c, d);
}
function ji(a) {
  a = a.prototype;
  return !(!a || !a.isReactComponent);
}
function hk(a) {
  if (typeof a === "function")
    return ji(a) ? 1 : 0;
  if (a !== void 0 && a !== null) {
    a = a.$$typeof;
    if (a === Aa)
      return 11;
    if (a === Da)
      return 14;
  }
  return 2;
}
function Tg(a, b) {
  var c = a.alternate;
  c === null ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
  c.childLanes = a.childLanes;
  c.lanes = a.lanes;
  c.child = a.child;
  c.memoizedProps = a.memoizedProps;
  c.memoizedState = a.memoizedState;
  c.updateQueue = a.updateQueue;
  b = a.dependencies;
  c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext };
  c.sibling = a.sibling;
  c.index = a.index;
  c.ref = a.ref;
  return c;
}
function Vg(a, b, c, d, e, f) {
  var g = 2;
  d = a;
  if (typeof a === "function")
    ji(a) && (g = 1);
  else if (typeof a === "string")
    g = 5;
  else
    a:
      switch (a) {
        case ua:
          return Xg(c.children, e, f, b);
        case Ha:
          g = 8;
          e |= 16;
          break;
        case wa:
          g = 8;
          e |= 1;
          break;
        case xa:
          return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;
        case Ba:
          return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;
        case Ca:
          return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;
        case Ia:
          return vi(c, e, f, b);
        case Ja:
          return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;
        default:
          if (typeof a === "object" && a !== null)
            switch (a.$$typeof) {
              case ya:
                g = 10;
                break a;
              case za:
                g = 9;
                break a;
              case Aa:
                g = 11;
                break a;
              case Da:
                g = 14;
                break a;
              case Ea:
                g = 16;
                d = null;
                break a;
              case Fa:
                g = 22;
                break a;
            }
          throw Error(y(130, a == null ? a : typeof a, ""));
      }
  b = nh(g, c, b, e);
  b.elementType = a;
  b.type = d;
  b.lanes = f;
  return b;
}
function Xg(a, b, c, d) {
  a = nh(7, a, d, b);
  a.lanes = c;
  return a;
}
function vi(a, b, c, d) {
  a = nh(23, a, d, b);
  a.elementType = Ia;
  a.lanes = c;
  return a;
}
function Ug(a, b, c) {
  a = nh(6, a, null, b);
  a.lanes = c;
  return a;
}
function Wg(a, b, c) {
  b = nh(4, a.children !== null ? a.children : [], a.key, b);
  b.lanes = c;
  b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };
  return b;
}
function jk(a, b, c) {
  this.tag = b;
  this.containerInfo = a;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.pendingContext = this.context = null;
  this.hydrate = c;
  this.callbackNode = null;
  this.callbackPriority = 0;
  this.eventTimes = Zc(0);
  this.expirationTimes = Zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = Zc(0);
  this.mutableSourceEagerHydrationData = null;
}
function kk(a, b, c) {
  var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: ta, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
}
function lk(a, b, c, d) {
  var e = b.current, f = Hg(), g = Ig(e);
  a:
    if (c) {
      c = c._reactInternals;
      b: {
        if (Zb(c) !== c || c.tag !== 1)
          throw Error(y(170));
        var h = c;
        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break b;
            case 1:
              if (Ff(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }
          }
          h = h.return;
        } while (h !== null);
        throw Error(y(171));
      }
      if (c.tag === 1) {
        var k = c.type;
        if (Ff(k)) {
          c = If(c, k, h);
          break a;
        }
      }
      c = h;
    } else
      c = Cf;
  b.context === null ? b.context = c : b.pendingContext = c;
  b = zg(f, g);
  b.payload = { element: a };
  d = d === void 0 ? null : d;
  d !== null && (b.callback = d);
  Ag(e, b);
  Jg(e, g, f);
  return g;
}
function mk(a) {
  a = a.current;
  if (!a.child)
    return null;
  switch (a.child.tag) {
    case 5:
      return a.child.stateNode;
    default:
      return a.child.stateNode;
  }
}
function nk(a, b) {
  a = a.memoizedState;
  if (a !== null && a.dehydrated !== null) {
    var c = a.retryLane;
    a.retryLane = c !== 0 && c < b ? c : b;
  }
}
function ok(a, b) {
  nk(a, b);
  (a = a.alternate) && nk(a, b);
}
function pk() {
  return null;
}
function qk(a, b, c) {
  var d = c != null && c.hydrationOptions != null && c.hydrationOptions.mutableSources || null;
  c = new jk(a, b, c != null && c.hydrate === true);
  b = nh(3, null, null, b === 2 ? 7 : b === 1 ? 3 : 0);
  c.current = b;
  b.stateNode = c;
  xg(b);
  a[ff] = c.current;
  cf(a.nodeType === 8 ? a.parentNode : a);
  if (d)
    for (a = 0; a < d.length; a++) {
      b = d[a];
      var e = b._getVersion;
      e = e(b._source);
      c.mutableSourceEagerHydrationData == null ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
    }
  this._internalRoot = c;
}
qk.prototype.render = function(a) {
  lk(a, this._internalRoot, null, null);
};
qk.prototype.unmount = function() {
  var a = this._internalRoot, b = a.containerInfo;
  lk(null, a, null, function() {
    b[ff] = null;
  });
};
function rk(a) {
  return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
}
function sk(a, b) {
  b || (b = a ? a.nodeType === 9 ? a.documentElement : a.firstChild : null, b = !(!b || b.nodeType !== 1 || !b.hasAttribute("data-reactroot")));
  if (!b)
    for (var c; c = a.lastChild; )
      a.removeChild(c);
  return new qk(a, 0, b ? { hydrate: true } : void 0);
}
function tk(a, b, c, d, e) {
  var f = c._reactRootContainer;
  if (f) {
    var g = f._internalRoot;
    if (typeof e === "function") {
      var h = e;
      e = function() {
        var a2 = mk(g);
        h.call(a2);
      };
    }
    lk(b, g, a, e);
  } else {
    f = c._reactRootContainer = sk(c, d);
    g = f._internalRoot;
    if (typeof e === "function") {
      var k = e;
      e = function() {
        var a2 = mk(g);
        k.call(a2);
      };
    }
    Xj(function() {
      lk(b, g, a, e);
    });
  }
  return mk(g);
}
ec = function(a) {
  if (a.tag === 13) {
    var b = Hg();
    Jg(a, 4, b);
    ok(a, 4);
  }
};
fc = function(a) {
  if (a.tag === 13) {
    var b = Hg();
    Jg(a, 67108864, b);
    ok(a, 67108864);
  }
};
gc = function(a) {
  if (a.tag === 13) {
    var b = Hg(), c = Ig(a);
    Jg(a, c, b);
    ok(a, c);
  }
};
hc = function(a, b) {
  return b();
};
yb = function(a, b, c) {
  switch (b) {
    case "input":
      ab(a, c);
      b = c.name;
      if (c.type === "radio" && b != null) {
        for (c = a; c.parentNode; )
          c = c.parentNode;
        c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');
        for (b = 0; b < c.length; b++) {
          var d = c[b];
          if (d !== a && d.form === a.form) {
            var e = Db(d);
            if (!e)
              throw Error(y(90));
            Wa(d);
            ab(d, e);
          }
        }
      }
      break;
    case "textarea":
      ib(a, c);
      break;
    case "select":
      b = c.value, b != null && fb(a, !!c.multiple, b, false);
  }
};
Gb = Wj;
Hb = function(a, b, c, d, e) {
  var f = X;
  X |= 4;
  try {
    return gg$1(98, a.bind(null, b, c, d, e));
  } finally {
    X = f, X === 0 && (wj(), ig());
  }
};
Ib = function() {
  (X & 49) === 0 && (Vj(), Oj());
};
Jb = function(a, b) {
  var c = X;
  X |= 2;
  try {
    return a(b);
  } finally {
    X = c, X === 0 && (wj(), ig());
  }
};
function uk(a, b) {
  var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!rk(b))
    throw Error(y(200));
  return kk(a, b, null, c);
}
var vk = { Events: [Cb, ue, Db, Eb, Fb, Oj, { current: false }] }, wk = { findFiberByHostInstance: wc, bundleType: 0, version: "17.0.2", rendererPackageName: "react-dom" };
var xk = { bundleType: wk.bundleType, version: wk.version, rendererPackageName: wk.rendererPackageName, rendererConfig: wk.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ra.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
  a = cc(a);
  return a === null ? null : a.stateNode;
}, findFiberByHostInstance: wk.findFiberByHostInstance || pk, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined") {
  var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!yk.isDisabled && yk.supportsFiber)
    try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
reactDom_production_min.createPortal = uk;
reactDom_production_min.findDOMNode = function(a) {
  if (a == null)
    return null;
  if (a.nodeType === 1)
    return a;
  var b = a._reactInternals;
  if (b === void 0) {
    if (typeof a.render === "function")
      throw Error(y(188));
    throw Error(y(268, Object.keys(a)));
  }
  a = cc(b);
  a = a === null ? null : a.stateNode;
  return a;
};
reactDom_production_min.flushSync = function(a, b) {
  var c = X;
  if ((c & 48) !== 0)
    return a(b);
  X |= 1;
  try {
    if (a)
      return gg$1(99, a.bind(null, b));
  } finally {
    X = c, ig();
  }
};
reactDom_production_min.hydrate = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, true, c);
};
reactDom_production_min.render = function(a, b, c) {
  if (!rk(b))
    throw Error(y(200));
  return tk(null, a, b, false, c);
};
reactDom_production_min.unmountComponentAtNode = function(a) {
  if (!rk(a))
    throw Error(y(40));
  return a._reactRootContainer ? (Xj(function() {
    tk(null, null, a, false, function() {
      a._reactRootContainer = null;
      a[ff] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Wj;
reactDom_production_min.unstable_createPortal = function(a, b) {
  return uk(a, b, 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null);
};
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
  if (!rk(c))
    throw Error(y(200));
  if (a == null || a._reactInternals === void 0)
    throw Error(y(38));
  return tk(a, b, c, false, d);
};
reactDom_production_min.version = "17.0.2";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var ReactDOM = reactDom.exports;
var toggleSelection = function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range2) {
        selection.addRange(range2);
      });
    }
    active && active.focus();
  };
};
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format$1(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
function copy$1(text3, options) {
  var debug, message, reselectPrevious, range2, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range2 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text3;
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e) {
      e.stopPropagation();
      if (options.format) {
        e.preventDefault();
        if (typeof e.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format3, text3);
        } else {
          e.clipboardData.clearData();
          e.clipboardData.setData(options.format, text3);
        }
      }
      if (options.onCopy) {
        e.preventDefault();
        options.onCopy(e.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range2.selectNodeContents(mark);
    selection.addRange(range2);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text3);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format$1("message" in options ? options.message : defaultMessage);
      window.prompt(message, text3);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range2);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
var copyToClipboard = copy$1;
const version = "16.3.0";
const versionInfo = Object.freeze({
  major: 16,
  minor: 3,
  patch: 0,
  preReleaseTag: null
});
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
function isPromise$1(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}
function invariant$1(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
const LineRegExp = /\r\n|[\n\r]/g;
function getLocation$1(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match2 of source.body.matchAll(LineRegExp)) {
    typeof match2.index === "number" || invariant$1(false);
    if (match2.index >= position) {
      break;
    }
    lastLineStart = match2.index + match2[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
function printLocation(location) {
  return printSourceLocation(location.source, getLocation$1(location.source, location.start));
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
function toNormalizedArgs(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedArgs(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation$1(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation$1(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
function printError(error2) {
  return error2.toString();
}
function formatError$1(error2) {
  return error2.toJSON();
}
function syntaxError$1(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, void 0, source, [
    position
  ]);
}
class Location$1 {
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
}
class Token$4 {
  constructor(kind2, start2, end2, line, column, value) {
    this.kind = kind2;
    this.start = start2;
    this.end = end2;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
}
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
let OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
let DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));
let Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
function isWhiteSpace$2(code3) {
  return code3 === 9 || code3 === 32;
}
function isDigit$1(code3) {
  return code3 >= 48 && code3 <= 57;
}
function isLetter$1(code3) {
  return code3 >= 97 && code3 <= 122 || code3 >= 65 && code3 <= 90;
}
function isNameStart(code3) {
  return isLetter$1(code3) || code3 === 95;
}
function isNameContinue(code3) {
  return isLetter$1(code3) || isDigit$1(code3) || code3 === 95;
}
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i = 0; i < lines.length; ++i) {
    var _firstNonEmptyLine;
    const line = lines[i];
    const indent2 = leadingWhitespace$1(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
    lastNonEmptyLine = i;
    if (i !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice((_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0, lastNonEmptyLine + 1);
}
function leadingWhitespace$1(str) {
  let i = 0;
  while (i < str.length && isWhiteSpace$2(str.charCodeAt(i))) {
    ++i;
  }
  return i;
}
function isPrintableAsBlockString(value) {
  if (value === "") {
    return true;
  }
  let isEmptyLine = true;
  let hasIndent = false;
  let hasCommonIndent = true;
  let seenNonEmptyLine = false;
  for (let i = 0; i < value.length; ++i) {
    switch (value.codePointAt(i)) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 11:
      case 12:
      case 14:
      case 15:
        return false;
      case 13:
        return false;
      case 10:
        if (isEmptyLine && !seenNonEmptyLine) {
          return false;
        }
        seenNonEmptyLine = true;
        isEmptyLine = true;
        hasIndent = false;
        break;
      case 9:
      case 32:
        hasIndent || (hasIndent = isEmptyLine);
        break;
      default:
        hasCommonIndent && (hasCommonIndent = hasIndent);
        isEmptyLine = false;
    }
  }
  if (isEmptyLine) {
    return false;
  }
  if (hasCommonIndent && seenNonEmptyLine) {
    return false;
  }
  return true;
}
function printBlockString$1(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace$2(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result2 = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace$2(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result2 += "\n";
  }
  result2 += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result2 += "\n";
  }
  return '"""' + result2 + '"""';
}
let TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));
class Lexer {
  constructor(source) {
    const startOfFileToken = new Token$4(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  advance() {
    this.lastToken = this.token;
    const token2 = this.token = this.lookahead();
    return token2;
  }
  lookahead() {
    let token2 = this.token;
    if (token2.kind !== TokenKind.EOF) {
      do {
        if (token2.next) {
          token2 = token2.next;
        } else {
          const nextToken = readNextToken(this, token2.end);
          token2.next = nextToken;
          nextToken.prev = token2;
          token2 = nextToken;
        }
      } while (token2.kind === TokenKind.COMMENT);
    }
    return token2;
  }
}
function isPunctuatorTokenKind(kind2) {
  return kind2 === TokenKind.BANG || kind2 === TokenKind.DOLLAR || kind2 === TokenKind.AMP || kind2 === TokenKind.PAREN_L || kind2 === TokenKind.PAREN_R || kind2 === TokenKind.SPREAD || kind2 === TokenKind.COLON || kind2 === TokenKind.EQUALS || kind2 === TokenKind.AT || kind2 === TokenKind.BRACKET_L || kind2 === TokenKind.BRACKET_R || kind2 === TokenKind.BRACE_L || kind2 === TokenKind.PIPE || kind2 === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code3) {
  return code3 >= 0 && code3 <= 55295 || code3 >= 57344 && code3 <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code3) {
  return code3 >= 55296 && code3 <= 56319;
}
function isTrailingSurrogate(code3) {
  return code3 >= 56320 && code3 <= 57343;
}
function printCodePointAt(lexer, location) {
  const code3 = lexer.source.body.codePointAt(location);
  if (code3 === void 0) {
    return TokenKind.EOF;
  } else if (code3 >= 32 && code3 <= 126) {
    const char = String.fromCodePoint(code3);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code3.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind2, start2, end2, value) {
  const line = lexer.line;
  const col = 1 + start2 - lexer.lineStart;
  return new Token$4(kind2, start2, end2, line, col, value);
}
function readNextToken(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start2;
  while (position < bodyLength) {
    const code3 = body.charCodeAt(position);
    switch (code3) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString$1(lexer, position);
    }
    if (isDigit$1(code3) || code3 === 45) {
      return readNumber$1(lexer, position, code3);
    }
    if (isNameStart(code3)) {
      return readName(lexer, position);
    }
    throw syntaxError$1(lexer.source, position, code3 === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code3) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start2 + 1;
  while (position < bodyLength) {
    const code3 = body.charCodeAt(position);
    if (code3 === 10 || code3 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code3)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.COMMENT, start2, position, body.slice(start2 + 1, position));
}
function readNumber$1(lexer, start2, firstCode) {
  const body = lexer.source.body;
  let position = start2;
  let code3 = firstCode;
  let isFloat = false;
  if (code3 === 45) {
    code3 = body.charCodeAt(++position);
  }
  if (code3 === 48) {
    code3 = body.charCodeAt(++position);
    if (isDigit$1(code3)) {
      throw syntaxError$1(lexer.source, position, `Invalid number, unexpected digit after 0: ${printCodePointAt(lexer, position)}.`);
    }
  } else {
    position = readDigits$1(lexer, position, code3);
    code3 = body.charCodeAt(position);
  }
  if (code3 === 46) {
    isFloat = true;
    code3 = body.charCodeAt(++position);
    position = readDigits$1(lexer, position, code3);
    code3 = body.charCodeAt(position);
  }
  if (code3 === 69 || code3 === 101) {
    isFloat = true;
    code3 = body.charCodeAt(++position);
    if (code3 === 43 || code3 === 45) {
      code3 = body.charCodeAt(++position);
    }
    position = readDigits$1(lexer, position, code3);
    code3 = body.charCodeAt(position);
  }
  if (code3 === 46 || isNameStart(code3)) {
    throw syntaxError$1(lexer.source, position, `Invalid number, expected digit but got: ${printCodePointAt(lexer, position)}.`);
  }
  return createToken(lexer, isFloat ? TokenKind.FLOAT : TokenKind.INT, start2, position, body.slice(start2, position));
}
function readDigits$1(lexer, start2, firstCode) {
  if (!isDigit$1(firstCode)) {
    throw syntaxError$1(lexer.source, start2, `Invalid number, expected digit but got: ${printCodePointAt(lexer, start2)}.`);
  }
  const body = lexer.source.body;
  let position = start2 + 1;
  while (isDigit$1(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString$1(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start2 + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code3 = body.charCodeAt(position);
    if (code3 === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start2, position + 1, value);
    }
    if (code3 === 92) {
      value += body.slice(chunkStart, position);
      const escape3 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape3.value;
      position += escape3.size;
      chunkStart = position;
      continue;
    }
    if (code3 === 10 || code3 === 13) {
      break;
    }
    if (isUnicodeScalarValue(code3)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError$1(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError$1(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code3 = body.charCodeAt(position + size++);
    if (code3 === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code3);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError$1(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + size)}".`);
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code3 = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code3)) {
    return {
      value: String.fromCodePoint(code3),
      size: 6
    };
  }
  if (isLeadingSurrogate(code3)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code3, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError$1(lexer.source, position, `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`);
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code3) {
  return code3 >= 48 && code3 <= 57 ? code3 - 48 : code3 >= 65 && code3 <= 70 ? code3 - 55 : code3 >= 97 && code3 <= 102 ? code3 - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code3 = body.charCodeAt(position + 1);
  switch (code3) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError$1(lexer.source, position, `Invalid character escape sequence: "${body.slice(position, position + 2)}".`);
}
function readBlockString(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start2 + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code3 = body.charCodeAt(position);
    if (code3 === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token2 = createToken(lexer, TokenKind.BLOCK_STRING, start2, position + 3, dedentBlockStringLines(blockLines).join("\n"));
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token2;
    }
    if (code3 === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code3 === 10 || code3 === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code3 === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code3)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError$1(lexer.source, position, `Invalid character within String: ${printCodePointAt(lexer, position)}.`);
    }
  }
  throw syntaxError$1(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start2) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start2 + 1;
  while (position < bodyLength) {
    const code3 = body.charCodeAt(position);
    if (isNameContinue(code3)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(lexer, TokenKind.NAME, start2, position, body.slice(start2, position));
}
const MAX_ARRAY_LENGTH$1 = 10;
const MAX_RECURSIVE_DEPTH$1 = 2;
function inspect$1(value) {
  return formatValue$1(value, []);
}
function formatValue$1(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue$1(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue$1(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable$1(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue$1(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray$1(value, seenValues);
  }
  return formatObject$1(value, seenValues);
}
function isJSONable$1(value) {
  return typeof value.toJSON === "function";
}
function formatObject$1(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {
    return "[" + getObjectTag$1(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue$1(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray$1(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH$1) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH$1, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue$1(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag$1(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
const instanceOf = function instanceOf2(value, constructor) {
  return value instanceof constructor;
};
class Source {
  constructor(body, name2 = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect$1(body)}.`);
    this.body = body;
    this.name = name2;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(false, "line in locationOffset is 1-indexed and must be positive.");
    this.locationOffset.column > 0 || devAssert(false, "column in locationOffset is 1-indexed and must be positive.");
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
}
function isSource(source) {
  return instanceOf(source, Source);
}
function parse$1(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
function parseValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseValueLiteral(false);
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseConstValue(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const value = parser.parseConstValueLiteral();
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  const parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  const type2 = parser.parseTypeReference();
  parser.expectToken(TokenKind.EOF);
  return type2;
}
class Parser {
  constructor(source, options) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
  }
  parseName() {
    const token2 = this.expectToken(TokenKind.NAME);
    return this.node(token2, {
      kind: Kind.NAME,
      value: token2.value
    });
  }
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF)
    });
  }
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError$1(this._lexer.source, this._lexer.token.start, "Unexpected description, descriptions are supported only on type definitions.");
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseOperationDefinition() {
    const start2 = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start2, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name2;
    if (this.peek(TokenKind.NAME)) {
      name2 = this.parseName();
    }
    return this.node(start2, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name: name2,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  parseVariableDefinitions() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
  }
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  parseVariable() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start2, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R)
    });
  }
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  parseField() {
    const start2 = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name2;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name2 = this.parseName();
    } else {
      name2 = nameOrAlias;
    }
    return this.node(start2, {
      kind: Kind.FIELD,
      alias,
      name: name2,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  parseArgument(isConst = false) {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.ARGUMENT,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  parseFragment() {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start2, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentDefinition() {
    var _this$_options;
    const start2 = this._lexer.token;
    this.expectKeyword("fragment");
    if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.allowLegacyFragmentVariables) === true) {
      return this.node(start2, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start2, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  parseValueLiteral(isConst) {
    const token2 = this._lexer.token;
    switch (token2.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this._lexer.advance();
        return this.node(token2, {
          kind: Kind.INT,
          value: token2.value
        });
      case TokenKind.FLOAT:
        this._lexer.advance();
        return this.node(token2, {
          kind: Kind.FLOAT,
          value: token2.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this._lexer.advance();
        switch (token2.value) {
          case "true":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token2, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token2, {
              kind: Kind.NULL
            });
          default:
            return this.node(token2, {
              kind: Kind.ENUM,
              value: token2.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError$1(this._lexer.source, token2.start, `Unexpected variable "$${varName}" in constant value.`);
          } else {
            throw this.unexpected(token2);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token2 = this._lexer.token;
    this._lexer.advance();
    return this.node(token2, {
      kind: Kind.STRING,
      value: token2.value,
      block: token2.kind === TokenKind.BLOCK_STRING
    });
  }
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  parseObjectField(isConst) {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start2, {
      kind: Kind.OBJECT_FIELD,
      name: name2,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  parseDirective(isConst) {
    const start2 = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start2, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  parseTypeReference() {
    const start2 = this._lexer.token;
    let type2;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type2 = this.node(start2, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type2 = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start2, {
        kind: Kind.NON_NULL_TYPE,
        type: type2
      });
    }
    return type2;
  }
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  parseSchemaDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    return this.node(start2, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  parseOperationTypeDefinition() {
    const start2 = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseNamedType();
    return this.node(start2, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type: type2
    });
  }
  parseScalarTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name: name2,
      directives
    });
  }
  parseObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  parseFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
  }
  parseFieldDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name: name2,
      arguments: args,
      type: type2,
      directives
    });
  }
  parseArgumentDefs() {
    return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
  }
  parseInputValueDef() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type2 = this.parseTypeReference();
    let defaultValue2;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue2 = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name: name2,
      type: type2,
      defaultValue: defaultValue2,
      directives
    });
  }
  parseInterfaceTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start2, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      types
    });
  }
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  parseEnumTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      values
    });
  }
  parseEnumValuesDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
  }
  parseEnumValueDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    const name2 = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start2, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name: name2,
      directives
    });
  }
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError$1(this._lexer.source, this._lexer.token.start, `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`);
    }
    return this.parseName();
  }
  parseInputObjectTypeDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name: name2,
      directives,
      fields
    });
  }
  parseInputFieldsDefinition() {
    return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
  }
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  parseSchemaExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  parseScalarTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name: name2,
      directives
    });
  }
  parseObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  parseInterfaceTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name2 = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name: name2,
      interfaces,
      directives,
      fields
    });
  }
  parseUnionTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name: name2,
      directives,
      types
    });
  }
  parseEnumTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name: name2,
      directives,
      values
    });
  }
  parseInputObjectTypeExtension() {
    const start2 = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name2 = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start2, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name: name2,
      directives,
      fields
    });
  }
  parseDirectiveDefinition() {
    const start2 = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name2 = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start2, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name: name2,
      arguments: args,
      repeatable,
      locations
    });
  }
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  parseDirectiveLocation() {
    const start2 = this._lexer.token;
    const name2 = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name2.value)) {
      return name2;
    }
    throw this.unexpected(start2);
  }
  node(startToken, node) {
    var _this$_options2;
    if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.noLocation) !== true) {
      node.loc = new Location$1(startToken, this._lexer.lastToken, this._lexer.source);
    }
    return node;
  }
  peek(kind2) {
    return this._lexer.token.kind === kind2;
  }
  expectToken(kind2) {
    const token2 = this._lexer.token;
    if (token2.kind === kind2) {
      this._lexer.advance();
      return token2;
    }
    throw syntaxError$1(this._lexer.source, token2.start, `Expected ${getTokenKindDesc(kind2)}, found ${getTokenDesc(token2)}.`);
  }
  expectOptionalToken(kind2) {
    const token2 = this._lexer.token;
    if (token2.kind === kind2) {
      this._lexer.advance();
      return true;
    }
    return false;
  }
  expectKeyword(value) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value) {
      this._lexer.advance();
    } else {
      throw syntaxError$1(this._lexer.source, token2.start, `Expected "${value}", found ${getTokenDesc(token2)}.`);
    }
  }
  expectOptionalKeyword(value) {
    const token2 = this._lexer.token;
    if (token2.kind === TokenKind.NAME && token2.value === value) {
      this._lexer.advance();
      return true;
    }
    return false;
  }
  unexpected(atToken) {
    const token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError$1(this._lexer.source, token2.start, `Unexpected ${getTokenDesc(token2)}.`);
  }
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
}
function getTokenDesc(token2) {
  const value = token2.value;
  return getTokenKindDesc(token2.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind2) {
  return isPunctuatorTokenKind(kind2) ? `"${kind2}"` : kind2;
}
const MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x2) => `"${x2}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
function identityFunc(x2) {
  return x2;
}
function keyMap(list3, keyFn) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const item of list3) {
    result2[keyFn(item)] = item;
  }
  return result2;
}
function keyValMap(list3, keyFn, valFn) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const item of list3) {
    result2[keyFn(item)] = valFn(item);
  }
  return result2;
}
function mapValue(map2, fn) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map2)) {
    result2[key] = fn(map2[key], key);
  }
  return result2;
}
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit(aChar) && isDigit(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
const DIGIT_0 = 48;
const DIGIT_9 = 57;
function isDigit(code3) {
  return !isNaN(code3) && DIGIT_0 <= code3 && code3 <= DIGIT_9;
}
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance2 = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance2.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a, b) => {
    const distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a = stringToArray(optionLowerCase);
    let b = this._inputArray;
    if (a.length < b.length) {
      const tmp = a;
      a = b;
      b = tmp;
    }
    const aLength = a.length;
    const bLength = b.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1; i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1; j <= bLength; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
}
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map2[key] = value;
  }
  return map2;
}
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
const BREAK = Object.freeze({});
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind2 of Object.values(Kind)) {
    enterLeaveMap.set(kind2, getEnterLeaveForKind(visitor, kind2));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys = [root2];
  let index = -1;
  let edits = [];
  let node = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result2;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect$1(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result2 = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result2 === BREAK) {
        break;
      }
      if (result2 === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result2 !== void 0) {
        edits.push([key, result2]);
        if (!isLeaving) {
          if (isNode(result2)) {
            node = result2;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result2 === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
function visitInParallel(visitors) {
  const skipping = new Array(visitors.length).fill(null);
  const mergedVisitor = /* @__PURE__ */ Object.create(null);
  for (const kind2 of Object.values(Kind)) {
    let hasVisitor = false;
    const enterList = new Array(visitors.length).fill(void 0);
    const leaveList = new Array(visitors.length).fill(void 0);
    for (let i = 0; i < visitors.length; ++i) {
      const { enter, leave } = getEnterLeaveForKind(visitors[i], kind2);
      hasVisitor || (hasVisitor = enter != null || leave != null);
      enterList[i] = enter;
      leaveList[i] = leave;
    }
    if (!hasVisitor) {
      continue;
    }
    const mergedEnterLeave = {
      enter(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _enterList$i;
            const result2 = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
            if (result2 === false) {
              skipping[i] = node;
            } else if (result2 === BREAK) {
              skipping[i] = BREAK;
            } else if (result2 !== void 0) {
              return result2;
            }
          }
        }
      },
      leave(...args) {
        const node = args[0];
        for (let i = 0; i < visitors.length; i++) {
          if (skipping[i] === null) {
            var _leaveList$i;
            const result2 = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
            if (result2 === BREAK) {
              skipping[i] = BREAK;
            } else if (result2 !== void 0 && result2 !== false) {
              return result2;
            }
          } else if (skipping[i] === node) {
            skipping[i] = null;
          }
        }
      }
    };
    mergedVisitor[kind2] = mergedEnterLeave;
  }
  return mergedVisitor;
}
function getEnterLeaveForKind(visitor, kind2) {
  const kindVisitor = visitor[kind2];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
function getVisitFn(visitor, kind2, isLeaving) {
  const { enter, leave } = getEnterLeaveForKind(visitor, kind2);
  return isLeaving ? leave : enter;
}
function print(ast2) {
  return visit(ast2, printDocASTReducer$1);
}
const MAX_LINE_LENGTH$1 = 80;
const printDocASTReducer$1 = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join$1(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap$1("(", join$1(node.variableDefinitions, ", "), ")");
      const prefix = join$1([
        node.operation,
        join$1([node.name, varDefs]),
        join$1(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue: defaultValue2, directives }) => variable + ": " + type2 + wrap$1(" = ", defaultValue2) + wrap$1(" ", join$1(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block$3(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
      const prefix = wrap$1("", alias, ": ") + name2;
      let argsLine = prefix + wrap$1("(", join$1(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH$1) {
        argsLine = prefix + wrap$1("(\n", indent$4(join$1(args, "\n")), "\n)");
      }
      return join$1([argsLine, join$1(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  FragmentSpread: {
    leave: ({ name: name2, directives }) => "..." + name2 + wrap$1(" ", join$1(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join$1([
      "...",
      wrap$1("on ", typeCondition),
      join$1(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name2}${wrap$1("(", join$1(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap$1("", join$1(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString$1(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join$1(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join$1(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value }) => name2 + ": " + value
  },
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap$1("(", join$1(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap$1("", description, "\n") + join$1(["schema", join$1(directives, " "), block$3(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives }) => wrap$1("", description, "\n") + join$1(["scalar", name2, join$1(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap$1("", description, "\n") + join$1([
      "type",
      name2,
      wrap$1("implements ", join$1(interfaces, " & ")),
      join$1(directives, " "),
      block$3(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives }) => wrap$1("", description, "\n") + name2 + (hasMultilineItems$1(args) ? wrap$1("(\n", indent$4(join$1(args, "\n")), "\n)") : wrap$1("(", join$1(args, ", "), ")")) + ": " + type2 + wrap$1(" ", join$1(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue: defaultValue2, directives }) => wrap$1("", description, "\n") + join$1([name2 + ": " + type2, wrap$1("= ", defaultValue2), join$1(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap$1("", description, "\n") + join$1([
      "interface",
      name2,
      wrap$1("implements ", join$1(interfaces, " & ")),
      join$1(directives, " "),
      block$3(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives, types }) => wrap$1("", description, "\n") + join$1(["union", name2, join$1(directives, " "), wrap$1("= ", join$1(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives, values }) => wrap$1("", description, "\n") + join$1(["enum", name2, join$1(directives, " "), block$3(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives }) => wrap$1("", description, "\n") + join$1([name2, join$1(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives, fields }) => wrap$1("", description, "\n") + join$1(["input", name2, join$1(directives, " "), block$3(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap$1("", description, "\n") + "directive @" + name2 + (hasMultilineItems$1(args) ? wrap$1("(\n", indent$4(join$1(args, "\n")), "\n)") : wrap$1("(", join$1(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join$1(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join$1(["extend schema", join$1(directives, " "), block$3(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives }) => join$1(["extend scalar", name2, join$1(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join$1([
      "extend type",
      name2,
      wrap$1("implements ", join$1(interfaces, " & ")),
      join$1(directives, " "),
      block$3(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join$1([
      "extend interface",
      name2,
      wrap$1("implements ", join$1(interfaces, " & ")),
      join$1(directives, " "),
      block$3(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives, types }) => join$1([
      "extend union",
      name2,
      join$1(directives, " "),
      wrap$1("= ", join$1(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives, values }) => join$1(["extend enum", name2, join$1(directives, " "), block$3(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives, fields }) => join$1(["extend input", name2, join$1(directives, " "), block$3(fields)], " ")
  }
};
function join$1(maybeArray, separator2 = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator2)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block$3(array) {
  return wrap$1("{\n", indent$4(join$1(array, "\n")), "\n}");
}
function wrap$1(start2, maybeString, end2 = "") {
  return maybeString != null && maybeString !== "" ? start2 + maybeString + end2 : "";
}
function indent$4(str) {
  return wrap$1("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems$1(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
var printer = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  print
});
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name2.length; ++i) {
    if (!isNameContinue(name2.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`);
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name2}" does not.`);
  }
  return name2;
}
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function assertType(type2) {
  if (!isType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL type.`);
  }
  return type2;
}
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
function assertScalarType(type2) {
  if (!isScalarType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Scalar type.`);
  }
  return type2;
}
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
function assertObjectType(type2) {
  if (!isObjectType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Object type.`);
  }
  return type2;
}
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
function assertInterfaceType(type2) {
  if (!isInterfaceType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Interface type.`);
  }
  return type2;
}
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
function assertUnionType(type2) {
  if (!isUnionType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Union type.`);
  }
  return type2;
}
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
function assertEnumType(type2) {
  if (!isEnumType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Enum type.`);
  }
  return type2;
}
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
function assertInputObjectType(type2) {
  if (!isInputObjectType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Input Object type.`);
  }
  return type2;
}
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
function assertListType(type2) {
  if (!isListType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL List type.`);
  }
  return type2;
}
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
function assertNonNullType(type2) {
  if (!isNonNullType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL Non-Null type.`);
  }
  return type2;
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function assertInputType(type2) {
  if (!isInputType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL input type.`);
  }
  return type2;
}
function isOutputType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
}
function assertOutputType(type2) {
  if (!isOutputType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL output type.`);
  }
  return type2;
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function assertLeafType(type2) {
  if (!isLeafType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL leaf type.`);
  }
  return type2;
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function assertCompositeType(type2) {
  if (!isCompositeType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL composite type.`);
  }
  return type2;
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
function assertAbstractType(type2) {
  if (!isAbstractType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL abstract type.`);
  }
  return type2;
}
class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect$1(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect$1(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function assertWrappingType(type2) {
  if (!isWrappingType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL wrapping type.`);
  }
  return type2;
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function assertNullableType(type2) {
  if (!isNullableType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL nullable type.`);
  }
  return type2;
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function isNamedType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
}
function assertNamedType(type2) {
  if (!isNamedType(type2)) {
    throw new Error(`Expected ${inspect$1(type2)} to be a GraphQL named type.`);
  }
  return type2;
}
function getNamedType(type2) {
  if (type2) {
    let unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
class GraphQLScalarType {
  constructor(config2) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.specifiedByURL = config2.specifiedByURL;
    this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect$1(config2.specifiedByURL)}.`);
    config2.serialize == null || typeof config2.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config2.parseLiteral) {
      typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLObjectType {
  constructor(config2) {
    var _config$extensionASTN2;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.isTypeOf = config2.isTypeOf;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config2);
    this._interfaces = () => defineInterfaces(config2);
    config2.isTypeOf == null || typeof config2.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, but got: ${inspect$1(config2.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineInterfaces(config2) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config2.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
}
function defineFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config2.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect$1(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config2.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config2) {
  return Object.entries(config2).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
function isRequiredArgument$1(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
class GraphQLInterfaceType {
  constructor(config2) {
    var _config$extensionASTN3;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config2);
    this._interfaces = defineInterfaces.bind(void 0, config2);
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, but got: ${inspect$1(config2.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
class GraphQLUnionType {
  constructor(config2) {
    var _config$extensionASTN4;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config2);
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, but got: ${inspect$1(config2.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineTypes(config2) {
  const types = resolveReadonlyArrayThunk(config2.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`);
  return types;
}
class GraphQLEnumType {
  constructor(config2) {
    var _config$extensionASTN5;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config2.values);
    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
    this._nameLookup = keyMap(this._values, (value) => value.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name2) {
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect$1(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect$1(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), valueNode);
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), valueNode);
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value) => value.name, (value) => ({
      description: value.description,
      value: value.value,
      deprecationReason: value.deprecationReason,
      extensions: value.extensions,
      astNode: value.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect$1(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
class GraphQLInputObjectType {
  constructor(config2) {
    var _config$extensionASTN6;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config2);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
function defineInputFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type2) => schema.isSubType(typeB, type2));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
const GRAPHQL_MAX_INT = 2147483647;
const GRAPHQL_MIN_INT = -2147483648;
const GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num2 = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num2 = Number(coercedValue);
    }
    if (typeof num2 !== "number" || !Number.isInteger(num2)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect$1(coercedValue)}`);
    }
    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect$1(coercedValue));
    }
    return num2;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect$1(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, valueNode);
    }
    const num2 = parseInt(valueNode.value, 10);
    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, valueNode);
    }
    return num2;
  }
});
const GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num2 = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num2 = Number(coercedValue);
    }
    if (typeof num2 !== "number" || !Number.isFinite(num2)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect$1(coercedValue)}`);
    }
    return num2;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect$1(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
const GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect$1(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect$1(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, valueNode);
    }
    return valueNode.value;
  }
});
const GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect$1(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect$1(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, valueNode);
    }
    return valueNode.value;
  }
});
const GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect$1(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect$1(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), valueNode);
    }
    return valueNode.value;
  }
});
const specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function isSpecifiedScalarType(type2) {
  return specifiedScalarTypes.some(({ name: name2 }) => type2.name === name2);
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
function isDirective(directive) {
  return instanceOf(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error(`Expected ${inspect$1(directive)} to be a GraphQL directive.`);
  }
  return directive;
}
class GraphQLDirective {
  constructor(config2) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.locations = config2.locations;
    this.isRepeatable = (_config$isRepeatable = config2.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    Array.isArray(config2.locations) || devAssert(false, `@${config2.name} locations must be an Array.`);
    const args = (_config$args = config2.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(false, `@${config2.name} args must be an object with argument names as keys.`);
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
}
const GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
const GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
const DEFAULT_DEPRECATION_REASON = "No longer supported";
const GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
const GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
const specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective
]);
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(({ name: name2 }) => name2 === directive.name);
}
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
function astFromValue(value, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect$1(serialized)}.`);
  }
  invariant$1(false, "Unexpected input type: " + inspect$1(type2));
}
const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
const __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
const __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
const __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
const __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant$1(false, `Unexpected type: "${inspect$1(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => "description" in type2 ? type2.description : void 0
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values = type2.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values = Object.values(type2.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    }
  })
});
const __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
const __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue: defaultValue2 } = inputValue;
        const valueAST = astFromValue(defaultValue2, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
const __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
let TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
const __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
const SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);
function isIntrospectionType(type2) {
  return introspectionTypes.some(({ name: name2 }) => type2.name === name2);
}
var introspection = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  get TypeKind() {
    return TypeKind;
  },
  __TypeKind,
  SchemaMetaFieldDef,
  TypeMetaFieldDef,
  TypeNameMetaFieldDef,
  introspectionTypes,
  isIntrospectionType
});
function isSchema(schema) {
  return instanceOf(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error(`Expected ${inspect$1(schema)} to be a GraphQL schema.`);
  }
  return schema;
}
class GraphQLSchema {
  constructor(config2) {
    var _config$extensionASTN, _config$directives;
    this.__validationErrors = config2.assumeValid === true ? [] : void 0;
    isObjectLike(config2) || devAssert(false, "Must provide configuration object.");
    !config2.types || Array.isArray(config2.types) || devAssert(false, `"types" must be Array if provided but got: ${inspect$1(config2.types)}.`);
    !config2.directives || Array.isArray(config2.directives) || devAssert(false, `"directives" must be Array if provided but got: ${inspect$1(config2.directives)}.`);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    this._queryType = config2.query;
    this._mutationType = config2.mutation;
    this._subscriptionType = config2.subscription;
    this._directives = (_config$directives = config2.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
    const allReferencedTypes = new Set(config2.types);
    if (config2.types != null) {
      for (const type2 of config2.types) {
        allReferencedTypes.delete(type2);
        collectReferencedTypes(type2, allReferencedTypes);
      }
    }
    if (this._queryType != null) {
      collectReferencedTypes(this._queryType, allReferencedTypes);
    }
    if (this._mutationType != null) {
      collectReferencedTypes(this._mutationType, allReferencedTypes);
    }
    if (this._subscriptionType != null) {
      collectReferencedTypes(this._subscriptionType, allReferencedTypes);
    }
    for (const directive of this._directives) {
      if (isDirective(directive)) {
        for (const arg of directive.args) {
          collectReferencedTypes(arg.type, allReferencedTypes);
        }
      }
    }
    collectReferencedTypes(__Schema, allReferencedTypes);
    this._typeMap = /* @__PURE__ */ Object.create(null);
    this._subTypeMap = /* @__PURE__ */ Object.create(null);
    this._implementationsMap = /* @__PURE__ */ Object.create(null);
    for (const namedType of allReferencedTypes) {
      if (namedType == null) {
        continue;
      }
      const typeName = namedType.name;
      typeName || devAssert(false, "One of the provided types for building the Schema is missing a name.");
      if (this._typeMap[typeName] !== void 0) {
        throw new Error(`Schema must contain uniquely named types but contains multiple types named "${typeName}".`);
      }
      this._typeMap[typeName] = namedType;
      if (isInterfaceType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.interfaces.push(namedType);
          }
        }
      } else if (isObjectType(namedType)) {
        for (const iface of namedType.getInterfaces()) {
          if (isInterfaceType(iface)) {
            let implementations = this._implementationsMap[iface.name];
            if (implementations === void 0) {
              implementations = this._implementationsMap[iface.name] = {
                objects: [],
                interfaces: []
              };
            }
            implementations.objects.push(namedType);
          }
        }
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLSchema";
  }
  getQueryType() {
    return this._queryType;
  }
  getMutationType() {
    return this._mutationType;
  }
  getSubscriptionType() {
    return this._subscriptionType;
  }
  getRootType(operation) {
    switch (operation) {
      case OperationTypeNode.QUERY:
        return this.getQueryType();
      case OperationTypeNode.MUTATION:
        return this.getMutationType();
      case OperationTypeNode.SUBSCRIPTION:
        return this.getSubscriptionType();
    }
  }
  getTypeMap() {
    return this._typeMap;
  }
  getType(name2) {
    return this.getTypeMap()[name2];
  }
  getPossibleTypes(abstractType) {
    return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
  }
  getImplementations(interfaceType) {
    const implementations = this._implementationsMap[interfaceType.name];
    return implementations !== null && implementations !== void 0 ? implementations : {
      objects: [],
      interfaces: []
    };
  }
  isSubType(abstractType, maybeSubType) {
    let map2 = this._subTypeMap[abstractType.name];
    if (map2 === void 0) {
      map2 = /* @__PURE__ */ Object.create(null);
      if (isUnionType(abstractType)) {
        for (const type2 of abstractType.getTypes()) {
          map2[type2.name] = true;
        }
      } else {
        const implementations = this.getImplementations(abstractType);
        for (const type2 of implementations.objects) {
          map2[type2.name] = true;
        }
        for (const type2 of implementations.interfaces) {
          map2[type2.name] = true;
        }
      }
      this._subTypeMap[abstractType.name] = map2;
    }
    return map2[maybeSubType.name] !== void 0;
  }
  getDirectives() {
    return this._directives;
  }
  getDirective(name2) {
    return this.getDirectives().find((directive) => directive.name === name2);
  }
  toConfig() {
    return {
      description: this.description,
      query: this.getQueryType(),
      mutation: this.getMutationType(),
      subscription: this.getSubscriptionType(),
      types: Object.values(this.getTypeMap()),
      directives: this.getDirectives(),
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      assumeValid: this.__validationErrors !== void 0
    };
  }
}
function collectReferencedTypes(type2, typeSet) {
  const namedType = getNamedType(type2);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (const memberType of namedType.getTypes()) {
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (const interfaceType of namedType.getInterfaces()) {
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
        for (const arg of field.args) {
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (const field of Object.values(namedType.getFields())) {
        collectReferencedTypes(field.type, typeSet);
      }
    }
  }
  return typeSet;
}
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  const context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  const errors2 = context.getErrors();
  schema.__validationErrors = errors2;
  return errors2;
}
function assertValidSchema(schema) {
  const errors2 = validateSchema(schema);
  if (errors2.length !== 0) {
    throw new Error(errors2.map((error2) => error2.message).join("\n\n"));
  }
}
class SchemaValidationContext {
  constructor(schema) {
    this._errors = [];
    this.schema = schema;
  }
  reportError(message, nodes) {
    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
    this._errors.push(new GraphQLError(message, _nodes));
  }
  getErrors() {
    return this._errors;
  }
}
function validateRootTypes(context) {
  const schema = context.schema;
  const queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError(`Query root type must be Object type, it cannot be ${inspect$1(queryType)}.`, (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
  }
  const mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError(`Mutation root type must be Object type if provided, it cannot be ${inspect$1(mutationType)}.`, (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError(`Subscription root type must be Object type if provided, it cannot be ${inspect$1(subscriptionType)}.`, (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
}
function getOperationTypeNode(schema, operation) {
  var _flatMap$find;
  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes].flatMap((schemaNode) => {
    var _schemaNode$operation;
    return (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : [];
  }).find((operationNode) => operationNode.operation === operation)) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;
}
function validateDirectives(context) {
  for (const directive of context.schema.getDirectives()) {
    if (!isDirective(directive)) {
      context.reportError(`Expected directive but got: ${inspect$1(directive)}.`, directive === null || directive === void 0 ? void 0 : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (const arg of directive.args) {
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError(`The type of @${directive.name}(${arg.name}:) must be Input Type but got: ${inspect$1(arg.type)}.`, arg.astNode);
      }
      if (isRequiredArgument$1(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError(`Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
        ]);
      }
    }
  }
}
function validateName(context, node) {
  if (node.name.startsWith("__")) {
    context.reportError(`Name "${node.name}" must not begin with "__", which is reserved by GraphQL introspection.`, node.astNode);
  }
}
function validateTypes(context) {
  const validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  const typeMap = context.schema.getTypeMap();
  for (const type2 of Object.values(typeMap)) {
    if (!isNamedType(type2)) {
      context.reportError(`Expected GraphQL named type but got: ${inspect$1(type2)}.`, type2.astNode);
      continue;
    }
    if (!isIntrospectionType(type2)) {
      validateName(context, type2);
    }
    if (isObjectType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isInterfaceType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isUnionType(type2)) {
      validateUnionMembers(context, type2);
    } else if (isEnumType(type2)) {
      validateEnumValues(context, type2);
    } else if (isInputObjectType(type2)) {
      validateInputFields(context, type2);
      validateInputObjectCircularRefs(type2);
    }
  }
}
function validateFields(context, type2) {
  const fields = Object.values(type2.getFields());
  if (fields.length === 0) {
    context.reportError(`Type ${type2.name} must define one or more fields.`, [
      type2.astNode,
      ...type2.extensionASTNodes
    ]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError(`The type of ${type2.name}.${field.name} must be Output Type but got: ${inspect$1(field.type)}.`, (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
    }
    for (const arg of field.args) {
      const argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError(`The type of ${type2.name}.${field.name}(${argName}:) must be Input Type but got: ${inspect$1(arg.type)}.`, (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
      }
      if (isRequiredArgument$1(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError(`Required argument ${type2.name}.${field.name}(${argName}:) cannot be deprecated.`, [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
        ]);
      }
    }
  }
}
function validateInterfaces(context, type2) {
  const ifaceTypeNames = /* @__PURE__ */ Object.create(null);
  for (const iface of type2.getInterfaces()) {
    if (!isInterfaceType(iface)) {
      context.reportError(`Type ${inspect$1(type2)} must only implement Interface types, it cannot implement ${inspect$1(iface)}.`, getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    if (type2 === iface) {
      context.reportError(`Type ${type2.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError(`Type ${type2.name} can only implement ${iface.name} once.`, getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type2, iface);
    validateTypeImplementsInterface(context, type2, iface);
  }
}
function validateTypeImplementsInterface(context, type2, iface) {
  const typeFieldMap = type2.getFields();
  for (const ifaceField of Object.values(iface.getFields())) {
    const fieldName = ifaceField.name;
    const typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError(`Interface field ${iface.name}.${fieldName} expected but ${type2.name} does not provide it.`, [ifaceField.astNode, type2.astNode, ...type2.extensionASTNodes]);
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError(`Interface field ${iface.name}.${fieldName} expects type ${inspect$1(ifaceField.type)} but ${type2.name}.${fieldName} is type ${inspect$1(typeField.type)}.`, [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
      ]);
    }
    for (const ifaceArg of ifaceField.args) {
      const argName = ifaceArg.name;
      const typeArg = typeField.args.find((arg) => arg.name === argName);
      if (!typeArg) {
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type2.name}.${fieldName} does not provide it.`, [ifaceArg.astNode, typeField.astNode]);
        continue;
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError(`Interface field argument ${iface.name}.${fieldName}(${argName}:) expects type ${inspect$1(ifaceArg.type)} but ${type2.name}.${fieldName}(${argName}:) is type ${inspect$1(typeArg.type)}.`, [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
        ]);
      }
    }
    for (const typeArg of typeField.args) {
      const argName = typeArg.name;
      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);
      if (!ifaceArg && isRequiredArgument$1(typeArg)) {
        context.reportError(`Object field ${type2.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`, [typeArg.astNode, ifaceField.astNode]);
      }
    }
  }
}
function validateTypeImplementsAncestors(context, type2, iface) {
  const ifaceInterfaces = type2.getInterfaces();
  for (const transitive of iface.getInterfaces()) {
    if (!ifaceInterfaces.includes(transitive)) {
      context.reportError(transitive === type2 ? `Type ${type2.name} cannot implement ${iface.name} because it would create a circular reference.` : `Type ${type2.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`, [
        ...getAllImplementsInterfaceNodes(iface, transitive),
        ...getAllImplementsInterfaceNodes(type2, iface)
      ]);
    }
  }
}
function validateUnionMembers(context, union2) {
  const memberTypes = union2.getTypes();
  if (memberTypes.length === 0) {
    context.reportError(`Union type ${union2.name} must define one or more member types.`, [union2.astNode, ...union2.extensionASTNodes]);
  }
  const includedTypeNames = /* @__PURE__ */ Object.create(null);
  for (const memberType of memberTypes) {
    if (includedTypeNames[memberType.name]) {
      context.reportError(`Union type ${union2.name} can only include type ${memberType.name} once.`, getUnionMemberTypeNodes(union2, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError(`Union type ${union2.name} can only include Object types, it cannot include ${inspect$1(memberType)}.`, getUnionMemberTypeNodes(union2, String(memberType)));
    }
  }
}
function validateEnumValues(context, enumType) {
  const enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError(`Enum type ${enumType.name} must define one or more values.`, [enumType.astNode, ...enumType.extensionASTNodes]);
  }
  for (const enumValue of enumValues) {
    validateName(context, enumValue);
  }
}
function validateInputFields(context, inputObj) {
  const fields = Object.values(inputObj.getFields());
  if (fields.length === 0) {
    context.reportError(`Input Object type ${inputObj.name} must define one or more fields.`, [inputObj.astNode, ...inputObj.extensionASTNodes]);
  }
  for (const field of fields) {
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError(`The type of ${inputObj.name}.${field.name} must be Input Type but got: ${inspect$1(field.type)}.`, (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError(`Required input field ${inputObj.name}.${field.name} cannot be deprecated.`, [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
      ]);
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  const visitedTypes = /* @__PURE__ */ Object.create(null);
  const fieldPath = [];
  const fieldPathIndexByTypeName = /* @__PURE__ */ Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    const fields = Object.values(inputObj.getFields());
    for (const field of fields) {
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        const fieldType = field.type.ofType;
        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          const cyclePath = fieldPath.slice(cycleIndex);
          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join(".");
          context.reportError(`Cannot reference Input Object "${fieldType.name}" within itself through a series of non-null fields: "${pathStr}".`, cyclePath.map((fieldObj) => fieldObj.astNode));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllImplementsInterfaceNodes(type2, iface) {
  const { astNode, extensionASTNodes } = type2;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((typeNode) => {
    var _typeNode$interfaces;
    return (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : [];
  }).filter((ifaceNode) => ifaceNode.name.value === iface.name);
}
function getUnionMemberTypeNodes(union2, typeName) {
  const { astNode, extensionASTNodes } = union2;
  const nodes = astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes;
  return nodes.flatMap((unionNode) => {
    var _unionNode$types;
    return (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : [];
  }).filter((typeNode) => typeNode.name.value === typeName);
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find((node) => node.name.value === GraphQLDeprecatedDirective.name);
}
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}
class TypeInfo {
  constructor(schema, initialType, getFieldDefFn) {
    this._schema = schema;
    this._typeStack = [];
    this._parentTypeStack = [];
    this._inputTypeStack = [];
    this._fieldDefStack = [];
    this._defaultValueStack = [];
    this._directive = null;
    this._argument = null;
    this._enumValue = null;
    this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef$3;
    if (initialType) {
      if (isInputType(initialType)) {
        this._inputTypeStack.push(initialType);
      }
      if (isCompositeType(initialType)) {
        this._parentTypeStack.push(initialType);
      }
      if (isOutputType(initialType)) {
        this._typeStack.push(initialType);
      }
    }
  }
  get [Symbol.toStringTag]() {
    return "TypeInfo";
  }
  getType() {
    if (this._typeStack.length > 0) {
      return this._typeStack[this._typeStack.length - 1];
    }
  }
  getParentType() {
    if (this._parentTypeStack.length > 0) {
      return this._parentTypeStack[this._parentTypeStack.length - 1];
    }
  }
  getInputType() {
    if (this._inputTypeStack.length > 0) {
      return this._inputTypeStack[this._inputTypeStack.length - 1];
    }
  }
  getParentInputType() {
    if (this._inputTypeStack.length > 1) {
      return this._inputTypeStack[this._inputTypeStack.length - 2];
    }
  }
  getFieldDef() {
    if (this._fieldDefStack.length > 0) {
      return this._fieldDefStack[this._fieldDefStack.length - 1];
    }
  }
  getDefaultValue() {
    if (this._defaultValueStack.length > 0) {
      return this._defaultValueStack[this._defaultValueStack.length - 1];
    }
  }
  getDirective() {
    return this._directive;
  }
  getArgument() {
    return this._argument;
  }
  getEnumValue() {
    return this._enumValue;
  }
  enter(node) {
    const schema = this._schema;
    switch (node.kind) {
      case Kind.SELECTION_SET: {
        const namedType = getNamedType(this.getType());
        this._parentTypeStack.push(isCompositeType(namedType) ? namedType : void 0);
        break;
      }
      case Kind.FIELD: {
        const parentType = this.getParentType();
        let fieldDef;
        let fieldType;
        if (parentType) {
          fieldDef = this._getFieldDef(schema, parentType, node);
          if (fieldDef) {
            fieldType = fieldDef.type;
          }
        }
        this._fieldDefStack.push(fieldDef);
        this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
        break;
      }
      case Kind.DIRECTIVE:
        this._directive = schema.getDirective(node.name.value);
        break;
      case Kind.OPERATION_DEFINITION: {
        const rootType = schema.getRootType(node.operation);
        this._typeStack.push(isObjectType(rootType) ? rootType : void 0);
        break;
      }
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION: {
        const typeConditionAST = node.typeCondition;
        const outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
        this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
        break;
      }
      case Kind.VARIABLE_DEFINITION: {
        const inputType = typeFromAST(schema, node.type);
        this._inputTypeStack.push(isInputType(inputType) ? inputType : void 0);
        break;
      }
      case Kind.ARGUMENT: {
        var _this$getDirective;
        let argDef;
        let argType;
        const fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
        if (fieldOrDirective) {
          argDef = fieldOrDirective.args.find((arg) => arg.name === node.name.value);
          if (argDef) {
            argType = argDef.type;
          }
        }
        this._argument = argDef;
        this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
        break;
      }
      case Kind.LIST: {
        const listType = getNullableType(this.getInputType());
        const itemType = isListType(listType) ? listType.ofType : listType;
        this._defaultValueStack.push(void 0);
        this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
        break;
      }
      case Kind.OBJECT_FIELD: {
        const objectType = getNamedType(this.getInputType());
        let inputFieldType;
        let inputField;
        if (isInputObjectType(objectType)) {
          inputField = objectType.getFields()[node.name.value];
          if (inputField) {
            inputFieldType = inputField.type;
          }
        }
        this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
        this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : void 0);
        break;
      }
      case Kind.ENUM: {
        const enumType = getNamedType(this.getInputType());
        let enumValue;
        if (isEnumType(enumType)) {
          enumValue = enumType.getValue(node.value);
        }
        this._enumValue = enumValue;
        break;
      }
    }
  }
  leave(node) {
    switch (node.kind) {
      case Kind.SELECTION_SET:
        this._parentTypeStack.pop();
        break;
      case Kind.FIELD:
        this._fieldDefStack.pop();
        this._typeStack.pop();
        break;
      case Kind.DIRECTIVE:
        this._directive = null;
        break;
      case Kind.OPERATION_DEFINITION:
      case Kind.INLINE_FRAGMENT:
      case Kind.FRAGMENT_DEFINITION:
        this._typeStack.pop();
        break;
      case Kind.VARIABLE_DEFINITION:
        this._inputTypeStack.pop();
        break;
      case Kind.ARGUMENT:
        this._argument = null;
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.LIST:
      case Kind.OBJECT_FIELD:
        this._defaultValueStack.pop();
        this._inputTypeStack.pop();
        break;
      case Kind.ENUM:
        this._enumValue = null;
        break;
    }
  }
}
function getFieldDef$3(schema, parentType, fieldNode) {
  const name2 = fieldNode.name.value;
  if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name2];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter(...args) {
      const node = args[0];
      typeInfo.enter(node);
      const fn = getEnterLeaveForKind(visitor, node.kind).enter;
      if (fn) {
        const result2 = fn.apply(visitor, args);
        if (result2 !== void 0) {
          typeInfo.leave(node);
          if (isNode(result2)) {
            typeInfo.enter(result2);
          }
        }
        return result2;
      }
    },
    leave(...args) {
      const node = args[0];
      const fn = getEnterLeaveForKind(visitor, node.kind).leave;
      let result2;
      if (fn) {
        result2 = fn.apply(visitor, args);
      }
      typeInfo.leave(node);
      return result2;
    }
  };
}
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isConstValueNode(node) {
  return isValueNode(node) && (node.kind === Kind.LIST ? node.values.some(isConstValueNode) : node.kind === Kind.OBJECT ? node.fields.some((field) => isConstValueNode(field.value)) : node.kind !== Kind.VARIABLE);
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(new GraphQLError(`The ${defName} definition is not executable.`, definition));
        }
      }
      return false;
    }
  };
}
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type2 = context.getParentType();
      if (type2) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema, type2, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(new GraphQLError(`Cannot query field "${fieldName}" on type "${type2.name}".` + suggestion, node));
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type2)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x2) => x2.name);
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    const possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          const typeStr = print(typeCondition);
          context.reportError(new GraphQLError(`Fragment cannot condition on non composite type "${typeStr}".`, typeCondition));
        }
      }
    },
    FragmentDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        const typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError(`Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`, node.typeCondition));
      }
    }
  };
}
function KnownArgumentNamesRule(context) {
  return __spreadProps(__spreadValues({}, KnownArgumentNamesOnDirectivesRule(context)), {
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError(`Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions), argNode));
      }
    }
  });
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError(`Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions), argNode));
          }
        }
      }
      return false;
    }
  };
}
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name2) => name2.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name2 = node.name.value;
      const locations = locationsMap[name2];
      if (!locations) {
        context.reportError(new GraphQLError(`Unknown directive "@${name2}".`, node));
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(new GraphQLError(`Directive "@${name2}" may not be used on ${candidateLocation}.`, node));
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant$1(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant$1(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant$1(false, "Unexpected kind: " + inspect$1(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError(`Unknown fragment "${fragmentName}".`, node.name));
      }
    }
  };
}
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError(`Unknown type "${typeName}".` + didYouMean(suggestedTypes), node));
      }
    }
  };
}
const standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map((type2) => type2.name);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter((definition) => definition.kind === Kind.OPERATION_DEFINITION).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", node));
      }
    }
  };
}
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", node));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", node));
      }
      ++schemaDefinitionsCount;
    }
  };
}
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s) => '"' + s.name.value + '"').join(", ");
        context.reportError(new GraphQLError(`Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."), cyclePath));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`, [node, operation]));
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(operation)) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError(`Fragment "${fragName}" is never used.`, fragmentDef));
          }
        }
      }
    }
  };
}
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`, variableDef));
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return __spreadProps(__spreadValues({}, valueNode), { fields: sortFields(valueNode.fields) });
    case Kind.LIST:
      return __spreadProps(__spreadValues({}, valueNode), { values: valueNode.values.map(sortValueNode) });
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => __spreadProps(__spreadValues({}, fieldNode), {
    value: sortValueNode(fieldNode.value)
  })).sort((fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value));
}
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError(`Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`, fields1.concat(fields2)));
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet);
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (let i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (let j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment);
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(referencedFragmentName, fragmentName, areMutuallyExclusive)) {
      continue;
    }
    comparedFragmentPairs.add(referencedFragmentName, fragmentName, areMutuallyExclusive);
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, referencedFragmentName);
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1);
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, referencedFragmentName2);
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, referencedFragmentName1, fragmentName2);
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1);
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2);
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentName2);
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentName1);
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2);
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i = 0; i < fields.length; i++) {
        for (let j = i + 1; j < fields.length; j++) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields[i], fields[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (stringifyArguments(node1) !== stringifyArguments(node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect$1(type1)}" and "${inspect$1(type2)}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function stringifyArguments(fieldNode) {
  var _fieldNode$arguments;
  const args = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
  const inputObjectWithArgs = {
    kind: Kind.OBJECT,
    fields: args.map((argNode) => ({
      kind: Kind.OBJECT_FIELD,
      name: argNode.name,
      value: argNode.value
    }))
  };
  return print(sortValueNode(inputObjectWithArgs));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
  const result2 = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result2);
  return result2;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
class PairSet {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a, b, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const result2 = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result2 === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result2;
  }
  add(a, b, areMutuallyExclusive) {
    const [key1, key2] = a < b ? [a, b] : [b, a];
    const map2 = this._data.get(key1);
    if (map2 === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map2.set(key2, areMutuallyExclusive);
    }
  }
}
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect$1(parentType);
        const fragTypeStr = inspect$1(fragType);
        context.reportError(new GraphQLError(`Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, node));
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect$1(parentType);
        const fragTypeStr = inspect$1(fragType);
        context.reportError(new GraphQLError(`Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`, node));
      }
    }
  };
}
function getFragmentType(context, name2) {
  const frag = context.getFragment(name2);
  if (frag) {
    const type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, defNode ? [defNode, node] : node));
      }
    } else {
      const allTypeNames = Object.keys(__spreadValues(__spreadValues({}, definedTypes), schema === null || schema === void 0 ? void 0 : schema.getTypeMap()));
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError(`Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes), node.name));
    }
  }
}
const defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant$1(false, "Unexpected type: " + inspect$1(type2));
}
function extensionKindToTypeName(kind2) {
  switch (kind2) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant$1(false, "Unexpected kind: " + inspect$1(kind2));
  }
}
function ProvidedRequiredArgumentsRule(context) {
  return __spreadProps(__spreadValues({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {
    Field: {
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set((_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value));
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument$1(argDef)) {
            const argTypeStr = inspect$1(argDef.type);
            context.reportError(new GraphQLError(`Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`, fieldNode));
          }
        }
      }
    }
  });
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument$1), (arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), (arg) => arg.name.value);
    }
  }
  return {
    Directive: {
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect$1(argDef.type) : print(argDef.type);
              context.reportError(new GraphQLError(`Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`, directiveNode));
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type2 = context.getType();
      const selectionSet = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect$1(type2);
            context.reportError(new GraphQLError(`Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`, selectionSet));
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect$1(type2);
          context.reportError(new GraphQLError(`Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`, node));
        }
      }
    }
  };
}
function printPathArray(path) {
  return path.map((key) => typeof key === "number" ? "[" + key.toString() + "]" : "." + key).join("");
}
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  const flattened = [];
  let curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
function coerceInputValue(inputValue, type2, onError = defaultOnError) {
  return coerceInputValueImpl(inputValue, type2, onError, void 0);
}
function defaultOnError(path, invalidValue, error2) {
  let errorPrefix = "Invalid value " + inspect$1(invalidValue);
  if (path.length > 0) {
    errorPrefix += ` at "value${printPathArray(path)}"`;
  }
  error2.message = errorPrefix + ": " + error2.message;
  throw error2;
}
function coerceInputValueImpl(inputValue, type2, onError, path) {
  if (isNonNullType(type2)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type2.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError(`Expected non-nullable type "${inspect$1(type2)}" not to be null.`));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(inputValue)) {
      return Array.from(inputValue, (itemValue, index) => {
        const itemPath = addPath(path, index, void 0);
        return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
      });
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type2.name}" to be an object.`));
      return;
    }
    const coercedValue = {};
    const fieldDefs = type2.getFields();
    for (const field of Object.values(fieldDefs)) {
      const fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          const typeStr = inspect$1(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError(`Field "${field.name}" of required type "${typeStr}" was not provided.`));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type2.name));
    }
    for (const fieldName of Object.keys(inputValue)) {
      if (!fieldDefs[fieldName]) {
        const suggestions = suggestionList(fieldName, Object.keys(type2.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError(`Field "${fieldName}" is not defined by type "${type2.name}".` + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type2)) {
    let parseResult;
    try {
      parseResult = type2.parseValue(inputValue);
    } catch (error2) {
      if (error2 instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error2);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type2.name}". ` + error2.message, void 0, void 0, void 0, void 0, error2));
      }
      return;
    }
    if (parseResult === void 0) {
      onError(pathToArray(path), inputValue, new GraphQLError(`Expected type "${type2.name}".`));
    }
    return parseResult;
  }
  invariant$1(false, "Unexpected input type: " + inspect$1(type2));
}
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type2.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    let result2;
    try {
      result2 = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result2 === void 0) {
      return;
    }
    return result2;
  }
  invariant$1(false, "Unexpected input type: " + inspect$1(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
function getVariableValues(schema, varDefNodes, inputs, options) {
  const errors2 = [];
  const maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
  try {
    const coerced = coerceVariableValues(schema, varDefNodes, inputs, (error2) => {
      if (maxErrors != null && errors2.length >= maxErrors) {
        throw new GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors2.push(error2);
    });
    if (errors2.length === 0) {
      return {
        coerced
      };
    }
  } catch (error2) {
    errors2.push(error2);
  }
  return {
    errors: errors2
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  const coercedValues = {};
  for (const varDefNode of varDefNodes) {
    const varName = varDefNode.variable.name.value;
    const varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      const varTypeStr = print(varDefNode.type);
      onError(new GraphQLError(`Variable "$${varName}" expected value of type "${varTypeStr}" which cannot be used as an input type.`, varDefNode.type));
      continue;
    }
    if (!hasOwnProperty$1(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        const varTypeStr = inspect$1(varType);
        onError(new GraphQLError(`Variable "$${varName}" of required type "${varTypeStr}" was not provided.`, varDefNode));
      }
      continue;
    }
    const value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      const varTypeStr = inspect$1(varType);
      onError(new GraphQLError(`Variable "$${varName}" of non-null type "${varTypeStr}" must not be null.`, varDefNode));
      continue;
    }
    coercedValues[varName] = coerceInputValue(value, varType, (path, invalidValue, error2) => {
      let prefix = `Variable "$${varName}" got invalid value ` + inspect$1(invalidValue);
      if (path.length > 0) {
        prefix += ` at "${varName}${printPathArray(path)}"`;
      }
      onError(new GraphQLError(prefix + "; " + error2.message, varDefNode, void 0, void 0, void 0, error2.originalError));
    });
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name2 = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(`Argument "${name2}" of required type "${inspect$1(argType)}" was not provided.`, node);
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty$1(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(`Argument "${name2}" of required type "${inspect$1(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`, valueNode);
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(`Argument "${name2}" of non-null type "${inspect$1(argType)}" must not be null.`, valueNode);
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(`Argument "${name2}" has invalid value ${print(valueNode)}.`, valueNode);
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find((directive) => directive.name.value === directiveDef.name);
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty$1(obj, prop2) {
  return Object.prototype.hasOwnProperty.call(obj, prop2);
}
function collectFields$1(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, /* @__PURE__ */ new Set());
  return fields;
}
function collectSubfields$1(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(schema, fragments, variableValues, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode$1(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey$1(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode$1(variableValues, selection) || !doesFragmentConditionMatch$1(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode$1(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch$1(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
}
function shouldIncludeNode$1(variableValues, node) {
  const skip2 = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip2 === null || skip2 === void 0 ? void 0 : skip2.if) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch$1(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey$1(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields$1(schema, fragments, variableValues, subscriptionType, node.selectionSet);
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.", extraFieldSelections));
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(new GraphQLError(operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.", fieldNodes));
            }
          }
        }
      }
    }
  };
}
function groupBy(list3, keyFn) {
  const result2 = /* @__PURE__ */ new Map();
  for (const item of list3) {
    const key = keyFn(item);
    const group = result2.get(key);
    if (group === void 0) {
      result2.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result2;
}
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`Argument "${parentName}(${argName}:)" can only be defined once.`, argNodes.map((node) => node.name)));
      }
    }
    return false;
  }
}
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(new GraphQLError(`There can be only one argument named "${argName}".`, argNodes.map((node) => node.name)));
      }
    }
  }
}
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(new GraphQLError(`Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`, node.name));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError(`There can be only one directive named "@${directiveName}".`, [knownDirectiveNames[directiveName], node.name]));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError(`The directive "@${directiveName}" can only be used once at this location.`, [seenDirectives[directiveName], directive]));
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`, valueDef.name));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError(`Enum value "${typeName}.${valueName}" can only be defined once.`, [valueNames[valueName], valueDef.name]));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`, fieldDef.name));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError(`Field "${typeName}.${fieldName}" can only be defined once.`, [fieldNames[fieldName], fieldDef.name]));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError(`There can be only one fragment named "${fragmentName}".`, [knownFragmentNames[fragmentName], node.name]));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant$1(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError(`There can be only one input field named "${fieldName}".`, [knownNames[fieldName], node.name]));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError(`There can be only one operation named "${operationName.value}".`, [knownOperationNames[operationName.value], operationName]));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError(`Type for ${operation} already defined in the schema. It cannot be redefined.`, operationType));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError(`There can be only one ${operation} type in schema.`, [alreadyDefinedOperationType, operationType]));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(new GraphQLError(`Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`, node.name));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError(`There can be only one type named "${typeName}".`, [
        knownTypeNames[typeName],
        node.name
      ]));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(variableDefinitions, (node) => node.variable.name.value);
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(new GraphQLError(`There can be only one variable named "$${variableName}".`, variableNodes.map((node) => node.variable.name)));
        }
      }
    }
  };
}
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue(node) {
      const type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type2.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect$1(fieldDef.type);
          context.reportError(new GraphQLError(`Field "${type2.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`, node));
        }
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError(`Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions), node));
      }
    },
    NullValue(node) {
      const type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(new GraphQLError(`Expected value of type "${inspect$1(type2)}", found ${print(node)}.`, node));
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    const typeStr = inspect$1(locationType);
    context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, node));
    return;
  }
  try {
    const parseResult = type2.parseLiteral(node, void 0);
    if (parseResult === void 0) {
      const typeStr = inspect$1(locationType);
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}.`, node));
    }
  } catch (error2) {
    const typeStr = inspect$1(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(new GraphQLError(`Expected value of type "${typeStr}", found ${print(node)}; ` + error2.message, node, void 0, void 0, void 0, error2));
    }
  }
}
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 !== void 0 && !isInputType(type2)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(new GraphQLError(`Variable "$${variableName}" cannot be non-input type "${typeName}".`, node.type));
      }
    }
  };
}
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type: type2, defaultValue: defaultValue2 } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type2) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type2, defaultValue2)) {
              const varTypeStr = inspect$1(varType);
              const typeStr = inspect$1(type2);
              context.reportError(new GraphQLError(`Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`, [varDef, node]));
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
const specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule
]);
const specifiedSDLRules$1 = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);
class ASTValidationContext {
  constructor(ast2, onError) {
    this._ast = ast2;
    this._fragments = void 0;
    this._fragmentSpreads = /* @__PURE__ */ new Map();
    this._recursivelyReferencedFragments = /* @__PURE__ */ new Map();
    this._onError = onError;
  }
  get [Symbol.toStringTag]() {
    return "ASTValidationContext";
  }
  reportError(error2) {
    this._onError(error2);
  }
  getDocument() {
    return this._ast;
  }
  getFragment(name2) {
    let fragments;
    if (this._fragments) {
      fragments = this._fragments;
    } else {
      fragments = /* @__PURE__ */ Object.create(null);
      for (const defNode of this.getDocument().definitions) {
        if (defNode.kind === Kind.FRAGMENT_DEFINITION) {
          fragments[defNode.name.value] = defNode;
        }
      }
      this._fragments = fragments;
    }
    return fragments[name2];
  }
  getFragmentSpreads(node) {
    let spreads = this._fragmentSpreads.get(node);
    if (!spreads) {
      spreads = [];
      const setsToVisit = [node];
      let set2;
      while (set2 = setsToVisit.pop()) {
        for (const selection of set2.selections) {
          if (selection.kind === Kind.FRAGMENT_SPREAD) {
            spreads.push(selection);
          } else if (selection.selectionSet) {
            setsToVisit.push(selection.selectionSet);
          }
        }
      }
      this._fragmentSpreads.set(node, spreads);
    }
    return spreads;
  }
  getRecursivelyReferencedFragments(operation) {
    let fragments = this._recursivelyReferencedFragments.get(operation);
    if (!fragments) {
      fragments = [];
      const collectedNames = /* @__PURE__ */ Object.create(null);
      const nodesToVisit = [operation.selectionSet];
      let node;
      while (node = nodesToVisit.pop()) {
        for (const spread of this.getFragmentSpreads(node)) {
          const fragName = spread.name.value;
          if (collectedNames[fragName] !== true) {
            collectedNames[fragName] = true;
            const fragment = this.getFragment(fragName);
            if (fragment) {
              fragments.push(fragment);
              nodesToVisit.push(fragment.selectionSet);
            }
          }
        }
      }
      this._recursivelyReferencedFragments.set(operation, fragments);
    }
    return fragments;
  }
}
class SDLValidationContext extends ASTValidationContext {
  constructor(ast2, schema, onError) {
    super(ast2, onError);
    this._schema = schema;
  }
  get [Symbol.toStringTag]() {
    return "SDLValidationContext";
  }
  getSchema() {
    return this._schema;
  }
}
class ValidationContext extends ASTValidationContext {
  constructor(schema, ast2, typeInfo, onError) {
    super(ast2, onError);
    this._schema = schema;
    this._typeInfo = typeInfo;
    this._variableUsages = /* @__PURE__ */ new Map();
    this._recursiveVariableUsages = /* @__PURE__ */ new Map();
  }
  get [Symbol.toStringTag]() {
    return "ValidationContext";
  }
  getSchema() {
    return this._schema;
  }
  getVariableUsages(node) {
    let usages = this._variableUsages.get(node);
    if (!usages) {
      const newUsages = [];
      const typeInfo = new TypeInfo(this._schema);
      visit(node, visitWithTypeInfo(typeInfo, {
        VariableDefinition: () => false,
        Variable(variable) {
          newUsages.push({
            node: variable,
            type: typeInfo.getInputType(),
            defaultValue: typeInfo.getDefaultValue()
          });
        }
      }));
      usages = newUsages;
      this._variableUsages.set(node, usages);
    }
    return usages;
  }
  getRecursiveVariableUsages(operation) {
    let usages = this._recursiveVariableUsages.get(operation);
    if (!usages) {
      usages = this.getVariableUsages(operation);
      for (const frag of this.getRecursivelyReferencedFragments(operation)) {
        usages = usages.concat(this.getVariableUsages(frag));
      }
      this._recursiveVariableUsages.set(operation, usages);
    }
    return usages;
  }
  getType() {
    return this._typeInfo.getType();
  }
  getParentType() {
    return this._typeInfo.getParentType();
  }
  getInputType() {
    return this._typeInfo.getInputType();
  }
  getParentInputType() {
    return this._typeInfo.getParentInputType();
  }
  getFieldDef() {
    return this._typeInfo.getFieldDef();
  }
  getDirective() {
    return this._typeInfo.getDirective();
  }
  getArgument() {
    return this._typeInfo.getArgument();
  }
  getEnumValue() {
    return this._typeInfo.getEnumValue();
  }
}
function validate(schema, documentAST, rules = specifiedRules, options, typeInfo = new TypeInfo(schema)) {
  var _options$maxErrors;
  const maxErrors = (_options$maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors) !== null && _options$maxErrors !== void 0 ? _options$maxErrors : 100;
  documentAST || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  const abortObj = Object.freeze({});
  const errors2 = [];
  const context = new ValidationContext(schema, documentAST, typeInfo, (error2) => {
    if (errors2.length >= maxErrors) {
      errors2.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors2.push(error2);
  });
  const visitor = visitInParallel(rules.map((rule) => rule(context)));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors2;
}
function validateSDL(documentAST, schemaToExtend, rules = specifiedSDLRules$1) {
  const errors2 = [];
  const context = new SDLValidationContext(documentAST, schemaToExtend, (error2) => {
    errors2.push(error2);
  });
  const visitors = rules.map((rule) => rule(context));
  visit(documentAST, visitInParallel(visitors));
  return errors2;
}
function assertValidSDL(documentAST) {
  const errors2 = validateSDL(documentAST);
  if (errors2.length !== 0) {
    throw new Error(errors2.map((error2) => error2.message).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  const errors2 = validateSDL(documentAST, schema);
  if (errors2.length !== 0) {
    throw new Error(errors2.map((error2) => error2.message).join("\n\n"));
  }
}
function memoize3(fn) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}
function promiseForObject(object) {
  return Promise.all(Object.values(object)).then((resolvedValues) => {
    const resolvedObject = /* @__PURE__ */ Object.create(null);
    for (const [i, key] of Object.keys(object).entries()) {
      resolvedObject[key] = resolvedValues[i];
    }
    return resolvedObject;
  });
}
function promiseReduce(values, callbackFn, initialValue) {
  let accumulator = initialValue;
  for (const value of values) {
    accumulator = isPromise$1(accumulator) ? accumulator.then((resolved) => callbackFn(resolved, value)) : callbackFn(accumulator, value);
  }
  return accumulator;
}
function toError(thrownValue) {
  return thrownValue instanceof Error ? thrownValue : new NonErrorThrown(thrownValue);
}
class NonErrorThrown extends Error {
  constructor(thrownValue) {
    super("Unexpected error value: " + inspect$1(thrownValue));
    this.name = "NonErrorThrown";
    this.thrownValue = thrownValue;
  }
}
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  const originalError = toError(rawOriginalError);
  if (isLocatedGraphQLError(originalError)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);
}
function isLocatedGraphQLError(error2) {
  return Array.isArray(error2.path);
}
const collectSubfields = memoize3((exeContext, returnType, fieldNodes) => collectSubfields$1(exeContext.schema, exeContext.fragments, exeContext.variableValues, returnType, fieldNodes));
function execute(args) {
  arguments.length < 2 || devAssert(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
  const { schema, document: document2, variableValues, rootValue } = args;
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext(args);
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const { operation } = exeContext;
    const result2 = executeOperation(exeContext, operation, rootValue);
    if (isPromise$1(result2)) {
      return result2.then((data) => buildResponse(data, exeContext.errors), (error2) => {
        exeContext.errors.push(error2);
        return buildResponse(null, exeContext.errors);
      });
    }
    return buildResponse(result2, exeContext.errors);
  } catch (error2) {
    exeContext.errors.push(error2);
    return buildResponse(null, exeContext.errors);
  }
}
function executeSync(args) {
  const result2 = execute(args);
  if (isPromise$1(result2)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result2;
}
function buildResponse(data, errors2) {
  return errors2.length === 0 ? {
    data
  } : {
    errors: errors2,
    data
  };
}
function assertValidExecutionArguments(schema, document2, rawVariableValues) {
  document2 || devAssert(false, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(false, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
}
function buildExecutionContext(args) {
  var _definition$name, _operation$variableDe;
  const {
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues: rawVariableValues,
    operationName,
    fieldResolver,
    typeResolver,
    subscribeFieldResolver
  } = args;
  let operation;
  const fragments = /* @__PURE__ */ Object.create(null);
  for (const definition of document2.definitions) {
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [
              new GraphQLError("Must provide operation name if query contains multiple operations.")
            ];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          operation = definition;
        }
        break;
      case Kind.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
    }
  }
  if (!operation) {
    if (operationName != null) {
      return [new GraphQLError(`Unknown operation named "${operationName}".`)];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  const variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  const coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    subscribeFieldResolver: subscribeFieldResolver !== null && subscribeFieldResolver !== void 0 ? subscribeFieldResolver : defaultFieldResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  const rootType = exeContext.schema.getRootType(operation.operation);
  if (rootType == null) {
    throw new GraphQLError(`Schema is not configured to execute ${operation.operation} operation.`, operation);
  }
  const rootFields = collectFields$1(exeContext.schema, exeContext.fragments, exeContext.variableValues, rootType, operation.selectionSet);
  const path = void 0;
  switch (operation.operation) {
    case OperationTypeNode.QUERY:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode.MUTATION:
      return executeFieldsSerially(exeContext, rootType, rootValue, path, rootFields);
    case OperationTypeNode.SUBSCRIPTION:
      return executeFields(exeContext, rootType, rootValue, path, rootFields);
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields) {
  return promiseReduce(fields.entries(), (results, [responseName, fieldNodes]) => {
    const fieldPath = addPath(path, responseName, parentType.name);
    const result2 = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
    if (result2 === void 0) {
      return results;
    }
    if (isPromise$1(result2)) {
      return result2.then((resolvedResult) => {
        results[responseName] = resolvedResult;
        return results;
      });
    }
    results[responseName] = result2;
    return results;
  }, /* @__PURE__ */ Object.create(null));
}
function executeFields(exeContext, parentType, sourceValue, path, fields) {
  const results = /* @__PURE__ */ Object.create(null);
  let containsPromise = false;
  for (const [responseName, fieldNodes] of fields.entries()) {
    const fieldPath = addPath(path, responseName, parentType.name);
    const result2 = executeField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
    if (result2 !== void 0) {
      results[responseName] = result2;
      if (isPromise$1(result2)) {
        containsPromise = true;
      }
    }
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function executeField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  const fieldDef = getFieldDef$2(exeContext.schema, parentType, fieldNodes[0]);
  if (!fieldDef) {
    return;
  }
  const returnType = fieldDef.type;
  const resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  const info2 = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    const args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);
    const contextValue = exeContext.contextValue;
    const result2 = resolveFn(source, args, contextValue, info2);
    let completed;
    if (isPromise$1(result2)) {
      completed = result2.then((resolved) => completeValue(exeContext, returnType, fieldNodes, info2, path, resolved));
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info2, path, result2);
    }
    if (isPromise$1(completed)) {
      return completed.then(void 0, (rawError) => {
        const error2 = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error2, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    const error2 = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error2, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error2, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error2;
  }
  exeContext.errors.push(error2);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info2, path, result2) {
  if (result2 instanceof Error) {
    throw result2;
  }
  if (isNonNullType(returnType)) {
    const completed = completeValue(exeContext, returnType.ofType, fieldNodes, info2, path, result2);
    if (completed === null) {
      throw new Error(`Cannot return null for non-nullable field ${info2.parentType.name}.${info2.fieldName}.`);
    }
    return completed;
  }
  if (result2 == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info2, path, result2);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result2);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info2, path, result2);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info2, path, result2);
  }
  invariant$1(false, "Cannot complete value of unexpected output type: " + inspect$1(returnType));
}
function completeListValue(exeContext, returnType, fieldNodes, info2, path, result2) {
  if (!isIterableObject(result2)) {
    throw new GraphQLError(`Expected Iterable, but did not find one for field "${info2.parentType.name}.${info2.fieldName}".`);
  }
  const itemType = returnType.ofType;
  let containsPromise = false;
  const completedResults = Array.from(result2, (item, index) => {
    const itemPath = addPath(path, index, void 0);
    try {
      let completedItem;
      if (isPromise$1(item)) {
        completedItem = item.then((resolved) => completeValue(exeContext, itemType, fieldNodes, info2, itemPath, resolved));
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info2, itemPath, item);
      }
      if (isPromise$1(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, (rawError) => {
          const error2 = locatedError(rawError, fieldNodes, pathToArray(itemPath));
          return handleFieldError(error2, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      const error2 = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error2, itemType, exeContext);
    }
  });
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result2) {
  const serializedResult = returnType.serialize(result2);
  if (serializedResult == null) {
    throw new Error(`Expected \`${inspect$1(returnType)}.serialize(${inspect$1(result2)})\` to return non-nullable value, returned: ${inspect$1(serializedResult)}`);
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info2, path, result2) {
  var _returnType$resolveTy;
  const resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  const contextValue = exeContext.contextValue;
  const runtimeType = resolveTypeFn(result2, contextValue, info2, returnType);
  if (isPromise$1(runtimeType)) {
    return runtimeType.then((resolvedRuntimeType) => completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info2, result2), fieldNodes, info2, path, result2));
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info2, result2), fieldNodes, info2, path, result2);
}
function ensureValidRuntimeType(runtimeTypeName, exeContext, returnType, fieldNodes, info2, result2) {
  if (runtimeTypeName == null) {
    throw new GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info2.parentType.name}.${info2.fieldName}". Either the "${returnType.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`, fieldNodes);
  }
  if (isObjectType(runtimeTypeName)) {
    throw new GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
  }
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError(`Abstract type "${returnType.name}" must resolve to an Object type at runtime for field "${info2.parentType.name}.${info2.fieldName}" with value ${inspect$1(result2)}, received "${inspect$1(runtimeTypeName)}".`);
  }
  const runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError(`Abstract type "${returnType.name}" was resolved to a type "${runtimeTypeName}" that does not exist inside the schema.`, fieldNodes);
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError(`Abstract type "${returnType.name}" was resolved to a non-object type "${runtimeTypeName}".`, fieldNodes);
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError(`Runtime Object type "${runtimeType.name}" is not a possible type for "${returnType.name}".`, fieldNodes);
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info2, path, result2) {
  const subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
  if (returnType.isTypeOf) {
    const isTypeOf = returnType.isTypeOf(result2, exeContext.contextValue, info2);
    if (isPromise$1(isTypeOf)) {
      return isTypeOf.then((resolvedIsTypeOf) => {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result2, fieldNodes);
        }
        return executeFields(exeContext, returnType, result2, path, subFieldNodes);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result2, fieldNodes);
    }
  }
  return executeFields(exeContext, returnType, result2, path, subFieldNodes);
}
function invalidReturnTypeError(returnType, result2, fieldNodes) {
  return new GraphQLError(`Expected value of type "${returnType.name}" but got: ${inspect$1(result2)}.`, fieldNodes);
}
const defaultTypeResolver = function(value, contextValue, info2, abstractType) {
  if (isObjectLike(value) && typeof value.__typename === "string") {
    return value.__typename;
  }
  const possibleTypes = info2.schema.getPossibleTypes(abstractType);
  const promisedIsTypeOfResults = [];
  for (let i = 0; i < possibleTypes.length; i++) {
    const type2 = possibleTypes[i];
    if (type2.isTypeOf) {
      const isTypeOfResult = type2.isTypeOf(value, contextValue, info2);
      if (isPromise$1(isTypeOfResult)) {
        promisedIsTypeOfResults[i] = isTypeOfResult;
      } else if (isTypeOfResult) {
        return type2.name;
      }
    }
  }
  if (promisedIsTypeOfResults.length) {
    return Promise.all(promisedIsTypeOfResults).then((isTypeOfResults) => {
      for (let i = 0; i < isTypeOfResults.length; i++) {
        if (isTypeOfResults[i]) {
          return possibleTypes[i].name;
        }
      }
    });
  }
};
const defaultFieldResolver = function(source, args, contextValue, info2) {
  if (isObjectLike(source) || typeof source === "function") {
    const property = source[info2.fieldName];
    if (typeof property === "function") {
      return source[info2.fieldName](args, contextValue, info2);
    }
    return property;
  }
};
function getFieldDef$2(schema, parentType, fieldNode) {
  const fieldName = fieldNode.name.value;
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
function graphql$1(args) {
  return new Promise((resolve) => resolve(graphqlImpl(args)));
}
function graphqlSync(args) {
  const result2 = graphqlImpl(args);
  if (isPromise$1(result2)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result2;
}
function graphqlImpl(args) {
  arguments.length < 2 || devAssert(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
  const {
    schema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  } = args;
  const schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  let document2;
  try {
    document2 = parse$1(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  const validationErrors = validate(schema, document2);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute({
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
}
function isAsyncIterable$2(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[Symbol.asyncIterator]) === "function";
}
function mapAsyncIterator$1(iterable, callback) {
  const iterator = iterable[Symbol.asyncIterator]();
  async function mapResult(result2) {
    if (result2.done) {
      return result2;
    }
    try {
      return {
        value: await callback(result2.value),
        done: false
      };
    } catch (error2) {
      if (typeof iterator.return === "function") {
        try {
          await iterator.return();
        } catch (_e) {
        }
      }
      throw error2;
    }
  }
  return {
    async next() {
      return mapResult(await iterator.next());
    },
    async return() {
      return typeof iterator.return === "function" ? mapResult(await iterator.return()) : {
        value: void 0,
        done: true
      };
    },
    async throw(error2) {
      if (typeof iterator.throw === "function") {
        return mapResult(await iterator.throw(error2));
      }
      throw error2;
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function subscribe(args) {
  arguments.length < 2 || devAssert(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
  const {
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    subscribeFieldResolver
  } = args;
  const resultOrStream = await createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
  if (!isAsyncIterable$2(resultOrStream)) {
    return resultOrStream;
  }
  const mapSourceToResponse = (payload) => execute({
    schema,
    document: document2,
    rootValue: payload,
    contextValue,
    variableValues,
    operationName,
    fieldResolver
  });
  return mapAsyncIterator$1(resultOrStream, mapSourceToResponse);
}
async function createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver) {
  assertValidExecutionArguments(schema, document2, variableValues);
  const exeContext = buildExecutionContext({
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    subscribeFieldResolver
  });
  if (!("schema" in exeContext)) {
    return {
      errors: exeContext
    };
  }
  try {
    const eventStream = await executeSubscription(exeContext);
    if (!isAsyncIterable$2(eventStream)) {
      throw new Error(`Subscription field must return Async Iterable. Received: ${inspect$1(eventStream)}.`);
    }
    return eventStream;
  } catch (error2) {
    if (error2 instanceof GraphQLError) {
      return {
        errors: [error2]
      };
    }
    throw error2;
  }
}
async function executeSubscription(exeContext) {
  const { schema, fragments, operation, variableValues, rootValue } = exeContext;
  const rootType = schema.getSubscriptionType();
  if (rootType == null) {
    throw new GraphQLError("Schema is not configured to execute subscription operation.", operation);
  }
  const rootFields = collectFields$1(schema, fragments, variableValues, rootType, operation.selectionSet);
  const [responseName, fieldNodes] = [...rootFields.entries()][0];
  const fieldDef = getFieldDef$2(schema, rootType, fieldNodes[0]);
  if (!fieldDef) {
    const fieldName = fieldNodes[0].name.value;
    throw new GraphQLError(`The subscription field "${fieldName}" is not defined.`, fieldNodes);
  }
  const path = addPath(void 0, responseName, rootType.name);
  const info2 = buildResolveInfo(exeContext, fieldDef, fieldNodes, rootType, path);
  try {
    var _fieldDef$subscribe;
    const args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    const contextValue = exeContext.contextValue;
    const resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.subscribeFieldResolver;
    const eventStream = await resolveFn(rootValue, args, contextValue, info2);
    if (eventStream instanceof Error) {
      throw eventStream;
    }
    return eventStream;
  } catch (error2) {
    throw locatedError(error2, fieldNodes, pathToArray(path));
  }
}
function NoDeprecatedCustomRule(context) {
  return {
    Field(node) {
      const fieldDef = context.getFieldDef();
      const deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        const parentType = context.getParentType();
        parentType != null || invariant$1(false);
        context.reportError(new GraphQLError(`The field ${parentType.name}.${fieldDef.name} is deprecated. ${deprecationReason}`, node));
      }
    },
    Argument(node) {
      const argDef = context.getArgument();
      const deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        const directiveDef = context.getDirective();
        if (directiveDef != null) {
          context.reportError(new GraphQLError(`Directive "@${directiveDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, node));
        } else {
          const parentType = context.getParentType();
          const fieldDef = context.getFieldDef();
          parentType != null && fieldDef != null || invariant$1(false);
          context.reportError(new GraphQLError(`Field "${parentType.name}.${fieldDef.name}" argument "${argDef.name}" is deprecated. ${deprecationReason}`, node));
        }
      }
    },
    ObjectField(node) {
      const inputObjectDef = getNamedType(context.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        const inputFieldDef = inputObjectDef.getFields()[node.name.value];
        const deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context.reportError(new GraphQLError(`The input field ${inputObjectDef.name}.${inputFieldDef.name} is deprecated. ${deprecationReason}`, node));
        }
      }
    },
    EnumValue(node) {
      const enumValueDef = context.getEnumValue();
      const deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        const enumTypeDef = getNamedType(context.getInputType());
        enumTypeDef != null || invariant$1(false);
        context.reportError(new GraphQLError(`The enum value "${enumTypeDef.name}.${enumValueDef.name}" is deprecated. ${deprecationReason}`, node));
      }
    }
  };
}
function NoSchemaIntrospectionCustomRule(context) {
  return {
    Field(node) {
      const type2 = getNamedType(context.getType());
      if (type2 && isIntrospectionType(type2)) {
        context.reportError(new GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${node.name.value}".`, node));
      }
    }
  };
}
function getIntrospectionQuery(options) {
  const optionsWithDefault = __spreadValues({
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false
  }, options);
  const descriptions = optionsWithDefault.descriptions ? "description" : "";
  const specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByURL" : "";
  const directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  const schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  return `
    query IntrospectionQuery {
      __schema {
        ${schemaDescription}
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
        directives {
          name
          ${descriptions}
          ${directiveIsRepeatable}
          locations
          args${inputDeprecation("(includeDeprecated: true)")} {
            ...InputValue
          }
        }
      }
    }

    fragment FullType on __Type {
      kind
      name
      ${descriptions}
      ${specifiedByUrl}
      fields(includeDeprecated: true) {
        name
        ${descriptions}
        args${inputDeprecation("(includeDeprecated: true)")} {
          ...InputValue
        }
        type {
          ...TypeRef
        }
        isDeprecated
        deprecationReason
      }
      inputFields${inputDeprecation("(includeDeprecated: true)")} {
        ...InputValue
      }
      interfaces {
        ...TypeRef
      }
      enumValues(includeDeprecated: true) {
        name
        ${descriptions}
        isDeprecated
        deprecationReason
      }
      possibleTypes {
        ...TypeRef
      }
    }

    fragment InputValue on __InputValue {
      name
      ${descriptions}
      type { ...TypeRef }
      defaultValue
      ${inputDeprecation("isDeprecated")}
      ${inputDeprecation("deprecationReason")}
    }

    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
                ofType {
                  kind
                  name
                  ofType {
                    kind
                    name
                  }
                }
              }
            }
          }
        }
      }
    }
  `;
}
function getOperationAST(documentAST, operationName) {
  let operation = null;
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }
  return operation;
}
var getOperationAST$1 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getOperationAST
});
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    const queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError("Schema does not define the required query root type.", operation);
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    const mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", operation);
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    const subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", operation);
    }
    return subscriptionType;
  }
  throw new GraphQLError("Can only have query, mutation and subscription operations.", operation);
}
function introspectionFromSchema(schema, options) {
  const optionsWithDefaults = __spreadValues({
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true
  }, options);
  const document2 = parse$1(getIntrospectionQuery(optionsWithDefaults));
  const result2 = executeSync({
    schema,
    document: document2
  });
  !result2.errors && result2.data || invariant$1(false);
  return result2.data;
}
function buildClientSchema(introspection2, options) {
  isObjectLike(introspection2) && isObjectLike(introspection2.__schema) || devAssert(false, `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${inspect$1(introspection2)}.`);
  const schemaIntrospection = introspection2.__schema;
  const typeMap = keyValMap(schemaIntrospection.types, (typeIntrospection) => typeIntrospection.name, (typeIntrospection) => buildType(typeIntrospection));
  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  const queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  const mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  const subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  const directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: Object.values(typeMap),
    directives,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      const itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      const nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      const nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    const typeName = typeRef.name;
    if (!typeName) {
      throw new Error(`Unknown type reference: ${inspect$1(typeRef)}.`);
    }
    const type2 = typeMap[typeName];
    if (!type2) {
      throw new Error(`Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`);
    }
    return type2;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type2) {
    if (type2 != null && type2.name != null && type2.kind != null) {
      switch (type2.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type2);
        case TypeKind.OBJECT:
          return buildObjectDef(type2);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type2);
        case TypeKind.UNION:
          return buildUnionDef(type2);
        case TypeKind.ENUM:
          return buildEnumDef(type2);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type2);
      }
    }
    const typeStr = inspect$1(type2);
    throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`);
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByURL: scalarIntrospection.specifiedByURL
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      const implementingIntrospectionStr = inspect$1(implementingIntrospection);
      throw new Error(`Introspection result missing interfaces: ${implementingIntrospectionStr}.`);
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: () => buildImplementationsList(objectIntrospection),
      fields: () => buildFieldDefMap(objectIntrospection)
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: () => buildImplementationsList(interfaceIntrospection),
      fields: () => buildFieldDefMap(interfaceIntrospection)
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      const unionIntrospectionStr = inspect$1(unionIntrospection);
      throw new Error(`Introspection result missing possibleTypes: ${unionIntrospectionStr}.`);
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: () => unionIntrospection.possibleTypes.map(getObjectType)
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      const enumIntrospectionStr = inspect$1(enumIntrospection);
      throw new Error(`Introspection result missing enumValues: ${enumIntrospectionStr}.`);
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(enumIntrospection.enumValues, (valueIntrospection) => valueIntrospection.name, (valueIntrospection) => ({
        description: valueIntrospection.description,
        deprecationReason: valueIntrospection.deprecationReason
      }))
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      const inputObjectIntrospectionStr = inspect$1(inputObjectIntrospection);
      throw new Error(`Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`);
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields)
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error(`Introspection result missing fields: ${inspect$1(typeIntrospection)}.`);
    }
    return keyValMap(typeIntrospection.fields, (fieldIntrospection) => fieldIntrospection.name, buildField);
  }
  function buildField(fieldIntrospection) {
    const type2 = getType(fieldIntrospection.type);
    if (!isOutputType(type2)) {
      const typeStr = inspect$1(type2);
      throw new Error(`Introspection must provide output type for fields, but received: ${typeStr}.`);
    }
    if (!fieldIntrospection.args) {
      const fieldIntrospectionStr = inspect$1(fieldIntrospection);
      throw new Error(`Introspection result missing field args: ${fieldIntrospectionStr}.`);
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type: type2,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(inputValueIntrospections, (inputValue) => inputValue.name, buildInputValue);
  }
  function buildInputValue(inputValueIntrospection) {
    const type2 = getType(inputValueIntrospection.type);
    if (!isInputType(type2)) {
      const typeStr = inspect$1(type2);
      throw new Error(`Introspection must provide input type for arguments, but received: ${typeStr}.`);
    }
    const defaultValue2 = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type2) : void 0;
    return {
      description: inputValueIntrospection.description,
      type: type2,
      defaultValue: defaultValue2,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      const directiveIntrospectionStr = inspect$1(directiveIntrospection);
      throw new Error(`Introspection result missing directive args: ${directiveIntrospectionStr}.`);
    }
    if (!directiveIntrospection.locations) {
      const directiveIntrospectionStr = inspect$1(directiveIntrospection);
      throw new Error(`Introspection result missing directive locations: ${directiveIntrospectionStr}.`);
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  const schemaConfig = schema.toConfig();
  const extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  const typeDefs = [];
  const typeExtensionsMap = /* @__PURE__ */ Object.create(null);
  const directiveDefs = [];
  let schemaDef;
  const schemaExtensions = [];
  for (const def of documentAST.definitions) {
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      const extendedTypeName = def.name.value;
      const existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  const typeMap = /* @__PURE__ */ Object.create(null);
  for (const existingType of schemaConfig.types) {
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (const typeNode of typeDefs) {
    var _stdTypeMap$name;
    const name2 = typeNode.name.value;
    typeMap[name2] = (_stdTypeMap$name = stdTypeMap[name2]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  const operationTypes = __spreadValues(__spreadValues({
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
  return __spreadProps(__spreadValues({
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value
  }, operationTypes), {
    types: Object.values(typeMap),
    directives: [
      ...schemaConfig.directives.map(replaceDirective),
      ...directiveDefs.map(buildDirective)
    ],
    extensions: /* @__PURE__ */ Object.create(null),
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  });
  function replaceType(type2) {
    if (isListType(type2)) {
      return new GraphQLList(replaceType(type2.ofType));
    }
    if (isNonNullType(type2)) {
      return new GraphQLNonNull(replaceType(type2.ofType));
    }
    return replaceNamedType(type2);
  }
  function replaceNamedType(type2) {
    return typeMap[type2.name];
  }
  function replaceDirective(directive) {
    const config2 = directive.toConfig();
    return new GraphQLDirective(__spreadProps(__spreadValues({}, config2), {
      args: mapValue(config2.args, extendArg)
    }));
  }
  function extendNamedType(type2) {
    if (isIntrospectionType(type2) || isSpecifiedScalarType(type2)) {
      return type2;
    }
    if (isScalarType(type2)) {
      return extendScalarType(type2);
    }
    if (isObjectType(type2)) {
      return extendObjectType(type2);
    }
    if (isInterfaceType(type2)) {
      return extendInterfaceType(type2);
    }
    if (isUnionType(type2)) {
      return extendUnionType(type2);
    }
    if (isEnumType(type2)) {
      return extendEnumType(type2);
    }
    if (isInputObjectType(type2)) {
      return extendInputObjectType(type2);
    }
    invariant$1(false, "Unexpected type: " + inspect$1(type2));
  }
  function extendInputObjectType(type2) {
    var _typeExtensionsMap$co;
    const config2 = type2.toConfig();
    const extensions = (_typeExtensionsMap$co = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
      fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, (field) => __spreadProps(__spreadValues({}, field), {
        type: replaceType(field.type)
      }))), buildInputFieldMap(extensions)),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendEnumType(type2) {
    var _typeExtensionsMap$ty;
    const config2 = type2.toConfig();
    const extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
      values: __spreadValues(__spreadValues({}, config2.values), buildEnumValueMap(extensions)),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendScalarType(type2) {
    var _typeExtensionsMap$co2;
    const config2 = type2.toConfig();
    const extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    let specifiedByURL = config2.specifiedByURL;
    for (const extensionNode of extensions) {
      var _getSpecifiedByURL;
      specifiedByURL = (_getSpecifiedByURL = getSpecifiedByURL(extensionNode)) !== null && _getSpecifiedByURL !== void 0 ? _getSpecifiedByURL : specifiedByURL;
    }
    return new GraphQLScalarType(__spreadProps(__spreadValues({}, config2), {
      specifiedByURL,
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendObjectType(type2) {
    var _typeExtensionsMap$co3;
    const config2 = type2.toConfig();
    const extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
      interfaces: () => [
        ...type2.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions)),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendInterfaceType(type2) {
    var _typeExtensionsMap$co4;
    const config2 = type2.toConfig();
    const extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
      interfaces: () => [
        ...type2.getInterfaces().map(replaceNamedType),
        ...buildInterfaces(extensions)
      ],
      fields: () => __spreadValues(__spreadValues({}, mapValue(config2.fields, extendField)), buildFieldMap(extensions)),
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendUnionType(type2) {
    var _typeExtensionsMap$co5;
    const config2 = type2.toConfig();
    const extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config2.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {
      types: () => [
        ...type2.getTypes().map(replaceNamedType),
        ...buildUnionTypes(extensions)
      ],
      extensionASTNodes: config2.extensionASTNodes.concat(extensions)
    }));
  }
  function extendField(field) {
    return __spreadProps(__spreadValues({}, field), {
      type: replaceType(field.type),
      args: field.args && mapValue(field.args, extendArg)
    });
  }
  function extendArg(arg) {
    return __spreadProps(__spreadValues({}, arg), { type: replaceType(arg.type) });
  }
  function getOperationTypes(nodes) {
    const opTypes = {};
    for (const node of nodes) {
      var _node$operationTypes;
      const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
      for (const operationType of operationTypesNodes) {
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    const name2 = node.name.value;
    const type2 = (_stdTypeMap$name2 = stdTypeMap[name2]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name2];
    if (type2 === void 0) {
      throw new Error(`Unknown type: "${name2}".`);
    }
    return type2;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var _node$description;
    return new GraphQLDirective({
      name: node.name.value,
      description: (_node$description = node.description) === null || _node$description === void 0 ? void 0 : _node$description.value,
      locations: node.locations.map(({ value }) => value),
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    const fieldConfigMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields;
      const nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
      for (const field of nodeFields) {
        var _field$description;
        fieldConfigMap[field.name.value] = {
          type: getWrappedType(field.type),
          description: (_field$description = field.description) === null || _field$description === void 0 ? void 0 : _field$description.value,
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    const argsNodes = args !== null && args !== void 0 ? args : [];
    const argConfigMap = /* @__PURE__ */ Object.create(null);
    for (const arg of argsNodes) {
      var _arg$description;
      const type2 = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type: type2,
        description: (_arg$description = arg.description) === null || _arg$description === void 0 ? void 0 : _arg$description.value,
        defaultValue: valueFromAST(arg.defaultValue, type2),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    const inputFieldMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$fields2;
      const fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
      for (const field of fieldsNodes) {
        var _field$description2;
        const type2 = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type: type2,
          description: (_field$description2 = field.description) === null || _field$description2 === void 0 ? void 0 : _field$description2.value,
          defaultValue: valueFromAST(field.defaultValue, type2),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    const enumValueMap = /* @__PURE__ */ Object.create(null);
    for (const node of nodes) {
      var _node$values;
      const valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
      for (const value of valuesNodes) {
        var _value$description;
        enumValueMap[value.name.value] = {
          description: (_value$description = value.description) === null || _value$description === void 0 ? void 0 : _value$description.value,
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    return nodes.flatMap((node) => {
      var _node$interfaces$map, _node$interfaces;
      return (_node$interfaces$map = (_node$interfaces = node.interfaces) === null || _node$interfaces === void 0 ? void 0 : _node$interfaces.map(getNamedType2)) !== null && _node$interfaces$map !== void 0 ? _node$interfaces$map : [];
    });
  }
  function buildUnionTypes(nodes) {
    return nodes.flatMap((node) => {
      var _node$types$map, _node$types;
      return (_node$types$map = (_node$types = node.types) === null || _node$types === void 0 ? void 0 : _node$types.map(getNamedType2)) !== null && _node$types$map !== void 0 ? _node$types$map : [];
    });
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    const name2 = astNode.name.value;
    const extensionASTNodes = (_typeExtensionsMap$na = typeExtensionsMap[name2]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var _astNode$description;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLObjectType({
          name: name2,
          description: (_astNode$description = astNode.description) === null || _astNode$description === void 0 ? void 0 : _astNode$description.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _astNode$description2;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInterfaceType({
          name: name2,
          description: (_astNode$description2 = astNode.description) === null || _astNode$description2 === void 0 ? void 0 : _astNode$description2.value,
          interfaces: () => buildInterfaces(allNodes),
          fields: () => buildFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _astNode$description3;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLEnumType({
          name: name2,
          description: (_astNode$description3 = astNode.description) === null || _astNode$description3 === void 0 ? void 0 : _astNode$description3.value,
          values: buildEnumValueMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _astNode$description4;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLUnionType({
          name: name2,
          description: (_astNode$description4 = astNode.description) === null || _astNode$description4 === void 0 ? void 0 : _astNode$description4.value,
          types: () => buildUnionTypes(allNodes),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _astNode$description5;
        return new GraphQLScalarType({
          name: name2,
          description: (_astNode$description5 = astNode.description) === null || _astNode$description5 === void 0 ? void 0 : _astNode$description5.value,
          specifiedByURL: getSpecifiedByURL(astNode),
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _astNode$description6;
        const allNodes = [astNode, ...extensionASTNodes];
        return new GraphQLInputObjectType({
          name: name2,
          description: (_astNode$description6 = astNode.description) === null || _astNode$description6 === void 0 ? void 0 : _astNode$description6.value,
          fields: () => buildInputFieldMap(allNodes),
          astNode,
          extensionASTNodes
        });
      }
    }
  }
}
const stdTypeMap = keyMap([...specifiedScalarTypes, ...introspectionTypes], (type2) => type2.name);
function getDeprecationReason(node) {
  const deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByURL(node) {
  const specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(false, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  const emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: /* @__PURE__ */ Object.create(null),
    extensionASTNodes: [],
    assumeValid: false
  };
  const config2 = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config2.astNode == null) {
    for (const type2 of config2.types) {
      switch (type2.name) {
        case "Query":
          config2.query = type2;
          break;
        case "Mutation":
          config2.mutation = type2;
          break;
        case "Subscription":
          config2.subscription = type2;
          break;
      }
    }
  }
  const directives = [
    ...config2.directives,
    ...specifiedDirectives.filter((stdDirective) => config2.directives.every((directive) => directive.name !== stdDirective.name))
  ];
  return new GraphQLSchema(__spreadProps(__spreadValues({}, config2), { directives }));
}
function buildSchema(source, options) {
  const document2 = parse$1(source, {
    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
    allowLegacyFragmentVariables: options === null || options === void 0 ? void 0 : options.allowLegacyFragmentVariables
  });
  return buildASTSchema(document2, {
    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
}
function lexicographicSortSchema(schema) {
  const schemaConfig = schema.toConfig();
  const typeMap = keyValMap(sortByName(schemaConfig.types), (type2) => type2.name, sortNamedType);
  return new GraphQLSchema(__spreadProps(__spreadValues({}, schemaConfig), {
    types: Object.values(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  }));
  function replaceType(type2) {
    if (isListType(type2)) {
      return new GraphQLList(replaceType(type2.ofType));
    } else if (isNonNullType(type2)) {
      return new GraphQLNonNull(replaceType(type2.ofType));
    }
    return replaceNamedType(type2);
  }
  function replaceNamedType(type2) {
    return typeMap[type2.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    const config2 = directive.toConfig();
    return new GraphQLDirective(__spreadProps(__spreadValues({}, config2), {
      locations: sortBy(config2.locations, (x2) => x2),
      args: sortArgs(config2.args)
    }));
  }
  function sortArgs(args) {
    return sortObjMap(args, (arg) => __spreadProps(__spreadValues({}, arg), { type: replaceType(arg.type) }));
  }
  function sortFields2(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => __spreadProps(__spreadValues({}, field), {
      type: replaceType(field.type),
      args: field.args && sortArgs(field.args)
    }));
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, (field) => __spreadProps(__spreadValues({}, field), {
      type: replaceType(field.type)
    }));
  }
  function sortTypes(array) {
    return sortByName(array).map(replaceNamedType);
  }
  function sortNamedType(type2) {
    if (isScalarType(type2) || isIntrospectionType(type2)) {
      return type2;
    }
    if (isObjectType(type2)) {
      const config2 = type2.toConfig();
      return new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
        interfaces: () => sortTypes(config2.interfaces),
        fields: () => sortFields2(config2.fields)
      }));
    }
    if (isInterfaceType(type2)) {
      const config2 = type2.toConfig();
      return new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
        interfaces: () => sortTypes(config2.interfaces),
        fields: () => sortFields2(config2.fields)
      }));
    }
    if (isUnionType(type2)) {
      const config2 = type2.toConfig();
      return new GraphQLUnionType(__spreadProps(__spreadValues({}, config2), {
        types: () => sortTypes(config2.types)
      }));
    }
    if (isEnumType(type2)) {
      const config2 = type2.toConfig();
      return new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
        values: sortObjMap(config2.values, (value) => value)
      }));
    }
    if (isInputObjectType(type2)) {
      const config2 = type2.toConfig();
      return new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
        fields: () => sortInputFields(config2.fields)
      }));
    }
    invariant$1(false, "Unexpected type: " + inspect$1(type2));
  }
}
function sortObjMap(map2, sortValueFn) {
  const sortedMap = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map2).sort(naturalCompare)) {
    sortedMap[key] = sortValueFn(map2[key]);
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, (obj) => obj.name);
}
function sortBy(array, mapToKey) {
  return array.slice().sort((obj1, obj2) => {
    const key1 = mapToKey(obj1);
    const key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
function printSchema(schema) {
  return printFilteredSchema(schema, (n2) => !isSpecifiedDirective(n2), isDefinedType);
}
function printIntrospectionSchema(schema) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType);
}
function isDefinedType(type2) {
  return !isSpecifiedScalarType(type2) && !isIntrospectionType(type2);
}
function printFilteredSchema(schema, directiveFilter, typeFilter) {
  const directives = schema.getDirectives().filter(directiveFilter);
  const types = Object.values(schema.getTypeMap()).filter(typeFilter);
  return [
    printSchemaDefinition(schema),
    ...directives.map((directive) => printDirective(directive)),
    ...types.map((type2) => printType(type2))
  ].filter(Boolean).join("\n\n");
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  const operationTypes = [];
  const queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push(`  query: ${queryType.name}`);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push(`  mutation: ${mutationType.name}`);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push(`  subscription: ${subscriptionType.name}`);
  }
  return printDescription(schema) + `schema {
${operationTypes.join("\n")}
}`;
}
function isSchemaOfCommonNames(schema) {
  const queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  const mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type2) {
  if (isScalarType(type2)) {
    return printScalar(type2);
  }
  if (isObjectType(type2)) {
    return printObject(type2);
  }
  if (isInterfaceType(type2)) {
    return printInterface(type2);
  }
  if (isUnionType(type2)) {
    return printUnion(type2);
  }
  if (isEnumType(type2)) {
    return printEnum(type2);
  }
  if (isInputObjectType(type2)) {
    return printInputObject(type2);
  }
  invariant$1(false, "Unexpected type: " + inspect$1(type2));
}
function printScalar(type2) {
  return printDescription(type2) + `scalar ${type2.name}` + printSpecifiedByURL(type2);
}
function printImplementedInterfaces(type2) {
  const interfaces = type2.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map((i) => i.name).join(" & ") : "";
}
function printObject(type2) {
  return printDescription(type2) + `type ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
}
function printInterface(type2) {
  return printDescription(type2) + `interface ${type2.name}` + printImplementedInterfaces(type2) + printFields(type2);
}
function printUnion(type2) {
  const types = type2.getTypes();
  const possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(type2) + "union " + type2.name + possibleTypes;
}
function printEnum(type2) {
  const values = type2.getValues().map((value, i) => printDescription(value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason));
  return printDescription(type2) + `enum ${type2.name}` + printBlock(values);
}
function printInputObject(type2) {
  const fields = Object.values(type2.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + printInputValue(f));
  return printDescription(type2) + `input ${type2.name}` + printBlock(fields);
}
function printFields(type2) {
  const fields = Object.values(type2.getFields()).map((f, i) => printDescription(f, "  ", !i) + "  " + f.name + printArgs(f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason));
  return printBlock(fields);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(args, indentation = "") {
  if (args.length === 0) {
    return "";
  }
  if (args.every((arg) => !arg.description)) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map((arg, i) => printDescription(arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg)).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  const defaultAST = astFromValue(arg.defaultValue, arg.type);
  let argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += ` = ${print(defaultAST)}`;
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive) {
  return printDescription(directive) + "directive @" + directive.name + printArgs(directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  if (reason !== DEFAULT_DEPRECATION_REASON) {
    const astValue = print({
      kind: Kind.STRING,
      value: reason
    });
    return ` @deprecated(reason: ${astValue})`;
  }
  return " @deprecated";
}
function printSpecifiedByURL(scalar) {
  if (scalar.specifiedByURL == null) {
    return "";
  }
  const astValue = print({
    kind: Kind.STRING,
    value: scalar.specifiedByURL
  });
  return ` @specifiedBy(url: ${astValue})`;
}
function printDescription(def, indentation = "", firstInBlock = true) {
  const { description } = def;
  if (description == null) {
    return "";
  }
  const blockString = print({
    kind: Kind.STRING,
    value: description,
    block: isPrintableAsBlockString(description)
  });
  const prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
function concatAST(documents) {
  const definitions = [];
  for (const doc of documents) {
    definitions.push(...doc.definitions);
  }
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
}
function separateOperations(documentAST) {
  const operations = [];
  const depGraph = /* @__PURE__ */ Object.create(null);
  for (const definitionNode of documentAST.definitions) {
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
        break;
    }
  }
  const separatedDocumentASTs = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const dependencies = /* @__PURE__ */ new Set();
    for (const fragmentName of collectDependencies(operation.selectionSet)) {
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    const operationName = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName] = {
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter((node) => node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value))
    };
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    const immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (const toName of immediateDeps) {
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  const dependencies = [];
  visit(selectionSet, {
    FragmentSpread(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
function stripIgnoredCharacters(source) {
  const sourceObj = isSource(source) ? source : new Source(source);
  const body = sourceObj.body;
  const lexer = new Lexer(sourceObj);
  let strippedBody = "";
  let wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    const currentToken = lexer.token;
    const tokenKind = currentToken.kind;
    const isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    const tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += printBlockString$1(currentToken.value, {
        minimize: true
      });
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
function assertValidName(name2) {
  const error2 = isValidNameError(name2);
  if (error2) {
    throw error2;
  }
  return name2;
}
function isValidNameError(name2) {
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.startsWith("__")) {
    return new GraphQLError(`Name "${name2}" must not begin with "__", which is reserved by GraphQL introspection.`);
  }
  try {
    assertName(name2);
  } catch (error2) {
    return error2;
  }
}
let BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
let DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));
function findBreakingChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in BreakingChangeType);
}
function findDangerousChanges(oldSchema, newSchema) {
  return findSchemaChanges(oldSchema, newSchema).filter((change) => change.type in DangerousChangeType);
}
function findSchemaChanges(oldSchema, newSchema) {
  return [
    ...findTypeChanges(oldSchema, newSchema),
    ...findDirectiveChanges(oldSchema, newSchema)
  ];
}
function findDirectiveChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
  for (const oldDirective of directivesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: `${oldDirective.name} was removed.`
    });
  }
  for (const [oldDirective, newDirective] of directivesDiff.persisted) {
    const argsDiff = diff(oldDirective.args, newDirective.args);
    for (const newArg of argsDiff.added) {
      if (isRequiredArgument$1(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: `A required arg ${newArg.name} on directive ${oldDirective.name} was added.`
        });
      }
    }
    for (const oldArg of argsDiff.removed) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: `${oldArg.name} was removed from ${oldDirective.name}.`
      });
    }
    if (oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: `Repeatable flag was removed from ${oldDirective.name}.`
      });
    }
    for (const location of oldDirective.locations) {
      if (!newDirective.locations.includes(location)) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: `${location} was removed from ${oldDirective.name}.`
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  const schemaChanges = [];
  const typesDiff = diff(Object.values(oldSchema.getTypeMap()), Object.values(newSchema.getTypeMap()));
  for (const oldType of typesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? `Standard scalar ${oldType.name} was removed because it is not referenced anymore.` : `${oldType.name} was removed.`
    });
  }
  for (const [oldType, newType] of typesDiff.persisted) {
    if (isEnumType(oldType) && isEnumType(newType)) {
      schemaChanges.push(...findEnumTypeChanges(oldType, newType));
    } else if (isUnionType(oldType) && isUnionType(newType)) {
      schemaChanges.push(...findUnionTypeChanges(oldType, newType));
    } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
      schemaChanges.push(...findInputObjectTypeChanges(oldType, newType));
    } else if (isObjectType(oldType) && isObjectType(newType)) {
      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
    } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
      schemaChanges.push(...findFieldChanges(oldType, newType), ...findImplementedInterfacesChanges(oldType, newType));
    } else if (oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: `${oldType.name} changed from ${typeKindName(oldType)} to ${typeKindName(newType)}.`
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
  for (const newField of fieldsDiff.added) {
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: `A required field ${newField.name} on input type ${oldType.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: `An optional field ${newField.name} on input type ${oldType.name} was added.`
      });
    }
  }
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldField.type, newField.type);
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (const newPossibleType of possibleTypesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: `${newPossibleType.name} was added to union type ${oldType.name}.`
    });
  }
  for (const oldPossibleType of possibleTypesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: `${oldPossibleType.name} was removed from union type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  const schemaChanges = [];
  const valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (const newValue of valuesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: `${newValue.name} was added to enum type ${oldType.name}.`
    });
  }
  for (const oldValue of valuesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: `${oldValue.name} was removed from enum type ${oldType.name}.`
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  const schemaChanges = [];
  const interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (const newInterface of interfacesDiff.added) {
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: `${newInterface.name} added to interfaces implemented by ${oldType.name}.`
    });
  }
  for (const oldInterface of interfacesDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: `${oldType.name} no longer implements interface ${oldInterface.name}.`
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  const schemaChanges = [];
  const fieldsDiff = diff(Object.values(oldType.getFields()), Object.values(newType.getFields()));
  for (const oldField of fieldsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: `${oldType.name}.${oldField.name} was removed.`
    });
  }
  for (const [oldField, newField] of fieldsDiff.persisted) {
    schemaChanges.push(...findArgChanges(oldType, oldField, newField));
    const isSafe = isChangeSafeForObjectOrInterfaceField(oldField.type, newField.type);
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} changed type from ${String(oldField.type)} to ${String(newField.type)}.`
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  const schemaChanges = [];
  const argsDiff = diff(oldField.args, newField.args);
  for (const oldArg of argsDiff.removed) {
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: `${oldType.name}.${oldField.name} arg ${oldArg.name} was removed.`
    });
  }
  for (const [oldArg, newArg] of argsDiff.persisted) {
    const isSafe = isChangeSafeForInputObjectFieldOrFieldArg(oldArg.type, newArg.type);
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed type from ${String(oldArg.type)} to ${String(newArg.type)}.`
      });
    } else if (oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: `${oldType.name}.${oldField.name} arg ${oldArg.name} defaultValue was removed.`
        });
      } else {
        const oldValueStr = stringifyValue(oldArg.defaultValue, oldArg.type);
        const newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: `${oldType.name}.${oldField.name} arg ${oldArg.name} has changed defaultValue from ${oldValueStr} to ${newValueStr}.`
          });
        }
      }
    }
  }
  for (const newArg of argsDiff.added) {
    if (isRequiredArgument$1(newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: `A required arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: `An optional arg ${newArg.name} on ${oldType.name}.${oldField.name} was added.`
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return isNamedType(newType) && oldType.name === newType.name || isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type2) {
  if (isScalarType(type2)) {
    return "a Scalar type";
  }
  if (isObjectType(type2)) {
    return "an Object type";
  }
  if (isInterfaceType(type2)) {
    return "an Interface type";
  }
  if (isUnionType(type2)) {
    return "a Union type";
  }
  if (isEnumType(type2)) {
    return "an Enum type";
  }
  if (isInputObjectType(type2)) {
    return "an Input type";
  }
  invariant$1(false, "Unexpected type: " + inspect$1(type2));
}
function stringifyValue(value, type2) {
  const ast2 = astFromValue(value, type2);
  ast2 != null || invariant$1(false);
  return print(sortValueNode(ast2));
}
function diff(oldArray, newArray) {
  const added = [];
  const removed = [];
  const persisted = [];
  const oldMap = keyMap(oldArray, ({ name: name2 }) => name2);
  const newMap = keyMap(newArray, ({ name: name2 }) => name2);
  for (const oldItem of oldArray) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (const newItem of newArray) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
var graphql = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  version,
  versionInfo,
  graphql: graphql$1,
  graphqlSync,
  resolveObjMapThunk,
  resolveReadonlyArrayThunk,
  GraphQLSchema,
  GraphQLDirective,
  GraphQLScalarType,
  GraphQLObjectType,
  GraphQLInterfaceType,
  GraphQLUnionType,
  GraphQLEnumType,
  GraphQLInputObjectType,
  GraphQLList,
  GraphQLNonNull,
  specifiedScalarTypes,
  GraphQLInt,
  GraphQLFloat,
  GraphQLString,
  GraphQLBoolean,
  GraphQLID,
  GRAPHQL_MAX_INT,
  GRAPHQL_MIN_INT,
  specifiedDirectives,
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  get TypeKind() {
    return TypeKind;
  },
  DEFAULT_DEPRECATION_REASON,
  introspectionTypes,
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind,
  SchemaMetaFieldDef,
  TypeMetaFieldDef,
  TypeNameMetaFieldDef,
  isSchema,
  isDirective,
  isType,
  isScalarType,
  isObjectType,
  isInterfaceType,
  isUnionType,
  isEnumType,
  isInputObjectType,
  isListType,
  isNonNullType,
  isInputType,
  isOutputType,
  isLeafType,
  isCompositeType,
  isAbstractType,
  isWrappingType,
  isNullableType,
  isNamedType,
  isRequiredArgument: isRequiredArgument$1,
  isRequiredInputField,
  isSpecifiedScalarType,
  isIntrospectionType,
  isSpecifiedDirective,
  assertSchema,
  assertDirective,
  assertType,
  assertScalarType,
  assertObjectType,
  assertInterfaceType,
  assertUnionType,
  assertEnumType,
  assertInputObjectType,
  assertListType,
  assertNonNullType,
  assertInputType,
  assertOutputType,
  assertLeafType,
  assertCompositeType,
  assertAbstractType,
  assertWrappingType,
  assertNullableType,
  assertNamedType,
  getNullableType,
  getNamedType,
  validateSchema,
  assertValidSchema,
  assertName,
  assertEnumValueName,
  Token: Token$4,
  Source,
  Location: Location$1,
  get OperationTypeNode() {
    return OperationTypeNode;
  },
  getLocation: getLocation$1,
  printLocation,
  printSourceLocation,
  Lexer,
  get TokenKind() {
    return TokenKind;
  },
  parse: parse$1,
  parseValue,
  parseConstValue,
  parseType,
  print,
  visit,
  visitInParallel,
  getVisitFn,
  getEnterLeaveForKind,
  BREAK,
  get Kind() {
    return Kind;
  },
  get DirectiveLocation() {
    return DirectiveLocation;
  },
  isDefinitionNode,
  isExecutableDefinitionNode,
  isSelectionNode,
  isValueNode,
  isConstValueNode,
  isTypeNode,
  isTypeSystemDefinitionNode,
  isTypeDefinitionNode,
  isTypeSystemExtensionNode,
  isTypeExtensionNode,
  execute,
  executeSync,
  defaultFieldResolver,
  defaultTypeResolver,
  responsePathAsArray: pathToArray,
  getVariableValues,
  getDirectiveValues,
  subscribe,
  createSourceEventStream,
  validate,
  ValidationContext,
  specifiedRules,
  ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule,
  KnownArgumentNamesRule,
  KnownDirectivesRule,
  KnownFragmentNamesRule,
  KnownTypeNamesRule,
  LoneAnonymousOperationRule,
  NoFragmentCyclesRule,
  NoUndefinedVariablesRule,
  NoUnusedFragmentsRule,
  NoUnusedVariablesRule,
  OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule,
  ProvidedRequiredArgumentsRule,
  ScalarLeafsRule,
  SingleFieldSubscriptionsRule,
  UniqueArgumentNamesRule,
  UniqueDirectivesPerLocationRule,
  UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule,
  UniqueOperationNamesRule,
  UniqueVariableNamesRule,
  ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule,
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  PossibleTypeExtensionsRule,
  NoDeprecatedCustomRule,
  NoSchemaIntrospectionCustomRule,
  GraphQLError,
  syntaxError: syntaxError$1,
  locatedError,
  printError,
  formatError: formatError$1,
  getIntrospectionQuery,
  getOperationAST,
  getOperationRootType,
  introspectionFromSchema,
  buildClientSchema,
  buildASTSchema,
  buildSchema,
  extendSchema,
  lexicographicSortSchema,
  printSchema,
  printType,
  printIntrospectionSchema,
  typeFromAST,
  valueFromAST,
  valueFromASTUntyped,
  astFromValue,
  TypeInfo,
  visitWithTypeInfo,
  coerceInputValue,
  concatAST,
  separateOperations,
  stripIgnoredCharacters,
  isEqualType,
  isTypeSubTypeOf,
  doTypesOverlap,
  assertValidName,
  isValidNameError,
  get BreakingChangeType() {
    return BreakingChangeType;
  },
  get DangerousChangeType() {
    return DangerousChangeType;
  },
  findBreakingChanges,
  findDangerousChanges
});
function getDefinitionState(tokenState) {
  let definitionState;
  forEachState$2(tokenState, (state) => {
    switch (state.kind) {
      case "Query":
      case "ShortQuery":
      case "Mutation":
      case "Subscription":
      case "FragmentDefinition":
        definitionState = state;
        break;
    }
  });
  return definitionState;
}
function getFieldDef$1(schema, type2, fieldName) {
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type2) {
    return SchemaMetaFieldDef;
  }
  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type2) {
    return TypeMetaFieldDef;
  }
  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type2)) {
    return TypeNameMetaFieldDef;
  }
  if ("getFields" in type2) {
    return type2.getFields()[fieldName];
  }
  return null;
}
function forEachState$2(stack, fn) {
  const reverseStateStack = [];
  let state = stack;
  while (state && state.kind) {
    reverseStateStack.push(state);
    state = state.prevState;
  }
  for (let i = reverseStateStack.length - 1; i >= 0; i--) {
    fn(reverseStateStack[i]);
  }
}
function objectValues(object) {
  const keys = Object.keys(object);
  const len = keys.length;
  const values = new Array(len);
  for (let i = 0; i < len; ++i) {
    values[i] = object[keys[i]];
  }
  return values;
}
function hintList$2(token2, list3) {
  return filterAndSortList$1(list3, normalizeText$1(token2.string));
}
function filterAndSortList$1(list3, text3) {
  if (!text3) {
    return filterNonEmpty$1(list3, (entry) => !entry.isDeprecated);
  }
  const byProximity = list3.map((entry) => ({
    proximity: getProximity$1(normalizeText$1(entry.label), text3),
    entry
  }));
  return filterNonEmpty$1(filterNonEmpty$1(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);
}
function filterNonEmpty$1(array, predicate) {
  const filtered = array.filter(predicate);
  return filtered.length === 0 ? array : filtered;
}
function normalizeText$1(text3) {
  return text3.toLowerCase().replace(/\W/g, "");
}
function getProximity$1(suggestion, text3) {
  let proximity = lexicalDistance$1(text3, suggestion);
  if (suggestion.length > text3.length) {
    proximity -= suggestion.length - text3.length - 1;
    proximity += suggestion.indexOf(text3) === 0 ? 0 : 0.5;
  }
  return proximity;
}
function lexicalDistance$1(a, b) {
  let i;
  let j;
  const d = [];
  const aLength = a.length;
  const bLength = b.length;
  for (i = 0; i <= aLength; i++) {
    d[i] = [i];
  }
  for (j = 1; j <= bLength; j++) {
    d[0][j] = j;
  }
  for (i = 1; i <= aLength; i++) {
    for (j = 1; j <= bLength; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }
  return d[aLength][bLength];
}
var integer;
(function(integer2) {
  integer2.MIN_VALUE = -2147483648;
  integer2.MAX_VALUE = 2147483647;
})(integer || (integer = {}));
var uinteger;
(function(uinteger2) {
  uinteger2.MIN_VALUE = 0;
  uinteger2.MAX_VALUE = 2147483647;
})(uinteger || (uinteger = {}));
var Position$1;
(function(Position2) {
  function create(line, character) {
    if (line === Number.MAX_VALUE) {
      line = uinteger.MAX_VALUE;
    }
    if (character === Number.MAX_VALUE) {
      character = uinteger.MAX_VALUE;
    }
    return { line, character };
  }
  Position2.create = create;
  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
  }
  Position2.is = is;
})(Position$1 || (Position$1 = {}));
var Range$1;
(function(Range2) {
  function create(one, two, three, four) {
    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
      return { start: Position$1.create(one, two), end: Position$1.create(three, four) };
    } else if (Position$1.is(one) && Position$1.is(two)) {
      return { start: one, end: two };
    } else {
      throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
    }
  }
  Range2.create = create;
  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Position$1.is(candidate.start) && Position$1.is(candidate.end);
  }
  Range2.is = is;
})(Range$1 || (Range$1 = {}));
var Location;
(function(Location2) {
  function create(uri, range2) {
    return { uri, range: range2 };
  }
  Location2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range$1.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
  }
  Location2.is = is;
})(Location || (Location = {}));
var LocationLink;
(function(LocationLink2) {
  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
  }
  LocationLink2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range$1.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range$1.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range$1.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
  }
  LocationLink2.is = is;
})(LocationLink || (LocationLink = {}));
var Color;
(function(Color2) {
  function create(red, green, blue, alpha2) {
    return {
      red,
      green,
      blue,
      alpha: alpha2
    };
  }
  Color2.create = create;
  function is(value) {
    var candidate = value;
    return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
  }
  Color2.is = is;
})(Color || (Color = {}));
var ColorInformation;
(function(ColorInformation2) {
  function create(range2, color) {
    return {
      range: range2,
      color
    };
  }
  ColorInformation2.create = create;
  function is(value) {
    var candidate = value;
    return Range$1.is(candidate.range) && Color.is(candidate.color);
  }
  ColorInformation2.is = is;
})(ColorInformation || (ColorInformation = {}));
var ColorPresentation;
(function(ColorPresentation2) {
  function create(label, textEdit, additionalTextEdits) {
    return {
      label,
      textEdit,
      additionalTextEdits
    };
  }
  ColorPresentation2.create = create;
  function is(value) {
    var candidate = value;
    return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
  }
  ColorPresentation2.is = is;
})(ColorPresentation || (ColorPresentation = {}));
var FoldingRangeKind;
(function(FoldingRangeKind2) {
  FoldingRangeKind2["Comment"] = "comment";
  FoldingRangeKind2["Imports"] = "imports";
  FoldingRangeKind2["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
var FoldingRange;
(function(FoldingRange2) {
  function create(startLine, endLine, startCharacter, endCharacter, kind2) {
    var result2 = {
      startLine,
      endLine
    };
    if (Is.defined(startCharacter)) {
      result2.startCharacter = startCharacter;
    }
    if (Is.defined(endCharacter)) {
      result2.endCharacter = endCharacter;
    }
    if (Is.defined(kind2)) {
      result2.kind = kind2;
    }
    return result2;
  }
  FoldingRange2.create = create;
  function is(value) {
    var candidate = value;
    return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
  }
  FoldingRange2.is = is;
})(FoldingRange || (FoldingRange = {}));
var DiagnosticRelatedInformation;
(function(DiagnosticRelatedInformation2) {
  function create(location, message) {
    return {
      location,
      message
    };
  }
  DiagnosticRelatedInformation2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
  }
  DiagnosticRelatedInformation2.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity2) {
  DiagnosticSeverity2.Error = 1;
  DiagnosticSeverity2.Warning = 2;
  DiagnosticSeverity2.Information = 3;
  DiagnosticSeverity2.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticTag;
(function(DiagnosticTag2) {
  DiagnosticTag2.Unnecessary = 1;
  DiagnosticTag2.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
var CodeDescription;
(function(CodeDescription2) {
  function is(value) {
    var candidate = value;
    return candidate !== void 0 && candidate !== null && Is.string(candidate.href);
  }
  CodeDescription2.is = is;
})(CodeDescription || (CodeDescription = {}));
var Diagnostic;
(function(Diagnostic2) {
  function create(range2, message, severity, code3, source, relatedInformation) {
    var result2 = { range: range2, message };
    if (Is.defined(severity)) {
      result2.severity = severity;
    }
    if (Is.defined(code3)) {
      result2.code = code3;
    }
    if (Is.defined(source)) {
      result2.source = source;
    }
    if (Is.defined(relatedInformation)) {
      result2.relatedInformation = relatedInformation;
    }
    return result2;
  }
  Diagnostic2.create = create;
  function is(value) {
    var _a2;
    var candidate = value;
    return Is.defined(candidate) && Range$1.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
  }
  Diagnostic2.is = is;
})(Diagnostic || (Diagnostic = {}));
var Command;
(function(Command2) {
  function create(title, command) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var result2 = { title, command };
    if (Is.defined(args) && args.length > 0) {
      result2.arguments = args;
    }
    return result2;
  }
  Command2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
  }
  Command2.is = is;
})(Command || (Command = {}));
var TextEdit;
(function(TextEdit2) {
  function replace2(range2, newText) {
    return { range: range2, newText };
  }
  TextEdit2.replace = replace2;
  function insert(position, newText) {
    return { range: { start: position, end: position }, newText };
  }
  TextEdit2.insert = insert;
  function del(range2) {
    return { range: range2, newText: "" };
  }
  TextEdit2.del = del;
  function is(value) {
    var candidate = value;
    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range$1.is(candidate.range);
  }
  TextEdit2.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function(ChangeAnnotation2) {
  function create(label, needsConfirmation, description) {
    var result2 = { label };
    if (needsConfirmation !== void 0) {
      result2.needsConfirmation = needsConfirmation;
    }
    if (description !== void 0) {
      result2.description = description;
    }
    return result2;
  }
  ChangeAnnotation2.create = create;
  function is(value) {
    var candidate = value;
    return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  ChangeAnnotation2.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function(ChangeAnnotationIdentifier2) {
  function is(value) {
    var candidate = value;
    return typeof candidate === "string";
  }
  ChangeAnnotationIdentifier2.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function(AnnotatedTextEdit2) {
  function replace2(range2, newText, annotation) {
    return { range: range2, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.replace = replace2;
  function insert(position, newText, annotation) {
    return { range: { start: position, end: position }, newText, annotationId: annotation };
  }
  AnnotatedTextEdit2.insert = insert;
  function del(range2, annotation) {
    return { range: range2, newText: "", annotationId: annotation };
  }
  AnnotatedTextEdit2.del = del;
  function is(value) {
    var candidate = value;
    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  AnnotatedTextEdit2.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
var TextDocumentEdit;
(function(TextDocumentEdit2) {
  function create(textDocument, edits) {
    return { textDocument, edits };
  }
  TextDocumentEdit2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
  }
  TextDocumentEdit2.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function(CreateFile2) {
  function create(uri, options, annotation) {
    var result2 = {
      kind: "create",
      uri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result2.options = options;
    }
    if (annotation !== void 0) {
      result2.annotationId = annotation;
    }
    return result2;
  }
  CreateFile2.create = create;
  function is(value) {
    var candidate = value;
    return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  CreateFile2.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function(RenameFile2) {
  function create(oldUri, newUri, options, annotation) {
    var result2 = {
      kind: "rename",
      oldUri,
      newUri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result2.options = options;
    }
    if (annotation !== void 0) {
      result2.annotationId = annotation;
    }
    return result2;
  }
  RenameFile2.create = create;
  function is(value) {
    var candidate = value;
    return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  RenameFile2.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function(DeleteFile2) {
  function create(uri, options, annotation) {
    var result2 = {
      kind: "delete",
      uri
    };
    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
      result2.options = options;
    }
    if (annotation !== void 0) {
      result2.annotationId = annotation;
    }
    return result2;
  }
  DeleteFile2.create = create;
  function is(value) {
    var candidate = value;
    return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  DeleteFile2.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function(WorkspaceEdit2) {
  function is(value) {
    var candidate = value;
    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
      if (Is.string(change.kind)) {
        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
      } else {
        return TextDocumentEdit.is(change);
      }
    }));
  }
  WorkspaceEdit2.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = function() {
  function TextEditChangeImpl2(edits, changeAnnotations) {
    this.edits = edits;
    this.changeAnnotations = changeAnnotations;
  }
  TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
    var edit;
    var id2;
    if (annotation === void 0) {
      edit = TextEdit.insert(position, newText);
    } else if (ChangeAnnotationIdentifier.is(annotation)) {
      id2 = annotation;
      edit = AnnotatedTextEdit.insert(position, newText, annotation);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      id2 = this.changeAnnotations.manage(annotation);
      edit = AnnotatedTextEdit.insert(position, newText, id2);
    }
    this.edits.push(edit);
    if (id2 !== void 0) {
      return id2;
    }
  };
  TextEditChangeImpl2.prototype.replace = function(range2, newText, annotation) {
    var edit;
    var id2;
    if (annotation === void 0) {
      edit = TextEdit.replace(range2, newText);
    } else if (ChangeAnnotationIdentifier.is(annotation)) {
      id2 = annotation;
      edit = AnnotatedTextEdit.replace(range2, newText, annotation);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      id2 = this.changeAnnotations.manage(annotation);
      edit = AnnotatedTextEdit.replace(range2, newText, id2);
    }
    this.edits.push(edit);
    if (id2 !== void 0) {
      return id2;
    }
  };
  TextEditChangeImpl2.prototype.delete = function(range2, annotation) {
    var edit;
    var id2;
    if (annotation === void 0) {
      edit = TextEdit.del(range2);
    } else if (ChangeAnnotationIdentifier.is(annotation)) {
      id2 = annotation;
      edit = AnnotatedTextEdit.del(range2, annotation);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      id2 = this.changeAnnotations.manage(annotation);
      edit = AnnotatedTextEdit.del(range2, id2);
    }
    this.edits.push(edit);
    if (id2 !== void 0) {
      return id2;
    }
  };
  TextEditChangeImpl2.prototype.add = function(edit) {
    this.edits.push(edit);
  };
  TextEditChangeImpl2.prototype.all = function() {
    return this.edits;
  };
  TextEditChangeImpl2.prototype.clear = function() {
    this.edits.splice(0, this.edits.length);
  };
  TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
    if (value === void 0) {
      throw new Error("Text edit change is not configured to manage change annotations.");
    }
  };
  return TextEditChangeImpl2;
}();
var ChangeAnnotations = function() {
  function ChangeAnnotations2(annotations2) {
    this._annotations = annotations2 === void 0 ? /* @__PURE__ */ Object.create(null) : annotations2;
    this._counter = 0;
    this._size = 0;
  }
  ChangeAnnotations2.prototype.all = function() {
    return this._annotations;
  };
  Object.defineProperty(ChangeAnnotations2.prototype, "size", {
    get: function() {
      return this._size;
    },
    enumerable: false,
    configurable: true
  });
  ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
    var id2;
    if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
      id2 = idOrAnnotation;
    } else {
      id2 = this.nextId();
      annotation = idOrAnnotation;
    }
    if (this._annotations[id2] !== void 0) {
      throw new Error("Id " + id2 + " is already in use.");
    }
    if (annotation === void 0) {
      throw new Error("No annotation provided for id " + id2);
    }
    this._annotations[id2] = annotation;
    this._size++;
    return id2;
  };
  ChangeAnnotations2.prototype.nextId = function() {
    this._counter++;
    return this._counter.toString();
  };
  return ChangeAnnotations2;
}();
(function() {
  function WorkspaceChange(workspaceEdit) {
    var _this = this;
    this._textEditChanges = /* @__PURE__ */ Object.create(null);
    if (workspaceEdit !== void 0) {
      this._workspaceEdit = workspaceEdit;
      if (workspaceEdit.documentChanges) {
        this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
        workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        workspaceEdit.documentChanges.forEach(function(change) {
          if (TextDocumentEdit.is(change)) {
            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
            _this._textEditChanges[change.textDocument.uri] = textEditChange;
          }
        });
      } else if (workspaceEdit.changes) {
        Object.keys(workspaceEdit.changes).forEach(function(key) {
          var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
          _this._textEditChanges[key] = textEditChange;
        });
      }
    } else {
      this._workspaceEdit = {};
    }
  }
  Object.defineProperty(WorkspaceChange.prototype, "edit", {
    get: function() {
      this.initDocumentChanges();
      if (this._changeAnnotations !== void 0) {
        if (this._changeAnnotations.size === 0) {
          this._workspaceEdit.changeAnnotations = void 0;
        } else {
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      return this._workspaceEdit;
    },
    enumerable: false,
    configurable: true
  });
  WorkspaceChange.prototype.getTextEditChange = function(key) {
    if (OptionalVersionedTextDocumentIdentifier.is(key)) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var textDocument = { uri: key.uri, version: key.version };
      var result2 = this._textEditChanges[textDocument.uri];
      if (!result2) {
        var edits = [];
        var textDocumentEdit = {
          textDocument,
          edits
        };
        this._workspaceEdit.documentChanges.push(textDocumentEdit);
        result2 = new TextEditChangeImpl(edits, this._changeAnnotations);
        this._textEditChanges[textDocument.uri] = result2;
      }
      return result2;
    } else {
      this.initChanges();
      if (this._workspaceEdit.changes === void 0) {
        throw new Error("Workspace edit is not configured for normal text edit changes.");
      }
      var result2 = this._textEditChanges[key];
      if (!result2) {
        var edits = [];
        this._workspaceEdit.changes[key] = edits;
        result2 = new TextEditChangeImpl(edits);
        this._textEditChanges[key] = result2;
      }
      return result2;
    }
  };
  WorkspaceChange.prototype.initDocumentChanges = function() {
    if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
      this._changeAnnotations = new ChangeAnnotations();
      this._workspaceEdit.documentChanges = [];
      this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
    }
  };
  WorkspaceChange.prototype.initChanges = function() {
    if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
      this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
    }
  };
  WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
    this.initDocumentChanges();
    if (this._workspaceEdit.documentChanges === void 0) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var annotation;
    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
      annotation = optionsOrAnnotation;
    } else {
      options = optionsOrAnnotation;
    }
    var operation;
    var id2;
    if (annotation === void 0) {
      operation = CreateFile.create(uri, options);
    } else {
      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
      operation = CreateFile.create(uri, options, id2);
    }
    this._workspaceEdit.documentChanges.push(operation);
    if (id2 !== void 0) {
      return id2;
    }
  };
  WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
    this.initDocumentChanges();
    if (this._workspaceEdit.documentChanges === void 0) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var annotation;
    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
      annotation = optionsOrAnnotation;
    } else {
      options = optionsOrAnnotation;
    }
    var operation;
    var id2;
    if (annotation === void 0) {
      operation = RenameFile.create(oldUri, newUri, options);
    } else {
      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
      operation = RenameFile.create(oldUri, newUri, options, id2);
    }
    this._workspaceEdit.documentChanges.push(operation);
    if (id2 !== void 0) {
      return id2;
    }
  };
  WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
    this.initDocumentChanges();
    if (this._workspaceEdit.documentChanges === void 0) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var annotation;
    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
      annotation = optionsOrAnnotation;
    } else {
      options = optionsOrAnnotation;
    }
    var operation;
    var id2;
    if (annotation === void 0) {
      operation = DeleteFile.create(uri, options);
    } else {
      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
      operation = DeleteFile.create(uri, options, id2);
    }
    this._workspaceEdit.documentChanges.push(operation);
    if (id2 !== void 0) {
      return id2;
    }
  };
  return WorkspaceChange;
})();
var TextDocumentIdentifier;
(function(TextDocumentIdentifier2) {
  function create(uri) {
    return { uri };
  }
  TextDocumentIdentifier2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri);
  }
  TextDocumentIdentifier2.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
var VersionedTextDocumentIdentifier;
(function(VersionedTextDocumentIdentifier2) {
  function create(uri, version2) {
    return { uri, version: version2 };
  }
  VersionedTextDocumentIdentifier2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
  }
  VersionedTextDocumentIdentifier2.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
var OptionalVersionedTextDocumentIdentifier;
(function(OptionalVersionedTextDocumentIdentifier2) {
  function create(uri, version2) {
    return { uri, version: version2 };
  }
  OptionalVersionedTextDocumentIdentifier2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
  }
  OptionalVersionedTextDocumentIdentifier2.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
var TextDocumentItem;
(function(TextDocumentItem2) {
  function create(uri, languageId, version2, text3) {
    return { uri, languageId, version: version2, text: text3 };
  }
  TextDocumentItem2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
  }
  TextDocumentItem2.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
var MarkupKind;
(function(MarkupKind2) {
  MarkupKind2.PlainText = "plaintext";
  MarkupKind2.Markdown = "markdown";
})(MarkupKind || (MarkupKind = {}));
(function(MarkupKind2) {
  function is(value) {
    var candidate = value;
    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
  }
  MarkupKind2.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function(MarkupContent2) {
  function is(value) {
    var candidate = value;
    return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
  }
  MarkupContent2.is = is;
})(MarkupContent || (MarkupContent = {}));
var CompletionItemKind$1;
(function(CompletionItemKind2) {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind$1 || (CompletionItemKind$1 = {}));
var InsertTextFormat;
(function(InsertTextFormat2) {
  InsertTextFormat2.PlainText = 1;
  InsertTextFormat2.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
var InsertReplaceEdit;
(function(InsertReplaceEdit2) {
  function create(newText, insert, replace2) {
    return { newText, insert, replace: replace2 };
  }
  InsertReplaceEdit2.create = create;
  function is(value) {
    var candidate = value;
    return candidate && Is.string(candidate.newText) && Range$1.is(candidate.insert) && Range$1.is(candidate.replace);
  }
  InsertReplaceEdit2.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
var InsertTextMode;
(function(InsertTextMode2) {
  InsertTextMode2.asIs = 1;
  InsertTextMode2.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItem;
(function(CompletionItem2) {
  function create(label) {
    return { label };
  }
  CompletionItem2.create = create;
})(CompletionItem || (CompletionItem = {}));
var CompletionList;
(function(CompletionList2) {
  function create(items, isIncomplete) {
    return { items: items ? items : [], isIncomplete: !!isIncomplete };
  }
  CompletionList2.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function(MarkedString2) {
  function fromPlainText(plainText) {
    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  MarkedString2.fromPlainText = fromPlainText;
  function is(value) {
    var candidate = value;
    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
  }
  MarkedString2.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function(Hover2) {
  function is(value) {
    var candidate = value;
    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range$1.is(value.range));
  }
  Hover2.is = is;
})(Hover || (Hover = {}));
var ParameterInformation;
(function(ParameterInformation2) {
  function create(label, documentation) {
    return documentation ? { label, documentation } : { label };
  }
  ParameterInformation2.create = create;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function(SignatureInformation2) {
  function create(label, documentation) {
    var parameters = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      parameters[_i - 2] = arguments[_i];
    }
    var result2 = { label };
    if (Is.defined(documentation)) {
      result2.documentation = documentation;
    }
    if (Is.defined(parameters)) {
      result2.parameters = parameters;
    } else {
      result2.parameters = [];
    }
    return result2;
  }
  SignatureInformation2.create = create;
})(SignatureInformation || (SignatureInformation = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2.Text = 1;
  DocumentHighlightKind2.Read = 2;
  DocumentHighlightKind2.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var DocumentHighlight;
(function(DocumentHighlight2) {
  function create(range2, kind2) {
    var result2 = { range: range2 };
    if (Is.number(kind2)) {
      result2.kind = kind2;
    }
    return result2;
  }
  DocumentHighlight2.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2.File = 1;
  SymbolKind2.Module = 2;
  SymbolKind2.Namespace = 3;
  SymbolKind2.Package = 4;
  SymbolKind2.Class = 5;
  SymbolKind2.Method = 6;
  SymbolKind2.Property = 7;
  SymbolKind2.Field = 8;
  SymbolKind2.Constructor = 9;
  SymbolKind2.Enum = 10;
  SymbolKind2.Interface = 11;
  SymbolKind2.Function = 12;
  SymbolKind2.Variable = 13;
  SymbolKind2.Constant = 14;
  SymbolKind2.String = 15;
  SymbolKind2.Number = 16;
  SymbolKind2.Boolean = 17;
  SymbolKind2.Array = 18;
  SymbolKind2.Object = 19;
  SymbolKind2.Key = 20;
  SymbolKind2.Null = 21;
  SymbolKind2.EnumMember = 22;
  SymbolKind2.Struct = 23;
  SymbolKind2.Event = 24;
  SymbolKind2.Operator = 25;
  SymbolKind2.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function(SymbolInformation2) {
  function create(name2, kind2, range2, uri, containerName) {
    var result2 = {
      name: name2,
      kind: kind2,
      location: { uri, range: range2 }
    };
    if (containerName) {
      result2.containerName = containerName;
    }
    return result2;
  }
  SymbolInformation2.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var DocumentSymbol;
(function(DocumentSymbol2) {
  function create(name2, detail, kind2, range2, selectionRange, children) {
    var result2 = {
      name: name2,
      detail,
      kind: kind2,
      range: range2,
      selectionRange
    };
    if (children !== void 0) {
      result2.children = children;
    }
    return result2;
  }
  DocumentSymbol2.create = create;
  function is(value) {
    var candidate = value;
    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range$1.is(candidate.range) && Range$1.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
  }
  DocumentSymbol2.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
var CodeActionKind;
(function(CodeActionKind2) {
  CodeActionKind2.Empty = "";
  CodeActionKind2.QuickFix = "quickfix";
  CodeActionKind2.Refactor = "refactor";
  CodeActionKind2.RefactorExtract = "refactor.extract";
  CodeActionKind2.RefactorInline = "refactor.inline";
  CodeActionKind2.RefactorRewrite = "refactor.rewrite";
  CodeActionKind2.Source = "source";
  CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
  CodeActionKind2.SourceFixAll = "source.fixAll";
})(CodeActionKind || (CodeActionKind = {}));
var CodeActionContext;
(function(CodeActionContext2) {
  function create(diagnostics, only) {
    var result2 = { diagnostics };
    if (only !== void 0 && only !== null) {
      result2.only = only;
    }
    return result2;
  }
  CodeActionContext2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
  }
  CodeActionContext2.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function(CodeAction2) {
  function create(title, kindOrCommandOrEdit, kind2) {
    var result2 = { title };
    var checkKind = true;
    if (typeof kindOrCommandOrEdit === "string") {
      checkKind = false;
      result2.kind = kindOrCommandOrEdit;
    } else if (Command.is(kindOrCommandOrEdit)) {
      result2.command = kindOrCommandOrEdit;
    } else {
      result2.edit = kindOrCommandOrEdit;
    }
    if (checkKind && kind2 !== void 0) {
      result2.kind = kind2;
    }
    return result2;
  }
  CodeAction2.create = create;
  function is(value) {
    var candidate = value;
    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
  }
  CodeAction2.is = is;
})(CodeAction || (CodeAction = {}));
var CodeLens;
(function(CodeLens2) {
  function create(range2, data) {
    var result2 = { range: range2 };
    if (Is.defined(data)) {
      result2.data = data;
    }
    return result2;
  }
  CodeLens2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range$1.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
  }
  CodeLens2.is = is;
})(CodeLens || (CodeLens = {}));
var FormattingOptions;
(function(FormattingOptions2) {
  function create(tabSize, insertSpaces) {
    return { tabSize, insertSpaces };
  }
  FormattingOptions2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
  }
  FormattingOptions2.is = is;
})(FormattingOptions || (FormattingOptions = {}));
var DocumentLink;
(function(DocumentLink2) {
  function create(range2, target2, data) {
    return { range: range2, target: target2, data };
  }
  DocumentLink2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Range$1.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
  }
  DocumentLink2.is = is;
})(DocumentLink || (DocumentLink = {}));
var SelectionRange;
(function(SelectionRange2) {
  function create(range2, parent) {
    return { range: range2, parent };
  }
  SelectionRange2.create = create;
  function is(value) {
    var candidate = value;
    return candidate !== void 0 && Range$1.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
  }
  SelectionRange2.is = is;
})(SelectionRange || (SelectionRange = {}));
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version2, content) {
    return new FullTextDocument(uri, languageId, version2, content);
  }
  TextDocument2.create = create;
  function is(value) {
    var candidate = value;
    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
  }
  TextDocument2.is = is;
  function applyEdits(document2, edits) {
    var text3 = document2.getText();
    var sortedEdits = mergeSort(edits, function(a, b) {
      var diff2 = a.range.start.line - b.range.start.line;
      if (diff2 === 0) {
        return a.range.start.character - b.range.start.character;
      }
      return diff2;
    });
    var lastModifiedOffset = text3.length;
    for (var i = sortedEdits.length - 1; i >= 0; i--) {
      var e = sortedEdits[i];
      var startOffset = document2.offsetAt(e.range.start);
      var endOffset = document2.offsetAt(e.range.end);
      if (endOffset <= lastModifiedOffset) {
        text3 = text3.substring(0, startOffset) + e.newText + text3.substring(endOffset, text3.length);
      } else {
        throw new Error("Overlapping edit");
      }
      lastModifiedOffset = startOffset;
    }
    return text3;
  }
  TextDocument2.applyEdits = applyEdits;
  function mergeSort(data, compare) {
    if (data.length <= 1) {
      return data;
    }
    var p2 = data.length / 2 | 0;
    var left = data.slice(0, p2);
    var right = data.slice(p2);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      var ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
})(TextDocument || (TextDocument = {}));
var FullTextDocument = function() {
  function FullTextDocument2(uri, languageId, version2, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version2;
    this._content = content;
    this._lineOffsets = void 0;
  }
  Object.defineProperty(FullTextDocument2.prototype, "uri", {
    get: function() {
      return this._uri;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FullTextDocument2.prototype, "languageId", {
    get: function() {
      return this._languageId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FullTextDocument2.prototype, "version", {
    get: function() {
      return this._version;
    },
    enumerable: false,
    configurable: true
  });
  FullTextDocument2.prototype.getText = function(range2) {
    if (range2) {
      var start2 = this.offsetAt(range2.start);
      var end2 = this.offsetAt(range2.end);
      return this._content.substring(start2, end2);
    }
    return this._content;
  };
  FullTextDocument2.prototype.update = function(event, version2) {
    this._content = event.text;
    this._version = version2;
    this._lineOffsets = void 0;
  };
  FullTextDocument2.prototype.getLineOffsets = function() {
    if (this._lineOffsets === void 0) {
      var lineOffsets = [];
      var text3 = this._content;
      var isLineStart = true;
      for (var i = 0; i < text3.length; i++) {
        if (isLineStart) {
          lineOffsets.push(i);
          isLineStart = false;
        }
        var ch2 = text3.charAt(i);
        isLineStart = ch2 === "\r" || ch2 === "\n";
        if (ch2 === "\r" && i + 1 < text3.length && text3.charAt(i + 1) === "\n") {
          i++;
        }
      }
      if (isLineStart && text3.length > 0) {
        lineOffsets.push(text3.length);
      }
      this._lineOffsets = lineOffsets;
    }
    return this._lineOffsets;
  };
  FullTextDocument2.prototype.positionAt = function(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    var lineOffsets = this.getLineOffsets();
    var low = 0, high = lineOffsets.length;
    if (high === 0) {
      return Position$1.create(0, offset);
    }
    while (low < high) {
      var mid2 = Math.floor((low + high) / 2);
      if (lineOffsets[mid2] > offset) {
        high = mid2;
      } else {
        low = mid2 + 1;
      }
    }
    var line = low - 1;
    return Position$1.create(line, offset - lineOffsets[line]);
  };
  FullTextDocument2.prototype.offsetAt = function(position) {
    var lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    var lineOffset = lineOffsets[position.line];
    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  };
  Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
    get: function() {
      return this.getLineOffsets().length;
    },
    enumerable: false,
    configurable: true
  });
  return FullTextDocument2;
}();
var Is;
(function(Is2) {
  var toString = Object.prototype.toString;
  function defined(value) {
    return typeof value !== "undefined";
  }
  Is2.defined = defined;
  function undefined$1(value) {
    return typeof value === "undefined";
  }
  Is2.undefined = undefined$1;
  function boolean(value) {
    return value === true || value === false;
  }
  Is2.boolean = boolean;
  function string2(value) {
    return toString.call(value) === "[object String]";
  }
  Is2.string = string2;
  function number(value) {
    return toString.call(value) === "[object Number]";
  }
  Is2.number = number;
  function numberRange(value, min, max) {
    return toString.call(value) === "[object Number]" && min <= value && value <= max;
  }
  Is2.numberRange = numberRange;
  function integer2(value) {
    return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
  }
  Is2.integer = integer2;
  function uinteger2(value) {
    return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
  }
  Is2.uinteger = uinteger2;
  function func(value) {
    return toString.call(value) === "[object Function]";
  }
  Is2.func = func;
  function objectLiteral(value) {
    return value !== null && typeof value === "object";
  }
  Is2.objectLiteral = objectLiteral;
  function typedArray(value, check2) {
    return Array.isArray(value) && value.every(check2);
  }
  Is2.typedArray = typedArray;
})(Is || (Is = {}));
class CharacterStream {
  constructor(sourceText) {
    this.getStartOfToken = () => this._start;
    this.getCurrentPosition = () => this._pos;
    this.eol = () => this._sourceText.length === this._pos;
    this.sol = () => this._pos === 0;
    this.peek = () => {
      return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;
    };
    this.next = () => {
      const char = this._sourceText.charAt(this._pos);
      this._pos++;
      return char;
    };
    this.eat = (pattern) => {
      const isMatched = this._testNextCharacter(pattern);
      if (isMatched) {
        this._start = this._pos;
        this._pos++;
        return this._sourceText.charAt(this._pos - 1);
      }
      return void 0;
    };
    this.eatWhile = (match2) => {
      let isMatched = this._testNextCharacter(match2);
      let didEat = false;
      if (isMatched) {
        didEat = isMatched;
        this._start = this._pos;
      }
      while (isMatched) {
        this._pos++;
        isMatched = this._testNextCharacter(match2);
        didEat = true;
      }
      return didEat;
    };
    this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
    this.skipToEnd = () => {
      this._pos = this._sourceText.length;
    };
    this.skipTo = (position) => {
      this._pos = position;
    };
    this.match = (pattern, consume = true, caseFold = false) => {
      let token2 = null;
      let match2 = null;
      if (typeof pattern === "string") {
        const regex2 = new RegExp(pattern, caseFold ? "i" : "g");
        match2 = regex2.test(this._sourceText.substr(this._pos, pattern.length));
        token2 = pattern;
      } else if (pattern instanceof RegExp) {
        match2 = this._sourceText.slice(this._pos).match(pattern);
        token2 = match2 && match2[0];
      }
      if (match2 != null) {
        if (typeof pattern === "string" || match2 instanceof Array && this._sourceText.startsWith(match2[0], this._pos)) {
          if (consume) {
            this._start = this._pos;
            if (token2 && token2.length) {
              this._pos += token2.length;
            }
          }
          return match2;
        }
      }
      return false;
    };
    this.backUp = (num2) => {
      this._pos -= num2;
    };
    this.column = () => this._pos;
    this.indentation = () => {
      const match2 = this._sourceText.match(/\s*/);
      let indent2 = 0;
      if (match2 && match2.length !== 0) {
        const whitespaces = match2[0];
        let pos = 0;
        while (whitespaces.length > pos) {
          if (whitespaces.charCodeAt(pos) === 9) {
            indent2 += 2;
          } else {
            indent2++;
          }
          pos++;
        }
      }
      return indent2;
    };
    this.current = () => this._sourceText.slice(this._start, this._pos);
    this._start = 0;
    this._pos = 0;
    this._sourceText = sourceText;
  }
  _testNextCharacter(pattern) {
    const character = this._sourceText.charAt(this._pos);
    let isMatched = false;
    if (typeof pattern === "string") {
      isMatched = character === pattern;
    } else {
      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
    }
    return isMatched;
  }
}
function opt(ofRule) {
  return { ofRule };
}
function list$1(ofRule, separator2) {
  return { ofRule, isList: true, separator: separator2 };
}
function butNot(rule, exclusions) {
  const ruleMatch = rule.match;
  rule.match = (token2) => {
    let check2 = false;
    if (ruleMatch) {
      check2 = ruleMatch(token2);
    }
    return check2 && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token2));
  };
  return rule;
}
function t(kind2, style) {
  return { style, match: (token2) => token2.kind === kind2 };
}
function p(value, style) {
  return {
    style: style || "punctuation",
    match: (token2) => token2.kind === "Punctuation" && token2.value === value
  };
}
const isIgnored = (ch2) => ch2 === " " || ch2 === "	" || ch2 === "," || ch2 === "\n" || ch2 === "\r" || ch2 === "\uFEFF" || ch2 === "\xA0";
const LexRules$2 = {
  Name: /^[_A-Za-z][_0-9A-Za-z]*/,
  Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
  String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
  Comment: /^#.*/
};
const ParseRules$2 = {
  Document: [list$1("Definition")],
  Definition(token2) {
    switch (token2.value) {
      case "{":
        return "ShortQuery";
      case "query":
        return "Query";
      case "mutation":
        return "Mutation";
      case "subscription":
        return "Subscription";
      case "fragment":
        return Kind.FRAGMENT_DEFINITION;
      case "schema":
        return "SchemaDef";
      case "scalar":
        return "ScalarDef";
      case "type":
        return "ObjectTypeDef";
      case "interface":
        return "InterfaceDef";
      case "union":
        return "UnionDef";
      case "enum":
        return "EnumDef";
      case "input":
        return "InputDef";
      case "extend":
        return "ExtendDef";
      case "directive":
        return "DirectiveDef";
    }
  },
  ShortQuery: ["SelectionSet"],
  Query: [
    word("query"),
    opt(name("def")),
    opt("VariableDefinitions"),
    list$1("Directive"),
    "SelectionSet"
  ],
  Mutation: [
    word("mutation"),
    opt(name("def")),
    opt("VariableDefinitions"),
    list$1("Directive"),
    "SelectionSet"
  ],
  Subscription: [
    word("subscription"),
    opt(name("def")),
    opt("VariableDefinitions"),
    list$1("Directive"),
    "SelectionSet"
  ],
  VariableDefinitions: [p("("), list$1("VariableDefinition"), p(")")],
  VariableDefinition: ["Variable", p(":"), "Type", opt("DefaultValue")],
  Variable: [p("$", "variable"), name("variable")],
  DefaultValue: [p("="), "Value"],
  SelectionSet: [p("{"), list$1("Selection"), p("}")],
  Selection(token2, stream) {
    return token2.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
  },
  AliasedField: [
    name("property"),
    p(":"),
    name("qualifier"),
    opt("Arguments"),
    list$1("Directive"),
    opt("SelectionSet")
  ],
  Field: [
    name("property"),
    opt("Arguments"),
    list$1("Directive"),
    opt("SelectionSet")
  ],
  Arguments: [p("("), list$1("Argument"), p(")")],
  Argument: [name("attribute"), p(":"), "Value"],
  FragmentSpread: [p("..."), name("def"), list$1("Directive")],
  InlineFragment: [
    p("..."),
    opt("TypeCondition"),
    list$1("Directive"),
    "SelectionSet"
  ],
  FragmentDefinition: [
    word("fragment"),
    opt(butNot(name("def"), [word("on")])),
    "TypeCondition",
    list$1("Directive"),
    "SelectionSet"
  ],
  TypeCondition: [word("on"), "NamedType"],
  Value(token2) {
    switch (token2.kind) {
      case "Number":
        return "NumberValue";
      case "String":
        return "StringValue";
      case "Punctuation":
        switch (token2.value) {
          case "[":
            return "ListValue";
          case "{":
            return "ObjectValue";
          case "$":
            return "Variable";
          case "&":
            return "NamedType";
        }
        return null;
      case "Name":
        switch (token2.value) {
          case "true":
          case "false":
            return "BooleanValue";
        }
        if (token2.value === "null") {
          return "NullValue";
        }
        return "EnumValue";
    }
  },
  NumberValue: [t("Number", "number")],
  StringValue: [
    {
      style: "string",
      match: (token2) => token2.kind === "String",
      update(state, token2) {
        if (token2.value.startsWith('"""')) {
          state.inBlockstring = !token2.value.slice(3).endsWith('"""');
        }
      }
    }
  ],
  BooleanValue: [t("Name", "builtin")],
  NullValue: [t("Name", "keyword")],
  EnumValue: [name("string-2")],
  ListValue: [p("["), list$1("Value"), p("]")],
  ObjectValue: [p("{"), list$1("ObjectField"), p("}")],
  ObjectField: [name("attribute"), p(":"), "Value"],
  Type(token2) {
    return token2.value === "[" ? "ListType" : "NonNullType";
  },
  ListType: [p("["), "Type", p("]"), opt(p("!"))],
  NonNullType: ["NamedType", opt(p("!"))],
  NamedType: [type("atom")],
  Directive: [p("@", "meta"), name("meta"), opt("Arguments")],
  DirectiveDef: [
    word("directive"),
    p("@", "meta"),
    name("meta"),
    opt("ArgumentsDef"),
    word("on"),
    list$1("DirectiveLocation", p("|"))
  ],
  InterfaceDef: [
    word("interface"),
    name("atom"),
    opt("Implements"),
    list$1("Directive"),
    p("{"),
    list$1("FieldDef"),
    p("}")
  ],
  Implements: [word("implements"), list$1("NamedType", p("&"))],
  DirectiveLocation: [name("string-2")],
  SchemaDef: [
    word("schema"),
    list$1("Directive"),
    p("{"),
    list$1("OperationTypeDef"),
    p("}")
  ],
  OperationTypeDef: [name("keyword"), p(":"), name("atom")],
  ScalarDef: [word("scalar"), name("atom"), list$1("Directive")],
  ObjectTypeDef: [
    word("type"),
    name("atom"),
    opt("Implements"),
    list$1("Directive"),
    p("{"),
    list$1("FieldDef"),
    p("}")
  ],
  FieldDef: [
    name("property"),
    opt("ArgumentsDef"),
    p(":"),
    "Type",
    list$1("Directive")
  ],
  ArgumentsDef: [p("("), list$1("InputValueDef"), p(")")],
  InputValueDef: [
    name("attribute"),
    p(":"),
    "Type",
    opt("DefaultValue"),
    list$1("Directive")
  ],
  UnionDef: [
    word("union"),
    name("atom"),
    list$1("Directive"),
    p("="),
    list$1("UnionMember", p("|"))
  ],
  UnionMember: ["NamedType"],
  EnumDef: [
    word("enum"),
    name("atom"),
    list$1("Directive"),
    p("{"),
    list$1("EnumValueDef"),
    p("}")
  ],
  EnumValueDef: [name("string-2"), list$1("Directive")],
  InputDef: [
    word("input"),
    name("atom"),
    list$1("Directive"),
    p("{"),
    list$1("InputValueDef"),
    p("}")
  ],
  ExtendDef: [word("extend"), "ObjectTypeDef"]
};
function word(value) {
  return {
    style: "keyword",
    match: (token2) => token2.kind === "Name" && token2.value === value
  };
}
function name(style) {
  return {
    style,
    match: (token2) => token2.kind === "Name",
    update(state, token2) {
      state.name = token2.value;
    }
  };
}
function type(style) {
  return {
    style,
    match: (token2) => token2.kind === "Name",
    update(state, token2) {
      if (state.prevState && state.prevState.prevState) {
        state.name = token2.value;
        state.prevState.prevState.type = token2.value;
      }
    }
  };
}
function onlineParser(options = {
  eatWhitespace: (stream) => stream.eatWhile(isIgnored),
  lexRules: LexRules$2,
  parseRules: ParseRules$2,
  editorConfig: {}
}) {
  return {
    startState() {
      const initialState = {
        level: 0,
        step: 0,
        name: null,
        kind: null,
        type: null,
        rule: null,
        needsSeperator: false,
        prevState: null
      };
      pushRule(options.parseRules, initialState, Kind.DOCUMENT);
      return initialState;
    },
    token(stream, state) {
      return getToken(stream, state, options);
    }
  };
}
function getToken(stream, state, options) {
  if (state.inBlockstring) {
    if (stream.match(/.*"""/)) {
      state.inBlockstring = false;
      return "string";
    } else {
      stream.skipToEnd();
      return "string";
    }
  }
  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
  if (state.rule && state.rule.length === 0) {
    popRule(state);
  } else if (state.needsAdvance) {
    state.needsAdvance = false;
    advanceRule(state, true);
  }
  if (stream.sol()) {
    const tabSize = editorConfig && editorConfig.tabSize || 2;
    state.indentLevel = Math.floor(stream.indentation() / tabSize);
  }
  if (eatWhitespace(stream)) {
    return "ws";
  }
  const token2 = lex$1(lexRules, stream);
  if (!token2) {
    const matchedSomething = stream.match(/\S+/);
    if (!matchedSomething) {
      stream.match(/\s/);
    }
    pushRule(SpecialParseRules, state, "Invalid");
    return "invalidchar";
  }
  if (token2.kind === "Comment") {
    pushRule(SpecialParseRules, state, "Comment");
    return "comment";
  }
  const backupState = assign$2({}, state);
  if (token2.kind === "Punctuation") {
    if (/^[{([]/.test(token2.value)) {
      if (state.indentLevel !== void 0) {
        state.levels = (state.levels || []).concat(state.indentLevel + 1);
      }
    } else if (/^[})\]]/.test(token2.value)) {
      const levels = state.levels = (state.levels || []).slice(0, -1);
      if (state.indentLevel) {
        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {
          state.indentLevel = levels[levels.length - 1];
        }
      }
    }
  }
  while (state.rule) {
    let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token2, stream) : null : state.rule[state.step];
    if (state.needsSeperator) {
      expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);
    }
    if (expected) {
      if (expected.ofRule) {
        expected = expected.ofRule;
      }
      if (typeof expected === "string") {
        pushRule(parseRules, state, expected);
        continue;
      }
      if (expected.match && expected.match(token2)) {
        if (expected.update) {
          expected.update(state, token2);
        }
        if (token2.kind === "Punctuation") {
          advanceRule(state, true);
        } else {
          state.needsAdvance = true;
        }
        return expected.style;
      }
    }
    unsuccessful(state);
  }
  assign$2(state, backupState);
  pushRule(SpecialParseRules, state, "Invalid");
  return "invalidchar";
}
function assign$2(to, from) {
  const keys = Object.keys(from);
  for (let i = 0; i < keys.length; i++) {
    to[keys[i]] = from[keys[i]];
  }
  return to;
}
const SpecialParseRules = {
  Invalid: [],
  Comment: []
};
function pushRule(rules, state, ruleKind) {
  if (!rules[ruleKind]) {
    throw new TypeError("Unknown rule: " + ruleKind);
  }
  state.prevState = Object.assign({}, state);
  state.kind = ruleKind;
  state.name = null;
  state.type = null;
  state.rule = rules[ruleKind];
  state.step = 0;
  state.needsSeperator = false;
}
function popRule(state) {
  if (!state.prevState) {
    return;
  }
  state.kind = state.prevState.kind;
  state.name = state.prevState.name;
  state.type = state.prevState.type;
  state.rule = state.prevState.rule;
  state.step = state.prevState.step;
  state.needsSeperator = state.prevState.needsSeperator;
  state.prevState = state.prevState.prevState;
}
function advanceRule(state, successful) {
  if (isList(state) && state.rule) {
    const step = state.rule[state.step];
    if (step.separator) {
      const separator2 = step.separator;
      state.needsSeperator = !state.needsSeperator;
      if (!state.needsSeperator && separator2.ofRule) {
        return;
      }
    }
    if (successful) {
      return;
    }
  }
  state.needsSeperator = false;
  state.step++;
  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
    popRule(state);
    if (state.rule) {
      if (isList(state)) {
        if (state.rule && state.rule[state.step].separator) {
          state.needsSeperator = !state.needsSeperator;
        }
      } else {
        state.needsSeperator = false;
        state.step++;
      }
    }
  }
}
function isList(state) {
  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];
  return step && step.isList;
}
function unsuccessful(state) {
  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
    popRule(state);
  }
  if (state.rule) {
    advanceRule(state, false);
  }
}
function lex$1(lexRules, stream) {
  const kinds = Object.keys(lexRules);
  for (let i = 0; i < kinds.length; i++) {
    const match2 = stream.match(lexRules[kinds[i]]);
    if (match2 && match2 instanceof Array) {
      return { kind: kinds[i], value: match2[0] };
    }
  }
}
const AdditionalRuleKinds = {
  ALIASED_FIELD: "AliasedField",
  ARGUMENTS: "Arguments",
  SHORT_QUERY: "ShortQuery",
  QUERY: "Query",
  MUTATION: "Mutation",
  SUBSCRIPTION: "Subscription",
  TYPE_CONDITION: "TypeCondition",
  INVALID: "Invalid",
  COMMENT: "Comment",
  SCHEMA_DEF: "SchemaDef",
  SCALAR_DEF: "ScalarDef",
  OBJECT_TYPE_DEF: "ObjectTypeDef",
  OBJECT_VALUE: "ObjectValue",
  LIST_VALUE: "ListValue",
  INTERFACE_DEF: "InterfaceDef",
  UNION_DEF: "UnionDef",
  ENUM_DEF: "EnumDef",
  ENUM_VALUE: "EnumValue",
  FIELD_DEF: "FieldDef",
  INPUT_DEF: "InputDef",
  INPUT_VALUE_DEF: "InputValueDef",
  ARGUMENTS_DEF: "ArgumentsDef",
  EXTEND_DEF: "ExtendDef",
  DIRECTIVE_DEF: "DirectiveDef",
  IMPLEMENTS: "Implements",
  VARIABLE_DEFINITIONS: "VariableDefinitions",
  TYPE: "Type"
};
const RuleKinds = Object.assign(Object.assign({}, Kind), AdditionalRuleKinds);
const SuggestionCommand = {
  command: "editor.action.triggerSuggest",
  title: "Suggestions"
};
const collectFragmentDefs = (op) => {
  const externalFragments = [];
  if (op) {
    visit(parse$1(op), {
      FragmentDefinition(def) {
        externalFragments.push(def);
      }
    });
  }
  return externalFragments;
};
function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
  var _a2;
  const opts = Object.assign(Object.assign({}, options), { schema });
  const token2 = contextToken || getTokenAtPosition(queryText, cursor);
  const state = token2.state.kind === "Invalid" ? token2.state.prevState : token2.state;
  if (!state) {
    return [];
  }
  const kind2 = state.kind;
  const step = state.step;
  const typeInfo = getTypeInfo$3(schema, token2.state);
  if (kind2 === RuleKinds.DOCUMENT) {
    return hintList$2(token2, [
      { label: "query", kind: CompletionItemKind$1.Function },
      { label: "mutation", kind: CompletionItemKind$1.Function },
      { label: "subscription", kind: CompletionItemKind$1.Function },
      { label: "fragment", kind: CompletionItemKind$1.Function },
      { label: "{", kind: CompletionItemKind$1.Constructor }
    ]);
  }
  if (kind2 === RuleKinds.IMPLEMENTS || kind2 === RuleKinds.NAMED_TYPE && ((_a2 = state.prevState) === null || _a2 === void 0 ? void 0 : _a2.kind) === RuleKinds.IMPLEMENTS) {
    return getSuggestionsForImplements(token2, state, schema, queryText, typeInfo);
  }
  if (kind2 === RuleKinds.SELECTION_SET || kind2 === RuleKinds.FIELD || kind2 === RuleKinds.ALIASED_FIELD) {
    return getSuggestionsForFieldNames(token2, typeInfo, opts);
  }
  if (kind2 === RuleKinds.ARGUMENTS || kind2 === RuleKinds.ARGUMENT && step === 0) {
    const argDefs = typeInfo.argDefs;
    if (argDefs) {
      return hintList$2(token2, argDefs.map((argDef) => {
        var _a3;
        return {
          label: argDef.name,
          insertText: argDef.name + ": ",
          command: SuggestionCommand,
          detail: String(argDef.type),
          documentation: (_a3 = argDef.description) !== null && _a3 !== void 0 ? _a3 : void 0,
          kind: CompletionItemKind$1.Variable,
          type: argDef.type
        };
      }));
    }
  }
  if (kind2 === RuleKinds.OBJECT_VALUE || kind2 === RuleKinds.OBJECT_FIELD && step === 0) {
    if (typeInfo.objectFieldDefs) {
      const objectFields = objectValues(typeInfo.objectFieldDefs);
      const completionKind = kind2 === RuleKinds.OBJECT_VALUE ? CompletionItemKind$1.Value : CompletionItemKind$1.Field;
      return hintList$2(token2, objectFields.map((field) => {
        var _a3;
        return {
          label: field.name,
          detail: String(field.type),
          documentation: (_a3 = field.description) !== null && _a3 !== void 0 ? _a3 : void 0,
          kind: completionKind,
          type: field.type
        };
      }));
    }
  }
  if (kind2 === RuleKinds.ENUM_VALUE || kind2 === RuleKinds.LIST_VALUE && step === 1 || kind2 === RuleKinds.OBJECT_FIELD && step === 2 || kind2 === RuleKinds.ARGUMENT && step === 2) {
    return getSuggestionsForInputValues(token2, typeInfo, queryText, schema);
  }
  if (kind2 === RuleKinds.VARIABLE && step === 1) {
    const namedInputType = getNamedType(typeInfo.inputType);
    const variableDefinitions = getVariableCompletions(queryText, schema, token2);
    return hintList$2(token2, variableDefinitions.filter((v2) => v2.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
  }
  if (kind2 === RuleKinds.TYPE_CONDITION && step === 1 || kind2 === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {
    return getSuggestionsForFragmentTypeConditions(token2, typeInfo, schema);
  }
  if (kind2 === RuleKinds.FRAGMENT_SPREAD && step === 1) {
    return getSuggestionsForFragmentSpread(token2, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
  }
  if (kind2 === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind2 === RuleKinds.LIST_TYPE && step === 1 || kind2 === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {
    return getSuggestionsForVariableDefinition(token2, schema);
  }
  if (kind2 === RuleKinds.DIRECTIVE) {
    return getSuggestionsForDirective(token2, state, schema);
  }
  return [];
}
const insertSuffix = ` {
  $1
}`;
const getInsertText = (field) => {
  const type2 = field.type;
  if (isCompositeType(type2)) {
    return insertSuffix;
  }
  if (isListType(type2) && isCompositeType(type2.ofType)) {
    return insertSuffix;
  }
  if (isNonNullType(type2)) {
    if (isCompositeType(type2.ofType)) {
      return insertSuffix;
    }
    if (isListType(type2.ofType) && isCompositeType(type2.ofType.ofType)) {
      return insertSuffix;
    }
  }
  return null;
};
function getSuggestionsForFieldNames(token2, typeInfo, options) {
  var _a2;
  if (typeInfo.parentType) {
    const parentType = typeInfo.parentType;
    let fields = [];
    if ("getFields" in parentType) {
      fields = objectValues(parentType.getFields());
    }
    if (isCompositeType(parentType)) {
      fields.push(TypeNameMetaFieldDef);
    }
    if (parentType === ((_a2 = options === null || options === void 0 ? void 0 : options.schema) === null || _a2 === void 0 ? void 0 : _a2.getQueryType())) {
      fields.push(SchemaMetaFieldDef, TypeMetaFieldDef);
    }
    return hintList$2(token2, fields.map((field, index) => {
      var _a3;
      const suggestion = {
        sortText: String(index) + field.name,
        label: field.name,
        detail: String(field.type),
        documentation: (_a3 = field.description) !== null && _a3 !== void 0 ? _a3 : void 0,
        deprecated: Boolean(field.deprecationReason),
        isDeprecated: Boolean(field.deprecationReason),
        deprecationReason: field.deprecationReason,
        kind: CompletionItemKind$1.Field,
        type: field.type
      };
      const insertText = getInsertText(field);
      if (insertText) {
        suggestion.insertText = field.name + insertText;
        suggestion.insertTextFormat = InsertTextFormat.Snippet;
        suggestion.command = SuggestionCommand;
      }
      return suggestion;
    }));
  }
  return [];
}
function getSuggestionsForInputValues(token2, typeInfo, queryText, schema) {
  const namedInputType = getNamedType(typeInfo.inputType);
  const queryVariables = getVariableCompletions(queryText, schema, token2).filter((v2) => v2.detail === namedInputType.name);
  if (namedInputType instanceof GraphQLEnumType) {
    const values = namedInputType.getValues();
    return hintList$2(token2, values.map((value) => {
      var _a2;
      return {
        label: value.name,
        detail: String(namedInputType),
        documentation: (_a2 = value.description) !== null && _a2 !== void 0 ? _a2 : void 0,
        deprecated: Boolean(value.deprecationReason),
        isDeprecated: Boolean(value.deprecationReason),
        deprecationReason: value.deprecationReason,
        kind: CompletionItemKind$1.EnumMember,
        type: namedInputType
      };
    }).concat(queryVariables));
  } else if (namedInputType === GraphQLBoolean) {
    return hintList$2(token2, queryVariables.concat([
      {
        label: "true",
        detail: String(GraphQLBoolean),
        documentation: "Not false.",
        kind: CompletionItemKind$1.Variable,
        type: GraphQLBoolean
      },
      {
        label: "false",
        detail: String(GraphQLBoolean),
        documentation: "Not true.",
        kind: CompletionItemKind$1.Variable,
        type: GraphQLBoolean
      }
    ]));
  }
  return queryVariables;
}
function getSuggestionsForImplements(token2, tokenState, schema, documentText, typeInfo) {
  if (tokenState.needsSeperator) {
    return [];
  }
  const typeMap = schema.getTypeMap();
  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType);
  const schemaInterfaceNames = schemaInterfaces.map(({ name: name2 }) => name2);
  const inlineInterfaces = /* @__PURE__ */ new Set();
  runOnlineParser(documentText, (_, state) => {
    var _a2, _b, _c, _d, _e;
    if (state.name) {
      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {
        inlineInterfaces.add(state.name);
      }
      if (state.kind === RuleKinds.NAMED_TYPE && ((_a2 = state.prevState) === null || _a2 === void 0 ? void 0 : _a2.kind) === RuleKinds.IMPLEMENTS) {
        if (typeInfo.interfaceDef) {
          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name: name2 }) => name2 === state.name);
          if (existingType) {
            return;
          }
          const type2 = schema.getType(state.name);
          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
            ...interfaceConfig.interfaces,
            type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })
          ] }));
        } else if (typeInfo.objectTypeDef) {
          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name: name2 }) => name2 === state.name);
          if (existingType) {
            return;
          }
          const type2 = schema.getType(state.name);
          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();
          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
            ...objectTypeConfig.interfaces,
            type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })
          ] }));
        }
      }
    }
  });
  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
  const siblingInterfaceNames = siblingInterfaces.map(({ name: name2 }) => name2);
  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name2) => ({ name: name2 }))).filter(({ name: name2 }) => name2 !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name2));
  return hintList$2(token2, possibleInterfaces.map((type2) => {
    const result2 = {
      label: type2.name,
      kind: CompletionItemKind$1.Interface,
      type: type2
    };
    if (type2 === null || type2 === void 0 ? void 0 : type2.description) {
      result2.documentation = type2.description;
    }
    return result2;
  }));
}
function getSuggestionsForFragmentTypeConditions(token2, typeInfo, schema, _kind) {
  let possibleTypes;
  if (typeInfo.parentType) {
    if (isAbstractType(typeInfo.parentType)) {
      const abstractType = assertAbstractType(typeInfo.parentType);
      const possibleObjTypes = schema.getPossibleTypes(abstractType);
      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);
      possibleObjTypes.forEach((type2) => {
        type2.getInterfaces().forEach((iface) => {
          possibleIfaceMap[iface.name] = iface;
        });
      });
      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));
    } else {
      possibleTypes = [typeInfo.parentType];
    }
  } else {
    const typeMap = schema.getTypeMap();
    possibleTypes = objectValues(typeMap).filter(isCompositeType);
  }
  return hintList$2(token2, possibleTypes.map((type2) => {
    const namedType = getNamedType(type2);
    return {
      label: String(type2),
      documentation: namedType && namedType.description || "",
      kind: CompletionItemKind$1.Field
    };
  }));
}
function getSuggestionsForFragmentSpread(token2, typeInfo, schema, queryText, fragmentDefs) {
  if (!queryText) {
    return [];
  }
  const typeMap = schema.getTypeMap();
  const defState = getDefinitionState(token2.state);
  const fragments = getFragmentDefinitions(queryText);
  if (fragmentDefs && fragmentDefs.length > 0) {
    fragments.push(...fragmentDefs);
  }
  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
  return hintList$2(token2, relevantFrags.map((frag) => ({
    label: frag.name.value,
    detail: String(typeMap[frag.typeCondition.name.value]),
    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
    kind: CompletionItemKind$1.Field,
    type: typeMap[frag.typeCondition.name.value]
  })));
}
const getParentDefinition = (state, kind2) => {
  var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  if (((_a2 = state.prevState) === null || _a2 === void 0 ? void 0 : _a2.kind) === kind2) {
    return state.prevState;
  }
  if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind2) {
    return state.prevState.prevState;
  }
  if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind2) {
    return state.prevState.prevState.prevState;
  }
  if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind2) {
    return state.prevState.prevState.prevState.prevState;
  }
};
function getVariableCompletions(queryText, schema, token2) {
  let variableName = null;
  let variableType;
  const definitions = /* @__PURE__ */ Object.create({});
  runOnlineParser(queryText, (_, state) => {
    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.VARIABLE && state.name) {
      variableName = state.name;
    }
    if ((state === null || state === void 0 ? void 0 : state.kind) === RuleKinds.NAMED_TYPE && variableName) {
      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);
      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
      }
    }
    if (variableName && variableType) {
      if (!definitions[variableName]) {
        definitions[variableName] = {
          detail: variableType.toString(),
          insertText: token2.string === "$" ? variableName : "$" + variableName,
          label: variableName,
          type: variableType,
          kind: CompletionItemKind$1.Variable
        };
        variableName = null;
        variableType = null;
      }
    }
  });
  return objectValues(definitions);
}
function getFragmentDefinitions(queryText) {
  const fragmentDefs = [];
  runOnlineParser(queryText, (_, state) => {
    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {
      fragmentDefs.push({
        kind: RuleKinds.FRAGMENT_DEFINITION,
        name: {
          kind: Kind.NAME,
          value: state.name
        },
        selectionSet: {
          kind: RuleKinds.SELECTION_SET,
          selections: []
        },
        typeCondition: {
          kind: RuleKinds.NAMED_TYPE,
          name: {
            kind: Kind.NAME,
            value: state.type
          }
        }
      });
    }
  });
  return fragmentDefs;
}
function getSuggestionsForVariableDefinition(token2, schema, _kind) {
  const inputTypeMap = schema.getTypeMap();
  const inputTypes = objectValues(inputTypeMap).filter(isInputType);
  return hintList$2(token2, inputTypes.map((type2) => ({
    label: type2.name,
    documentation: type2.description,
    kind: CompletionItemKind$1.Variable
  })));
}
function getSuggestionsForDirective(token2, state, schema, _kind) {
  if (state.prevState && state.prevState.kind) {
    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));
    return hintList$2(token2, directives.map((directive) => ({
      label: directive.name,
      documentation: directive.description || "",
      kind: CompletionItemKind$1.Function
    })));
  }
  return [];
}
function getTokenAtPosition(queryText, cursor) {
  let styleAtCursor = null;
  let stateAtCursor = null;
  let stringAtCursor = null;
  const token2 = runOnlineParser(queryText, (stream, state, style, index) => {
    if (index === cursor.line) {
      if (stream.getCurrentPosition() >= cursor.character) {
        styleAtCursor = style;
        stateAtCursor = Object.assign({}, state);
        stringAtCursor = stream.current();
        return "BREAK";
      }
    }
  });
  return {
    start: token2.start,
    end: token2.end,
    string: stringAtCursor || token2.string,
    state: stateAtCursor || token2.state,
    style: styleAtCursor || token2.style
  };
}
function runOnlineParser(queryText, callback) {
  const lines = queryText.split("\n");
  const parser = onlineParser();
  let state = parser.startState();
  let style = "";
  let stream = new CharacterStream("");
  for (let i = 0; i < lines.length; i++) {
    stream = new CharacterStream(lines[i]);
    while (!stream.eol()) {
      style = parser.token(stream, state);
      const code3 = callback(stream, state, style, i);
      if (code3 === "BREAK") {
        break;
      }
    }
    callback(stream, state, style, i);
    if (!state.kind) {
      state = parser.startState();
    }
  }
  return {
    start: stream.getStartOfToken(),
    end: stream.getCurrentPosition(),
    string: stream.current(),
    state,
    style
  };
}
function canUseDirective(state, directive) {
  if (!state || !state.kind) {
    return false;
  }
  const kind2 = state.kind;
  const locations = directive.locations;
  switch (kind2) {
    case RuleKinds.QUERY:
      return locations.indexOf(DirectiveLocation.QUERY) !== -1;
    case RuleKinds.MUTATION:
      return locations.indexOf(DirectiveLocation.MUTATION) !== -1;
    case RuleKinds.SUBSCRIPTION:
      return locations.indexOf(DirectiveLocation.SUBSCRIPTION) !== -1;
    case RuleKinds.FIELD:
    case RuleKinds.ALIASED_FIELD:
      return locations.indexOf(DirectiveLocation.FIELD) !== -1;
    case RuleKinds.FRAGMENT_DEFINITION:
      return locations.indexOf(DirectiveLocation.FRAGMENT_DEFINITION) !== -1;
    case RuleKinds.FRAGMENT_SPREAD:
      return locations.indexOf(DirectiveLocation.FRAGMENT_SPREAD) !== -1;
    case RuleKinds.INLINE_FRAGMENT:
      return locations.indexOf(DirectiveLocation.INLINE_FRAGMENT) !== -1;
    case RuleKinds.SCHEMA_DEF:
      return locations.indexOf(DirectiveLocation.SCHEMA) !== -1;
    case RuleKinds.SCALAR_DEF:
      return locations.indexOf(DirectiveLocation.SCALAR) !== -1;
    case RuleKinds.OBJECT_TYPE_DEF:
      return locations.indexOf(DirectiveLocation.OBJECT) !== -1;
    case RuleKinds.FIELD_DEF:
      return locations.indexOf(DirectiveLocation.FIELD_DEFINITION) !== -1;
    case RuleKinds.INTERFACE_DEF:
      return locations.indexOf(DirectiveLocation.INTERFACE) !== -1;
    case RuleKinds.UNION_DEF:
      return locations.indexOf(DirectiveLocation.UNION) !== -1;
    case RuleKinds.ENUM_DEF:
      return locations.indexOf(DirectiveLocation.ENUM) !== -1;
    case RuleKinds.ENUM_VALUE:
      return locations.indexOf(DirectiveLocation.ENUM_VALUE) !== -1;
    case RuleKinds.INPUT_DEF:
      return locations.indexOf(DirectiveLocation.INPUT_OBJECT) !== -1;
    case RuleKinds.INPUT_VALUE_DEF:
      const prevStateKind = state.prevState && state.prevState.kind;
      switch (prevStateKind) {
        case RuleKinds.ARGUMENTS_DEF:
          return locations.indexOf(DirectiveLocation.ARGUMENT_DEFINITION) !== -1;
        case RuleKinds.INPUT_DEF:
          return locations.indexOf(DirectiveLocation.INPUT_FIELD_DEFINITION) !== -1;
      }
  }
  return false;
}
function getTypeInfo$3(schema, tokenState) {
  let argDef;
  let argDefs;
  let directiveDef;
  let enumValue;
  let fieldDef;
  let inputType;
  let objectTypeDef;
  let objectFieldDefs;
  let parentType;
  let type2;
  let interfaceDef;
  forEachState$2(tokenState, (state) => {
    switch (state.kind) {
      case RuleKinds.QUERY:
      case "ShortQuery":
        type2 = schema.getQueryType();
        break;
      case RuleKinds.MUTATION:
        type2 = schema.getMutationType();
        break;
      case RuleKinds.SUBSCRIPTION:
        type2 = schema.getSubscriptionType();
        break;
      case RuleKinds.INLINE_FRAGMENT:
      case RuleKinds.FRAGMENT_DEFINITION:
        if (state.type) {
          type2 = schema.getType(state.type);
        }
        break;
      case RuleKinds.FIELD:
      case RuleKinds.ALIASED_FIELD: {
        if (!type2 || !state.name) {
          fieldDef = null;
        } else {
          fieldDef = parentType ? getFieldDef$1(schema, parentType, state.name) : null;
          type2 = fieldDef ? fieldDef.type : null;
        }
        break;
      }
      case RuleKinds.SELECTION_SET:
        parentType = getNamedType(type2);
        break;
      case RuleKinds.DIRECTIVE:
        directiveDef = state.name ? schema.getDirective(state.name) : null;
        break;
      case RuleKinds.INTERFACE_DEF:
        if (state.name) {
          objectTypeDef = null;
          interfaceDef = new GraphQLInterfaceType({
            name: state.name,
            interfaces: [],
            fields: {}
          });
        }
        break;
      case RuleKinds.OBJECT_TYPE_DEF:
        if (state.name) {
          interfaceDef = null;
          objectTypeDef = new GraphQLObjectType({
            name: state.name,
            interfaces: [],
            fields: {}
          });
        }
        break;
      case RuleKinds.ARGUMENTS: {
        if (!state.prevState) {
          argDefs = null;
        } else {
          switch (state.prevState.kind) {
            case RuleKinds.FIELD:
              argDefs = fieldDef && fieldDef.args;
              break;
            case RuleKinds.DIRECTIVE:
              argDefs = directiveDef && directiveDef.args;
              break;
            case RuleKinds.ALIASED_FIELD: {
              const name2 = state.prevState && state.prevState.name;
              if (!name2) {
                argDefs = null;
                break;
              }
              const field = parentType ? getFieldDef$1(schema, parentType, name2) : null;
              if (!field) {
                argDefs = null;
                break;
              }
              argDefs = field.args;
              break;
            }
            default:
              argDefs = null;
              break;
          }
        }
        break;
      }
      case RuleKinds.ARGUMENT:
        if (argDefs) {
          for (let i = 0; i < argDefs.length; i++) {
            if (argDefs[i].name === state.name) {
              argDef = argDefs[i];
              break;
            }
          }
        }
        inputType = argDef && argDef.type;
        break;
      case RuleKinds.ENUM_VALUE:
        const enumType = getNamedType(inputType);
        enumValue = enumType instanceof GraphQLEnumType ? enumType.getValues().find((val) => val.value === state.name) : null;
        break;
      case RuleKinds.LIST_VALUE:
        const nullableType = getNullableType(inputType);
        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;
        break;
      case RuleKinds.OBJECT_VALUE:
        const objectType = getNamedType(inputType);
        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;
        break;
      case RuleKinds.OBJECT_FIELD:
        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
        inputType = objectField && objectField.type;
        break;
      case RuleKinds.NAMED_TYPE:
        if (state.name) {
          type2 = schema.getType(state.name);
        }
        break;
    }
  });
  return {
    argDef,
    argDefs,
    directiveDef,
    enumValue,
    fieldDef,
    inputType,
    objectFieldDefs,
    parentType,
    type: type2,
    interfaceDef,
    objectTypeDef
  };
}
var nullthrows$2 = { exports: {} };
function nullthrows(x2, message) {
  if (x2 != null) {
    return x2;
  }
  var error2 = new Error(message !== void 0 ? message : "Got unexpected " + x2);
  error2.framesToPop = 1;
  throw error2;
}
nullthrows$2.exports = nullthrows;
nullthrows$2.exports.default = nullthrows;
Object.defineProperty(nullthrows$2.exports, "__esModule", { value: true });
var nullthrows$1 = /* @__PURE__ */ getDefaultExportFromCjs(nullthrows$2.exports);
const getFragmentDependencies = (operationString, fragmentDefinitions) => {
  if (!fragmentDefinitions) {
    return [];
  }
  let parsedOperation;
  try {
    parsedOperation = parse$1(operationString);
  } catch (error2) {
    return [];
  }
  return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);
};
const getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {
  if (!fragmentDefinitions) {
    return [];
  }
  const existingFrags = /* @__PURE__ */ new Map();
  const referencedFragNames = /* @__PURE__ */ new Set();
  visit(parsedOperation, {
    FragmentDefinition(node) {
      existingFrags.set(node.name.value, true);
    },
    FragmentSpread(node) {
      if (!referencedFragNames.has(node.name.value)) {
        referencedFragNames.add(node.name.value);
      }
    }
  });
  const asts = /* @__PURE__ */ new Set();
  referencedFragNames.forEach((name2) => {
    if (!existingFrags.has(name2) && fragmentDefinitions.has(name2)) {
      asts.add(nullthrows$1(fragmentDefinitions.get(name2)));
    }
  });
  const referencedFragments = [];
  asts.forEach((ast2) => {
    visit(ast2, {
      FragmentSpread(node) {
        if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
          asts.add(nullthrows$1(fragmentDefinitions.get(node.name.value)));
          referencedFragNames.add(node.name.value);
        }
      }
    });
    if (!existingFrags.has(ast2.name.value)) {
      referencedFragments.push(ast2);
    }
  });
  return referencedFragments;
};
function text$3(into, newText) {
  into.push(newText);
}
function renderType$4(into, t2) {
  if (isNonNullType(t2)) {
    renderType$4(into, t2.ofType);
    text$3(into, "!");
  } else if (isListType(t2)) {
    text$3(into, "[");
    renderType$4(into, t2.ofType);
    text$3(into, "]");
  } else {
    text$3(into, t2.name);
  }
}
function renderTypeToString(t2, useMarkdown) {
  const into = [];
  if (useMarkdown) {
    text$3(into, "```graphql\n");
  }
  renderType$4(into, t2);
  if (useMarkdown) {
    text$3(into, "\n```");
  }
  return into.join("");
}
const scalarTypesMap = {
  Int: "integer",
  String: "string",
  Float: "number",
  ID: "string",
  Boolean: "boolean",
  DateTime: "string"
};
function getJSONSchemaFromGraphQLType(type2, options) {
  var _a2;
  let required = false;
  let definition = /* @__PURE__ */ Object.create(null);
  const definitions = /* @__PURE__ */ Object.create(null);
  if ("defaultValue" in type2 && type2.defaultValue !== void 0) {
    definition.default = type2.defaultValue;
  }
  if (isEnumType(type2)) {
    definition.type = "string";
    definition.enum = type2.getValues().map((val) => val.name);
  }
  if (isScalarType(type2)) {
    definition.type = (_a2 = scalarTypesMap[type2.name]) !== null && _a2 !== void 0 ? _a2 : "any";
  }
  if (isListType(type2)) {
    definition.type = "array";
    const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type2.ofType, options);
    if (def.$ref) {
      definition.items = { $ref: def.$ref };
    } else {
      definition.items = def;
    }
    if (defs) {
      Object.keys(defs).forEach((defName) => {
        definitions[defName] = defs[defName];
      });
    }
  }
  if (isNonNullType(type2)) {
    required = true;
    const { definition: def, definitions: defs } = getJSONSchemaFromGraphQLType(type2.ofType, options);
    definition = def;
    if (defs) {
      Object.keys(defs).forEach((defName) => {
        definitions[defName] = defs[defName];
      });
    }
  }
  if (isInputObjectType(type2)) {
    definition.$ref = `#/definitions/${type2.name}`;
    const fields = type2.getFields();
    const fieldDef = {
      type: "object",
      properties: {},
      required: []
    };
    if (type2.description) {
      fieldDef.description = type2.description + `
` + renderTypeToString(type2);
      if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
        fieldDef.markdownDescription = type2.description + `
` + renderTypeToString(type2, true);
      }
    } else {
      fieldDef.description = renderTypeToString(type2);
      if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
        fieldDef.markdownDescription = renderTypeToString(type2, true);
      }
    }
    Object.keys(fields).forEach((fieldName) => {
      const field = fields[fieldName];
      const { required: fieldRequired, definition: typeDefinition, definitions: typeDefinitions } = getJSONSchemaFromGraphQLType(field.type, options);
      const { definition: fieldDefinition } = getJSONSchemaFromGraphQLType(field, options);
      fieldDef.properties[fieldName] = Object.assign(Object.assign({}, typeDefinition), fieldDefinition);
      const renderedField = renderTypeToString(field.type);
      fieldDef.properties[fieldName].description = field.description ? field.description + "\n" + renderedField : renderedField;
      if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
        const renderedFieldMarkdown = renderTypeToString(field.type, true);
        fieldDef.properties[fieldName].markdownDescription = field.description ? field.description + "\n" + renderedFieldMarkdown : renderedFieldMarkdown;
      }
      if (fieldRequired) {
        fieldDef.required.push(fieldName);
      }
      if (typeDefinitions) {
        Object.keys(typeDefinitions).map((defName) => {
          definitions[defName] = typeDefinitions[defName];
        });
      }
    });
    definitions[type2.name] = fieldDef;
  }
  if ("description" in type2 && !isScalarType(type2) && type2.description && !definition.description) {
    definition.description = type2.description + "\n" + renderTypeToString(type2);
    if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
      definition.markdownDescription = type2.description + "\n" + renderTypeToString(type2, true);
    }
  } else {
    definition.description = renderTypeToString(type2);
    if (options === null || options === void 0 ? void 0 : options.useMarkdownDescription) {
      definition.markdownDescription = renderTypeToString(type2, true);
    }
  }
  return { required, definition, definitions };
}
function getVariablesJSONSchema(variableToType, options) {
  const jsonSchema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: {},
    required: []
  };
  if (variableToType) {
    Object.entries(variableToType).forEach(([variableName, type2]) => {
      var _a2;
      const { definition, required, definitions } = getJSONSchemaFromGraphQLType(type2, options);
      jsonSchema.properties[variableName] = definition;
      if (required) {
        (_a2 = jsonSchema.required) === null || _a2 === void 0 ? void 0 : _a2.push(variableName);
      }
      if (definitions) {
        jsonSchema.definitions = Object.assign(Object.assign({}, jsonSchema === null || jsonSchema === void 0 ? void 0 : jsonSchema.definitions), definitions);
      }
    });
  }
  return jsonSchema;
}
function getASTNodeAtPosition(query, ast2, point) {
  const offset = pointToOffset(query, point);
  let nodeContainingPosition;
  visit(ast2, {
    enter(node) {
      if (node.kind !== "Name" && node.loc && node.loc.start <= offset && offset <= node.loc.end) {
        nodeContainingPosition = node;
      } else {
        return false;
      }
    },
    leave(node) {
      if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {
        return false;
      }
    }
  });
  return nodeContainingPosition;
}
function pointToOffset(text3, point) {
  const linesUntilPosition = text3.split("\n").slice(0, point.line);
  return point.character + linesUntilPosition.map((line) => line.length + 1).reduce((a, b) => a + b, 0);
}
class Range {
  constructor(start2, end2) {
    this.containsPosition = (position) => {
      if (this.start.line === position.line) {
        return this.start.character <= position.character;
      } else if (this.end.line === position.line) {
        return this.end.character >= position.character;
      } else {
        return this.start.line <= position.line && this.end.line >= position.line;
      }
    };
    this.start = start2;
    this.end = end2;
  }
  setStart(line, character) {
    this.start = new Position(line, character);
  }
  setEnd(line, character) {
    this.end = new Position(line, character);
  }
}
class Position {
  constructor(line, character) {
    this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;
    this.line = line;
    this.character = character;
  }
  setLine(line) {
    this.line = line;
  }
  setCharacter(character) {
    this.character = character;
  }
}
function offsetToPosition(text3, loc) {
  const EOL = "\n";
  const buf = text3.slice(0, loc);
  const lines = buf.split(EOL).length - 1;
  const lastLineIndex = buf.lastIndexOf(EOL);
  return new Position(lines, loc - lastLineIndex - 1);
}
function locToRange(text3, loc) {
  const start2 = offsetToPosition(text3, loc.start);
  const end2 = offsetToPosition(text3, loc.end);
  return new Range(start2, end2);
}
const specifiedSDLRules = [
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule
];
function validateWithCustomRules(schema, ast2, customRules, isRelayCompatMode, isSchemaDocument) {
  const rules = specifiedRules.filter((rule) => {
    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {
      return false;
    }
    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {
      return false;
    }
    return true;
  });
  if (customRules) {
    Array.prototype.push.apply(rules, customRules);
  }
  if (isSchemaDocument) {
    Array.prototype.push.apply(rules, specifiedSDLRules);
  }
  const errors2 = validate(schema, ast2, rules);
  return errors2.filter((error2) => {
    if (error2.message.indexOf("Unknown directive") !== -1 && error2.nodes) {
      const node = error2.nodes[0];
      if (node && node.kind === Kind.DIRECTIVE) {
        const name2 = node.name.value;
        if (name2 === "arguments" || name2 === "argumentDefinitions") {
          return false;
        }
      }
    }
    return true;
  });
}
function collectVariables(schema, documentAST) {
  const variableToType = /* @__PURE__ */ Object.create(null);
  documentAST.definitions.forEach((definition) => {
    if (definition.kind === "OperationDefinition") {
      const variableDefinitions = definition.variableDefinitions;
      if (variableDefinitions) {
        variableDefinitions.forEach(({ variable, type: type2 }) => {
          const inputType = typeFromAST(schema, type2);
          if (inputType) {
            variableToType[variable.name.value] = inputType;
          } else if (type2.kind === Kind.NAMED_TYPE) {
            if (type2.name.value === "Float") {
              variableToType[variable.name.value] = GraphQLFloat;
            }
          }
        });
      }
    }
  });
  return variableToType;
}
function getOperationASTFacts(documentAST, schema) {
  const variableToType = schema ? collectVariables(schema, documentAST) : void 0;
  const operations = [];
  visit(documentAST, {
    OperationDefinition(node) {
      operations.push(node);
    }
  });
  return { variableToType, operations };
}
function getOperationFacts(schema, documentString) {
  if (!documentString) {
    return;
  }
  try {
    const documentAST = parse$1(documentString);
    return Object.assign(Object.assign({}, getOperationASTFacts(documentAST, schema)), { documentAST });
  } catch (_a2) {
    return;
  }
}
const getQueryFacts = getOperationFacts;
var __awaiter$3 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const LANGUAGE = "GraphQL";
function assert(value, message) {
  if (!value) {
    throw new Error(message);
  }
}
function getRange$1(text3, node) {
  const location = node.loc;
  assert(location, "Expected ASTNode to have a location.");
  return locToRange(text3, location);
}
function getPosition(text3, node) {
  const location = node.loc;
  assert(location, "Expected ASTNode to have a location.");
  return offsetToPosition(text3, location.start);
}
function getDefinitionQueryResultForNamedType(text3, node, dependencies) {
  return __awaiter$3(this, void 0, void 0, function* () {
    const name2 = node.name.value;
    const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name2);
    if (defNodes.length === 0) {
      throw Error(`Definition not found for GraphQL type ${name2}`);
    }
    const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || "", content, definition));
    return {
      definitions,
      queryRange: definitions.map((_) => getRange$1(text3, node))
    };
  });
}
function getDefinitionQueryResultForFragmentSpread(text3, fragment, dependencies) {
  return __awaiter$3(this, void 0, void 0, function* () {
    const name2 = fragment.name.value;
    const defNodes = dependencies.filter(({ definition }) => definition.name.value === name2);
    if (defNodes.length === 0) {
      throw Error(`Definition not found for GraphQL fragment ${name2}`);
    }
    const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || "", content, definition));
    return {
      definitions,
      queryRange: definitions.map((_) => getRange$1(text3, fragment))
    };
  });
}
function getDefinitionQueryResultForDefinitionNode(path, text3, definition) {
  return {
    definitions: [getDefinitionForFragmentDefinition(path, text3, definition)],
    queryRange: definition.name ? [getRange$1(text3, definition.name)] : []
  };
}
function getDefinitionForFragmentDefinition(path, text3, definition) {
  const name2 = definition.name;
  if (!name2) {
    throw Error("Expected ASTNode to have a Name.");
  }
  return {
    path,
    position: getPosition(text3, definition),
    range: getRange$1(text3, definition),
    name: name2.value || "",
    language: LANGUAGE,
    projectRoot: path
  };
}
function getDefinitionForNodeDefinition(path, text3, definition) {
  const name2 = definition.name;
  assert(name2, "Expected ASTNode to have a Name.");
  return {
    path,
    position: getPosition(text3, definition),
    range: getRange$1(text3, definition),
    name: name2.value || "",
    language: LANGUAGE,
    projectRoot: path
  };
}
const SEVERITY$1 = {
  Error: "Error",
  Warning: "Warning",
  Information: "Information",
  Hint: "Hint"
};
const DIAGNOSTIC_SEVERITY = {
  [SEVERITY$1.Error]: 1,
  [SEVERITY$1.Warning]: 2,
  [SEVERITY$1.Information]: 3,
  [SEVERITY$1.Hint]: 4
};
const invariant = (condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
};
function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {
  let ast2 = null;
  if (externalFragments) {
    if (typeof externalFragments === "string") {
      query += "\n\n" + externalFragments;
    } else {
      query += "\n\n" + externalFragments.reduce((agg, node) => {
        agg += print(node) + "\n\n";
        return agg;
      }, "");
    }
  }
  try {
    ast2 = parse$1(query);
  } catch (error2) {
    const range2 = getRange(error2.locations[0], query);
    return [
      {
        severity: DIAGNOSTIC_SEVERITY.Error,
        message: error2.message,
        source: "GraphQL: Syntax",
        range: range2
      }
    ];
  }
  return validateQuery(ast2, schema, customRules, isRelayCompatMode);
}
function validateQuery(ast2, schema = null, customRules, isRelayCompatMode) {
  if (!schema) {
    return [];
  }
  const validationErrorAnnotations = mapCat$1(validateWithCustomRules(schema, ast2, customRules, isRelayCompatMode), (error2) => annotations(error2, DIAGNOSTIC_SEVERITY.Error, "Validation"));
  const deprecationWarningAnnotations = mapCat$1(validate(schema, ast2, [NoDeprecatedCustomRule]), (error2) => annotations(error2, DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));
  return validationErrorAnnotations.concat(deprecationWarningAnnotations);
}
function mapCat$1(array, mapper) {
  return Array.prototype.concat.apply([], array.map(mapper));
}
function annotations(error2, severity, type2) {
  if (!error2.nodes) {
    return [];
  }
  const highlightedNodes = [];
  error2.nodes.forEach((node) => {
    const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;
    if (highlightNode) {
      invariant(error2.locations, "GraphQL validation error requires locations.");
      const loc = error2.locations[0];
      const highlightLoc = getLocation(highlightNode);
      const end2 = loc.column + (highlightLoc.end - highlightLoc.start);
      highlightedNodes.push({
        source: `GraphQL: ${type2}`,
        message: error2.message,
        severity,
        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end2))
      });
    }
  });
  return highlightedNodes;
}
function getRange(location, queryText) {
  const parser = onlineParser();
  const state = parser.startState();
  const lines = queryText.split("\n");
  invariant(lines.length >= location.line, "Query text must have more lines than where the error happened");
  let stream = null;
  for (let i = 0; i < location.line; i++) {
    stream = new CharacterStream(lines[i]);
    while (!stream.eol()) {
      const style = parser.token(stream, state);
      if (style === "invalidchar") {
        break;
      }
    }
  }
  invariant(stream, "Expected Parser stream to be available.");
  const line = location.line - 1;
  const start2 = stream.getStartOfToken();
  const end2 = stream.getCurrentPosition();
  return new Range(new Position(line, start2), new Position(line, end2));
}
function getLocation(node) {
  const typeCastedNode = node;
  const location = typeCastedNode.loc;
  invariant(location, "Expected ASTNode to have a location.");
  return location;
}
const { INLINE_FRAGMENT } = Kind;
function getOutline(documentText) {
  let ast2;
  try {
    ast2 = parse$1(documentText);
  } catch (error2) {
    return null;
  }
  const visitorFns = outlineTreeConverter(documentText);
  const outlineTrees = visit(ast2, {
    leave(node) {
      if (visitorFns !== void 0 && node.kind in visitorFns) {
        return visitorFns[node.kind](node);
      }
      return null;
    }
  });
  return { outlineTrees };
}
function outlineTreeConverter(docText) {
  const meta = (node) => {
    return {
      representativeName: node.name,
      startPosition: offsetToPosition(docText, node.loc.start),
      endPosition: offsetToPosition(docText, node.loc.end),
      kind: node.kind,
      children: node.selectionSet || node.fields || node.values || node.arguments || []
    };
  };
  return {
    Field: (node) => {
      const tokenizedText = node.alias ? [buildToken("plain", node.alias), buildToken("plain", ": ")] : [];
      tokenizedText.push(buildToken("plain", node.name));
      return Object.assign({ tokenizedText }, meta(node));
    },
    OperationDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", node.operation),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    Document: (node) => node.definitions,
    SelectionSet: (node) => concatMap(node.selections, (child) => {
      return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;
    }),
    Name: (node) => node.value,
    FragmentDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "fragment"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    InterfaceTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "interface"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    EnumTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "enum"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    EnumValueDefinition: (node) => Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node)),
    ObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "type"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    InputObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "input"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    FragmentSpread: (node) => Object.assign({ tokenizedText: [
      buildToken("plain", "..."),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    InputValueDefinition: (node) => {
      return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
    },
    FieldDefinition: (node) => {
      return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
    },
    InlineFragment: (node) => node.selectionSet
  };
}
function buildToken(kind2, value) {
  return { kind: kind2, value };
}
function concatMap(arr, fn) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    const x2 = fn(arr[i], i);
    if (Array.isArray(x2)) {
      res.push(...x2);
    } else {
      res.push(x2);
    }
  }
  return res;
}
function getHoverInformation(schema, queryText, cursor, contextToken, config2) {
  const token2 = contextToken || getTokenAtPosition(queryText, cursor);
  if (!schema || !token2 || !token2.state) {
    return "";
  }
  const state = token2.state;
  const kind2 = state.kind;
  const step = state.step;
  const typeInfo = getTypeInfo$3(schema, token2.state);
  const options = Object.assign(Object.assign({}, config2), { schema });
  if (kind2 === "Field" && step === 0 && typeInfo.fieldDef || kind2 === "AliasedField" && step === 2 && typeInfo.fieldDef) {
    const into = [];
    renderMdCodeStart(into, options);
    renderField$1(into, typeInfo, options);
    renderMdCodeEnd(into, options);
    renderDescription$1(into, options, typeInfo.fieldDef);
    return into.join("").trim();
  } else if (kind2 === "Directive" && step === 1 && typeInfo.directiveDef) {
    const into = [];
    renderMdCodeStart(into, options);
    renderDirective$1(into, typeInfo);
    renderMdCodeEnd(into, options);
    renderDescription$1(into, options, typeInfo.directiveDef);
    return into.join("").trim();
  } else if (kind2 === "Argument" && step === 0 && typeInfo.argDef) {
    const into = [];
    renderMdCodeStart(into, options);
    renderArg$1(into, typeInfo, options);
    renderMdCodeEnd(into, options);
    renderDescription$1(into, options, typeInfo.argDef);
    return into.join("").trim();
  } else if (kind2 === "EnumValue" && typeInfo.enumValue && "description" in typeInfo.enumValue) {
    const into = [];
    renderMdCodeStart(into, options);
    renderEnumValue$1(into, typeInfo, options);
    renderMdCodeEnd(into, options);
    renderDescription$1(into, options, typeInfo.enumValue);
    return into.join("").trim();
  } else if (kind2 === "NamedType" && typeInfo.type && "description" in typeInfo.type) {
    const into = [];
    renderMdCodeStart(into, options);
    renderType$3(into, typeInfo, options, typeInfo.type);
    renderMdCodeEnd(into, options);
    renderDescription$1(into, options, typeInfo.type);
    return into.join("").trim();
  }
  return "";
}
function renderMdCodeStart(into, options) {
  if (options.useMarkdown) {
    text$2(into, "```graphql\n");
  }
}
function renderMdCodeEnd(into, options) {
  if (options.useMarkdown) {
    text$2(into, "\n```");
  }
}
function renderField$1(into, typeInfo, options) {
  renderQualifiedField$1(into, typeInfo, options);
  renderTypeAnnotation$1(into, typeInfo, options, typeInfo.type);
}
function renderQualifiedField$1(into, typeInfo, options) {
  if (!typeInfo.fieldDef) {
    return;
  }
  const fieldName = typeInfo.fieldDef.name;
  if (fieldName.slice(0, 2) !== "__") {
    renderType$3(into, typeInfo, options, typeInfo.parentType);
    text$2(into, ".");
  }
  text$2(into, fieldName);
}
function renderDirective$1(into, typeInfo, _options) {
  if (!typeInfo.directiveDef) {
    return;
  }
  const name2 = "@" + typeInfo.directiveDef.name;
  text$2(into, name2);
}
function renderArg$1(into, typeInfo, options) {
  if (typeInfo.directiveDef) {
    renderDirective$1(into, typeInfo);
  } else if (typeInfo.fieldDef) {
    renderQualifiedField$1(into, typeInfo, options);
  }
  if (!typeInfo.argDef) {
    return;
  }
  const name2 = typeInfo.argDef.name;
  text$2(into, "(");
  text$2(into, name2);
  renderTypeAnnotation$1(into, typeInfo, options, typeInfo.inputType);
  text$2(into, ")");
}
function renderTypeAnnotation$1(into, typeInfo, options, t2) {
  text$2(into, ": ");
  renderType$3(into, typeInfo, options, t2);
}
function renderEnumValue$1(into, typeInfo, options) {
  if (!typeInfo.enumValue) {
    return;
  }
  const name2 = typeInfo.enumValue.name;
  renderType$3(into, typeInfo, options, typeInfo.inputType);
  text$2(into, ".");
  text$2(into, name2);
}
function renderType$3(into, typeInfo, options, t2) {
  if (!t2) {
    return;
  }
  if (t2 instanceof GraphQLNonNull) {
    renderType$3(into, typeInfo, options, t2.ofType);
    text$2(into, "!");
  } else if (t2 instanceof GraphQLList) {
    text$2(into, "[");
    renderType$3(into, typeInfo, options, t2.ofType);
    text$2(into, "]");
  } else {
    text$2(into, t2.name);
  }
}
function renderDescription$1(into, options, def) {
  if (!def) {
    return;
  }
  const description = typeof def.description === "string" ? def.description : null;
  if (description) {
    text$2(into, "\n\n");
    text$2(into, description);
  }
  renderDeprecation$1(into, options, def);
}
function renderDeprecation$1(into, _options, def) {
  if (!def) {
    return;
  }
  const reason = def.deprecationReason ? def.deprecationReason : null;
  if (!reason) {
    return;
  }
  text$2(into, "\n\n");
  text$2(into, "Deprecated: ");
  text$2(into, reason);
}
function text$2(into, content) {
  into.push(content);
}
var __awaiter$2 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
const { FRAGMENT_DEFINITION, OBJECT_TYPE_DEFINITION, INTERFACE_TYPE_DEFINITION, ENUM_TYPE_DEFINITION, UNION_TYPE_DEFINITION, SCALAR_TYPE_DEFINITION, INPUT_OBJECT_TYPE_DEFINITION, SCALAR_TYPE_EXTENSION, OBJECT_TYPE_EXTENSION, INTERFACE_TYPE_EXTENSION, UNION_TYPE_EXTENSION, ENUM_TYPE_EXTENSION, INPUT_OBJECT_TYPE_EXTENSION, DIRECTIVE_DEFINITION, FRAGMENT_SPREAD, OPERATION_DEFINITION, NAMED_TYPE } = Kind;
const KIND_TO_SYMBOL_KIND = {
  [Kind.FIELD]: SymbolKind.Field,
  [Kind.OPERATION_DEFINITION]: SymbolKind.Class,
  [Kind.FRAGMENT_DEFINITION]: SymbolKind.Class,
  [Kind.FRAGMENT_SPREAD]: SymbolKind.Struct,
  [Kind.OBJECT_TYPE_DEFINITION]: SymbolKind.Class,
  [Kind.ENUM_TYPE_DEFINITION]: SymbolKind.Enum,
  [Kind.ENUM_VALUE_DEFINITION]: SymbolKind.EnumMember,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: SymbolKind.Class,
  [Kind.INPUT_VALUE_DEFINITION]: SymbolKind.Field,
  [Kind.FIELD_DEFINITION]: SymbolKind.Field,
  [Kind.INTERFACE_TYPE_DEFINITION]: SymbolKind.Interface,
  [Kind.DOCUMENT]: SymbolKind.File,
  FieldWithArguments: SymbolKind.Method
};
function getKind(tree) {
  if (tree.kind === "FieldDefinition" && tree.children && tree.children.length > 0) {
    return KIND_TO_SYMBOL_KIND.FieldWithArguments;
  }
  return KIND_TO_SYMBOL_KIND[tree.kind];
}
class GraphQLLanguageService {
  constructor(cache) {
    this._graphQLCache = cache;
    this._graphQLConfig = cache.getGraphQLConfig();
  }
  getConfigForURI(uri) {
    const config2 = this._graphQLCache.getProjectForFile(uri);
    if (config2) {
      return config2;
    }
    throw Error(`No config found for uri: ${uri}`);
  }
  getDiagnostics(query, uri, isRelayCompatMode) {
    return __awaiter$2(this, void 0, void 0, function* () {
      let queryHasExtensions = false;
      const projectConfig = this.getConfigForURI(uri);
      if (!projectConfig) {
        return [];
      }
      const { schema: schemaPath, name: projectName, extensions } = projectConfig;
      try {
        const queryAST = parse$1(query);
        if (!schemaPath || uri !== schemaPath) {
          queryHasExtensions = queryAST.definitions.some((definition) => {
            switch (definition.kind) {
              case OBJECT_TYPE_DEFINITION:
              case INTERFACE_TYPE_DEFINITION:
              case ENUM_TYPE_DEFINITION:
              case UNION_TYPE_DEFINITION:
              case SCALAR_TYPE_DEFINITION:
              case INPUT_OBJECT_TYPE_DEFINITION:
              case SCALAR_TYPE_EXTENSION:
              case OBJECT_TYPE_EXTENSION:
              case INTERFACE_TYPE_EXTENSION:
              case UNION_TYPE_EXTENSION:
              case ENUM_TYPE_EXTENSION:
              case INPUT_OBJECT_TYPE_EXTENSION:
              case DIRECTIVE_DEFINITION:
                return true;
            }
            return false;
          });
        }
      } catch (error2) {
        const range2 = getRange(error2.locations[0], query);
        return [
          {
            severity: DIAGNOSTIC_SEVERITY.Error,
            message: error2.message,
            source: "GraphQL: Syntax",
            range: range2
          }
        ];
      }
      let source = query;
      const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);
      const fragmentDependencies = yield this._graphQLCache.getFragmentDependencies(query, fragmentDefinitions);
      const dependenciesSource = fragmentDependencies.reduce((prev, cur) => `${prev} ${print(cur.definition)}`, "");
      source = `${source} ${dependenciesSource}`;
      let validationAst = null;
      try {
        validationAst = parse$1(source);
      } catch (error2) {
        return [];
      }
      let customRules = null;
      if ((extensions === null || extensions === void 0 ? void 0 : extensions.customValidationRules) && typeof extensions.customValidationRules === "function") {
        customRules = extensions.customValidationRules(this._graphQLConfig);
      }
      const schema = yield this._graphQLCache.getSchema(projectName, queryHasExtensions);
      if (!schema) {
        return [];
      }
      return validateQuery(validationAst, schema, customRules, isRelayCompatMode);
    });
  }
  getAutocompleteSuggestions(query, position, filePath) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const projectConfig = this.getConfigForURI(filePath);
      const schema = yield this._graphQLCache.getSchema(projectConfig.name);
      const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);
      const fragmentInfo = Array.from(fragmentDefinitions).map(([, info2]) => info2.definition);
      if (schema) {
        return getAutocompleteSuggestions(schema, query, position, void 0, fragmentInfo);
      }
      return [];
    });
  }
  getHoverInformation(query, position, filePath, options) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const projectConfig = this.getConfigForURI(filePath);
      const schema = yield this._graphQLCache.getSchema(projectConfig.name);
      if (schema) {
        return getHoverInformation(schema, query, position, void 0, options);
      }
      return "";
    });
  }
  getDefinition(query, position, filePath) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const projectConfig = this.getConfigForURI(filePath);
      let ast2;
      try {
        ast2 = parse$1(query);
      } catch (error2) {
        return null;
      }
      const node = getASTNodeAtPosition(query, ast2, position);
      if (node) {
        switch (node.kind) {
          case FRAGMENT_SPREAD:
            return this._getDefinitionForFragmentSpread(query, ast2, node, filePath, projectConfig);
          case FRAGMENT_DEFINITION:
          case OPERATION_DEFINITION:
            return getDefinitionQueryResultForDefinitionNode(filePath, query, node);
          case NAMED_TYPE:
            return this._getDefinitionForNamedType(query, ast2, node, filePath, projectConfig);
        }
      }
      return null;
    });
  }
  getDocumentSymbols(document2, filePath) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const outline = yield this.getOutline(document2);
      if (!outline) {
        return [];
      }
      const output = [];
      const input = outline.outlineTrees.map((tree) => [null, tree]);
      while (input.length > 0) {
        const res = input.pop();
        if (!res) {
          return [];
        }
        const [parent, tree] = res;
        if (!tree) {
          return [];
        }
        output.push({
          name: tree.representativeName,
          kind: getKind(tree),
          location: {
            uri: filePath,
            range: {
              start: tree.startPosition,
              end: tree.endPosition
            }
          },
          containerName: parent ? parent.representativeName : void 0
        });
        input.push(...tree.children.map((child) => [tree, child]));
      }
      return output;
    });
  }
  _getDefinitionForNamedType(query, ast2, node, filePath, projectConfig) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const objectTypeDefinitions = yield this._graphQLCache.getObjectTypeDefinitions(projectConfig);
      const dependencies = yield this._graphQLCache.getObjectTypeDependenciesForAST(ast2, objectTypeDefinitions);
      const localObjectTypeDefinitions = ast2.definitions.filter((definition) => definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION || definition.kind === SCALAR_TYPE_DEFINITION || definition.kind === INTERFACE_TYPE_DEFINITION);
      const typeCastedDefs = localObjectTypeDefinitions;
      const localOperationDefinationInfos = typeCastedDefs.map((definition) => ({
        filePath,
        content: query,
        definition
      }));
      const result2 = yield getDefinitionQueryResultForNamedType(query, node, dependencies.concat(localOperationDefinationInfos));
      return result2;
    });
  }
  _getDefinitionForFragmentSpread(query, ast2, node, filePath, projectConfig) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);
      const dependencies = yield this._graphQLCache.getFragmentDependenciesForAST(ast2, fragmentDefinitions);
      const localFragDefinitions = ast2.definitions.filter((definition) => definition.kind === FRAGMENT_DEFINITION);
      const typeCastedDefs = localFragDefinitions;
      const localFragInfos = typeCastedDefs.map((definition) => ({
        filePath,
        content: query,
        definition
      }));
      const result2 = yield getDefinitionQueryResultForFragmentSpread(query, node, dependencies.concat(localFragInfos));
      return result2;
    });
  }
  getOutline(documentText) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return getOutline(documentText);
    });
  }
}
const FileChangeTypeKind = {
  Created: 1,
  Changed: 2,
  Deleted: 3
};
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
var esm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  getAutocompleteSuggestions,
  getDefinitionQueryResultForDefinitionNode,
  getDefinitionQueryResultForFragmentSpread,
  getDefinitionQueryResultForNamedType,
  getDefinitionState,
  getDiagnostics,
  getFieldDef: getFieldDef$1,
  getFragmentDefinitions,
  getHoverInformation,
  getOutline,
  getRange,
  getTokenAtPosition,
  getTypeInfo: getTypeInfo$3,
  getVariableCompletions,
  GraphQLLanguageService,
  SEVERITY: SEVERITY$1,
  DIAGNOSTIC_SEVERITY,
  canUseDirective,
  SuggestionCommand,
  onlineParser,
  ParseRules: ParseRules$2,
  CharacterStream,
  RuleKinds,
  LexRules: LexRules$2,
  isIgnored,
  p,
  list: list$1,
  t,
  opt,
  get CompletionItemKind() {
    return CompletionItemKind;
  },
  FileChangeTypeKind,
  getASTNodeAtPosition,
  getFragmentDependencies,
  getFragmentDependenciesForAST,
  getOperationASTFacts,
  getOperationFacts,
  getQueryFacts,
  getVariablesJSONSchema,
  offsetToPosition,
  pointToOffset,
  Position,
  collectVariables,
  validateWithCustomRules,
  Range
});
var __extends$f = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ExecuteButton = function(_super2) {
  __extends$f(ExecuteButton2, _super2);
  function ExecuteButton2(props) {
    var _this = _super2.call(this, props) || this;
    _this._onClick = function() {
      if (_this.props.isRunning) {
        _this.props.onStop();
      } else {
        _this.props.onRun();
      }
    };
    _this._onOptionSelected = function(operation) {
      _this.setState({ optionsOpen: false });
      _this.props.onRun(operation.name && operation.name.value);
    };
    _this._onOptionsOpen = function(downEvent) {
      var initialPress = true;
      var downTarget = downEvent.currentTarget;
      _this.setState({ highlight: null, optionsOpen: true });
      var onMouseUp = function(upEvent) {
        var _a2;
        if (initialPress && upEvent.target === downTarget) {
          initialPress = false;
        } else {
          document.removeEventListener("mouseup", onMouseUp);
          onMouseUp = null;
          var isOptionsMenuClicked = upEvent.currentTarget && ((_a2 = downTarget.parentNode) === null || _a2 === void 0 ? void 0 : _a2.compareDocumentPosition(upEvent.currentTarget)) && Node.DOCUMENT_POSITION_CONTAINED_BY;
          if (!isOptionsMenuClicked) {
            _this.setState({ optionsOpen: false });
          }
        }
      };
      document.addEventListener("mouseup", onMouseUp);
    };
    _this.state = {
      optionsOpen: false,
      highlight: null
    };
    return _this;
  }
  ExecuteButton2.prototype.render = function() {
    var _this = this;
    var operations = this.props.operations || [];
    var optionsOpen = this.state.optionsOpen;
    var hasOptions = operations && operations.length > 1;
    var options = null;
    if (hasOptions && optionsOpen) {
      var highlight_1 = this.state.highlight;
      options = React$1.createElement("ul", { className: "execute-options" }, operations.map(function(operation, i) {
        var opName = operation.name ? operation.name.value : "<Unnamed " + operation.operation + ">";
        return React$1.createElement("li", { key: opName + "-" + i, className: operation === highlight_1 ? "selected" : void 0, onMouseOver: function() {
          return _this.setState({ highlight: operation });
        }, onMouseOut: function() {
          return _this.setState({ highlight: null });
        }, onMouseUp: function() {
          return _this._onOptionSelected(operation);
        } }, opName);
      }));
    }
    var onClick;
    if (this.props.isRunning || !hasOptions) {
      onClick = this._onClick;
    }
    var onMouseDown = function() {
    };
    if (!this.props.isRunning && hasOptions && !optionsOpen) {
      onMouseDown = this._onOptionsOpen;
    }
    var pathJSX = this.props.isRunning ? React$1.createElement("path", { d: "M 10 10 L 23 10 L 23 23 L 10 23 z" }) : React$1.createElement("path", { d: "M 11 9 L 24 16 L 11 23 z" });
    return React$1.createElement("div", { className: "execute-button-wrap" }, React$1.createElement("button", { type: "button", className: "execute-button", onMouseDown, onClick, title: "Execute Query (Ctrl-Enter)" }, React$1.createElement("svg", { width: "34", height: "34" }, pathJSX)), options);
  };
  return ExecuteButton2;
}(React$1.Component);
var __extends$e = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function tokenToURL(token2) {
  if (token2.type !== "string") {
    return;
  }
  var value = token2.string.slice(1).slice(0, -1).trim();
  try {
    var location_1 = window.location;
    return new URL(value, location_1.protocol + "//" + location_1.host);
  } catch (err) {
    return;
  }
}
function isImageURL(url) {
  return /(bmp|gif|jpeg|jpg|png|svg)$/.test(url.pathname);
}
var ImagePreview = function(_super2) {
  __extends$e(ImagePreview2, _super2);
  function ImagePreview2() {
    var _this = _super2 !== null && _super2.apply(this, arguments) || this;
    _this._node = null;
    _this.state = {
      width: null,
      height: null,
      src: null,
      mime: null
    };
    return _this;
  }
  ImagePreview2.shouldRender = function(token2) {
    var url = tokenToURL(token2);
    return url ? isImageURL(url) : false;
  };
  ImagePreview2.prototype.componentDidMount = function() {
    this._updateMetadata();
  };
  ImagePreview2.prototype.componentDidUpdate = function() {
    this._updateMetadata();
  };
  ImagePreview2.prototype.render = function() {
    var _this = this;
    var _a2;
    var dims = null;
    if (this.state.width !== null && this.state.height !== null) {
      var dimensions = this.state.width + "x" + this.state.height;
      if (this.state.mime !== null) {
        dimensions += " " + this.state.mime;
      }
      dims = React$1.createElement("div", null, dimensions);
    }
    return React$1.createElement("div", null, React$1.createElement("img", { onLoad: function() {
      return _this._updateMetadata();
    }, ref: function(node) {
      _this._node = node;
    }, src: (_a2 = tokenToURL(this.props.token)) === null || _a2 === void 0 ? void 0 : _a2.href }), dims);
  };
  ImagePreview2.prototype._updateMetadata = function() {
    var _this = this;
    if (!this._node) {
      return;
    }
    var width = this._node.naturalWidth;
    var height = this._node.naturalHeight;
    var src = this._node.src;
    if (src !== this.state.src) {
      this.setState({ src });
      fetch(src, { method: "HEAD" }).then(function(response) {
        _this.setState({
          mime: response.headers.get("Content-Type")
        });
      });
    }
    if (width !== this.state.width || height !== this.state.height) {
      this.setState({ height, width });
    }
  };
  return ImagePreview2;
}(React$1.Component);
var __extends$d = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ToolbarButton = function(_super2) {
  __extends$d(ToolbarButton2, _super2);
  function ToolbarButton2(props) {
    var _this = _super2.call(this, props) || this;
    _this.handleClick = function() {
      try {
        _this.props.onClick();
        _this.setState({ error: null });
      } catch (error2) {
        _this.setState({ error: error2 });
      }
    };
    _this.state = { error: null };
    return _this;
  }
  ToolbarButton2.prototype.render = function() {
    var error2 = this.state.error;
    return React$1.createElement("button", { className: "toolbar-button" + (error2 ? " error" : ""), onClick: this.handleClick, title: error2 ? error2.message : this.props.title, "aria-invalid": error2 ? "true" : "false" }, this.props.label);
  };
  return ToolbarButton2;
}(React$1.Component);
function ToolbarGroup(_a2) {
  var children = _a2.children;
  return React$1.createElement("div", { className: "toolbar-button-group" }, children);
}
var __extends$c = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ToolbarMenu = function(_super2) {
  __extends$c(ToolbarMenu2, _super2);
  function ToolbarMenu2(props) {
    var _this = _super2.call(this, props) || this;
    _this._node = null;
    _this._listener = null;
    _this.handleOpen = function(e) {
      preventDefault$1(e);
      _this.setState({ visible: true });
      _this._subscribe();
    };
    _this.state = { visible: false };
    return _this;
  }
  ToolbarMenu2.prototype.componentWillUnmount = function() {
    this._release();
  };
  ToolbarMenu2.prototype.render = function() {
    var _this = this;
    var visible = this.state.visible;
    return React$1.createElement("a", { className: "toolbar-menu toolbar-button", onClick: this.handleOpen.bind(this), onMouseDown: preventDefault$1, ref: function(node) {
      if (node) {
        _this._node = node;
      }
    }, title: this.props.title }, this.props.label, React$1.createElement("svg", { width: "14", height: "8" }, React$1.createElement("path", { fill: "#666", d: "M 5 1.5 L 14 1.5 L 9.5 7 z" })), React$1.createElement("ul", { className: "toolbar-menu-items" + (visible ? " open" : "") }, this.props.children));
  };
  ToolbarMenu2.prototype._subscribe = function() {
    if (!this._listener) {
      this._listener = this.handleClick.bind(this);
      document.addEventListener("click", this._listener);
    }
  };
  ToolbarMenu2.prototype._release = function() {
    if (this._listener) {
      document.removeEventListener("click", this._listener);
      this._listener = null;
    }
  };
  ToolbarMenu2.prototype.handleClick = function(e) {
    if (this._node !== e.target) {
      e.preventDefault();
      this.setState({ visible: false });
      this._release();
    }
  };
  return ToolbarMenu2;
}(React$1.Component);
var ToolbarMenuItem = function(_a2) {
  var onSelect = _a2.onSelect, title = _a2.title, label = _a2.label;
  return React$1.createElement("li", { onMouseOver: function(e) {
    e.currentTarget.className = "hover";
  }, onMouseOut: function(e) {
    e.currentTarget.className = "";
  }, onMouseDown: preventDefault$1, onMouseUp: onSelect, title }, label);
};
function preventDefault$1(e) {
  e.preventDefault();
}
var utils$1 = {};
const Aacute = "\xC1";
const aacute = "\xE1";
const Abreve = "\u0102";
const abreve = "\u0103";
const ac = "\u223E";
const acd = "\u223F";
const acE = "\u223E\u0333";
const Acirc = "\xC2";
const acirc = "\xE2";
const acute = "\xB4";
const Acy = "\u0410";
const acy = "\u0430";
const AElig = "\xC6";
const aelig = "\xE6";
const af = "\u2061";
const Afr = "\u{1D504}";
const afr = "\u{1D51E}";
const Agrave = "\xC0";
const agrave = "\xE0";
const alefsym = "\u2135";
const aleph = "\u2135";
const Alpha = "\u0391";
const alpha = "\u03B1";
const Amacr = "\u0100";
const amacr = "\u0101";
const amalg = "\u2A3F";
const amp = "&";
const AMP = "&";
const andand = "\u2A55";
const And = "\u2A53";
const and = "\u2227";
const andd = "\u2A5C";
const andslope = "\u2A58";
const andv = "\u2A5A";
const ang = "\u2220";
const ange = "\u29A4";
const angle = "\u2220";
const angmsdaa = "\u29A8";
const angmsdab = "\u29A9";
const angmsdac = "\u29AA";
const angmsdad = "\u29AB";
const angmsdae = "\u29AC";
const angmsdaf = "\u29AD";
const angmsdag = "\u29AE";
const angmsdah = "\u29AF";
const angmsd = "\u2221";
const angrt = "\u221F";
const angrtvb = "\u22BE";
const angrtvbd = "\u299D";
const angsph = "\u2222";
const angst = "\xC5";
const angzarr = "\u237C";
const Aogon = "\u0104";
const aogon = "\u0105";
const Aopf = "\u{1D538}";
const aopf = "\u{1D552}";
const apacir = "\u2A6F";
const ap = "\u2248";
const apE = "\u2A70";
const ape = "\u224A";
const apid = "\u224B";
const apos = "'";
const ApplyFunction = "\u2061";
const approx = "\u2248";
const approxeq = "\u224A";
const Aring = "\xC5";
const aring = "\xE5";
const Ascr = "\u{1D49C}";
const ascr = "\u{1D4B6}";
const Assign = "\u2254";
const ast = "*";
const asymp = "\u2248";
const asympeq = "\u224D";
const Atilde = "\xC3";
const atilde = "\xE3";
const Auml = "\xC4";
const auml = "\xE4";
const awconint = "\u2233";
const awint = "\u2A11";
const backcong = "\u224C";
const backepsilon = "\u03F6";
const backprime = "\u2035";
const backsim = "\u223D";
const backsimeq = "\u22CD";
const Backslash = "\u2216";
const Barv = "\u2AE7";
const barvee = "\u22BD";
const barwed = "\u2305";
const Barwed = "\u2306";
const barwedge = "\u2305";
const bbrk = "\u23B5";
const bbrktbrk = "\u23B6";
const bcong = "\u224C";
const Bcy = "\u0411";
const bcy = "\u0431";
const bdquo = "\u201E";
const becaus = "\u2235";
const because = "\u2235";
const Because = "\u2235";
const bemptyv = "\u29B0";
const bepsi = "\u03F6";
const bernou = "\u212C";
const Bernoullis = "\u212C";
const Beta = "\u0392";
const beta = "\u03B2";
const beth = "\u2136";
const between = "\u226C";
const Bfr = "\u{1D505}";
const bfr = "\u{1D51F}";
const bigcap = "\u22C2";
const bigcirc = "\u25EF";
const bigcup = "\u22C3";
const bigodot = "\u2A00";
const bigoplus = "\u2A01";
const bigotimes = "\u2A02";
const bigsqcup = "\u2A06";
const bigstar = "\u2605";
const bigtriangledown = "\u25BD";
const bigtriangleup = "\u25B3";
const biguplus = "\u2A04";
const bigvee = "\u22C1";
const bigwedge = "\u22C0";
const bkarow = "\u290D";
const blacklozenge = "\u29EB";
const blacksquare = "\u25AA";
const blacktriangle = "\u25B4";
const blacktriangledown = "\u25BE";
const blacktriangleleft = "\u25C2";
const blacktriangleright = "\u25B8";
const blank = "\u2423";
const blk12 = "\u2592";
const blk14 = "\u2591";
const blk34 = "\u2593";
const block$2 = "\u2588";
const bne = "=\u20E5";
const bnequiv = "\u2261\u20E5";
const bNot = "\u2AED";
const bnot = "\u2310";
const Bopf = "\u{1D539}";
const bopf = "\u{1D553}";
const bot = "\u22A5";
const bottom = "\u22A5";
const bowtie = "\u22C8";
const boxbox = "\u29C9";
const boxdl = "\u2510";
const boxdL = "\u2555";
const boxDl = "\u2556";
const boxDL = "\u2557";
const boxdr = "\u250C";
const boxdR = "\u2552";
const boxDr = "\u2553";
const boxDR = "\u2554";
const boxh = "\u2500";
const boxH = "\u2550";
const boxhd = "\u252C";
const boxHd = "\u2564";
const boxhD = "\u2565";
const boxHD = "\u2566";
const boxhu = "\u2534";
const boxHu = "\u2567";
const boxhU = "\u2568";
const boxHU = "\u2569";
const boxminus = "\u229F";
const boxplus = "\u229E";
const boxtimes = "\u22A0";
const boxul = "\u2518";
const boxuL = "\u255B";
const boxUl = "\u255C";
const boxUL = "\u255D";
const boxur = "\u2514";
const boxuR = "\u2558";
const boxUr = "\u2559";
const boxUR = "\u255A";
const boxv = "\u2502";
const boxV = "\u2551";
const boxvh = "\u253C";
const boxvH = "\u256A";
const boxVh = "\u256B";
const boxVH = "\u256C";
const boxvl = "\u2524";
const boxvL = "\u2561";
const boxVl = "\u2562";
const boxVL = "\u2563";
const boxvr = "\u251C";
const boxvR = "\u255E";
const boxVr = "\u255F";
const boxVR = "\u2560";
const bprime = "\u2035";
const breve = "\u02D8";
const Breve = "\u02D8";
const brvbar = "\xA6";
const bscr = "\u{1D4B7}";
const Bscr = "\u212C";
const bsemi = "\u204F";
const bsim = "\u223D";
const bsime = "\u22CD";
const bsolb = "\u29C5";
const bsol = "\\";
const bsolhsub = "\u27C8";
const bull = "\u2022";
const bullet = "\u2022";
const bump = "\u224E";
const bumpE = "\u2AAE";
const bumpe = "\u224F";
const Bumpeq = "\u224E";
const bumpeq = "\u224F";
const Cacute = "\u0106";
const cacute = "\u0107";
const capand = "\u2A44";
const capbrcup = "\u2A49";
const capcap = "\u2A4B";
const cap = "\u2229";
const Cap = "\u22D2";
const capcup = "\u2A47";
const capdot = "\u2A40";
const CapitalDifferentialD = "\u2145";
const caps = "\u2229\uFE00";
const caret = "\u2041";
const caron = "\u02C7";
const Cayleys = "\u212D";
const ccaps = "\u2A4D";
const Ccaron = "\u010C";
const ccaron = "\u010D";
const Ccedil = "\xC7";
const ccedil = "\xE7";
const Ccirc = "\u0108";
const ccirc = "\u0109";
const Cconint = "\u2230";
const ccups = "\u2A4C";
const ccupssm = "\u2A50";
const Cdot = "\u010A";
const cdot = "\u010B";
const cedil = "\xB8";
const Cedilla = "\xB8";
const cemptyv = "\u29B2";
const cent = "\xA2";
const centerdot = "\xB7";
const CenterDot = "\xB7";
const cfr = "\u{1D520}";
const Cfr = "\u212D";
const CHcy = "\u0427";
const chcy = "\u0447";
const check = "\u2713";
const checkmark = "\u2713";
const Chi = "\u03A7";
const chi = "\u03C7";
const circ = "\u02C6";
const circeq = "\u2257";
const circlearrowleft = "\u21BA";
const circlearrowright = "\u21BB";
const circledast = "\u229B";
const circledcirc = "\u229A";
const circleddash = "\u229D";
const CircleDot = "\u2299";
const circledR = "\xAE";
const circledS = "\u24C8";
const CircleMinus = "\u2296";
const CirclePlus = "\u2295";
const CircleTimes = "\u2297";
const cir = "\u25CB";
const cirE = "\u29C3";
const cire = "\u2257";
const cirfnint = "\u2A10";
const cirmid = "\u2AEF";
const cirscir = "\u29C2";
const ClockwiseContourIntegral = "\u2232";
const CloseCurlyDoubleQuote = "\u201D";
const CloseCurlyQuote = "\u2019";
const clubs = "\u2663";
const clubsuit = "\u2663";
const colon = ":";
const Colon = "\u2237";
const Colone = "\u2A74";
const colone = "\u2254";
const coloneq = "\u2254";
const comma = ",";
const commat = "@";
const comp = "\u2201";
const compfn = "\u2218";
const complement = "\u2201";
const complexes = "\u2102";
const cong = "\u2245";
const congdot = "\u2A6D";
const Congruent = "\u2261";
const conint = "\u222E";
const Conint = "\u222F";
const ContourIntegral = "\u222E";
const copf = "\u{1D554}";
const Copf = "\u2102";
const coprod = "\u2210";
const Coproduct = "\u2210";
const copy = "\xA9";
const COPY = "\xA9";
const copysr = "\u2117";
const CounterClockwiseContourIntegral = "\u2233";
const crarr = "\u21B5";
const cross = "\u2717";
const Cross = "\u2A2F";
const Cscr = "\u{1D49E}";
const cscr = "\u{1D4B8}";
const csub = "\u2ACF";
const csube = "\u2AD1";
const csup = "\u2AD0";
const csupe = "\u2AD2";
const ctdot = "\u22EF";
const cudarrl = "\u2938";
const cudarrr = "\u2935";
const cuepr = "\u22DE";
const cuesc = "\u22DF";
const cularr = "\u21B6";
const cularrp = "\u293D";
const cupbrcap = "\u2A48";
const cupcap = "\u2A46";
const CupCap = "\u224D";
const cup = "\u222A";
const Cup = "\u22D3";
const cupcup = "\u2A4A";
const cupdot = "\u228D";
const cupor = "\u2A45";
const cups = "\u222A\uFE00";
const curarr = "\u21B7";
const curarrm = "\u293C";
const curlyeqprec = "\u22DE";
const curlyeqsucc = "\u22DF";
const curlyvee = "\u22CE";
const curlywedge = "\u22CF";
const curren = "\xA4";
const curvearrowleft = "\u21B6";
const curvearrowright = "\u21B7";
const cuvee = "\u22CE";
const cuwed = "\u22CF";
const cwconint = "\u2232";
const cwint = "\u2231";
const cylcty = "\u232D";
const dagger = "\u2020";
const Dagger = "\u2021";
const daleth = "\u2138";
const darr = "\u2193";
const Darr = "\u21A1";
const dArr = "\u21D3";
const dash = "\u2010";
const Dashv = "\u2AE4";
const dashv = "\u22A3";
const dbkarow = "\u290F";
const dblac = "\u02DD";
const Dcaron = "\u010E";
const dcaron = "\u010F";
const Dcy = "\u0414";
const dcy = "\u0434";
const ddagger = "\u2021";
const ddarr = "\u21CA";
const DD = "\u2145";
const dd = "\u2146";
const DDotrahd = "\u2911";
const ddotseq = "\u2A77";
const deg = "\xB0";
const Del = "\u2207";
const Delta = "\u0394";
const delta = "\u03B4";
const demptyv = "\u29B1";
const dfisht = "\u297F";
const Dfr = "\u{1D507}";
const dfr = "\u{1D521}";
const dHar = "\u2965";
const dharl = "\u21C3";
const dharr = "\u21C2";
const DiacriticalAcute = "\xB4";
const DiacriticalDot = "\u02D9";
const DiacriticalDoubleAcute = "\u02DD";
const DiacriticalGrave = "`";
const DiacriticalTilde = "\u02DC";
const diam = "\u22C4";
const diamond = "\u22C4";
const Diamond = "\u22C4";
const diamondsuit = "\u2666";
const diams = "\u2666";
const die = "\xA8";
const DifferentialD = "\u2146";
const digamma = "\u03DD";
const disin = "\u22F2";
const div = "\xF7";
const divide = "\xF7";
const divideontimes = "\u22C7";
const divonx = "\u22C7";
const DJcy = "\u0402";
const djcy = "\u0452";
const dlcorn = "\u231E";
const dlcrop = "\u230D";
const dollar = "$";
const Dopf = "\u{1D53B}";
const dopf = "\u{1D555}";
const Dot = "\xA8";
const dot = "\u02D9";
const DotDot = "\u20DC";
const doteq = "\u2250";
const doteqdot = "\u2251";
const DotEqual = "\u2250";
const dotminus = "\u2238";
const dotplus = "\u2214";
const dotsquare = "\u22A1";
const doublebarwedge = "\u2306";
const DoubleContourIntegral = "\u222F";
const DoubleDot = "\xA8";
const DoubleDownArrow = "\u21D3";
const DoubleLeftArrow = "\u21D0";
const DoubleLeftRightArrow = "\u21D4";
const DoubleLeftTee = "\u2AE4";
const DoubleLongLeftArrow = "\u27F8";
const DoubleLongLeftRightArrow = "\u27FA";
const DoubleLongRightArrow = "\u27F9";
const DoubleRightArrow = "\u21D2";
const DoubleRightTee = "\u22A8";
const DoubleUpArrow = "\u21D1";
const DoubleUpDownArrow = "\u21D5";
const DoubleVerticalBar = "\u2225";
const DownArrowBar = "\u2913";
const downarrow = "\u2193";
const DownArrow = "\u2193";
const Downarrow = "\u21D3";
const DownArrowUpArrow = "\u21F5";
const DownBreve = "\u0311";
const downdownarrows = "\u21CA";
const downharpoonleft = "\u21C3";
const downharpoonright = "\u21C2";
const DownLeftRightVector = "\u2950";
const DownLeftTeeVector = "\u295E";
const DownLeftVectorBar = "\u2956";
const DownLeftVector = "\u21BD";
const DownRightTeeVector = "\u295F";
const DownRightVectorBar = "\u2957";
const DownRightVector = "\u21C1";
const DownTeeArrow = "\u21A7";
const DownTee = "\u22A4";
const drbkarow = "\u2910";
const drcorn = "\u231F";
const drcrop = "\u230C";
const Dscr = "\u{1D49F}";
const dscr = "\u{1D4B9}";
const DScy = "\u0405";
const dscy = "\u0455";
const dsol = "\u29F6";
const Dstrok = "\u0110";
const dstrok = "\u0111";
const dtdot = "\u22F1";
const dtri = "\u25BF";
const dtrif = "\u25BE";
const duarr = "\u21F5";
const duhar = "\u296F";
const dwangle = "\u29A6";
const DZcy = "\u040F";
const dzcy = "\u045F";
const dzigrarr = "\u27FF";
const Eacute = "\xC9";
const eacute = "\xE9";
const easter = "\u2A6E";
const Ecaron = "\u011A";
const ecaron = "\u011B";
const Ecirc = "\xCA";
const ecirc = "\xEA";
const ecir = "\u2256";
const ecolon = "\u2255";
const Ecy = "\u042D";
const ecy = "\u044D";
const eDDot = "\u2A77";
const Edot = "\u0116";
const edot = "\u0117";
const eDot = "\u2251";
const ee = "\u2147";
const efDot = "\u2252";
const Efr = "\u{1D508}";
const efr = "\u{1D522}";
const eg = "\u2A9A";
const Egrave = "\xC8";
const egrave = "\xE8";
const egs = "\u2A96";
const egsdot = "\u2A98";
const el = "\u2A99";
const Element = "\u2208";
const elinters = "\u23E7";
const ell = "\u2113";
const els = "\u2A95";
const elsdot = "\u2A97";
const Emacr = "\u0112";
const emacr = "\u0113";
const empty = "\u2205";
const emptyset = "\u2205";
const EmptySmallSquare = "\u25FB";
const emptyv = "\u2205";
const EmptyVerySmallSquare = "\u25AB";
const emsp13 = "\u2004";
const emsp14 = "\u2005";
const emsp = "\u2003";
const ENG = "\u014A";
const eng = "\u014B";
const ensp = "\u2002";
const Eogon = "\u0118";
const eogon = "\u0119";
const Eopf = "\u{1D53C}";
const eopf = "\u{1D556}";
const epar = "\u22D5";
const eparsl = "\u29E3";
const eplus = "\u2A71";
const epsi = "\u03B5";
const Epsilon = "\u0395";
const epsilon = "\u03B5";
const epsiv = "\u03F5";
const eqcirc = "\u2256";
const eqcolon = "\u2255";
const eqsim = "\u2242";
const eqslantgtr = "\u2A96";
const eqslantless = "\u2A95";
const Equal = "\u2A75";
const equals = "=";
const EqualTilde = "\u2242";
const equest = "\u225F";
const Equilibrium = "\u21CC";
const equiv = "\u2261";
const equivDD = "\u2A78";
const eqvparsl = "\u29E5";
const erarr = "\u2971";
const erDot = "\u2253";
const escr = "\u212F";
const Escr = "\u2130";
const esdot = "\u2250";
const Esim = "\u2A73";
const esim = "\u2242";
const Eta = "\u0397";
const eta = "\u03B7";
const ETH = "\xD0";
const eth = "\xF0";
const Euml = "\xCB";
const euml = "\xEB";
const euro = "\u20AC";
const excl = "!";
const exist = "\u2203";
const Exists = "\u2203";
const expectation = "\u2130";
const exponentiale = "\u2147";
const ExponentialE = "\u2147";
const fallingdotseq = "\u2252";
const Fcy = "\u0424";
const fcy = "\u0444";
const female = "\u2640";
const ffilig = "\uFB03";
const fflig = "\uFB00";
const ffllig = "\uFB04";
const Ffr = "\u{1D509}";
const ffr = "\u{1D523}";
const filig = "\uFB01";
const FilledSmallSquare = "\u25FC";
const FilledVerySmallSquare = "\u25AA";
const fjlig = "fj";
const flat = "\u266D";
const fllig = "\uFB02";
const fltns = "\u25B1";
const fnof = "\u0192";
const Fopf = "\u{1D53D}";
const fopf = "\u{1D557}";
const forall = "\u2200";
const ForAll = "\u2200";
const fork = "\u22D4";
const forkv = "\u2AD9";
const Fouriertrf = "\u2131";
const fpartint = "\u2A0D";
const frac12 = "\xBD";
const frac13 = "\u2153";
const frac14 = "\xBC";
const frac15 = "\u2155";
const frac16 = "\u2159";
const frac18 = "\u215B";
const frac23 = "\u2154";
const frac25 = "\u2156";
const frac34 = "\xBE";
const frac35 = "\u2157";
const frac38 = "\u215C";
const frac45 = "\u2158";
const frac56 = "\u215A";
const frac58 = "\u215D";
const frac78 = "\u215E";
const frasl = "\u2044";
const frown = "\u2322";
const fscr = "\u{1D4BB}";
const Fscr = "\u2131";
const gacute = "\u01F5";
const Gamma = "\u0393";
const gamma = "\u03B3";
const Gammad = "\u03DC";
const gammad = "\u03DD";
const gap = "\u2A86";
const Gbreve = "\u011E";
const gbreve = "\u011F";
const Gcedil = "\u0122";
const Gcirc = "\u011C";
const gcirc = "\u011D";
const Gcy = "\u0413";
const gcy = "\u0433";
const Gdot = "\u0120";
const gdot = "\u0121";
const ge = "\u2265";
const gE = "\u2267";
const gEl = "\u2A8C";
const gel = "\u22DB";
const geq = "\u2265";
const geqq = "\u2267";
const geqslant = "\u2A7E";
const gescc = "\u2AA9";
const ges = "\u2A7E";
const gesdot = "\u2A80";
const gesdoto = "\u2A82";
const gesdotol = "\u2A84";
const gesl = "\u22DB\uFE00";
const gesles = "\u2A94";
const Gfr = "\u{1D50A}";
const gfr = "\u{1D524}";
const gg = "\u226B";
const Gg = "\u22D9";
const ggg = "\u22D9";
const gimel = "\u2137";
const GJcy = "\u0403";
const gjcy = "\u0453";
const gla = "\u2AA5";
const gl = "\u2277";
const glE = "\u2A92";
const glj = "\u2AA4";
const gnap = "\u2A8A";
const gnapprox = "\u2A8A";
const gne = "\u2A88";
const gnE = "\u2269";
const gneq = "\u2A88";
const gneqq = "\u2269";
const gnsim = "\u22E7";
const Gopf = "\u{1D53E}";
const gopf = "\u{1D558}";
const grave = "`";
const GreaterEqual = "\u2265";
const GreaterEqualLess = "\u22DB";
const GreaterFullEqual = "\u2267";
const GreaterGreater = "\u2AA2";
const GreaterLess = "\u2277";
const GreaterSlantEqual = "\u2A7E";
const GreaterTilde = "\u2273";
const Gscr = "\u{1D4A2}";
const gscr = "\u210A";
const gsim = "\u2273";
const gsime = "\u2A8E";
const gsiml = "\u2A90";
const gtcc = "\u2AA7";
const gtcir = "\u2A7A";
const gt = ">";
const GT = ">";
const Gt = "\u226B";
const gtdot = "\u22D7";
const gtlPar = "\u2995";
const gtquest = "\u2A7C";
const gtrapprox = "\u2A86";
const gtrarr = "\u2978";
const gtrdot = "\u22D7";
const gtreqless = "\u22DB";
const gtreqqless = "\u2A8C";
const gtrless = "\u2277";
const gtrsim = "\u2273";
const gvertneqq = "\u2269\uFE00";
const gvnE = "\u2269\uFE00";
const Hacek = "\u02C7";
const hairsp = "\u200A";
const half = "\xBD";
const hamilt = "\u210B";
const HARDcy = "\u042A";
const hardcy = "\u044A";
const harrcir = "\u2948";
const harr = "\u2194";
const hArr = "\u21D4";
const harrw = "\u21AD";
const Hat = "^";
const hbar = "\u210F";
const Hcirc = "\u0124";
const hcirc = "\u0125";
const hearts = "\u2665";
const heartsuit = "\u2665";
const hellip = "\u2026";
const hercon = "\u22B9";
const hfr = "\u{1D525}";
const Hfr = "\u210C";
const HilbertSpace = "\u210B";
const hksearow = "\u2925";
const hkswarow = "\u2926";
const hoarr = "\u21FF";
const homtht = "\u223B";
const hookleftarrow = "\u21A9";
const hookrightarrow = "\u21AA";
const hopf = "\u{1D559}";
const Hopf = "\u210D";
const horbar = "\u2015";
const HorizontalLine = "\u2500";
const hscr = "\u{1D4BD}";
const Hscr = "\u210B";
const hslash = "\u210F";
const Hstrok = "\u0126";
const hstrok = "\u0127";
const HumpDownHump = "\u224E";
const HumpEqual = "\u224F";
const hybull = "\u2043";
const hyphen = "\u2010";
const Iacute = "\xCD";
const iacute = "\xED";
const ic = "\u2063";
const Icirc = "\xCE";
const icirc = "\xEE";
const Icy = "\u0418";
const icy = "\u0438";
const Idot = "\u0130";
const IEcy = "\u0415";
const iecy = "\u0435";
const iexcl = "\xA1";
const iff = "\u21D4";
const ifr = "\u{1D526}";
const Ifr = "\u2111";
const Igrave = "\xCC";
const igrave = "\xEC";
const ii = "\u2148";
const iiiint = "\u2A0C";
const iiint = "\u222D";
const iinfin = "\u29DC";
const iiota = "\u2129";
const IJlig = "\u0132";
const ijlig = "\u0133";
const Imacr = "\u012A";
const imacr = "\u012B";
const image$1 = "\u2111";
const ImaginaryI = "\u2148";
const imagline = "\u2110";
const imagpart = "\u2111";
const imath = "\u0131";
const Im = "\u2111";
const imof = "\u22B7";
const imped = "\u01B5";
const Implies = "\u21D2";
const incare = "\u2105";
const infin = "\u221E";
const infintie = "\u29DD";
const inodot = "\u0131";
const intcal = "\u22BA";
const int = "\u222B";
const Int = "\u222C";
const integers = "\u2124";
const Integral = "\u222B";
const intercal = "\u22BA";
const Intersection = "\u22C2";
const intlarhk = "\u2A17";
const intprod = "\u2A3C";
const InvisibleComma = "\u2063";
const InvisibleTimes = "\u2062";
const IOcy = "\u0401";
const iocy = "\u0451";
const Iogon = "\u012E";
const iogon = "\u012F";
const Iopf = "\u{1D540}";
const iopf = "\u{1D55A}";
const Iota = "\u0399";
const iota = "\u03B9";
const iprod = "\u2A3C";
const iquest = "\xBF";
const iscr = "\u{1D4BE}";
const Iscr = "\u2110";
const isin = "\u2208";
const isindot = "\u22F5";
const isinE = "\u22F9";
const isins = "\u22F4";
const isinsv = "\u22F3";
const isinv = "\u2208";
const it = "\u2062";
const Itilde = "\u0128";
const itilde = "\u0129";
const Iukcy = "\u0406";
const iukcy = "\u0456";
const Iuml = "\xCF";
const iuml = "\xEF";
const Jcirc = "\u0134";
const jcirc = "\u0135";
const Jcy = "\u0419";
const jcy = "\u0439";
const Jfr = "\u{1D50D}";
const jfr = "\u{1D527}";
const jmath = "\u0237";
const Jopf = "\u{1D541}";
const jopf = "\u{1D55B}";
const Jscr = "\u{1D4A5}";
const jscr = "\u{1D4BF}";
const Jsercy = "\u0408";
const jsercy = "\u0458";
const Jukcy = "\u0404";
const jukcy = "\u0454";
const Kappa = "\u039A";
const kappa = "\u03BA";
const kappav = "\u03F0";
const Kcedil = "\u0136";
const kcedil = "\u0137";
const Kcy = "\u041A";
const kcy = "\u043A";
const Kfr = "\u{1D50E}";
const kfr = "\u{1D528}";
const kgreen = "\u0138";
const KHcy = "\u0425";
const khcy = "\u0445";
const KJcy = "\u040C";
const kjcy = "\u045C";
const Kopf = "\u{1D542}";
const kopf = "\u{1D55C}";
const Kscr = "\u{1D4A6}";
const kscr = "\u{1D4C0}";
const lAarr = "\u21DA";
const Lacute = "\u0139";
const lacute = "\u013A";
const laemptyv = "\u29B4";
const lagran = "\u2112";
const Lambda = "\u039B";
const lambda = "\u03BB";
const lang = "\u27E8";
const Lang = "\u27EA";
const langd = "\u2991";
const langle = "\u27E8";
const lap = "\u2A85";
const Laplacetrf = "\u2112";
const laquo = "\xAB";
const larrb = "\u21E4";
const larrbfs = "\u291F";
const larr = "\u2190";
const Larr = "\u219E";
const lArr = "\u21D0";
const larrfs = "\u291D";
const larrhk = "\u21A9";
const larrlp = "\u21AB";
const larrpl = "\u2939";
const larrsim = "\u2973";
const larrtl = "\u21A2";
const latail = "\u2919";
const lAtail = "\u291B";
const lat = "\u2AAB";
const late = "\u2AAD";
const lates = "\u2AAD\uFE00";
const lbarr = "\u290C";
const lBarr = "\u290E";
const lbbrk = "\u2772";
const lbrace = "{";
const lbrack = "[";
const lbrke = "\u298B";
const lbrksld = "\u298F";
const lbrkslu = "\u298D";
const Lcaron = "\u013D";
const lcaron = "\u013E";
const Lcedil = "\u013B";
const lcedil = "\u013C";
const lceil = "\u2308";
const lcub = "{";
const Lcy = "\u041B";
const lcy = "\u043B";
const ldca = "\u2936";
const ldquo = "\u201C";
const ldquor = "\u201E";
const ldrdhar = "\u2967";
const ldrushar = "\u294B";
const ldsh = "\u21B2";
const le = "\u2264";
const lE = "\u2266";
const LeftAngleBracket = "\u27E8";
const LeftArrowBar = "\u21E4";
const leftarrow = "\u2190";
const LeftArrow = "\u2190";
const Leftarrow = "\u21D0";
const LeftArrowRightArrow = "\u21C6";
const leftarrowtail = "\u21A2";
const LeftCeiling = "\u2308";
const LeftDoubleBracket = "\u27E6";
const LeftDownTeeVector = "\u2961";
const LeftDownVectorBar = "\u2959";
const LeftDownVector = "\u21C3";
const LeftFloor = "\u230A";
const leftharpoondown = "\u21BD";
const leftharpoonup = "\u21BC";
const leftleftarrows = "\u21C7";
const leftrightarrow = "\u2194";
const LeftRightArrow = "\u2194";
const Leftrightarrow = "\u21D4";
const leftrightarrows = "\u21C6";
const leftrightharpoons = "\u21CB";
const leftrightsquigarrow = "\u21AD";
const LeftRightVector = "\u294E";
const LeftTeeArrow = "\u21A4";
const LeftTee = "\u22A3";
const LeftTeeVector = "\u295A";
const leftthreetimes = "\u22CB";
const LeftTriangleBar = "\u29CF";
const LeftTriangle = "\u22B2";
const LeftTriangleEqual = "\u22B4";
const LeftUpDownVector = "\u2951";
const LeftUpTeeVector = "\u2960";
const LeftUpVectorBar = "\u2958";
const LeftUpVector = "\u21BF";
const LeftVectorBar = "\u2952";
const LeftVector = "\u21BC";
const lEg = "\u2A8B";
const leg = "\u22DA";
const leq = "\u2264";
const leqq = "\u2266";
const leqslant = "\u2A7D";
const lescc = "\u2AA8";
const les = "\u2A7D";
const lesdot = "\u2A7F";
const lesdoto = "\u2A81";
const lesdotor = "\u2A83";
const lesg = "\u22DA\uFE00";
const lesges = "\u2A93";
const lessapprox = "\u2A85";
const lessdot = "\u22D6";
const lesseqgtr = "\u22DA";
const lesseqqgtr = "\u2A8B";
const LessEqualGreater = "\u22DA";
const LessFullEqual = "\u2266";
const LessGreater = "\u2276";
const lessgtr = "\u2276";
const LessLess = "\u2AA1";
const lesssim = "\u2272";
const LessSlantEqual = "\u2A7D";
const LessTilde = "\u2272";
const lfisht = "\u297C";
const lfloor = "\u230A";
const Lfr = "\u{1D50F}";
const lfr = "\u{1D529}";
const lg = "\u2276";
const lgE = "\u2A91";
const lHar = "\u2962";
const lhard = "\u21BD";
const lharu = "\u21BC";
const lharul = "\u296A";
const lhblk = "\u2584";
const LJcy = "\u0409";
const ljcy = "\u0459";
const llarr = "\u21C7";
const ll = "\u226A";
const Ll = "\u22D8";
const llcorner = "\u231E";
const Lleftarrow = "\u21DA";
const llhard = "\u296B";
const lltri = "\u25FA";
const Lmidot = "\u013F";
const lmidot = "\u0140";
const lmoustache = "\u23B0";
const lmoust = "\u23B0";
const lnap = "\u2A89";
const lnapprox = "\u2A89";
const lne = "\u2A87";
const lnE = "\u2268";
const lneq = "\u2A87";
const lneqq = "\u2268";
const lnsim = "\u22E6";
const loang = "\u27EC";
const loarr = "\u21FD";
const lobrk = "\u27E6";
const longleftarrow = "\u27F5";
const LongLeftArrow = "\u27F5";
const Longleftarrow = "\u27F8";
const longleftrightarrow = "\u27F7";
const LongLeftRightArrow = "\u27F7";
const Longleftrightarrow = "\u27FA";
const longmapsto = "\u27FC";
const longrightarrow = "\u27F6";
const LongRightArrow = "\u27F6";
const Longrightarrow = "\u27F9";
const looparrowleft = "\u21AB";
const looparrowright = "\u21AC";
const lopar = "\u2985";
const Lopf = "\u{1D543}";
const lopf = "\u{1D55D}";
const loplus = "\u2A2D";
const lotimes = "\u2A34";
const lowast = "\u2217";
const lowbar = "_";
const LowerLeftArrow = "\u2199";
const LowerRightArrow = "\u2198";
const loz = "\u25CA";
const lozenge = "\u25CA";
const lozf = "\u29EB";
const lpar = "(";
const lparlt = "\u2993";
const lrarr = "\u21C6";
const lrcorner = "\u231F";
const lrhar = "\u21CB";
const lrhard = "\u296D";
const lrm = "\u200E";
const lrtri = "\u22BF";
const lsaquo = "\u2039";
const lscr = "\u{1D4C1}";
const Lscr = "\u2112";
const lsh = "\u21B0";
const Lsh = "\u21B0";
const lsim = "\u2272";
const lsime = "\u2A8D";
const lsimg = "\u2A8F";
const lsqb = "[";
const lsquo = "\u2018";
const lsquor = "\u201A";
const Lstrok = "\u0141";
const lstrok = "\u0142";
const ltcc = "\u2AA6";
const ltcir = "\u2A79";
const lt = "<";
const LT = "<";
const Lt = "\u226A";
const ltdot = "\u22D6";
const lthree = "\u22CB";
const ltimes = "\u22C9";
const ltlarr = "\u2976";
const ltquest = "\u2A7B";
const ltri = "\u25C3";
const ltrie = "\u22B4";
const ltrif = "\u25C2";
const ltrPar = "\u2996";
const lurdshar = "\u294A";
const luruhar = "\u2966";
const lvertneqq = "\u2268\uFE00";
const lvnE = "\u2268\uFE00";
const macr = "\xAF";
const male = "\u2642";
const malt = "\u2720";
const maltese = "\u2720";
const map$1 = "\u21A6";
const mapsto = "\u21A6";
const mapstodown = "\u21A7";
const mapstoleft = "\u21A4";
const mapstoup = "\u21A5";
const marker = "\u25AE";
const mcomma = "\u2A29";
const Mcy = "\u041C";
const mcy = "\u043C";
const mdash = "\u2014";
const mDDot = "\u223A";
const measuredangle = "\u2221";
const MediumSpace = "\u205F";
const Mellintrf = "\u2133";
const Mfr = "\u{1D510}";
const mfr = "\u{1D52A}";
const mho = "\u2127";
const micro = "\xB5";
const midast = "*";
const midcir = "\u2AF0";
const mid = "\u2223";
const middot = "\xB7";
const minusb = "\u229F";
const minus = "\u2212";
const minusd = "\u2238";
const minusdu = "\u2A2A";
const MinusPlus = "\u2213";
const mlcp = "\u2ADB";
const mldr = "\u2026";
const mnplus = "\u2213";
const models = "\u22A7";
const Mopf = "\u{1D544}";
const mopf = "\u{1D55E}";
const mp = "\u2213";
const mscr = "\u{1D4C2}";
const Mscr = "\u2133";
const mstpos = "\u223E";
const Mu = "\u039C";
const mu = "\u03BC";
const multimap = "\u22B8";
const mumap = "\u22B8";
const nabla = "\u2207";
const Nacute = "\u0143";
const nacute = "\u0144";
const nang = "\u2220\u20D2";
const nap = "\u2249";
const napE = "\u2A70\u0338";
const napid = "\u224B\u0338";
const napos = "\u0149";
const napprox = "\u2249";
const natural = "\u266E";
const naturals = "\u2115";
const natur = "\u266E";
const nbsp = "\xA0";
const nbump = "\u224E\u0338";
const nbumpe = "\u224F\u0338";
const ncap = "\u2A43";
const Ncaron = "\u0147";
const ncaron = "\u0148";
const Ncedil = "\u0145";
const ncedil = "\u0146";
const ncong = "\u2247";
const ncongdot = "\u2A6D\u0338";
const ncup = "\u2A42";
const Ncy = "\u041D";
const ncy = "\u043D";
const ndash = "\u2013";
const nearhk = "\u2924";
const nearr = "\u2197";
const neArr = "\u21D7";
const nearrow = "\u2197";
const ne = "\u2260";
const nedot = "\u2250\u0338";
const NegativeMediumSpace = "\u200B";
const NegativeThickSpace = "\u200B";
const NegativeThinSpace = "\u200B";
const NegativeVeryThinSpace = "\u200B";
const nequiv = "\u2262";
const nesear = "\u2928";
const nesim = "\u2242\u0338";
const NestedGreaterGreater = "\u226B";
const NestedLessLess = "\u226A";
const NewLine = "\n";
const nexist = "\u2204";
const nexists = "\u2204";
const Nfr = "\u{1D511}";
const nfr = "\u{1D52B}";
const ngE = "\u2267\u0338";
const nge = "\u2271";
const ngeq = "\u2271";
const ngeqq = "\u2267\u0338";
const ngeqslant = "\u2A7E\u0338";
const nges = "\u2A7E\u0338";
const nGg = "\u22D9\u0338";
const ngsim = "\u2275";
const nGt = "\u226B\u20D2";
const ngt = "\u226F";
const ngtr = "\u226F";
const nGtv = "\u226B\u0338";
const nharr = "\u21AE";
const nhArr = "\u21CE";
const nhpar = "\u2AF2";
const ni = "\u220B";
const nis = "\u22FC";
const nisd = "\u22FA";
const niv = "\u220B";
const NJcy = "\u040A";
const njcy = "\u045A";
const nlarr = "\u219A";
const nlArr = "\u21CD";
const nldr = "\u2025";
const nlE = "\u2266\u0338";
const nle = "\u2270";
const nleftarrow = "\u219A";
const nLeftarrow = "\u21CD";
const nleftrightarrow = "\u21AE";
const nLeftrightarrow = "\u21CE";
const nleq = "\u2270";
const nleqq = "\u2266\u0338";
const nleqslant = "\u2A7D\u0338";
const nles = "\u2A7D\u0338";
const nless = "\u226E";
const nLl = "\u22D8\u0338";
const nlsim = "\u2274";
const nLt = "\u226A\u20D2";
const nlt = "\u226E";
const nltri = "\u22EA";
const nltrie = "\u22EC";
const nLtv = "\u226A\u0338";
const nmid = "\u2224";
const NoBreak = "\u2060";
const NonBreakingSpace = "\xA0";
const nopf = "\u{1D55F}";
const Nopf = "\u2115";
const Not = "\u2AEC";
const not = "\xAC";
const NotCongruent = "\u2262";
const NotCupCap = "\u226D";
const NotDoubleVerticalBar = "\u2226";
const NotElement = "\u2209";
const NotEqual = "\u2260";
const NotEqualTilde = "\u2242\u0338";
const NotExists = "\u2204";
const NotGreater = "\u226F";
const NotGreaterEqual = "\u2271";
const NotGreaterFullEqual = "\u2267\u0338";
const NotGreaterGreater = "\u226B\u0338";
const NotGreaterLess = "\u2279";
const NotGreaterSlantEqual = "\u2A7E\u0338";
const NotGreaterTilde = "\u2275";
const NotHumpDownHump = "\u224E\u0338";
const NotHumpEqual = "\u224F\u0338";
const notin = "\u2209";
const notindot = "\u22F5\u0338";
const notinE = "\u22F9\u0338";
const notinva = "\u2209";
const notinvb = "\u22F7";
const notinvc = "\u22F6";
const NotLeftTriangleBar = "\u29CF\u0338";
const NotLeftTriangle = "\u22EA";
const NotLeftTriangleEqual = "\u22EC";
const NotLess = "\u226E";
const NotLessEqual = "\u2270";
const NotLessGreater = "\u2278";
const NotLessLess = "\u226A\u0338";
const NotLessSlantEqual = "\u2A7D\u0338";
const NotLessTilde = "\u2274";
const NotNestedGreaterGreater = "\u2AA2\u0338";
const NotNestedLessLess = "\u2AA1\u0338";
const notni = "\u220C";
const notniva = "\u220C";
const notnivb = "\u22FE";
const notnivc = "\u22FD";
const NotPrecedes = "\u2280";
const NotPrecedesEqual = "\u2AAF\u0338";
const NotPrecedesSlantEqual = "\u22E0";
const NotReverseElement = "\u220C";
const NotRightTriangleBar = "\u29D0\u0338";
const NotRightTriangle = "\u22EB";
const NotRightTriangleEqual = "\u22ED";
const NotSquareSubset = "\u228F\u0338";
const NotSquareSubsetEqual = "\u22E2";
const NotSquareSuperset = "\u2290\u0338";
const NotSquareSupersetEqual = "\u22E3";
const NotSubset = "\u2282\u20D2";
const NotSubsetEqual = "\u2288";
const NotSucceeds = "\u2281";
const NotSucceedsEqual = "\u2AB0\u0338";
const NotSucceedsSlantEqual = "\u22E1";
const NotSucceedsTilde = "\u227F\u0338";
const NotSuperset = "\u2283\u20D2";
const NotSupersetEqual = "\u2289";
const NotTilde = "\u2241";
const NotTildeEqual = "\u2244";
const NotTildeFullEqual = "\u2247";
const NotTildeTilde = "\u2249";
const NotVerticalBar = "\u2224";
const nparallel = "\u2226";
const npar = "\u2226";
const nparsl = "\u2AFD\u20E5";
const npart = "\u2202\u0338";
const npolint = "\u2A14";
const npr = "\u2280";
const nprcue = "\u22E0";
const nprec = "\u2280";
const npreceq = "\u2AAF\u0338";
const npre = "\u2AAF\u0338";
const nrarrc = "\u2933\u0338";
const nrarr = "\u219B";
const nrArr = "\u21CF";
const nrarrw = "\u219D\u0338";
const nrightarrow = "\u219B";
const nRightarrow = "\u21CF";
const nrtri = "\u22EB";
const nrtrie = "\u22ED";
const nsc = "\u2281";
const nsccue = "\u22E1";
const nsce = "\u2AB0\u0338";
const Nscr = "\u{1D4A9}";
const nscr = "\u{1D4C3}";
const nshortmid = "\u2224";
const nshortparallel = "\u2226";
const nsim = "\u2241";
const nsime = "\u2244";
const nsimeq = "\u2244";
const nsmid = "\u2224";
const nspar = "\u2226";
const nsqsube = "\u22E2";
const nsqsupe = "\u22E3";
const nsub = "\u2284";
const nsubE = "\u2AC5\u0338";
const nsube = "\u2288";
const nsubset = "\u2282\u20D2";
const nsubseteq = "\u2288";
const nsubseteqq = "\u2AC5\u0338";
const nsucc = "\u2281";
const nsucceq = "\u2AB0\u0338";
const nsup = "\u2285";
const nsupE = "\u2AC6\u0338";
const nsupe = "\u2289";
const nsupset = "\u2283\u20D2";
const nsupseteq = "\u2289";
const nsupseteqq = "\u2AC6\u0338";
const ntgl = "\u2279";
const Ntilde = "\xD1";
const ntilde = "\xF1";
const ntlg = "\u2278";
const ntriangleleft = "\u22EA";
const ntrianglelefteq = "\u22EC";
const ntriangleright = "\u22EB";
const ntrianglerighteq = "\u22ED";
const Nu = "\u039D";
const nu = "\u03BD";
const num = "#";
const numero = "\u2116";
const numsp = "\u2007";
const nvap = "\u224D\u20D2";
const nvdash = "\u22AC";
const nvDash = "\u22AD";
const nVdash = "\u22AE";
const nVDash = "\u22AF";
const nvge = "\u2265\u20D2";
const nvgt = ">\u20D2";
const nvHarr = "\u2904";
const nvinfin = "\u29DE";
const nvlArr = "\u2902";
const nvle = "\u2264\u20D2";
const nvlt = "<\u20D2";
const nvltrie = "\u22B4\u20D2";
const nvrArr = "\u2903";
const nvrtrie = "\u22B5\u20D2";
const nvsim = "\u223C\u20D2";
const nwarhk = "\u2923";
const nwarr = "\u2196";
const nwArr = "\u21D6";
const nwarrow = "\u2196";
const nwnear = "\u2927";
const Oacute = "\xD3";
const oacute = "\xF3";
const oast = "\u229B";
const Ocirc = "\xD4";
const ocirc = "\xF4";
const ocir = "\u229A";
const Ocy = "\u041E";
const ocy = "\u043E";
const odash = "\u229D";
const Odblac = "\u0150";
const odblac = "\u0151";
const odiv = "\u2A38";
const odot = "\u2299";
const odsold = "\u29BC";
const OElig = "\u0152";
const oelig = "\u0153";
const ofcir = "\u29BF";
const Ofr = "\u{1D512}";
const ofr = "\u{1D52C}";
const ogon = "\u02DB";
const Ograve = "\xD2";
const ograve = "\xF2";
const ogt = "\u29C1";
const ohbar = "\u29B5";
const ohm = "\u03A9";
const oint = "\u222E";
const olarr = "\u21BA";
const olcir = "\u29BE";
const olcross = "\u29BB";
const oline = "\u203E";
const olt = "\u29C0";
const Omacr = "\u014C";
const omacr = "\u014D";
const Omega = "\u03A9";
const omega = "\u03C9";
const Omicron = "\u039F";
const omicron = "\u03BF";
const omid = "\u29B6";
const ominus = "\u2296";
const Oopf = "\u{1D546}";
const oopf = "\u{1D560}";
const opar = "\u29B7";
const OpenCurlyDoubleQuote = "\u201C";
const OpenCurlyQuote = "\u2018";
const operp = "\u29B9";
const oplus = "\u2295";
const orarr = "\u21BB";
const Or = "\u2A54";
const or = "\u2228";
const ord = "\u2A5D";
const order = "\u2134";
const orderof = "\u2134";
const ordf = "\xAA";
const ordm = "\xBA";
const origof = "\u22B6";
const oror = "\u2A56";
const orslope = "\u2A57";
const orv = "\u2A5B";
const oS = "\u24C8";
const Oscr = "\u{1D4AA}";
const oscr = "\u2134";
const Oslash = "\xD8";
const oslash = "\xF8";
const osol = "\u2298";
const Otilde = "\xD5";
const otilde = "\xF5";
const otimesas = "\u2A36";
const Otimes = "\u2A37";
const otimes = "\u2297";
const Ouml = "\xD6";
const ouml = "\xF6";
const ovbar = "\u233D";
const OverBar = "\u203E";
const OverBrace = "\u23DE";
const OverBracket = "\u23B4";
const OverParenthesis = "\u23DC";
const para = "\xB6";
const parallel = "\u2225";
const par = "\u2225";
const parsim = "\u2AF3";
const parsl = "\u2AFD";
const part = "\u2202";
const PartialD = "\u2202";
const Pcy = "\u041F";
const pcy = "\u043F";
const percnt = "%";
const period = ".";
const permil = "\u2030";
const perp = "\u22A5";
const pertenk = "\u2031";
const Pfr = "\u{1D513}";
const pfr = "\u{1D52D}";
const Phi = "\u03A6";
const phi = "\u03C6";
const phiv = "\u03D5";
const phmmat = "\u2133";
const phone = "\u260E";
const Pi = "\u03A0";
const pi = "\u03C0";
const pitchfork = "\u22D4";
const piv = "\u03D6";
const planck = "\u210F";
const planckh = "\u210E";
const plankv = "\u210F";
const plusacir = "\u2A23";
const plusb = "\u229E";
const pluscir = "\u2A22";
const plus = "+";
const plusdo = "\u2214";
const plusdu = "\u2A25";
const pluse = "\u2A72";
const PlusMinus = "\xB1";
const plusmn = "\xB1";
const plussim = "\u2A26";
const plustwo = "\u2A27";
const pm = "\xB1";
const Poincareplane = "\u210C";
const pointint = "\u2A15";
const popf = "\u{1D561}";
const Popf = "\u2119";
const pound = "\xA3";
const prap = "\u2AB7";
const Pr = "\u2ABB";
const pr = "\u227A";
const prcue = "\u227C";
const precapprox = "\u2AB7";
const prec = "\u227A";
const preccurlyeq = "\u227C";
const Precedes = "\u227A";
const PrecedesEqual = "\u2AAF";
const PrecedesSlantEqual = "\u227C";
const PrecedesTilde = "\u227E";
const preceq = "\u2AAF";
const precnapprox = "\u2AB9";
const precneqq = "\u2AB5";
const precnsim = "\u22E8";
const pre = "\u2AAF";
const prE = "\u2AB3";
const precsim = "\u227E";
const prime = "\u2032";
const Prime = "\u2033";
const primes = "\u2119";
const prnap = "\u2AB9";
const prnE = "\u2AB5";
const prnsim = "\u22E8";
const prod = "\u220F";
const Product = "\u220F";
const profalar = "\u232E";
const profline = "\u2312";
const profsurf = "\u2313";
const prop = "\u221D";
const Proportional = "\u221D";
const Proportion = "\u2237";
const propto = "\u221D";
const prsim = "\u227E";
const prurel = "\u22B0";
const Pscr = "\u{1D4AB}";
const pscr = "\u{1D4C5}";
const Psi = "\u03A8";
const psi = "\u03C8";
const puncsp = "\u2008";
const Qfr = "\u{1D514}";
const qfr = "\u{1D52E}";
const qint = "\u2A0C";
const qopf = "\u{1D562}";
const Qopf = "\u211A";
const qprime = "\u2057";
const Qscr = "\u{1D4AC}";
const qscr = "\u{1D4C6}";
const quaternions = "\u210D";
const quatint = "\u2A16";
const quest = "?";
const questeq = "\u225F";
const quot = '"';
const QUOT = '"';
const rAarr = "\u21DB";
const race = "\u223D\u0331";
const Racute = "\u0154";
const racute = "\u0155";
const radic = "\u221A";
const raemptyv = "\u29B3";
const rang = "\u27E9";
const Rang = "\u27EB";
const rangd = "\u2992";
const range = "\u29A5";
const rangle = "\u27E9";
const raquo = "\xBB";
const rarrap = "\u2975";
const rarrb = "\u21E5";
const rarrbfs = "\u2920";
const rarrc = "\u2933";
const rarr = "\u2192";
const Rarr = "\u21A0";
const rArr = "\u21D2";
const rarrfs = "\u291E";
const rarrhk = "\u21AA";
const rarrlp = "\u21AC";
const rarrpl = "\u2945";
const rarrsim = "\u2974";
const Rarrtl = "\u2916";
const rarrtl = "\u21A3";
const rarrw = "\u219D";
const ratail = "\u291A";
const rAtail = "\u291C";
const ratio = "\u2236";
const rationals = "\u211A";
const rbarr = "\u290D";
const rBarr = "\u290F";
const RBarr = "\u2910";
const rbbrk = "\u2773";
const rbrace = "}";
const rbrack = "]";
const rbrke = "\u298C";
const rbrksld = "\u298E";
const rbrkslu = "\u2990";
const Rcaron = "\u0158";
const rcaron = "\u0159";
const Rcedil = "\u0156";
const rcedil = "\u0157";
const rceil = "\u2309";
const rcub = "}";
const Rcy = "\u0420";
const rcy = "\u0440";
const rdca = "\u2937";
const rdldhar = "\u2969";
const rdquo = "\u201D";
const rdquor = "\u201D";
const rdsh = "\u21B3";
const real = "\u211C";
const realine = "\u211B";
const realpart = "\u211C";
const reals = "\u211D";
const Re = "\u211C";
const rect = "\u25AD";
const reg = "\xAE";
const REG = "\xAE";
const ReverseElement = "\u220B";
const ReverseEquilibrium = "\u21CB";
const ReverseUpEquilibrium = "\u296F";
const rfisht = "\u297D";
const rfloor = "\u230B";
const rfr = "\u{1D52F}";
const Rfr = "\u211C";
const rHar = "\u2964";
const rhard = "\u21C1";
const rharu = "\u21C0";
const rharul = "\u296C";
const Rho = "\u03A1";
const rho = "\u03C1";
const rhov = "\u03F1";
const RightAngleBracket = "\u27E9";
const RightArrowBar = "\u21E5";
const rightarrow = "\u2192";
const RightArrow = "\u2192";
const Rightarrow = "\u21D2";
const RightArrowLeftArrow = "\u21C4";
const rightarrowtail = "\u21A3";
const RightCeiling = "\u2309";
const RightDoubleBracket = "\u27E7";
const RightDownTeeVector = "\u295D";
const RightDownVectorBar = "\u2955";
const RightDownVector = "\u21C2";
const RightFloor = "\u230B";
const rightharpoondown = "\u21C1";
const rightharpoonup = "\u21C0";
const rightleftarrows = "\u21C4";
const rightleftharpoons = "\u21CC";
const rightrightarrows = "\u21C9";
const rightsquigarrow = "\u219D";
const RightTeeArrow = "\u21A6";
const RightTee = "\u22A2";
const RightTeeVector = "\u295B";
const rightthreetimes = "\u22CC";
const RightTriangleBar = "\u29D0";
const RightTriangle = "\u22B3";
const RightTriangleEqual = "\u22B5";
const RightUpDownVector = "\u294F";
const RightUpTeeVector = "\u295C";
const RightUpVectorBar = "\u2954";
const RightUpVector = "\u21BE";
const RightVectorBar = "\u2953";
const RightVector = "\u21C0";
const ring = "\u02DA";
const risingdotseq = "\u2253";
const rlarr = "\u21C4";
const rlhar = "\u21CC";
const rlm = "\u200F";
const rmoustache = "\u23B1";
const rmoust = "\u23B1";
const rnmid = "\u2AEE";
const roang = "\u27ED";
const roarr = "\u21FE";
const robrk = "\u27E7";
const ropar = "\u2986";
const ropf = "\u{1D563}";
const Ropf = "\u211D";
const roplus = "\u2A2E";
const rotimes = "\u2A35";
const RoundImplies = "\u2970";
const rpar = ")";
const rpargt = "\u2994";
const rppolint = "\u2A12";
const rrarr = "\u21C9";
const Rrightarrow = "\u21DB";
const rsaquo = "\u203A";
const rscr = "\u{1D4C7}";
const Rscr = "\u211B";
const rsh = "\u21B1";
const Rsh = "\u21B1";
const rsqb = "]";
const rsquo = "\u2019";
const rsquor = "\u2019";
const rthree = "\u22CC";
const rtimes = "\u22CA";
const rtri = "\u25B9";
const rtrie = "\u22B5";
const rtrif = "\u25B8";
const rtriltri = "\u29CE";
const RuleDelayed = "\u29F4";
const ruluhar = "\u2968";
const rx = "\u211E";
const Sacute = "\u015A";
const sacute = "\u015B";
const sbquo = "\u201A";
const scap = "\u2AB8";
const Scaron = "\u0160";
const scaron = "\u0161";
const Sc = "\u2ABC";
const sc = "\u227B";
const sccue = "\u227D";
const sce = "\u2AB0";
const scE = "\u2AB4";
const Scedil = "\u015E";
const scedil = "\u015F";
const Scirc = "\u015C";
const scirc = "\u015D";
const scnap = "\u2ABA";
const scnE = "\u2AB6";
const scnsim = "\u22E9";
const scpolint = "\u2A13";
const scsim = "\u227F";
const Scy = "\u0421";
const scy = "\u0441";
const sdotb = "\u22A1";
const sdot = "\u22C5";
const sdote = "\u2A66";
const searhk = "\u2925";
const searr = "\u2198";
const seArr = "\u21D8";
const searrow = "\u2198";
const sect = "\xA7";
const semi = ";";
const seswar = "\u2929";
const setminus = "\u2216";
const setmn = "\u2216";
const sext = "\u2736";
const Sfr = "\u{1D516}";
const sfr = "\u{1D530}";
const sfrown = "\u2322";
const sharp = "\u266F";
const SHCHcy = "\u0429";
const shchcy = "\u0449";
const SHcy = "\u0428";
const shcy = "\u0448";
const ShortDownArrow = "\u2193";
const ShortLeftArrow = "\u2190";
const shortmid = "\u2223";
const shortparallel = "\u2225";
const ShortRightArrow = "\u2192";
const ShortUpArrow = "\u2191";
const shy = "\xAD";
const Sigma = "\u03A3";
const sigma = "\u03C3";
const sigmaf = "\u03C2";
const sigmav = "\u03C2";
const sim = "\u223C";
const simdot = "\u2A6A";
const sime = "\u2243";
const simeq = "\u2243";
const simg = "\u2A9E";
const simgE = "\u2AA0";
const siml = "\u2A9D";
const simlE = "\u2A9F";
const simne = "\u2246";
const simplus = "\u2A24";
const simrarr = "\u2972";
const slarr = "\u2190";
const SmallCircle = "\u2218";
const smallsetminus = "\u2216";
const smashp = "\u2A33";
const smeparsl = "\u29E4";
const smid = "\u2223";
const smile = "\u2323";
const smt = "\u2AAA";
const smte = "\u2AAC";
const smtes = "\u2AAC\uFE00";
const SOFTcy = "\u042C";
const softcy = "\u044C";
const solbar = "\u233F";
const solb = "\u29C4";
const sol = "/";
const Sopf = "\u{1D54A}";
const sopf = "\u{1D564}";
const spades = "\u2660";
const spadesuit = "\u2660";
const spar = "\u2225";
const sqcap = "\u2293";
const sqcaps = "\u2293\uFE00";
const sqcup = "\u2294";
const sqcups = "\u2294\uFE00";
const Sqrt = "\u221A";
const sqsub = "\u228F";
const sqsube = "\u2291";
const sqsubset = "\u228F";
const sqsubseteq = "\u2291";
const sqsup = "\u2290";
const sqsupe = "\u2292";
const sqsupset = "\u2290";
const sqsupseteq = "\u2292";
const square = "\u25A1";
const Square = "\u25A1";
const SquareIntersection = "\u2293";
const SquareSubset = "\u228F";
const SquareSubsetEqual = "\u2291";
const SquareSuperset = "\u2290";
const SquareSupersetEqual = "\u2292";
const SquareUnion = "\u2294";
const squarf = "\u25AA";
const squ = "\u25A1";
const squf = "\u25AA";
const srarr = "\u2192";
const Sscr = "\u{1D4AE}";
const sscr = "\u{1D4C8}";
const ssetmn = "\u2216";
const ssmile = "\u2323";
const sstarf = "\u22C6";
const Star = "\u22C6";
const star = "\u2606";
const starf = "\u2605";
const straightepsilon = "\u03F5";
const straightphi = "\u03D5";
const strns = "\xAF";
const sub = "\u2282";
const Sub = "\u22D0";
const subdot = "\u2ABD";
const subE = "\u2AC5";
const sube = "\u2286";
const subedot = "\u2AC3";
const submult = "\u2AC1";
const subnE = "\u2ACB";
const subne = "\u228A";
const subplus = "\u2ABF";
const subrarr = "\u2979";
const subset = "\u2282";
const Subset = "\u22D0";
const subseteq = "\u2286";
const subseteqq = "\u2AC5";
const SubsetEqual = "\u2286";
const subsetneq = "\u228A";
const subsetneqq = "\u2ACB";
const subsim = "\u2AC7";
const subsub = "\u2AD5";
const subsup = "\u2AD3";
const succapprox = "\u2AB8";
const succ = "\u227B";
const succcurlyeq = "\u227D";
const Succeeds = "\u227B";
const SucceedsEqual = "\u2AB0";
const SucceedsSlantEqual = "\u227D";
const SucceedsTilde = "\u227F";
const succeq = "\u2AB0";
const succnapprox = "\u2ABA";
const succneqq = "\u2AB6";
const succnsim = "\u22E9";
const succsim = "\u227F";
const SuchThat = "\u220B";
const sum = "\u2211";
const Sum = "\u2211";
const sung = "\u266A";
const sup1 = "\xB9";
const sup2 = "\xB2";
const sup3 = "\xB3";
const sup = "\u2283";
const Sup = "\u22D1";
const supdot = "\u2ABE";
const supdsub = "\u2AD8";
const supE = "\u2AC6";
const supe = "\u2287";
const supedot = "\u2AC4";
const Superset = "\u2283";
const SupersetEqual = "\u2287";
const suphsol = "\u27C9";
const suphsub = "\u2AD7";
const suplarr = "\u297B";
const supmult = "\u2AC2";
const supnE = "\u2ACC";
const supne = "\u228B";
const supplus = "\u2AC0";
const supset = "\u2283";
const Supset = "\u22D1";
const supseteq = "\u2287";
const supseteqq = "\u2AC6";
const supsetneq = "\u228B";
const supsetneqq = "\u2ACC";
const supsim = "\u2AC8";
const supsub = "\u2AD4";
const supsup = "\u2AD6";
const swarhk = "\u2926";
const swarr = "\u2199";
const swArr = "\u21D9";
const swarrow = "\u2199";
const swnwar = "\u292A";
const szlig = "\xDF";
const Tab = "	";
const target = "\u2316";
const Tau = "\u03A4";
const tau = "\u03C4";
const tbrk = "\u23B4";
const Tcaron = "\u0164";
const tcaron = "\u0165";
const Tcedil = "\u0162";
const tcedil = "\u0163";
const Tcy = "\u0422";
const tcy = "\u0442";
const tdot = "\u20DB";
const telrec = "\u2315";
const Tfr = "\u{1D517}";
const tfr = "\u{1D531}";
const there4 = "\u2234";
const therefore = "\u2234";
const Therefore = "\u2234";
const Theta = "\u0398";
const theta = "\u03B8";
const thetasym = "\u03D1";
const thetav = "\u03D1";
const thickapprox = "\u2248";
const thicksim = "\u223C";
const ThickSpace = "\u205F\u200A";
const ThinSpace = "\u2009";
const thinsp = "\u2009";
const thkap = "\u2248";
const thksim = "\u223C";
const THORN = "\xDE";
const thorn = "\xFE";
const tilde = "\u02DC";
const Tilde = "\u223C";
const TildeEqual = "\u2243";
const TildeFullEqual = "\u2245";
const TildeTilde = "\u2248";
const timesbar = "\u2A31";
const timesb = "\u22A0";
const times = "\xD7";
const timesd = "\u2A30";
const tint = "\u222D";
const toea = "\u2928";
const topbot = "\u2336";
const topcir = "\u2AF1";
const top = "\u22A4";
const Topf = "\u{1D54B}";
const topf = "\u{1D565}";
const topfork = "\u2ADA";
const tosa = "\u2929";
const tprime = "\u2034";
const trade = "\u2122";
const TRADE = "\u2122";
const triangle = "\u25B5";
const triangledown = "\u25BF";
const triangleleft = "\u25C3";
const trianglelefteq = "\u22B4";
const triangleq = "\u225C";
const triangleright = "\u25B9";
const trianglerighteq = "\u22B5";
const tridot = "\u25EC";
const trie = "\u225C";
const triminus = "\u2A3A";
const TripleDot = "\u20DB";
const triplus = "\u2A39";
const trisb = "\u29CD";
const tritime = "\u2A3B";
const trpezium = "\u23E2";
const Tscr = "\u{1D4AF}";
const tscr = "\u{1D4C9}";
const TScy = "\u0426";
const tscy = "\u0446";
const TSHcy = "\u040B";
const tshcy = "\u045B";
const Tstrok = "\u0166";
const tstrok = "\u0167";
const twixt = "\u226C";
const twoheadleftarrow = "\u219E";
const twoheadrightarrow = "\u21A0";
const Uacute = "\xDA";
const uacute = "\xFA";
const uarr = "\u2191";
const Uarr = "\u219F";
const uArr = "\u21D1";
const Uarrocir = "\u2949";
const Ubrcy = "\u040E";
const ubrcy = "\u045E";
const Ubreve = "\u016C";
const ubreve = "\u016D";
const Ucirc = "\xDB";
const ucirc = "\xFB";
const Ucy = "\u0423";
const ucy = "\u0443";
const udarr = "\u21C5";
const Udblac = "\u0170";
const udblac = "\u0171";
const udhar = "\u296E";
const ufisht = "\u297E";
const Ufr = "\u{1D518}";
const ufr = "\u{1D532}";
const Ugrave = "\xD9";
const ugrave = "\xF9";
const uHar = "\u2963";
const uharl = "\u21BF";
const uharr = "\u21BE";
const uhblk = "\u2580";
const ulcorn = "\u231C";
const ulcorner = "\u231C";
const ulcrop = "\u230F";
const ultri = "\u25F8";
const Umacr = "\u016A";
const umacr = "\u016B";
const uml = "\xA8";
const UnderBar = "_";
const UnderBrace = "\u23DF";
const UnderBracket = "\u23B5";
const UnderParenthesis = "\u23DD";
const Union = "\u22C3";
const UnionPlus = "\u228E";
const Uogon = "\u0172";
const uogon = "\u0173";
const Uopf = "\u{1D54C}";
const uopf = "\u{1D566}";
const UpArrowBar = "\u2912";
const uparrow = "\u2191";
const UpArrow = "\u2191";
const Uparrow = "\u21D1";
const UpArrowDownArrow = "\u21C5";
const updownarrow = "\u2195";
const UpDownArrow = "\u2195";
const Updownarrow = "\u21D5";
const UpEquilibrium = "\u296E";
const upharpoonleft = "\u21BF";
const upharpoonright = "\u21BE";
const uplus = "\u228E";
const UpperLeftArrow = "\u2196";
const UpperRightArrow = "\u2197";
const upsi = "\u03C5";
const Upsi = "\u03D2";
const upsih = "\u03D2";
const Upsilon = "\u03A5";
const upsilon = "\u03C5";
const UpTeeArrow = "\u21A5";
const UpTee = "\u22A5";
const upuparrows = "\u21C8";
const urcorn = "\u231D";
const urcorner = "\u231D";
const urcrop = "\u230E";
const Uring = "\u016E";
const uring = "\u016F";
const urtri = "\u25F9";
const Uscr = "\u{1D4B0}";
const uscr = "\u{1D4CA}";
const utdot = "\u22F0";
const Utilde = "\u0168";
const utilde = "\u0169";
const utri = "\u25B5";
const utrif = "\u25B4";
const uuarr = "\u21C8";
const Uuml = "\xDC";
const uuml = "\xFC";
const uwangle = "\u29A7";
const vangrt = "\u299C";
const varepsilon = "\u03F5";
const varkappa = "\u03F0";
const varnothing = "\u2205";
const varphi = "\u03D5";
const varpi = "\u03D6";
const varpropto = "\u221D";
const varr = "\u2195";
const vArr = "\u21D5";
const varrho = "\u03F1";
const varsigma = "\u03C2";
const varsubsetneq = "\u228A\uFE00";
const varsubsetneqq = "\u2ACB\uFE00";
const varsupsetneq = "\u228B\uFE00";
const varsupsetneqq = "\u2ACC\uFE00";
const vartheta = "\u03D1";
const vartriangleleft = "\u22B2";
const vartriangleright = "\u22B3";
const vBar = "\u2AE8";
const Vbar = "\u2AEB";
const vBarv = "\u2AE9";
const Vcy = "\u0412";
const vcy = "\u0432";
const vdash = "\u22A2";
const vDash = "\u22A8";
const Vdash = "\u22A9";
const VDash = "\u22AB";
const Vdashl = "\u2AE6";
const veebar = "\u22BB";
const vee = "\u2228";
const Vee = "\u22C1";
const veeeq = "\u225A";
const vellip = "\u22EE";
const verbar = "|";
const Verbar = "\u2016";
const vert = "|";
const Vert = "\u2016";
const VerticalBar = "\u2223";
const VerticalLine = "|";
const VerticalSeparator = "\u2758";
const VerticalTilde = "\u2240";
const VeryThinSpace = "\u200A";
const Vfr = "\u{1D519}";
const vfr = "\u{1D533}";
const vltri = "\u22B2";
const vnsub = "\u2282\u20D2";
const vnsup = "\u2283\u20D2";
const Vopf = "\u{1D54D}";
const vopf = "\u{1D567}";
const vprop = "\u221D";
const vrtri = "\u22B3";
const Vscr = "\u{1D4B1}";
const vscr = "\u{1D4CB}";
const vsubnE = "\u2ACB\uFE00";
const vsubne = "\u228A\uFE00";
const vsupnE = "\u2ACC\uFE00";
const vsupne = "\u228B\uFE00";
const Vvdash = "\u22AA";
const vzigzag = "\u299A";
const Wcirc = "\u0174";
const wcirc = "\u0175";
const wedbar = "\u2A5F";
const wedge = "\u2227";
const Wedge = "\u22C0";
const wedgeq = "\u2259";
const weierp = "\u2118";
const Wfr = "\u{1D51A}";
const wfr = "\u{1D534}";
const Wopf = "\u{1D54E}";
const wopf = "\u{1D568}";
const wp = "\u2118";
const wr = "\u2240";
const wreath = "\u2240";
const Wscr = "\u{1D4B2}";
const wscr = "\u{1D4CC}";
const xcap = "\u22C2";
const xcirc = "\u25EF";
const xcup = "\u22C3";
const xdtri = "\u25BD";
const Xfr = "\u{1D51B}";
const xfr = "\u{1D535}";
const xharr = "\u27F7";
const xhArr = "\u27FA";
const Xi = "\u039E";
const xi = "\u03BE";
const xlarr = "\u27F5";
const xlArr = "\u27F8";
const xmap = "\u27FC";
const xnis = "\u22FB";
const xodot = "\u2A00";
const Xopf = "\u{1D54F}";
const xopf = "\u{1D569}";
const xoplus = "\u2A01";
const xotime = "\u2A02";
const xrarr = "\u27F6";
const xrArr = "\u27F9";
const Xscr = "\u{1D4B3}";
const xscr = "\u{1D4CD}";
const xsqcup = "\u2A06";
const xuplus = "\u2A04";
const xutri = "\u25B3";
const xvee = "\u22C1";
const xwedge = "\u22C0";
const Yacute = "\xDD";
const yacute = "\xFD";
const YAcy = "\u042F";
const yacy = "\u044F";
const Ycirc = "\u0176";
const ycirc = "\u0177";
const Ycy = "\u042B";
const ycy = "\u044B";
const yen = "\xA5";
const Yfr = "\u{1D51C}";
const yfr = "\u{1D536}";
const YIcy = "\u0407";
const yicy = "\u0457";
const Yopf = "\u{1D550}";
const yopf = "\u{1D56A}";
const Yscr = "\u{1D4B4}";
const yscr = "\u{1D4CE}";
const YUcy = "\u042E";
const yucy = "\u044E";
const yuml = "\xFF";
const Yuml = "\u0178";
const Zacute = "\u0179";
const zacute = "\u017A";
const Zcaron = "\u017D";
const zcaron = "\u017E";
const Zcy = "\u0417";
const zcy = "\u0437";
const Zdot = "\u017B";
const zdot = "\u017C";
const zeetrf = "\u2128";
const ZeroWidthSpace = "\u200B";
const Zeta = "\u0396";
const zeta = "\u03B6";
const zfr = "\u{1D537}";
const Zfr = "\u2128";
const ZHcy = "\u0416";
const zhcy = "\u0436";
const zigrarr = "\u21DD";
const zopf = "\u{1D56B}";
const Zopf = "\u2124";
const Zscr = "\u{1D4B5}";
const zscr = "\u{1D4CF}";
const zwj = "\u200D";
const zwnj = "\u200C";
var require$$0 = {
  Aacute,
  aacute,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc,
  acirc,
  acute,
  Acy,
  acy,
  AElig,
  aelig,
  af,
  Afr,
  afr,
  Agrave,
  agrave,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp,
  AMP,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos,
  ApplyFunction,
  approx,
  approxeq,
  Aring,
  aring,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde,
  atilde,
  Auml,
  auml,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$2,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil,
  ccedil,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil,
  Cedilla,
  cemptyv,
  cent,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy,
  COPY,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute,
  eacute,
  easter,
  Ecaron,
  ecaron,
  Ecirc,
  ecirc,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave,
  egrave,
  egs,
  egsdot,
  el,
  Element,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH,
  eth,
  Euml,
  euml,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt,
  GT,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute,
  iacute,
  ic,
  Icirc,
  icirc,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl,
  iff,
  ifr,
  Ifr,
  Igrave,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$1,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "\u2208",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml,
  iuml,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt,
  LT,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr,
  male,
  malt,
  maltese,
  "Map": "\u2905",
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro,
  midast,
  midcir,
  mid,
  middot,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute,
  oacute,
  oast,
  Ocirc,
  ocirc,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash,
  oslash,
  osol,
  Otilde,
  otilde,
  otimesas,
  Otimes,
  otimes,
  Ouml,
  ouml,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot,
  QUOT,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg,
  REG,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1,
  sup2,
  sup3,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig,
  Tab,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN,
  thorn,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute,
  uacute,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc,
  ucirc,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave,
  ugrave,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml,
  uuml,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute,
  yacute,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var entities$1 = require$$0;
var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var mdurl$1 = {};
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch2, cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch2 = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch2)) {
      cache.push(ch2);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
function encode$1(string2, exclude, keepEscaped) {
  var i, l2, code3, nextCode, cache, result2 = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache = getEncodeCache(exclude);
  for (i = 0, l2 = string2.length; i < l2; i++) {
    code3 = string2.charCodeAt(i);
    if (keepEscaped && code3 === 37 && i + 2 < l2) {
      if (/^[0-9a-f]{2}$/i.test(string2.slice(i + 1, i + 3))) {
        result2 += string2.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code3 < 128) {
      result2 += cache[code3];
      continue;
    }
    if (code3 >= 55296 && code3 <= 57343) {
      if (code3 >= 55296 && code3 <= 56319 && i + 1 < l2) {
        nextCode = string2.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result2 += encodeURIComponent(string2[i] + string2[i + 1]);
          i++;
          continue;
        }
      }
      result2 += "%EF%BF%BD";
      continue;
    }
    result2 += encodeURIComponent(string2[i]);
  }
  return result2;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var decodeCache = {};
function getDecodeCache(exclude) {
  var i, ch2, cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch2 = String.fromCharCode(i);
    cache.push(ch2);
  }
  for (i = 0; i < exclude.length; i++) {
    ch2 = exclude.charCodeAt(i);
    cache[ch2] = "%" + ("0" + ch2.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
function decode$1(string2, exclude) {
  var cache;
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  cache = getDecodeCache(exclude);
  return string2.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l2, b1, b2, b3, b4, chr, result2 = "";
    for (i = 0, l2 = seq.length; i < l2; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result2 += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l2) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result2 += "\uFFFD\uFFFD";
          } else {
            result2 += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l2) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result2 += "\uFFFD\uFFFD\uFFFD";
          } else {
            result2 += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l2) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result2 += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result2 += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result2 += "\uFFFD";
    }
    return result2;
  });
}
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
var decode_1 = decode$1;
var format = function format2(url) {
  var result2 = "";
  result2 += url.protocol || "";
  result2 += url.slashes ? "//" : "";
  result2 += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result2 += "[" + url.hostname + "]";
  } else {
    result2 += url.hostname || "";
  }
  result2 += url.port ? ":" + url.port : "";
  result2 += url.pathname || "";
  result2 += url.search || "";
  result2 += url.hash || "";
  return result2;
};
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }
  var u2 = new Url();
  u2.parse(url, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l2, lowerProto, hec, slashes, rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l2 = hostparts.length; i < l2; i++) {
        var part2 = hostparts[i];
        if (!part2) {
          continue;
        }
        if (!part2.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k = part2.length; j < k; j++) {
            if (part2.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part2[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part2.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse = urlParse;
mdurl$1.encode = encode_1;
mdurl$1.decode = decode_1;
mdurl$1.format = format;
mdurl$1.parse = parse;
var uc_micro = {};
var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var regex$2 = /[\0-\x1F\x7F-\x9F]/;
var regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
uc_micro.Any = regex$3;
uc_micro.Cc = regex$2;
uc_micro.Cf = regex$1;
uc_micro.P = regex$4;
uc_micro.Z = regex;
(function(exports) {
  function _class2(obj) {
    return Object.prototype.toString.call(obj);
  }
  function isString2(obj) {
    return _class2(obj) === "[object String]";
  }
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has2(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  function assign2(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  function arrayReplaceAt2(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  function isValidEntityCode2(c) {
    if (c >= 55296 && c <= 57343) {
      return false;
    }
    if (c >= 64976 && c <= 65007) {
      return false;
    }
    if ((c & 65535) === 65535 || (c & 65535) === 65534) {
      return false;
    }
    if (c >= 0 && c <= 8) {
      return false;
    }
    if (c === 11) {
      return false;
    }
    if (c >= 14 && c <= 31) {
      return false;
    }
    if (c >= 127 && c <= 159) {
      return false;
    }
    if (c > 1114111) {
      return false;
    }
    return true;
  }
  function fromCodePoint2(c) {
    if (c > 65535) {
      c -= 65536;
      var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c);
  }
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
  var entities2 = entities$1;
  function replaceEntityPattern(match2, name2) {
    var code3 = 0;
    if (has2(entities2, name2)) {
      return entities2[name2];
    }
    if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
      code3 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
      if (isValidEntityCode2(code3)) {
        return fromCodePoint2(code3);
      }
    }
    return match2;
  }
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  function unescapeAll2(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity3) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match2, entity3);
    });
  }
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch2) {
    return HTML_REPLACEMENTS[ch2];
  }
  function escapeHtml2(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE2(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  function isSpace2(code3) {
    switch (code3) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  function isWhiteSpace2(code3) {
    if (code3 >= 8192 && code3 <= 8202) {
      return true;
    }
    switch (code3) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  var UNICODE_PUNCT_RE = regex$4;
  function isPunctChar2(ch2) {
    return UNICODE_PUNCT_RE.test(ch2);
  }
  function isMdAsciiPunct2(ch2) {
    switch (ch2) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  function normalizeReference2(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(//g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  exports.lib = {};
  exports.lib.mdurl = mdurl$1;
  exports.lib.ucmicro = uc_micro;
  exports.assign = assign2;
  exports.isString = isString2;
  exports.has = has2;
  exports.unescapeMd = unescapeMd;
  exports.unescapeAll = unescapeAll2;
  exports.isValidEntityCode = isValidEntityCode2;
  exports.fromCodePoint = fromCodePoint2;
  exports.escapeHtml = escapeHtml2;
  exports.arrayReplaceAt = arrayReplaceAt2;
  exports.isSpace = isSpace2;
  exports.isWhiteSpace = isWhiteSpace2;
  exports.isMdAsciiPunct = isMdAsciiPunct2;
  exports.isPunctChar = isPunctChar2;
  exports.escapeRE = escapeRE2;
  exports.normalizeReference = normalizeReference2;
})(utils$1);
var helpers$1 = {};
var parse_link_label = function parseLinkLabel(state, start2, disableNested) {
  var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
  state.pos = start2 + 1;
  level = 1;
  while (state.pos < max) {
    marker2 = state.src.charCodeAt(state.pos);
    if (marker2 === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker2 === 91) {
      if (prevPos === state.pos - 1) {
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }
  if (found) {
    labelEnd = state.pos;
  }
  state.pos = oldPos;
  return labelEnd;
};
var unescapeAll$2 = utils$1.unescapeAll;
var parse_link_destination = function parseLinkDestination(str, pos, max) {
  var code3, level, lines = 0, start2 = pos, result2 = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code3 = str.charCodeAt(pos);
      if (code3 === 10) {
        return result2;
      }
      if (code3 === 60) {
        return result2;
      }
      if (code3 === 62) {
        result2.pos = pos + 1;
        result2.str = unescapeAll$2(str.slice(start2 + 1, pos));
        result2.ok = true;
        return result2;
      }
      if (code3 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result2;
  }
  level = 0;
  while (pos < max) {
    code3 = str.charCodeAt(pos);
    if (code3 === 32) {
      break;
    }
    if (code3 < 32 || code3 === 127) {
      break;
    }
    if (code3 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code3 === 40) {
      level++;
      if (level > 32) {
        return result2;
      }
    }
    if (code3 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start2 === pos) {
    return result2;
  }
  if (level !== 0) {
    return result2;
  }
  result2.str = unescapeAll$2(str.slice(start2, pos));
  result2.lines = lines;
  result2.pos = pos;
  result2.ok = true;
  return result2;
};
var unescapeAll$1 = utils$1.unescapeAll;
var parse_link_title = function parseLinkTitle(str, pos, max) {
  var code3, marker2, lines = 0, start2 = pos, result2 = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (pos >= max) {
    return result2;
  }
  marker2 = str.charCodeAt(pos);
  if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
    return result2;
  }
  pos++;
  if (marker2 === 40) {
    marker2 = 41;
  }
  while (pos < max) {
    code3 = str.charCodeAt(pos);
    if (code3 === marker2) {
      result2.pos = pos + 1;
      result2.lines = lines;
      result2.str = unescapeAll$1(str.slice(start2 + 1, pos));
      result2.ok = true;
      return result2;
    } else if (code3 === 40 && marker2 === 41) {
      return result2;
    } else if (code3 === 10) {
      lines++;
    } else if (code3 === 92 && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
    pos++;
  }
  return result2;
};
helpers$1.parseLinkLabel = parse_link_label;
helpers$1.parseLinkDestination = parse_link_destination;
helpers$1.parseLinkTitle = parse_link_title;
var assign$1 = utils$1.assign;
var unescapeAll = utils$1.unescapeAll;
var escapeHtml$1 = utils$1.escapeHtml;
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml$1(tokens[idx].content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml$1(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx], info2 = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
  if (info2) {
    arr = info2.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  if (options.highlight) {
    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml$1(token2.content);
  } else {
    highlighted = escapeHtml$1(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info2) {
    i = token2.attrIndex("class");
    tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    tmpToken = {
      attrs: tmpAttrs
    };
    return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
  }
  return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
};
default_rules.image = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml$1(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer$1() {
  this.rules = assign$1({}, default_rules);
}
Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
  var i, l2, result2;
  if (!token2.attrs) {
    return "";
  }
  result2 = "";
  for (i = 0, l2 = token2.attrs.length; i < l2; i++) {
    result2 += " " + escapeHtml$1(token2.attrs[i][0]) + '="' + escapeHtml$1(token2.attrs[i][1]) + '"';
  }
  return result2;
};
Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken, result2 = "", needLf = false, token2 = tokens[idx];
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result2 += "\n";
  }
  result2 += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result2 += this.renderAttrs(token2);
  if (token2.nesting === 0 && options.xhtmlOut) {
    result2 += " /";
  }
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result2 += needLf ? ">\n" : ">";
  return result2;
};
Renderer$1.prototype.renderInline = function(tokens, options, env) {
  var type2, result2 = "", rules = this.rules;
  for (var i = 0, len = tokens.length; i < len; i++) {
    type2 = tokens[i].type;
    if (typeof rules[type2] !== "undefined") {
      result2 += rules[type2](tokens, i, options, env, this);
    } else {
      result2 += this.renderToken(tokens, i, options);
    }
  }
  return result2;
};
Renderer$1.prototype.renderInlineAsText = function(tokens, options, env) {
  var result2 = "";
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === "text") {
      result2 += tokens[i].content;
    } else if (tokens[i].type === "image") {
      result2 += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === "softbreak") {
      result2 += "\n";
    }
  }
  return result2;
};
Renderer$1.prototype.render = function(tokens, options, env) {
  var i, len, type2, result2 = "", rules = this.rules;
  for (i = 0, len = tokens.length; i < len; i++) {
    type2 = tokens[i].type;
    if (type2 === "inline") {
      result2 += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type2] !== "undefined") {
      result2 += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result2 += this.renderToken(tokens, i, options, env);
    }
  }
  return result2;
};
var renderer = Renderer$1;
function Ruler$3() {
  this.__rules__ = [];
  this.__cache__ = null;
}
Ruler$3.prototype.__find__ = function(name2) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler$3.prototype.__compile__ = function() {
  var self2 = this;
  var chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler$3.prototype.at = function(name2, fn, options) {
  var index = this.__find__(name2);
  var opt2 = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt2.alt || [];
  this.__cache__ = null;
};
Ruler$3.prototype.before = function(beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt2 = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt2.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.after = function(afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt2 = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt2.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.push = function(ruleName, fn, options) {
  var opt2 = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt2.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.enable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result2 = [];
  list3.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result2.push(name2);
  }, this);
  this.__cache__ = null;
  return result2;
};
Ruler$3.prototype.enableOnly = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list3, ignoreInvalid);
};
Ruler$3.prototype.disable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result2 = [];
  list3.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result2.push(name2);
  }, this);
  this.__cache__ = null;
  return result2;
};
Ruler$3.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler = Ruler$3;
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
var normalize = function normalize2(state) {
  var str;
  str = state.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state.src = str;
};
var block$1 = function block(state) {
  var token2;
  if (state.inlineMode) {
    token2 = new state.Token("inline", "", 0);
    token2.content = state.src;
    token2.map = [0, 1];
    token2.children = [];
    state.tokens.push(token2);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};
var inline = function inline2(state) {
  var tokens = state.tokens, tok, i, l2;
  for (i = 0, l2 = tokens.length; i < l2; i++) {
    tok = tokens[i];
    if (tok.type === "inline") {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};
var arrayReplaceAt = utils$1.arrayReplaceAt;
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
var linkify = function linkify2(state) {
  var i, j, l2, tokens, token2, currentToken, nodes, ln, text3, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
  if (!state.md.options.linkify) {
    return;
  }
  for (j = 0, l2 = blockTokens.length; j < l2; j++) {
    if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    tokens = blockTokens[j].children;
    htmlLinkLevel = 0;
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
        text3 = currentToken.content;
        links = state.md.linkify.match(text3);
        nodes = [];
        level = currentToken.level;
        lastPos = 0;
        for (ln = 0; ln < links.length; ln++) {
          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) {
            continue;
          }
          urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }
          pos = links[ln].index;
          if (pos > lastPos) {
            token2 = new state.Token("text", "", 0);
            token2.content = text3.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          token2 = new state.Token("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.level = level++;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          token2 = new state.Token("text", "", 0);
          token2.content = urlText;
          token2.level = level;
          nodes.push(token2);
          token2 = new state.Token("link_close", "a", -1);
          token2.level = --level;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text3.length) {
          token2 = new state.Token("text", "", 0);
          token2.content = text3.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  p: "\xA7",
  tm: "\u2122"
};
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
function replace_scoped(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
function replace_rare(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
var replacements = function replace(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }
  }
};
var isWhiteSpace$1 = utils$1.isWhiteSpace;
var isPunctChar$1 = utils$1.isPunctChar;
var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index, ch2) {
  return str.substr(0, index) + ch2 + str.substr(index + 1);
}
function process_inlines(tokens, state) {
  var i, token2, text3, t2, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
  stack = [];
  for (i = 0; i < tokens.length; i++) {
    token2 = tokens[i];
    thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token2.type !== "text") {
      continue;
    }
    text3 = token2.content;
    pos = 0;
    max = text3.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t2 = QUOTE_RE.exec(text3);
        if (!t2) {
          break;
        }
        canOpen = canClose = true;
        pos = t2.index + 1;
        isSingle = t2[0] === "'";
        lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text3.charCodeAt(t2.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        nextChar = 32;
        if (pos < max) {
          nextChar = text3.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                openQuote = state.md.options.quotes[2];
                closeQuote = state.md.options.quotes[3];
              } else {
                openQuote = state.md.options.quotes[0];
                closeQuote = state.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t2.index, closeQuote);
              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text3 = token2.content;
              max = text3.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
        }
      }
  }
}
var smartquotes = function smartquotes2(state) {
  var blkIdx;
  if (!state.md.options.typographer) {
    return;
  }
  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state.tokens[blkIdx].children, state);
  }
};
function Token$3(type2, tag, nesting) {
  this.type = type2;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
Token$3.prototype.attrIndex = function attrIndex(name2) {
  var attrs, i, len;
  if (!this.attrs) {
    return -1;
  }
  attrs = this.attrs;
  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
};
Token$3.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
};
Token$3.prototype.attrSet = function attrSet(name2, value) {
  var idx = this.attrIndex(name2), attrData = [name2, value];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};
Token$3.prototype.attrGet = function attrGet(name2) {
  var idx = this.attrIndex(name2), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};
Token$3.prototype.attrJoin = function attrJoin(name2, value) {
  var idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
  }
};
var token = Token$3;
var Token$2 = token;
function StateCore(src, md2, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md2;
}
StateCore.prototype.Token = Token$2;
var state_core = StateCore;
var Ruler$2 = ruler;
var _rules$2 = [
  ["normalize", normalize],
  ["block", block$1],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replacements],
  ["smartquotes", smartquotes]
];
function Core() {
  this.ruler = new Ruler$2();
  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
Core.prototype.process = function(state) {
  var i, l2, rules;
  rules = this.ruler.getRules("");
  for (i = 0, l2 = rules.length; i < l2; i++) {
    rules[i](state);
  }
};
Core.prototype.State = state_core;
var parser_core = Core;
var isSpace$a = utils$1.isSpace;
function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
  return state.src.substr(pos, max - pos);
}
function escapedSplit(str) {
  var result2 = [], pos = 0, max = str.length, ch2, isEscaped = false, lastPos = 0, current = "";
  ch2 = str.charCodeAt(pos);
  while (pos < max) {
    if (ch2 === 124) {
      if (!isEscaped) {
        result2.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch2 === 92;
    pos++;
    ch2 = str.charCodeAt(pos);
  }
  result2.push(current + str.substring(lastPos));
  return result2;
}
var table = function table2(state, startLine, endLine, silent) {
  var ch2, lineText, pos, i, l2, nextLine, columns, columnCount, token2, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state.sCount[nextLine] < state.blkIndent) {
    return false;
  }
  if (state.sCount[nextLine] - state.blkIndent >= 4) {
    return false;
  }
  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  firstCh = state.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state.eMarks[nextLine]) {
    return false;
  }
  secondCh = state.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace$a(secondCh)) {
    return false;
  }
  while (pos < state.eMarks[nextLine]) {
    ch2 = state.src.charCodeAt(pos);
    if (ch2 !== 124 && ch2 !== 45 && ch2 !== 58 && !isSpace$a(ch2)) {
      return false;
    }
    pos++;
  }
  lineText = getLine(state, startLine + 1);
  columns = lineText.split("|");
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t2 = columns[i].trim();
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  oldParentType = state.parentType;
  state.parentType = "table";
  terminatorRules = state.md.block.ruler.getRules("blockquote");
  token2 = state.push("table_open", "table", 1);
  token2.map = tableLines = [startLine, 0];
  token2 = state.push("thead_open", "thead", 1);
  token2.map = [startLine, startLine + 1];
  token2 = state.push("tr_open", "tr", 1);
  token2.map = [startLine, startLine + 1];
  for (i = 0; i < columns.length; i++) {
    token2 = state.push("th_open", "th", 1);
    if (aligns[i]) {
      token2.attrs = [["style", "text-align:" + aligns[i]]];
    }
    token2 = state.push("inline", "", 0);
    token2.content = columns[i].trim();
    token2.children = [];
    token2 = state.push("th_close", "th", -1);
  }
  token2 = state.push("tr_close", "tr", -1);
  token2 = state.push("thead_close", "thead", -1);
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    if (nextLine === startLine + 2) {
      token2 = state.push("tbody_open", "tbody", 1);
      token2.map = tbodyLines = [startLine + 2, 0];
    }
    token2 = state.push("tr_open", "tr", 1);
    token2.map = [nextLine, nextLine + 1];
    for (i = 0; i < columnCount; i++) {
      token2 = state.push("td_open", "td", 1);
      if (aligns[i]) {
        token2.attrs = [["style", "text-align:" + aligns[i]]];
      }
      token2 = state.push("inline", "", 0);
      token2.content = columns[i] ? columns[i].trim() : "";
      token2.children = [];
      token2 = state.push("td_close", "td", -1);
    }
    token2 = state.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    token2 = state.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  token2 = state.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};
var code$2 = function code(state, startLine, endLine) {
  var nextLine, last, token2;
  if (state.sCount[startLine] - state.blkIndent < 4) {
    return false;
  }
  last = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state.line = last;
  token2 = state.push("code_block", "code", 0);
  token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
  token2.map = [startLine, state.line];
  return true;
};
var fence = function fence2(state, startLine, endLine, silent) {
  var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  marker2 = state.src.charCodeAt(pos);
  if (marker2 !== 126 && marker2 !== 96) {
    return false;
  }
  mem = pos;
  pos = state.skipChars(pos, marker2);
  len = pos - mem;
  if (len < 3) {
    return false;
  }
  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);
  if (marker2 === 96) {
    if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  nextLine = startLine;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.src.charCodeAt(pos) !== marker2) {
      continue;
    }
    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      continue;
    }
    pos = state.skipChars(pos, marker2);
    if (pos - mem < len) {
      continue;
    }
    pos = state.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state.sCount[startLine];
  state.line = nextLine + (haveEndMarker ? 1 : 0);
  token2 = state.push("fence", "code", 0);
  token2.info = params;
  token2.content = state.getLines(startLine + 1, nextLine, len, true);
  token2.markup = markup;
  token2.map = [startLine, state.line];
  return true;
};
var isSpace$9 = utils$1.isSpace;
var blockquote = function blockquote2(state, startLine, endLine, silent) {
  var adjustTab, ch2, i, initial, l2, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos++) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  initial = offset = state.sCount[startLine] + 1;
  if (state.src.charCodeAt(pos) === 32) {
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 9) {
    spaceAfterMarker = true;
    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }
  oldBMarks = [state.bMarks[startLine]];
  state.bMarks[startLine] = pos;
  while (pos < max) {
    ch2 = state.src.charCodeAt(pos);
    if (isSpace$9(ch2)) {
      if (ch2 === 9) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }
    pos++;
  }
  oldBSCount = [state.bsCount[startLine]];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max;
  oldSCount = [state.sCount[startLine]];
  state.sCount[startLine] = offset - initial;
  oldTShift = [state.tShift[startLine]];
  state.tShift[startLine] = pos - state.bMarks[startLine];
  terminatorRules = state.md.block.ruler.getRules("blockquote");
  oldParentType = state.parentType;
  state.parentType = "blockquote";
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    isOutdented = state.sCount[nextLine] < state.blkIndent;
    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
      initial = offset = state.sCount[nextLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;
      while (pos < max) {
        ch2 = state.src.charCodeAt(pos);
        if (isSpace$9(ch2)) {
          if (ch2 === 9) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;
      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state.lineMax = nextLine;
      if (state.blkIndent !== 0) {
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }
      break;
    }
    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);
    state.sCount[nextLine] = -1;
  }
  oldIndent = state.blkIndent;
  state.blkIndent = 0;
  token2 = state.push("blockquote_open", "blockquote", 1);
  token2.markup = ">";
  token2.map = lines = [startLine, 0];
  state.md.block.tokenize(state, startLine, nextLine);
  token2 = state.push("blockquote_close", "blockquote", -1);
  token2.markup = ">";
  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;
  return true;
};
var isSpace$8 = utils$1.isSpace;
var hr = function hr2(state, startLine, endLine, silent) {
  var marker2, cnt, ch2, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  marker2 = state.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
    return false;
  }
  cnt = 1;
  while (pos < max) {
    ch2 = state.src.charCodeAt(pos++);
    if (ch2 !== marker2 && !isSpace$8(ch2)) {
      return false;
    }
    if (ch2 === marker2) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state.line = startLine + 1;
  token2 = state.push("hr", "hr", 0);
  token2.map = [startLine, state.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
  return true;
};
var isSpace$7 = utils$1.isSpace;
function skipBulletListMarker(state, startLine) {
  var marker2, pos, max, ch2;
  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];
  marker2 = state.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
    return -1;
  }
  if (pos < max) {
    ch2 = state.src.charCodeAt(pos);
    if (!isSpace$7(ch2)) {
      return -1;
    }
  }
  return pos;
}
function skipOrderedListMarker(state, startLine) {
  var ch2, start2 = state.bMarks[startLine] + state.tShift[startLine], pos = start2, max = state.eMarks[startLine];
  if (pos + 1 >= max) {
    return -1;
  }
  ch2 = state.src.charCodeAt(pos++);
  if (ch2 < 48 || ch2 > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch2 = state.src.charCodeAt(pos++);
    if (ch2 >= 48 && ch2 <= 57) {
      if (pos - start2 >= 10) {
        return -1;
      }
      continue;
    }
    if (ch2 === 41 || ch2 === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch2 = state.src.charCodeAt(pos);
    if (!isSpace$7(ch2)) {
      return -1;
    }
  }
  return pos;
}
function markTightParagraphs(state, idx) {
  var i, l2, level = state.level + 2;
  for (i = idx + 2, l2 = state.tokens.length - 2; i < l2; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}
var list = function list2(state, startLine, endLine, silent) {
  var ch2, contentStart, i, indent2, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start2, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
    return false;
  }
  if (silent && state.parentType === "paragraph") {
    if (state.sCount[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start2 = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.slice(start2, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
      return false;
  }
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
  if (silent) {
    return true;
  }
  listTokIdx = state.tokens.length;
  if (isOrdered) {
    token2 = state.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state.push("bullet_list_open", "ul", 1);
  }
  token2.map = listLines = [startLine, 0];
  token2.markup = String.fromCharCode(markerCharCode);
  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules("list");
  oldParentType = state.parentType;
  state.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];
    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
    while (pos < max) {
      ch2 = state.src.charCodeAt(pos);
      if (ch2 === 9) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch2 === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    contentStart = pos;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    indent2 = initial + indentAfterMarker;
    token2 = state.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    token2.map = itemLines = [startLine, 0];
    if (isOrdered) {
      token2.info = state.src.slice(start2, posAfterMarker - 1);
    }
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent2;
    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;
    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;
    token2 = state.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }
    if (state.sCount[nextLine] < state.blkIndent) {
      break;
    }
    if (state.sCount[startLine] - state.blkIndent >= 4) {
      break;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start2 = state.bMarks[nextLine] + state.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state.line = nextLine;
  state.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }
  return true;
};
var normalizeReference$2 = utils$1.normalizeReference;
var isSpace$6 = utils$1.isSpace;
var reference = function reference2(state, startLine, _endLine, silent) {
  var ch2, destEndPos, destEndLineNo, endLine, href, i, l2, label, labelEnd, oldParentType, res, start2, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 91) {
    return false;
  }
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
      if (pos + 1 === max) {
        return false;
      }
      if (state.src.charCodeAt(pos + 1) !== 58) {
        return false;
      }
      break;
    }
  }
  endLine = state.lineMax;
  terminatorRules = state.md.block.ruler.getRules("reference");
  oldParentType = state.parentType;
  state.parentType = "reference";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;
  for (pos = 1; pos < max; pos++) {
    ch2 = str.charCodeAt(pos);
    if (ch2 === 91) {
      return false;
    } else if (ch2 === 93) {
      labelEnd = pos;
      break;
    } else if (ch2 === 10) {
      lines++;
    } else if (ch2 === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch2 = str.charCodeAt(pos);
    if (ch2 === 10) {
      lines++;
    } else if (isSpace$6(ch2))
      ;
    else {
      break;
    }
  }
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }
  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) {
    return false;
  }
  pos = res.pos;
  lines += res.lines;
  destEndPos = pos;
  destEndLineNo = lines;
  start2 = pos;
  for (; pos < max; pos++) {
    ch2 = str.charCodeAt(pos);
    if (ch2 === 10) {
      lines++;
    } else if (isSpace$6(ch2))
      ;
    else {
      break;
    }
  }
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start2 !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = "";
    pos = destEndPos;
    lines = destEndLineNo;
  }
  while (pos < max) {
    ch2 = str.charCodeAt(pos);
    if (!isSpace$6(ch2)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch2 = str.charCodeAt(pos);
        if (!isSpace$6(ch2)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  label = normalizeReference$2(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state.env.references === "undefined") {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === "undefined") {
    state.env.references[label] = { title, href };
  }
  state.parentType = oldParentType;
  state.line = startLine + lines + 1;
  return true;
};
var html_blocks = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var html_re = {};
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
html_re.HTML_TAG_RE = HTML_TAG_RE$1;
html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
var block_names = html_blocks;
var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
var html_block = function html_block2(state, startLine, endLine, silent) {
  var i, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  if (!state.md.options.html) {
    return false;
  }
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  lineText = state.src.slice(pos, max);
  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) {
        break;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state.line = nextLine;
  token2 = state.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
  return true;
};
var isSpace$5 = utils$1.isSpace;
var heading = function heading2(state, startLine, endLine, silent) {
  var ch2, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  ch2 = state.src.charCodeAt(pos);
  if (ch2 !== 35 || pos >= max) {
    return false;
  }
  level = 1;
  ch2 = state.src.charCodeAt(++pos);
  while (ch2 === 35 && pos < max && level <= 6) {
    level++;
    ch2 = state.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace$5(ch2)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state.line = startLine + 1;
  token2 = state.push("heading_open", "h" + String(level), 1);
  token2.markup = "########".slice(0, level);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = state.src.slice(pos, max).trim();
  token2.map = [startLine, state.line];
  token2.children = [];
  token2 = state.push("heading_close", "h" + String(level), -1);
  token2.markup = "########".slice(0, level);
  return true;
};
var lheading = function lheading2(state, startLine, endLine) {
  var content, terminate, i, l2, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
  if (state.sCount[startLine] - state.blkIndent >= 4) {
    return false;
  }
  oldParentType = state.parentType;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      if (pos < max) {
        marker2 = state.src.charCodeAt(pos);
        if (marker2 === 45 || marker2 === 61) {
          pos = state.skipChars(pos, marker2);
          pos = state.skipSpaces(pos);
          if (pos >= max) {
            level = marker2 === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine + 1;
  token2 = state.push("heading_open", "h" + String(level), 1);
  token2.markup = String.fromCharCode(marker2);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state.line - 1];
  token2.children = [];
  token2 = state.push("heading_close", "h" + String(level), -1);
  token2.markup = String.fromCharCode(marker2);
  state.parentType = oldParentType;
  return true;
};
var paragraph = function paragraph2(state, startLine) {
  var content, terminate, i, l2, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
  oldParentType = state.parentType;
  state.parentType = "paragraph";
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    if (state.sCount[nextLine] - state.blkIndent > 3) {
      continue;
    }
    if (state.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  state.line = nextLine;
  token2 = state.push("paragraph_open", "p", 1);
  token2.map = [startLine, state.line];
  token2 = state.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state.line];
  token2.children = [];
  token2 = state.push("paragraph_close", "p", -1);
  state.parentType = oldParentType;
  return true;
};
var Token$1 = token;
var isSpace$4 = utils$1.isSpace;
function StateBlock(src, md2, env, tokens) {
  var ch2, s, start2, pos, len, indent2, offset, indent_found;
  this.src = src;
  this.md = md2;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  this.result = "";
  s = this.src;
  indent_found = false;
  for (start2 = pos = indent2 = offset = 0, len = s.length; pos < len; pos++) {
    ch2 = s.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace$4(ch2)) {
        indent2++;
        if (ch2 === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch2 === 10 || pos === len - 1) {
      if (ch2 !== 10) {
        pos++;
      }
      this.bMarks.push(start2);
      this.eMarks.push(pos);
      this.tShift.push(indent2);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent2 = 0;
      offset = 0;
      start2 = pos + 1;
    }
  }
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
StateBlock.prototype.push = function(type2, tag, nesting) {
  var token2 = new Token$1(type2, tag, nesting);
  token2.block = true;
  if (nesting < 0)
    this.level--;
  token2.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};
StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch2;
  for (var max = this.src.length; pos < max; pos++) {
    ch2 = this.src.charCodeAt(pos);
    if (!isSpace$4(ch2)) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace$4(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.skipChars = function skipChars(pos, code3) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code3) {
      break;
    }
  }
  return pos;
};
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code3, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code3 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
};
StateBlock.prototype.getLines = function getLines(begin, end2, indent2, keepLastLF) {
  var i, lineIndent, ch2, first, last, queue, lineStart, line = begin;
  if (begin >= end2) {
    return "";
  }
  queue = new Array(end2 - begin);
  for (i = 0; line < end2; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];
    if (line + 1 < end2 || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent2) {
      ch2 = this.src.charCodeAt(first);
      if (isSpace$4(ch2)) {
        if (ch2 === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent2) {
      queue[i] = new Array(lineIndent - indent2 + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
};
StateBlock.prototype.Token = Token$1;
var state_block = StateBlock;
var Ruler$1 = ruler;
var _rules$1 = [
  ["table", table, ["paragraph", "reference"]],
  ["code", code$2],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock$1() {
  this.ruler = new Ruler$1();
  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
  var ok2, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state.sCount[line] < state.blkIndent) {
      break;
    }
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }
    for (i = 0; i < len; i++) {
      ok2 = rules[i](state, line, endLine, false);
      if (ok2) {
        break;
      }
    }
    state.tight = !hasEmptyLines;
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }
    line = state.line;
    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};
ParserBlock$1.prototype.parse = function(src, md2, env, outTokens) {
  var state;
  if (!src) {
    return;
  }
  state = new this.State(src, md2, env, outTokens);
  this.tokenize(state, state.line, state.lineMax);
};
ParserBlock$1.prototype.State = state_block;
var parser_block = ParserBlock$1;
function isTerminatorChar(ch2) {
  switch (ch2) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
var text$1 = function text(state, silent) {
  var pos = state.pos;
  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state.pos) {
    return false;
  }
  if (!silent) {
    state.pending += state.src.slice(state.pos, pos);
  }
  state.pos = pos;
  return true;
};
var isSpace$3 = utils$1.isSpace;
var newline = function newline2(state, silent) {
  var pmax, max, ws2, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 10) {
    return false;
  }
  pmax = state.pending.length - 1;
  max = state.posMax;
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
        ws2 = pmax - 1;
        while (ws2 >= 1 && state.pending.charCodeAt(ws2 - 1) === 32)
          ws2--;
        state.pending = state.pending.slice(0, ws2);
        state.push("hardbreak", "br", 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push("softbreak", "br", 0);
      }
    } else {
      state.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {
    pos++;
  }
  state.pos = pos;
  return true;
};
var isSpace$2 = utils$1.isSpace;
var ESCAPED = [];
for (var i$1 = 0; i$1 < 256; i$1++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch2) {
  ESCAPED[ch2.charCodeAt(0)] = 1;
});
var _escape = function escape2(state, silent) {
  var ch2, pos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(pos) !== 92) {
    return false;
  }
  pos++;
  if (pos < max) {
    ch2 = state.src.charCodeAt(pos);
    if (ch2 < 256 && ESCAPED[ch2] !== 0) {
      if (!silent) {
        state.pending += state.src[pos];
      }
      state.pos += 2;
      return true;
    }
    if (ch2 === 10) {
      if (!silent) {
        state.push("hardbreak", "br", 0);
      }
      pos++;
      while (pos < max) {
        ch2 = state.src.charCodeAt(pos);
        if (!isSpace$2(ch2)) {
          break;
        }
        pos++;
      }
      state.pos = pos;
      return true;
    }
  }
  if (!silent) {
    state.pending += "\\";
  }
  state.pos++;
  return true;
};
var backticks = function backtick(state, silent) {
  var start2, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch2 = state.src.charCodeAt(pos);
  if (ch2 !== 96) {
    return false;
  }
  start2 = pos;
  pos++;
  max = state.posMax;
  while (pos < max && state.src.charCodeAt(pos) === 96) {
    pos++;
  }
  marker2 = state.src.slice(start2, pos);
  openerLength = marker2.length;
  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start2) {
    if (!silent)
      state.pending += marker2;
    state.pos += openerLength;
    return true;
  }
  matchStart = matchEnd = pos;
  while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        token2 = state.push("code_inline", "code", 0);
        token2.markup = marker2;
        token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state.pos = matchEnd;
      return true;
    }
    state.backticks[closerLength] = matchStart;
  }
  state.backticksScanned = true;
  if (!silent)
    state.pending += marker2;
  state.pos += openerLength;
  return true;
};
var strikethrough = {};
strikethrough.tokenize = function strikethrough2(state, silent) {
  var i, scanned, token2, len, ch2, start2 = state.pos, marker2 = state.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker2 !== 126) {
    return false;
  }
  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch2 = String.fromCharCode(marker2);
  if (len < 2) {
    return false;
  }
  if (len % 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch2;
    len--;
  }
  for (i = 0; i < len; i += 2) {
    token2 = state.push("text", "", 0);
    token2.content = ch2 + ch2;
    state.delimiters.push({
      marker: marker2,
      length: 0,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess$1(state, delimiters) {
  var i, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    token2 = state.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;
    while (j < state.tokens.length && state.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token2 = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token2;
    }
  }
}
strikethrough.postProcess = function strikethrough3(state) {
  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  postProcess$1(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
};
var emphasis = {};
emphasis.tokenize = function emphasis2(state, silent) {
  var i, scanned, token2, start2 = state.pos, marker2 = state.src.charCodeAt(start2);
  if (silent) {
    return false;
  }
  if (marker2 !== 95 && marker2 !== 42) {
    return false;
  }
  scanned = state.scanDelims(state.pos, marker2 === 42);
  for (i = 0; i < scanned.length; i++) {
    token2 = state.push("text", "", 0);
    token2.content = String.fromCharCode(marker2);
    state.delimiters.push({
      marker: marker2,
      length: scanned.length,
      token: state.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state.pos += scanned.length;
  return true;
};
function postProcess(state, delimiters) {
  var i, startDelim, endDelim, token2, ch2, isStrong, max = delimiters.length;
  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].marker === startDelim.marker && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
    ch2 = String.fromCharCode(startDelim.marker);
    token2 = state.tokens[startDelim.token];
    token2.type = isStrong ? "strong_open" : "em_open";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = 1;
    token2.markup = isStrong ? ch2 + ch2 : ch2;
    token2.content = "";
    token2 = state.tokens[endDelim.token];
    token2.type = isStrong ? "strong_close" : "em_close";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = -1;
    token2.markup = isStrong ? ch2 + ch2 : ch2;
    token2.content = "";
    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = "";
      state.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
emphasis.postProcess = function emphasis3(state) {
  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  postProcess(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};
var normalizeReference$1 = utils$1.normalizeReference;
var isSpace$1 = utils$1.isSpace;
var link = function link2(state, silent) {
  var attrs, code3, label, labelEnd, labelStart, pos, res, ref, token2, href = "", title = "", oldPos = state.pos, max = state.posMax, start2 = state.pos, parseReference = true;
  if (state.src.charCodeAt(state.pos) !== 91) {
    return false;
  }
  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code3 = state.src.charCodeAt(pos);
      if (!isSpace$1(code3) && code3 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start2 = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start2 = pos;
      for (; pos < max; pos++) {
        code3 = state.src.charCodeAt(pos);
        if (!isSpace$1(code3) && code3 !== 10) {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start2 !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code3 = state.src.charCodeAt(pos);
          if (!isSpace$1(code3) && code3 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference$1(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;
    token2 = state.push("link_open", "a", 1);
    token2.attrs = attrs = [["href", href]];
    if (title) {
      attrs.push(["title", title]);
    }
    state.md.inline.tokenize(state);
    token2 = state.push("link_close", "a", -1);
  }
  state.pos = pos;
  state.posMax = max;
  return true;
};
var normalizeReference = utils$1.normalizeReference;
var isSpace = utils$1.isSpace;
var image = function image2(state, silent) {
  var attrs, code3, content, label, labelEnd, labelStart, pos, ref, res, title, token2, tokens, start2, href = "", oldPos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(state.pos) !== 33) {
    return false;
  }
  if (state.src.charCodeAt(state.pos + 1) !== 91) {
    return false;
  }
  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code3 = state.src.charCodeAt(pos);
      if (!isSpace(code3) && code3 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start2 = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start2 = pos;
    for (; pos < max; pos++) {
      code3 = state.src.charCodeAt(pos);
      if (!isSpace(code3) && code3 !== 10) {
        break;
      }
    }
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start2 !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code3 = state.src.charCodeAt(pos);
        if (!isSpace(code3) && code3 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state.src.charCodeAt(pos) !== 41) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state.env.references === "undefined") {
      return false;
    }
    if (pos < max && state.src.charCodeAt(pos) === 91) {
      start2 = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start2, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state.src.slice(labelStart, labelEnd);
    }
    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);
    state.md.inline.parse(content, state.md, state.env, tokens = []);
    token2 = state.push("image", "img", 0);
    token2.attrs = attrs = [["src", href], ["alt", ""]];
    token2.children = tokens;
    token2.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state.pos = pos;
  state.posMax = max;
  return true;
};
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var autolink = function autolink2(state, silent) {
  var url, fullUrl, token2, ch2, start2, max, pos = state.pos;
  if (state.src.charCodeAt(pos) !== 60) {
    return false;
  }
  start2 = state.pos;
  max = state.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    ch2 = state.src.charCodeAt(pos);
    if (ch2 === 60)
      return false;
    if (ch2 === 62)
      break;
  }
  url = state.src.slice(start2 + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink("mailto:" + url);
    if (!state.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state.push("text", "", 0);
      token2.content = state.md.normalizeLinkText(url);
      token2 = state.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state.pos += url.length + 2;
    return true;
  }
  return false;
};
var HTML_TAG_RE = html_re.HTML_TAG_RE;
function isLetter(ch2) {
  var lc2 = ch2 | 32;
  return lc2 >= 97 && lc2 <= 122;
}
var html_inline = function html_inline2(state, silent) {
  var ch2, match2, max, token2, pos = state.pos;
  if (!state.md.options.html) {
    return false;
  }
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  ch2 = state.src.charCodeAt(pos + 1);
  if (ch2 !== 33 && ch2 !== 63 && ch2 !== 47 && !isLetter(ch2)) {
    return false;
  }
  match2 = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    token2 = state.push("html_inline", "", 0);
    token2.content = state.src.slice(pos, pos + match2[0].length);
  }
  state.pos += match2[0].length;
  return true;
};
var entities = entities$1;
var has = utils$1.has;
var isValidEntityCode = utils$1.isValidEntityCode;
var fromCodePoint = utils$1.fromCodePoint;
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
var entity = function entity2(state, silent) {
  var ch2, code3, match2, pos = state.pos, max = state.posMax;
  if (state.src.charCodeAt(pos) !== 38) {
    return false;
  }
  if (pos + 1 < max) {
    ch2 = state.src.charCodeAt(pos + 1);
    if (ch2 === 35) {
      match2 = state.src.slice(pos).match(DIGITAL_RE);
      if (match2) {
        if (!silent) {
          code3 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
          state.pending += isValidEntityCode(code3) ? fromCodePoint(code3) : fromCodePoint(65533);
        }
        state.pos += match2[0].length;
        return true;
      }
    } else {
      match2 = state.src.slice(pos).match(NAMED_RE);
      if (match2) {
        if (has(entities, match2[1])) {
          if (!silent) {
            state.pending += entities[match2[1]];
          }
          state.pos += match2[0].length;
          return true;
        }
      }
    }
  }
  if (!silent) {
    state.pending += "&";
  }
  state.pos++;
  return true;
};
function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
  if (!max)
    return;
  var headerIdx = 0;
  var lastTokenIdx = -2;
  var jumps = [];
  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];
    jumps.push(0);
    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
      headerIdx = closerIdx;
    }
    lastTokenIdx = closer.token;
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    openerIdx = headerIdx - jumps[headerIdx] - 1;
    newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
      opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
          jumps[closerIdx] = closerIdx - openerIdx + lastJump;
          jumps[openerIdx] = lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.close = false;
          newMinOpenerIdx = -1;
          lastTokenIdx = -2;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
var balance_pairs = function link_pairs(state) {
  var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
  processDelimiters(state, state.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};
var text_collapse = function text_collapse2(state) {
  var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
};
var Token = token;
var isWhiteSpace = utils$1.isWhiteSpace;
var isPunctChar = utils$1.isPunctChar;
var isMdAsciiPunct = utils$1.isMdAsciiPunct;
function StateInline(src, md2, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md2;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
}
StateInline.prototype.pushPending = function() {
  var token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type2, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  var token2 = new Token(type2, tag, nesting);
  var token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start2, canSplitWord) {
  var pos = start2, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start2);
  lastChar = start2 > 0 ? this.src.charCodeAt(start2 - 1) : 32;
  while (pos < max && this.src.charCodeAt(pos) === marker2) {
    pos++;
  }
  count = pos - start2;
  nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);
  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }
  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }
  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }
  return {
    can_open,
    can_close,
    length: count
  };
};
StateInline.prototype.Token = Token;
var state_inline = StateInline;
var Ruler = ruler;
var _rules = [
  ["text", text$1],
  ["newline", newline],
  ["escape", _escape],
  ["backticks", backticks],
  ["strikethrough", strikethrough.tokenize],
  ["emphasis", emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules2 = [
  ["balance_pairs", balance_pairs],
  ["strikethrough", strikethrough.postProcess],
  ["emphasis", emphasis.postProcess],
  ["text_collapse", text_collapse]
];
function ParserInline$1() {
  var i;
  this.ruler = new Ruler();
  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
ParserInline$1.prototype.skipToken = function(state) {
  var ok2, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
  if (typeof cache[pos] !== "undefined") {
    state.pos = cache[pos];
    return;
  }
  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      state.level++;
      ok2 = rules[i](state, true);
      state.level--;
      if (ok2) {
        break;
      }
    }
  } else {
    state.pos = state.posMax;
  }
  if (!ok2) {
    state.pos++;
  }
  cache[pos] = state.pos;
};
ParserInline$1.prototype.tokenize = function(state) {
  var ok2, i, rules = this.ruler.getRules(""), len = rules.length, end2 = state.posMax, maxNesting = state.md.options.maxNesting;
  while (state.pos < end2) {
    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok2 = rules[i](state, false);
        if (ok2) {
          break;
        }
      }
    }
    if (ok2) {
      if (state.pos >= end2) {
        break;
      }
      continue;
    }
    state.pending += state.src[state.pos++];
  }
  if (state.pending) {
    state.pushPending();
  }
};
ParserInline$1.prototype.parse = function(str, md2, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md2, env, outTokens);
  this.tokenize(state);
  rules = this.ruler2.getRules("");
  len = rules.length;
  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};
ParserInline$1.prototype.State = state_inline;
var parser_inline = ParserInline$1;
var re = function(opts) {
  var re2 = {};
  re2.src_Any = regex$3.source;
  re2.src_Cc = regex$2.source;
  re2.src_Z = regex.source;
  re2.src_P = regex$4.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  var text_separators = "[><\uFF5C]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + ").|;(?!" + re2.src_ZCc + ").|\\!+(?!" + re2.src_ZCc + "|[!]).|\\?(?!" + re2.src_ZCc + "|[?]).)+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
};
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function isString$2(obj) {
  return _class(obj) === "[object String]";
}
function isObject$4(obj) {
  return _class(obj) === "[object Object]";
}
function isRegExp(obj) {
  return _class(obj) === "[object RegExp]";
}
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}
var defaultSchemas = {
  "http:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text3[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text3[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
function createValidator(re2) {
  return function(text3, pos) {
    var tail = text3.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
function compile(self2) {
  var re$12 = self2.re = re(self2.__opts__);
  var tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re$12.src_xn);
  re$12.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re$12.src_tlds);
  }
  re$12.email_fuzzy = RegExp(untpl(re$12.tpl_email_fuzzy), "i");
  re$12.link_fuzzy = RegExp(untpl(re$12.tpl_link_fuzzy), "i");
  re$12.link_no_ip_fuzzy = RegExp(untpl(re$12.tpl_link_no_ip_fuzzy), "i");
  re$12.host_fuzzy_test = RegExp(untpl(re$12.tpl_host_fuzzy_test), "i");
  var aliases = [];
  self2.__compiled__ = {};
  function schemaError(name2, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
  }
  Object.keys(self2.__schemas__).forEach(function(name2) {
    var val = self2.__schemas__[name2];
    if (val === null) {
      return;
    }
    var compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject$4(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name2, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val);
      }
      return;
    }
    if (isString$2(val)) {
      aliases.push(name2);
      return;
    }
    schemaError(name2, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  var slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$12.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$12.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
  resetScanCache(self2);
}
function Match(self2, shift) {
  var start2 = self2.__index__, end2 = self2.__last_index__, text3 = self2.__text_cache__.slice(start2, end2);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start2 + shift;
  this.lastIndex = end2 + shift;
  this.raw = text3;
  this.text = text3;
  this.url = text3;
}
function createMatch(self2, shift) {
  var match2 = new Match(self2, shift);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
function LinkifyIt$1(schemas, options) {
  if (!(this instanceof LinkifyIt$1)) {
    return new LinkifyIt$1(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
LinkifyIt$1.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};
LinkifyIt$1.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};
LinkifyIt$1.prototype.test = function test(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length) {
    return false;
  }
  var m2, ml, me2, len, shift, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text3)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m2 = re2.exec(text3)) !== null) {
      len = this.testSchemaAt(text3, m2[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m2[2];
        this.__index__ = m2.index + m2[1].length;
        this.__last_index__ = m2.index + m2[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text3.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text3.indexOf("@");
    if (at_pos >= 0) {
      if ((me2 = text3.match(this.re.email_fuzzy)) !== null) {
        shift = me2.index + me2[1].length;
        next = me2.index + me2[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
};
LinkifyIt$1.prototype.pretest = function pretest(text3) {
  return this.re.pretest.test(text3);
};
LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text3, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text3, pos, this);
};
LinkifyIt$1.prototype.match = function match(text3) {
  var shift = 0, result2 = [];
  if (this.__index__ >= 0 && this.__text_cache__ === text3) {
    result2.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  var tail = shift ? text3.slice(shift) : text3;
  while (this.test(tail)) {
    result2.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result2.length) {
    return result2;
  }
  return null;
};
LinkifyIt$1.prototype.tlds = function tlds(list3, keepOld) {
  list3 = Array.isArray(list3) ? list3 : [list3];
  if (!keepOld) {
    this.__tlds__ = list3.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list3).sort().filter(function(el2, idx, arr) {
    return el2 !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
};
LinkifyIt$1.prototype.normalize = function normalize3(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
};
LinkifyIt$1.prototype.onCompile = function onCompile() {
};
var linkifyIt = LinkifyIt$1;
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map(array, fn) {
  const result2 = [];
  let length = array.length;
  while (length--) {
    result2[length] = fn(array[length]);
  }
  return result2;
}
function mapDomain(string2, fn) {
  const parts = string2.split("@");
  let result2 = "";
  if (parts.length > 1) {
    result2 = parts[0] + "@";
    string2 = parts[1];
  }
  string2 = string2.replace(regexSeparators, ".");
  const labels = string2.split(".");
  const encoded = map(labels, fn).join(".");
  return result2 + encoded;
}
function ucs2decode(string2) {
  const output = [];
  let counter = 0;
  const length = string2.length;
  while (counter < length) {
    const value = string2.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string2.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
const ucs2encode = (array) => String.fromCodePoint(...array);
const basicToDigit = function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
};
const digitToBasic = function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};
const adapt = function(delta2, numPoints, firstTime) {
  let k = 0;
  delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
  delta2 += floor(delta2 / numPoints);
  for (; delta2 > baseMinusTMin * tMax >> 1; k += base) {
    delta2 = floor(delta2 / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
};
const decode = function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n2 = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    let oldi = i;
    for (let w = 1, k = base; ; k += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base || digit > floor((maxInt - i) / w)) {
        error("overflow");
      }
      i += digit * w;
      const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n2) {
      error("overflow");
    }
    n2 += floor(i / out);
    i %= out;
    output.splice(i++, 0, n2);
  }
  return String.fromCodePoint(...output);
};
const encode = function(input) {
  const output = [];
  input = ucs2decode(input);
  let inputLength = input.length;
  let n2 = initialN;
  let delta2 = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta2) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta2 += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta2 > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        let q2 = delta2;
        for (let k = base; ; k += base) {
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (q2 < t2) {
            break;
          }
          const qMinusT = q2 - t2;
          const baseMinusT = base - t2;
          output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
        delta2 = 0;
        ++handledCPCount;
      }
    }
    ++delta2;
    ++n2;
  }
  return output.join("");
};
const toUnicode = function(input) {
  return mapDomain(input, function(string2) {
    return regexPunycode.test(string2) ? decode(string2.slice(4).toLowerCase()) : string2;
  });
};
const toASCII = function(input) {
  return mapDomain(input, function(string2) {
    return regexNonASCII.test(string2) ? "xn--" + encode(string2) : string2;
  });
};
const punycode$1 = {
  "version": "2.1.0",
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  ucs2decode,
  ucs2encode,
  decode,
  encode,
  toASCII,
  toUnicode,
  "default": punycode$1
});
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
var _default$1 = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var zero = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
};
var commonmark = {
  options: {
    html: true,
    xhtmlOut: true,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
};
var utils = utils$1;
var helpers = helpers$1;
var Renderer = renderer;
var ParserCore = parser_core;
var ParserBlock = parser_block;
var ParserInline = parser_inline;
var LinkifyIt = linkifyIt;
var mdurl = mdurl$1;
var punycode = require$$8;
var config = {
  default: _default$1,
  zero,
  commonmark
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  var str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.encode(mdurl.format(parsed));
}
function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
}
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new ParserCore();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils;
  this.helpers = utils.assign({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
MarkdownIt.prototype.set = function(options) {
  utils.assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  var self2 = this, presetName;
  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list3, ignoreInvalid) {
  var result2 = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result2 = result2.concat(this[chain].ruler.enable(list3, true));
  }, this);
  result2 = result2.concat(this.inline.ruler2.enable(list3, true));
  var missed = list3.filter(function(name2) {
    return result2.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list3, ignoreInvalid) {
  var result2 = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result2 = result2.concat(this[chain].ruler.disable(list3, true));
  }, this);
  result2 = result2.concat(this.inline.ruler2.disable(list3, true));
  var missed = list3.filter(function(name2) {
    return result2.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  var state = new this.core.State(src, this, env);
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  var state = new this.core.State(src, this, env);
  state.inlineMode = true;
  this.core.process(state);
  return state.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib = MarkdownIt;
var markdownIt = lib;
var invalidCharacters = Array.from({ length: 11 }, function(_, i) {
  return String.fromCharCode(8192 + i);
}).concat(["\u2028", "\u2029", "\u202F", "\xA0"]);
var sanitizeRegex = new RegExp("[" + invalidCharacters.join("") + "]", "g");
function normalizeWhitespace(line) {
  return line.replace(sanitizeRegex, " ");
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml;
function escapeHtml(string2) {
  var str = "" + string2;
  var match2 = matchHtmlRegExp.exec(str);
  if (!match2) {
    return str;
  }
  var escape3;
  var html = "";
  var index = 0;
  var lastIndex = 0;
  for (index = match2.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        escape3 = "&quot;";
        break;
      case 38:
        escape3 = "&amp;";
        break;
      case 39:
        escape3 = "&#39;";
        break;
      case 60:
        escape3 = "&lt;";
        break;
      case 62:
        escape3 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }
    lastIndex = index + 1;
    html += escape3;
  }
  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
var codemirror = { exports: {} };
(function(module2, exports) {
  (function(global2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    var userAgent = navigator.userAgent;
    var platform = navigator.platform;
    var gecko = /gecko\/\d/i.test(userAgent);
    var ie_upto10 = /MSIE \d/.test(userAgent);
    var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
    var edge = /Edge\/(\d+)/.exec(userAgent);
    var ie2 = ie_upto10 || ie_11up || edge;
    var ie_version = ie2 && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
    var webkit = !edge && /WebKit\//.test(userAgent);
    var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
    var chrome = !edge && /Chrome\//.test(userAgent);
    var presto = /Opera\//.test(userAgent);
    var safari = /Apple Computer/.test(navigator.vendor);
    var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
    var phantom = /PhantomJS/.test(userAgent);
    var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
    var android = /Android/.test(userAgent);
    var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
    var mac = ios || /Mac/.test(platform);
    var chromeOS = /\bCrOS\b/.test(userAgent);
    var windows = /win/i.test(platform);
    var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
    if (presto_version) {
      presto_version = Number(presto_version[1]);
    }
    if (presto_version && presto_version >= 15) {
      presto = false;
      webkit = true;
    }
    var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
    var captureRightClick = gecko || ie2 && ie_version >= 9;
    function classTest(cls) {
      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    var rmClass = function(node, cls) {
      var current = node.className;
      var match2 = classTest(cls).exec(current);
      if (match2) {
        var after = current.slice(match2.index + match2[0].length);
        node.className = current.slice(0, match2.index) + (after ? match2[1] + after : "");
      }
    };
    function removeChildren(e) {
      for (var count = e.childNodes.length; count > 0; --count) {
        e.removeChild(e.firstChild);
      }
      return e;
    }
    function removeChildrenAndAdd(parent, e) {
      return removeChildren(parent).appendChild(e);
    }
    function elt(tag, content, className, style) {
      var e = document.createElement(tag);
      if (className) {
        e.className = className;
      }
      if (style) {
        e.style.cssText = style;
      }
      if (typeof content == "string") {
        e.appendChild(document.createTextNode(content));
      } else if (content) {
        for (var i2 = 0; i2 < content.length; ++i2) {
          e.appendChild(content[i2]);
        }
      }
      return e;
    }
    function eltP(tag, content, className, style) {
      var e = elt(tag, content, className, style);
      e.setAttribute("role", "presentation");
      return e;
    }
    var range2;
    if (document.createRange) {
      range2 = function(node, start2, end2, endNode) {
        var r2 = document.createRange();
        r2.setEnd(endNode || node, end2);
        r2.setStart(node, start2);
        return r2;
      };
    } else {
      range2 = function(node, start2, end2) {
        var r2 = document.body.createTextRange();
        try {
          r2.moveToElementText(node.parentNode);
        } catch (e) {
          return r2;
        }
        r2.collapse(true);
        r2.moveEnd("character", end2);
        r2.moveStart("character", start2);
        return r2;
      };
    }
    function contains(parent, child) {
      if (child.nodeType == 3) {
        child = child.parentNode;
      }
      if (parent.contains) {
        return parent.contains(child);
      }
      do {
        if (child.nodeType == 11) {
          child = child.host;
        }
        if (child == parent) {
          return true;
        }
      } while (child = child.parentNode);
    }
    function activeElt() {
      var activeElement;
      try {
        activeElement = document.activeElement;
      } catch (e) {
        activeElement = document.body || null;
      }
      while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }
      return activeElement;
    }
    function addClass(node, cls) {
      var current = node.className;
      if (!classTest(cls).test(current)) {
        node.className += (current ? " " : "") + cls;
      }
    }
    function joinClasses(a, b) {
      var as = a.split(" ");
      for (var i2 = 0; i2 < as.length; i2++) {
        if (as[i2] && !classTest(as[i2]).test(b)) {
          b += " " + as[i2];
        }
      }
      return b;
    }
    var selectInput = function(node) {
      node.select();
    };
    if (ios) {
      selectInput = function(node) {
        node.selectionStart = 0;
        node.selectionEnd = node.value.length;
      };
    } else if (ie2) {
      selectInput = function(node) {
        try {
          node.select();
        } catch (_e) {
        }
      };
    }
    function bind(f) {
      var args = Array.prototype.slice.call(arguments, 1);
      return function() {
        return f.apply(null, args);
      };
    }
    function copyObj(obj, target2, overwrite) {
      if (!target2) {
        target2 = {};
      }
      for (var prop3 in obj) {
        if (obj.hasOwnProperty(prop3) && (overwrite !== false || !target2.hasOwnProperty(prop3))) {
          target2[prop3] = obj[prop3];
        }
      }
      return target2;
    }
    function countColumn(string2, end2, tabSize, startIndex, startValue) {
      if (end2 == null) {
        end2 = string2.search(/[^\s\u00a0]/);
        if (end2 == -1) {
          end2 = string2.length;
        }
      }
      for (var i2 = startIndex || 0, n2 = startValue || 0; ; ) {
        var nextTab = string2.indexOf("	", i2);
        if (nextTab < 0 || nextTab >= end2) {
          return n2 + (end2 - i2);
        }
        n2 += nextTab - i2;
        n2 += tabSize - n2 % tabSize;
        i2 = nextTab + 1;
      }
    }
    var Delayed = function() {
      this.id = null;
      this.f = null;
      this.time = 0;
      this.handler = bind(this.onTimeout, this);
    };
    Delayed.prototype.onTimeout = function(self2) {
      self2.id = 0;
      if (self2.time <= +new Date()) {
        self2.f();
      } else {
        setTimeout(self2.handler, self2.time - +new Date());
      }
    };
    Delayed.prototype.set = function(ms, f) {
      this.f = f;
      var time = +new Date() + ms;
      if (!this.id || time < this.time) {
        clearTimeout(this.id);
        this.id = setTimeout(this.handler, ms);
        this.time = time;
      }
    };
    function indexOf(array, elt2) {
      for (var i2 = 0; i2 < array.length; ++i2) {
        if (array[i2] == elt2) {
          return i2;
        }
      }
      return -1;
    }
    var scrollerGap = 50;
    var Pass = { toString: function() {
      return "CodeMirror.Pass";
    } };
    var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
    function findColumn(string2, goal, tabSize) {
      for (var pos = 0, col = 0; ; ) {
        var nextTab = string2.indexOf("	", pos);
        if (nextTab == -1) {
          nextTab = string2.length;
        }
        var skipped = nextTab - pos;
        if (nextTab == string2.length || col + skipped >= goal) {
          return pos + Math.min(skipped, goal - col);
        }
        col += nextTab - pos;
        col += tabSize - col % tabSize;
        pos = nextTab + 1;
        if (col >= goal) {
          return pos;
        }
      }
    }
    var spaceStrs = [""];
    function spaceStr(n2) {
      while (spaceStrs.length <= n2) {
        spaceStrs.push(lst(spaceStrs) + " ");
      }
      return spaceStrs[n2];
    }
    function lst(arr) {
      return arr[arr.length - 1];
    }
    function map2(array, f) {
      var out = [];
      for (var i2 = 0; i2 < array.length; i2++) {
        out[i2] = f(array[i2], i2);
      }
      return out;
    }
    function insertSorted(array, value, score) {
      var pos = 0, priority = score(value);
      while (pos < array.length && score(array[pos]) <= priority) {
        pos++;
      }
      array.splice(pos, 0, value);
    }
    function nothing() {
    }
    function createObj(base2, props) {
      var inst;
      if (Object.create) {
        inst = Object.create(base2);
      } else {
        nothing.prototype = base2;
        inst = new nothing();
      }
      if (props) {
        copyObj(props, inst);
      }
      return inst;
    }
    var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
    function isWordCharBasic(ch2) {
      return /\w/.test(ch2) || ch2 > "\x80" && (ch2.toUpperCase() != ch2.toLowerCase() || nonASCIISingleCaseWordChar.test(ch2));
    }
    function isWordChar(ch2, helper) {
      if (!helper) {
        return isWordCharBasic(ch2);
      }
      if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch2)) {
        return true;
      }
      return helper.test(ch2);
    }
    function isEmpty2(obj) {
      for (var n2 in obj) {
        if (obj.hasOwnProperty(n2) && obj[n2]) {
          return false;
        }
      }
      return true;
    }
    var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
    function isExtendingChar(ch2) {
      return ch2.charCodeAt(0) >= 768 && extendingChars.test(ch2);
    }
    function skipExtendingChars(str, pos, dir) {
      while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
        pos += dir;
      }
      return pos;
    }
    function findFirst(pred, from, to) {
      var dir = from > to ? -1 : 1;
      for (; ; ) {
        if (from == to) {
          return from;
        }
        var midF = (from + to) / 2, mid2 = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
        if (mid2 == from) {
          return pred(mid2) ? from : to;
        }
        if (pred(mid2)) {
          to = mid2;
        } else {
          from = mid2 + dir;
        }
      }
    }
    function iterateBidiSections(order2, from, to, f) {
      if (!order2) {
        return f(from, to, "ltr", 0);
      }
      var found = false;
      for (var i2 = 0; i2 < order2.length; ++i2) {
        var part2 = order2[i2];
        if (part2.from < to && part2.to > from || from == to && part2.to == from) {
          f(Math.max(part2.from, from), Math.min(part2.to, to), part2.level == 1 ? "rtl" : "ltr", i2);
          found = true;
        }
      }
      if (!found) {
        f(from, to, "ltr");
      }
    }
    var bidiOther = null;
    function getBidiPartAt(order2, ch2, sticky) {
      var found;
      bidiOther = null;
      for (var i2 = 0; i2 < order2.length; ++i2) {
        var cur = order2[i2];
        if (cur.from < ch2 && cur.to > ch2) {
          return i2;
        }
        if (cur.to == ch2) {
          if (cur.from != cur.to && sticky == "before") {
            found = i2;
          } else {
            bidiOther = i2;
          }
        }
        if (cur.from == ch2) {
          if (cur.from != cur.to && sticky != "before") {
            found = i2;
          } else {
            bidiOther = i2;
          }
        }
      }
      return found != null ? found : bidiOther;
    }
    var bidiOrdering = function() {
      var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
      var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
      function charType(code3) {
        if (code3 <= 247) {
          return lowTypes.charAt(code3);
        } else if (1424 <= code3 && code3 <= 1524) {
          return "R";
        } else if (1536 <= code3 && code3 <= 1785) {
          return arabicTypes.charAt(code3 - 1536);
        } else if (1774 <= code3 && code3 <= 2220) {
          return "r";
        } else if (8192 <= code3 && code3 <= 8203) {
          return "w";
        } else if (code3 == 8204) {
          return "b";
        } else {
          return "L";
        }
      }
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
      function BidiSpan(level, from, to) {
        this.level = level;
        this.from = from;
        this.to = to;
      }
      return function(str, direction) {
        var outerType = direction == "ltr" ? "L" : "R";
        if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
          return false;
        }
        var len = str.length, types = [];
        for (var i2 = 0; i2 < len; ++i2) {
          types.push(charType(str.charCodeAt(i2)));
        }
        for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
          var type2 = types[i$12];
          if (type2 == "m") {
            types[i$12] = prev;
          } else {
            prev = type2;
          }
        }
        for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
          var type$1 = types[i$22];
          if (type$1 == "1" && cur == "r") {
            types[i$22] = "n";
          } else if (isStrong.test(type$1)) {
            cur = type$1;
            if (type$1 == "r") {
              types[i$22] = "R";
            }
          }
        }
        for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
          var type$2 = types[i$3];
          if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
            types[i$3] = "1";
          } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
            types[i$3] = prev$1;
          }
          prev$1 = type$2;
        }
        for (var i$4 = 0; i$4 < len; ++i$4) {
          var type$3 = types[i$4];
          if (type$3 == ",") {
            types[i$4] = "N";
          } else if (type$3 == "%") {
            var end2 = void 0;
            for (end2 = i$4 + 1; end2 < len && types[end2] == "%"; ++end2) {
            }
            var replace2 = i$4 && types[i$4 - 1] == "!" || end2 < len && types[end2] == "1" ? "1" : "N";
            for (var j = i$4; j < end2; ++j) {
              types[j] = replace2;
            }
            i$4 = end2 - 1;
          }
        }
        for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
          var type$4 = types[i$5];
          if (cur$1 == "L" && type$4 == "1") {
            types[i$5] = "L";
          } else if (isStrong.test(type$4)) {
            cur$1 = type$4;
          }
        }
        for (var i$6 = 0; i$6 < len; ++i$6) {
          if (isNeutral.test(types[i$6])) {
            var end$1 = void 0;
            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {
            }
            var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
            var after = (end$1 < len ? types[end$1] : outerType) == "L";
            var replace$1 = before == after ? before ? "L" : "R" : outerType;
            for (var j$1 = i$6; j$1 < end$1; ++j$1) {
              types[j$1] = replace$1;
            }
            i$6 = end$1 - 1;
          }
        }
        var order2 = [], m2;
        for (var i$7 = 0; i$7 < len; ) {
          if (countsAsLeft.test(types[i$7])) {
            var start2 = i$7;
            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {
            }
            order2.push(new BidiSpan(0, start2, i$7));
          } else {
            var pos = i$7, at = order2.length, isRTL = direction == "rtl" ? 1 : 0;
            for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {
            }
            for (var j$2 = pos; j$2 < i$7; ) {
              if (countsAsNum.test(types[j$2])) {
                if (pos < j$2) {
                  order2.splice(at, 0, new BidiSpan(1, pos, j$2));
                  at += isRTL;
                }
                var nstart = j$2;
                for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                }
                order2.splice(at, 0, new BidiSpan(2, nstart, j$2));
                at += isRTL;
                pos = j$2;
              } else {
                ++j$2;
              }
            }
            if (pos < i$7) {
              order2.splice(at, 0, new BidiSpan(1, pos, i$7));
            }
          }
        }
        if (direction == "ltr") {
          if (order2[0].level == 1 && (m2 = str.match(/^\s+/))) {
            order2[0].from = m2[0].length;
            order2.unshift(new BidiSpan(0, 0, m2[0].length));
          }
          if (lst(order2).level == 1 && (m2 = str.match(/\s+$/))) {
            lst(order2).to -= m2[0].length;
            order2.push(new BidiSpan(0, len - m2[0].length, len));
          }
        }
        return direction == "rtl" ? order2.reverse() : order2;
      };
    }();
    function getOrder(line, direction) {
      var order2 = line.order;
      if (order2 == null) {
        order2 = line.order = bidiOrdering(line.text, direction);
      }
      return order2;
    }
    var noHandlers = [];
    var on = function(emitter, type2, f) {
      if (emitter.addEventListener) {
        emitter.addEventListener(type2, f, false);
      } else if (emitter.attachEvent) {
        emitter.attachEvent("on" + type2, f);
      } else {
        var map3 = emitter._handlers || (emitter._handlers = {});
        map3[type2] = (map3[type2] || noHandlers).concat(f);
      }
    };
    function getHandlers(emitter, type2) {
      return emitter._handlers && emitter._handlers[type2] || noHandlers;
    }
    function off(emitter, type2, f) {
      if (emitter.removeEventListener) {
        emitter.removeEventListener(type2, f, false);
      } else if (emitter.detachEvent) {
        emitter.detachEvent("on" + type2, f);
      } else {
        var map3 = emitter._handlers, arr = map3 && map3[type2];
        if (arr) {
          var index = indexOf(arr, f);
          if (index > -1) {
            map3[type2] = arr.slice(0, index).concat(arr.slice(index + 1));
          }
        }
      }
    }
    function signal(emitter, type2) {
      var handlers = getHandlers(emitter, type2);
      if (!handlers.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2);
      for (var i2 = 0; i2 < handlers.length; ++i2) {
        handlers[i2].apply(null, args);
      }
    }
    function signalDOMEvent(cm, e, override) {
      if (typeof e == "string") {
        e = { type: e, preventDefault: function() {
          this.defaultPrevented = true;
        } };
      }
      signal(cm, override || e.type, cm, e);
      return e_defaultPrevented(e) || e.codemirrorIgnore;
    }
    function signalCursorActivity(cm) {
      var arr = cm._handlers && cm._handlers.cursorActivity;
      if (!arr) {
        return;
      }
      var set2 = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
      for (var i2 = 0; i2 < arr.length; ++i2) {
        if (indexOf(set2, arr[i2]) == -1) {
          set2.push(arr[i2]);
        }
      }
    }
    function hasHandler(emitter, type2) {
      return getHandlers(emitter, type2).length > 0;
    }
    function eventMixin(ctor) {
      ctor.prototype.on = function(type2, f) {
        on(this, type2, f);
      };
      ctor.prototype.off = function(type2, f) {
        off(this, type2, f);
      };
    }
    function e_preventDefault(e) {
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
    function e_stopPropagation(e) {
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        e.cancelBubble = true;
      }
    }
    function e_defaultPrevented(e) {
      return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
    }
    function e_stop(e) {
      e_preventDefault(e);
      e_stopPropagation(e);
    }
    function e_target(e) {
      return e.target || e.srcElement;
    }
    function e_button(e) {
      var b = e.which;
      if (b == null) {
        if (e.button & 1) {
          b = 1;
        } else if (e.button & 2) {
          b = 3;
        } else if (e.button & 4) {
          b = 2;
        }
      }
      if (mac && e.ctrlKey && b == 1) {
        b = 3;
      }
      return b;
    }
    var dragAndDrop = function() {
      if (ie2 && ie_version < 9) {
        return false;
      }
      var div2 = elt("div");
      return "draggable" in div2 || "dragDrop" in div2;
    }();
    var zwspSupported;
    function zeroWidthElement(measure) {
      if (zwspSupported == null) {
        var test2 = elt("span", "\u200B");
        removeChildrenAndAdd(measure, elt("span", [test2, document.createTextNode("x")]));
        if (measure.firstChild.offsetHeight != 0) {
          zwspSupported = test2.offsetWidth <= 1 && test2.offsetHeight > 2 && !(ie2 && ie_version < 8);
        }
      }
      var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
      node.setAttribute("cm-text", "");
      return node;
    }
    var badBidiRects;
    function hasBadBidiRects(measure) {
      if (badBidiRects != null) {
        return badBidiRects;
      }
      var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
      var r0 = range2(txt, 0, 1).getBoundingClientRect();
      var r1 = range2(txt, 1, 2).getBoundingClientRect();
      removeChildren(measure);
      if (!r0 || r0.left == r0.right) {
        return false;
      }
      return badBidiRects = r1.right - r0.right < 3;
    }
    var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string2) {
      var pos = 0, result2 = [], l2 = string2.length;
      while (pos <= l2) {
        var nl = string2.indexOf("\n", pos);
        if (nl == -1) {
          nl = string2.length;
        }
        var line = string2.slice(pos, string2.charAt(nl - 1) == "\r" ? nl - 1 : nl);
        var rt = line.indexOf("\r");
        if (rt != -1) {
          result2.push(line.slice(0, rt));
          pos += rt + 1;
        } else {
          result2.push(line);
          pos = nl + 1;
        }
      }
      return result2;
    } : function(string2) {
      return string2.split(/\r\n?|\n/);
    };
    var hasSelection = window.getSelection ? function(te2) {
      try {
        return te2.selectionStart != te2.selectionEnd;
      } catch (e) {
        return false;
      }
    } : function(te2) {
      var range3;
      try {
        range3 = te2.ownerDocument.selection.createRange();
      } catch (e) {
      }
      if (!range3 || range3.parentElement() != te2) {
        return false;
      }
      return range3.compareEndPoints("StartToEnd", range3) != 0;
    };
    var hasCopyEvent = function() {
      var e = elt("div");
      if ("oncopy" in e) {
        return true;
      }
      e.setAttribute("oncopy", "return;");
      return typeof e.oncopy == "function";
    }();
    var badZoomedRects = null;
    function hasBadZoomedRects(measure) {
      if (badZoomedRects != null) {
        return badZoomedRects;
      }
      var node = removeChildrenAndAdd(measure, elt("span", "x"));
      var normal = node.getBoundingClientRect();
      var fromRange = range2(node, 0, 1).getBoundingClientRect();
      return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
    }
    var modes = {}, mimeModes = {};
    function defineMode(name2, mode2) {
      if (arguments.length > 2) {
        mode2.dependencies = Array.prototype.slice.call(arguments, 2);
      }
      modes[name2] = mode2;
    }
    function defineMIME(mime, spec) {
      mimeModes[mime] = spec;
    }
    function resolveMode(spec) {
      if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
        spec = mimeModes[spec];
      } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
        var found = mimeModes[spec.name];
        if (typeof found == "string") {
          found = { name: found };
        }
        spec = createObj(found, spec);
        spec.name = found.name;
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
        return resolveMode("application/xml");
      } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
        return resolveMode("application/json");
      }
      if (typeof spec == "string") {
        return { name: spec };
      } else {
        return spec || { name: "null" };
      }
    }
    function getMode(options, spec) {
      spec = resolveMode(spec);
      var mfactory = modes[spec.name];
      if (!mfactory) {
        return getMode(options, "text/plain");
      }
      var modeObj = mfactory(options, spec);
      if (modeExtensions.hasOwnProperty(spec.name)) {
        var exts = modeExtensions[spec.name];
        for (var prop3 in exts) {
          if (!exts.hasOwnProperty(prop3)) {
            continue;
          }
          if (modeObj.hasOwnProperty(prop3)) {
            modeObj["_" + prop3] = modeObj[prop3];
          }
          modeObj[prop3] = exts[prop3];
        }
      }
      modeObj.name = spec.name;
      if (spec.helperType) {
        modeObj.helperType = spec.helperType;
      }
      if (spec.modeProps) {
        for (var prop$1 in spec.modeProps) {
          modeObj[prop$1] = spec.modeProps[prop$1];
        }
      }
      return modeObj;
    }
    var modeExtensions = {};
    function extendMode(mode2, properties) {
      var exts = modeExtensions.hasOwnProperty(mode2) ? modeExtensions[mode2] : modeExtensions[mode2] = {};
      copyObj(properties, exts);
    }
    function copyState(mode2, state) {
      if (state === true) {
        return state;
      }
      if (mode2.copyState) {
        return mode2.copyState(state);
      }
      var nstate = {};
      for (var n2 in state) {
        var val = state[n2];
        if (val instanceof Array) {
          val = val.concat([]);
        }
        nstate[n2] = val;
      }
      return nstate;
    }
    function innerMode(mode2, state) {
      var info2;
      while (mode2.innerMode) {
        info2 = mode2.innerMode(state);
        if (!info2 || info2.mode == mode2) {
          break;
        }
        state = info2.state;
        mode2 = info2.mode;
      }
      return info2 || { mode: mode2, state };
    }
    function startState(mode2, a1, a2) {
      return mode2.startState ? mode2.startState(a1, a2) : true;
    }
    var StringStream = function(string2, tabSize, lineOracle) {
      this.pos = this.start = 0;
      this.string = string2;
      this.tabSize = tabSize || 8;
      this.lastColumnPos = this.lastColumnValue = 0;
      this.lineStart = 0;
      this.lineOracle = lineOracle;
    };
    StringStream.prototype.eol = function() {
      return this.pos >= this.string.length;
    };
    StringStream.prototype.sol = function() {
      return this.pos == this.lineStart;
    };
    StringStream.prototype.peek = function() {
      return this.string.charAt(this.pos) || void 0;
    };
    StringStream.prototype.next = function() {
      if (this.pos < this.string.length) {
        return this.string.charAt(this.pos++);
      }
    };
    StringStream.prototype.eat = function(match2) {
      var ch2 = this.string.charAt(this.pos);
      var ok2;
      if (typeof match2 == "string") {
        ok2 = ch2 == match2;
      } else {
        ok2 = ch2 && (match2.test ? match2.test(ch2) : match2(ch2));
      }
      if (ok2) {
        ++this.pos;
        return ch2;
      }
    };
    StringStream.prototype.eatWhile = function(match2) {
      var start2 = this.pos;
      while (this.eat(match2)) {
      }
      return this.pos > start2;
    };
    StringStream.prototype.eatSpace = function() {
      var start2 = this.pos;
      while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
        ++this.pos;
      }
      return this.pos > start2;
    };
    StringStream.prototype.skipToEnd = function() {
      this.pos = this.string.length;
    };
    StringStream.prototype.skipTo = function(ch2) {
      var found = this.string.indexOf(ch2, this.pos);
      if (found > -1) {
        this.pos = found;
        return true;
      }
    };
    StringStream.prototype.backUp = function(n2) {
      this.pos -= n2;
    };
    StringStream.prototype.column = function() {
      if (this.lastColumnPos < this.start) {
        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
        this.lastColumnPos = this.start;
      }
      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.indentation = function() {
      return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
    };
    StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
      if (typeof pattern == "string") {
        var cased = function(str) {
          return caseInsensitive ? str.toLowerCase() : str;
        };
        var substr = this.string.substr(this.pos, pattern.length);
        if (cased(substr) == cased(pattern)) {
          if (consume !== false) {
            this.pos += pattern.length;
          }
          return true;
        }
      } else {
        var match2 = this.string.slice(this.pos).match(pattern);
        if (match2 && match2.index > 0) {
          return null;
        }
        if (match2 && consume !== false) {
          this.pos += match2[0].length;
        }
        return match2;
      }
    };
    StringStream.prototype.current = function() {
      return this.string.slice(this.start, this.pos);
    };
    StringStream.prototype.hideFirstChars = function(n2, inner) {
      this.lineStart += n2;
      try {
        return inner();
      } finally {
        this.lineStart -= n2;
      }
    };
    StringStream.prototype.lookAhead = function(n2) {
      var oracle = this.lineOracle;
      return oracle && oracle.lookAhead(n2);
    };
    StringStream.prototype.baseToken = function() {
      var oracle = this.lineOracle;
      return oracle && oracle.baseToken(this.pos);
    };
    function getLine2(doc, n2) {
      n2 -= doc.first;
      if (n2 < 0 || n2 >= doc.size) {
        throw new Error("There is no line " + (n2 + doc.first) + " in the document.");
      }
      var chunk = doc;
      while (!chunk.lines) {
        for (var i2 = 0; ; ++i2) {
          var child = chunk.children[i2], sz = child.chunkSize();
          if (n2 < sz) {
            chunk = child;
            break;
          }
          n2 -= sz;
        }
      }
      return chunk.lines[n2];
    }
    function getBetween(doc, start2, end2) {
      var out = [], n2 = start2.line;
      doc.iter(start2.line, end2.line + 1, function(line) {
        var text3 = line.text;
        if (n2 == end2.line) {
          text3 = text3.slice(0, end2.ch);
        }
        if (n2 == start2.line) {
          text3 = text3.slice(start2.ch);
        }
        out.push(text3);
        ++n2;
      });
      return out;
    }
    function getLines2(doc, from, to) {
      var out = [];
      doc.iter(from, to, function(line) {
        out.push(line.text);
      });
      return out;
    }
    function updateLineHeight(line, height) {
      var diff2 = height - line.height;
      if (diff2) {
        for (var n2 = line; n2; n2 = n2.parent) {
          n2.height += diff2;
        }
      }
    }
    function lineNo(line) {
      if (line.parent == null) {
        return null;
      }
      var cur = line.parent, no = indexOf(cur.lines, line);
      for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
        for (var i2 = 0; ; ++i2) {
          if (chunk.children[i2] == cur) {
            break;
          }
          no += chunk.children[i2].chunkSize();
        }
      }
      return no + cur.first;
    }
    function lineAtHeight(chunk, h) {
      var n2 = chunk.first;
      outer:
        do {
          for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
            var child = chunk.children[i$12], ch2 = child.height;
            if (h < ch2) {
              chunk = child;
              continue outer;
            }
            h -= ch2;
            n2 += child.chunkSize();
          }
          return n2;
        } while (!chunk.lines);
      var i2 = 0;
      for (; i2 < chunk.lines.length; ++i2) {
        var line = chunk.lines[i2], lh2 = line.height;
        if (h < lh2) {
          break;
        }
        h -= lh2;
      }
      return n2 + i2;
    }
    function isLine(doc, l2) {
      return l2 >= doc.first && l2 < doc.first + doc.size;
    }
    function lineNumberFor(options, i2) {
      return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
    }
    function Pos(line, ch2, sticky) {
      if (sticky === void 0)
        sticky = null;
      if (!(this instanceof Pos)) {
        return new Pos(line, ch2, sticky);
      }
      this.line = line;
      this.ch = ch2;
      this.sticky = sticky;
    }
    function cmp(a, b) {
      return a.line - b.line || a.ch - b.ch;
    }
    function equalCursorPos(a, b) {
      return a.sticky == b.sticky && cmp(a, b) == 0;
    }
    function copyPos(x2) {
      return Pos(x2.line, x2.ch);
    }
    function maxPos(a, b) {
      return cmp(a, b) < 0 ? b : a;
    }
    function minPos(a, b) {
      return cmp(a, b) < 0 ? a : b;
    }
    function clipLine(doc, n2) {
      return Math.max(doc.first, Math.min(n2, doc.first + doc.size - 1));
    }
    function clipPos(doc, pos) {
      if (pos.line < doc.first) {
        return Pos(doc.first, 0);
      }
      var last = doc.first + doc.size - 1;
      if (pos.line > last) {
        return Pos(last, getLine2(doc, last).text.length);
      }
      return clipToLen(pos, getLine2(doc, pos.line).text.length);
    }
    function clipToLen(pos, linelen) {
      var ch2 = pos.ch;
      if (ch2 == null || ch2 > linelen) {
        return Pos(pos.line, linelen);
      } else if (ch2 < 0) {
        return Pos(pos.line, 0);
      } else {
        return pos;
      }
    }
    function clipPosArray(doc, array) {
      var out = [];
      for (var i2 = 0; i2 < array.length; i2++) {
        out[i2] = clipPos(doc, array[i2]);
      }
      return out;
    }
    var SavedContext = function(state, lookAhead) {
      this.state = state;
      this.lookAhead = lookAhead;
    };
    var Context = function(doc, state, line, lookAhead) {
      this.state = state;
      this.doc = doc;
      this.line = line;
      this.maxLookAhead = lookAhead || 0;
      this.baseTokens = null;
      this.baseTokenPos = 1;
    };
    Context.prototype.lookAhead = function(n2) {
      var line = this.doc.getLine(this.line + n2);
      if (line != null && n2 > this.maxLookAhead) {
        this.maxLookAhead = n2;
      }
      return line;
    };
    Context.prototype.baseToken = function(n2) {
      if (!this.baseTokens) {
        return null;
      }
      while (this.baseTokens[this.baseTokenPos] <= n2) {
        this.baseTokenPos += 2;
      }
      var type2 = this.baseTokens[this.baseTokenPos + 1];
      return {
        type: type2 && type2.replace(/( |^)overlay .*/, ""),
        size: this.baseTokens[this.baseTokenPos] - n2
      };
    };
    Context.prototype.nextLine = function() {
      this.line++;
      if (this.maxLookAhead > 0) {
        this.maxLookAhead--;
      }
    };
    Context.fromSaved = function(doc, saved, line) {
      if (saved instanceof SavedContext) {
        return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
      } else {
        return new Context(doc, copyState(doc.mode, saved), line);
      }
    };
    Context.prototype.save = function(copy2) {
      var state = copy2 !== false ? copyState(this.doc.mode, this.state) : this.state;
      return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
    };
    function highlightLine(cm, line, context, forceToEnd) {
      var st = [cm.state.modeGen], lineClasses = {};
      runMode(cm, line.text, cm.doc.mode, context, function(end2, style) {
        return st.push(end2, style);
      }, lineClasses, forceToEnd);
      var state = context.state;
      var loop = function(o2) {
        context.baseTokens = st;
        var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
        context.state = true;
        runMode(cm, line.text, overlay.mode, context, function(end2, style) {
          var start2 = i2;
          while (at < end2) {
            var i_end = st[i2];
            if (i_end > end2) {
              st.splice(i2, 1, end2, st[i2 + 1], i_end);
            }
            i2 += 2;
            at = Math.min(end2, i_end);
          }
          if (!style) {
            return;
          }
          if (overlay.opaque) {
            st.splice(start2, i2 - start2, end2, "overlay " + style);
            i2 = start2 + 2;
          } else {
            for (; start2 < i2; start2 += 2) {
              var cur = st[start2 + 1];
              st[start2 + 1] = (cur ? cur + " " : "") + "overlay " + style;
            }
          }
        }, lineClasses);
        context.state = state;
        context.baseTokens = null;
        context.baseTokenPos = 1;
      };
      for (var o = 0; o < cm.state.overlays.length; ++o)
        loop(o);
      return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
    }
    function getLineStyles(cm, line, updateFrontier) {
      if (!line.styles || line.styles[0] != cm.state.modeGen) {
        var context = getContextBefore(cm, lineNo(line));
        var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
        var result2 = highlightLine(cm, line, context);
        if (resetState) {
          context.state = resetState;
        }
        line.stateAfter = context.save(!resetState);
        line.styles = result2.styles;
        if (result2.classes) {
          line.styleClasses = result2.classes;
        } else if (line.styleClasses) {
          line.styleClasses = null;
        }
        if (updateFrontier === cm.doc.highlightFrontier) {
          cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
        }
      }
      return line.styles;
    }
    function getContextBefore(cm, n2, precise) {
      var doc = cm.doc, display = cm.display;
      if (!doc.mode.startState) {
        return new Context(doc, true, n2);
      }
      var start2 = findStartLine(cm, n2, precise);
      var saved = start2 > doc.first && getLine2(doc, start2 - 1).stateAfter;
      var context = saved ? Context.fromSaved(doc, saved, start2) : new Context(doc, startState(doc.mode), start2);
      doc.iter(start2, n2, function(line) {
        processLine(cm, line.text, context);
        var pos = context.line;
        line.stateAfter = pos == n2 - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
        context.nextLine();
      });
      if (precise) {
        doc.modeFrontier = context.line;
      }
      return context;
    }
    function processLine(cm, text3, context, startAt) {
      var mode2 = cm.doc.mode;
      var stream = new StringStream(text3, cm.options.tabSize, context);
      stream.start = stream.pos = startAt || 0;
      if (text3 == "") {
        callBlankLine(mode2, context.state);
      }
      while (!stream.eol()) {
        readToken(mode2, stream, context.state);
        stream.start = stream.pos;
      }
    }
    function callBlankLine(mode2, state) {
      if (mode2.blankLine) {
        return mode2.blankLine(state);
      }
      if (!mode2.innerMode) {
        return;
      }
      var inner = innerMode(mode2, state);
      if (inner.mode.blankLine) {
        return inner.mode.blankLine(inner.state);
      }
    }
    function readToken(mode2, stream, state, inner) {
      for (var i2 = 0; i2 < 10; i2++) {
        if (inner) {
          inner[0] = innerMode(mode2, state).mode;
        }
        var style = mode2.token(stream, state);
        if (stream.pos > stream.start) {
          return style;
        }
      }
      throw new Error("Mode " + mode2.name + " failed to advance stream.");
    }
    var Token2 = function(stream, type2, state) {
      this.start = stream.start;
      this.end = stream.pos;
      this.string = stream.current();
      this.type = type2 || null;
      this.state = state;
    };
    function takeToken(cm, pos, precise, asArray) {
      var doc = cm.doc, mode2 = doc.mode, style;
      pos = clipPos(doc, pos);
      var line = getLine2(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
      var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
      if (asArray) {
        tokens = [];
      }
      while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
        stream.start = stream.pos;
        style = readToken(mode2, stream, context.state);
        if (asArray) {
          tokens.push(new Token2(stream, style, copyState(doc.mode, context.state)));
        }
      }
      return asArray ? tokens : new Token2(stream, style, context.state);
    }
    function extractLineClasses(type2, output) {
      if (type2) {
        for (; ; ) {
          var lineClass = type2.match(/(?:^|\s+)line-(background-)?(\S+)/);
          if (!lineClass) {
            break;
          }
          type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
          var prop3 = lineClass[1] ? "bgClass" : "textClass";
          if (output[prop3] == null) {
            output[prop3] = lineClass[2];
          } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop3])) {
            output[prop3] += " " + lineClass[2];
          }
        }
      }
      return type2;
    }
    function runMode(cm, text3, mode2, context, f, lineClasses, forceToEnd) {
      var flattenSpans = mode2.flattenSpans;
      if (flattenSpans == null) {
        flattenSpans = cm.options.flattenSpans;
      }
      var curStart = 0, curStyle = null;
      var stream = new StringStream(text3, cm.options.tabSize, context), style;
      var inner = cm.options.addModeClass && [null];
      if (text3 == "") {
        extractLineClasses(callBlankLine(mode2, context.state), lineClasses);
      }
      while (!stream.eol()) {
        if (stream.pos > cm.options.maxHighlightLength) {
          flattenSpans = false;
          if (forceToEnd) {
            processLine(cm, text3, context, stream.pos);
          }
          stream.pos = text3.length;
          style = null;
        } else {
          style = extractLineClasses(readToken(mode2, stream, context.state, inner), lineClasses);
        }
        if (inner) {
          var mName = inner[0].name;
          if (mName) {
            style = "m-" + (style ? mName + " " + style : mName);
          }
        }
        if (!flattenSpans || curStyle != style) {
          while (curStart < stream.start) {
            curStart = Math.min(stream.start, curStart + 5e3);
            f(curStart, curStyle);
          }
          curStyle = style;
        }
        stream.start = stream.pos;
      }
      while (curStart < stream.pos) {
        var pos = Math.min(stream.pos, curStart + 5e3);
        f(pos, curStyle);
        curStart = pos;
      }
    }
    function findStartLine(cm, n2, precise) {
      var minindent, minline, doc = cm.doc;
      var lim = precise ? -1 : n2 - (cm.doc.mode.innerMode ? 1e3 : 100);
      for (var search = n2; search > lim; --search) {
        if (search <= doc.first) {
          return doc.first;
        }
        var line = getLine2(doc, search - 1), after = line.stateAfter;
        if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
          return search;
        }
        var indented = countColumn(line.text, null, cm.options.tabSize);
        if (minline == null || minindent > indented) {
          minline = search - 1;
          minindent = indented;
        }
      }
      return minline;
    }
    function retreatFrontier(doc, n2) {
      doc.modeFrontier = Math.min(doc.modeFrontier, n2);
      if (doc.highlightFrontier < n2 - 10) {
        return;
      }
      var start2 = doc.first;
      for (var line = n2 - 1; line > start2; line--) {
        var saved = getLine2(doc, line).stateAfter;
        if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n2)) {
          start2 = line + 1;
          break;
        }
      }
      doc.highlightFrontier = Math.min(doc.highlightFrontier, start2);
    }
    var sawReadOnlySpans = false, sawCollapsedSpans = false;
    function seeReadOnlySpans() {
      sawReadOnlySpans = true;
    }
    function seeCollapsedSpans() {
      sawCollapsedSpans = true;
    }
    function MarkedSpan(marker2, from, to) {
      this.marker = marker2;
      this.from = from;
      this.to = to;
    }
    function getMarkedSpanFor(spans, marker2) {
      if (spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if (span.marker == marker2) {
            return span;
          }
        }
      }
    }
    function removeMarkedSpan(spans, span) {
      var r2;
      for (var i2 = 0; i2 < spans.length; ++i2) {
        if (spans[i2] != span) {
          (r2 || (r2 = [])).push(spans[i2]);
        }
      }
      return r2;
    }
    function addMarkedSpan(line, span, op) {
      var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = /* @__PURE__ */ new WeakSet()));
      if (inThisOp && inThisOp.has(line.markedSpans)) {
        line.markedSpans.push(span);
      } else {
        line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
        if (inThisOp) {
          inThisOp.add(line.markedSpans);
        }
      }
      span.marker.attachLine(line);
    }
    function markedSpansBefore(old, startCh, isInsert) {
      var nw;
      if (old) {
        for (var i2 = 0; i2 < old.length; ++i2) {
          var span = old[i2], marker2 = span.marker;
          var startsBefore = span.from == null || (marker2.inclusiveLeft ? span.from <= startCh : span.from < startCh);
          if (startsBefore || span.from == startCh && marker2.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
            var endsAfter = span.to == null || (marker2.inclusiveRight ? span.to >= startCh : span.to > startCh);
            (nw || (nw = [])).push(new MarkedSpan(marker2, span.from, endsAfter ? null : span.to));
          }
        }
      }
      return nw;
    }
    function markedSpansAfter(old, endCh, isInsert) {
      var nw;
      if (old) {
        for (var i2 = 0; i2 < old.length; ++i2) {
          var span = old[i2], marker2 = span.marker;
          var endsAfter = span.to == null || (marker2.inclusiveRight ? span.to >= endCh : span.to > endCh);
          if (endsAfter || span.from == endCh && marker2.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
            var startsBefore = span.from == null || (marker2.inclusiveLeft ? span.from <= endCh : span.from < endCh);
            (nw || (nw = [])).push(new MarkedSpan(marker2, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
          }
        }
      }
      return nw;
    }
    function stretchSpansOverChange(doc, change) {
      if (change.full) {
        return null;
      }
      var oldFirst = isLine(doc, change.from.line) && getLine2(doc, change.from.line).markedSpans;
      var oldLast = isLine(doc, change.to.line) && getLine2(doc, change.to.line).markedSpans;
      if (!oldFirst && !oldLast) {
        return null;
      }
      var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
      var first = markedSpansBefore(oldFirst, startCh, isInsert);
      var last = markedSpansAfter(oldLast, endCh, isInsert);
      var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
      if (first) {
        for (var i2 = 0; i2 < first.length; ++i2) {
          var span = first[i2];
          if (span.to == null) {
            var found = getMarkedSpanFor(last, span.marker);
            if (!found) {
              span.to = startCh;
            } else if (sameLine) {
              span.to = found.to == null ? null : found.to + offset;
            }
          }
        }
      }
      if (last) {
        for (var i$12 = 0; i$12 < last.length; ++i$12) {
          var span$1 = last[i$12];
          if (span$1.to != null) {
            span$1.to += offset;
          }
          if (span$1.from == null) {
            var found$1 = getMarkedSpanFor(first, span$1.marker);
            if (!found$1) {
              span$1.from = offset;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          } else {
            span$1.from += offset;
            if (sameLine) {
              (first || (first = [])).push(span$1);
            }
          }
        }
      }
      if (first) {
        first = clearEmptySpans(first);
      }
      if (last && last != first) {
        last = clearEmptySpans(last);
      }
      var newMarkers = [first];
      if (!sameLine) {
        var gap2 = change.text.length - 2, gapMarkers;
        if (gap2 > 0 && first) {
          for (var i$22 = 0; i$22 < first.length; ++i$22) {
            if (first[i$22].to == null) {
              (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
            }
          }
        }
        for (var i$3 = 0; i$3 < gap2; ++i$3) {
          newMarkers.push(gapMarkers);
        }
        newMarkers.push(last);
      }
      return newMarkers;
    }
    function clearEmptySpans(spans) {
      for (var i2 = 0; i2 < spans.length; ++i2) {
        var span = spans[i2];
        if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
          spans.splice(i2--, 1);
        }
      }
      if (!spans.length) {
        return null;
      }
      return spans;
    }
    function removeReadOnlyRanges(doc, from, to) {
      var markers = null;
      doc.iter(from.line, to.line + 1, function(line) {
        if (line.markedSpans) {
          for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
            var mark = line.markedSpans[i3].marker;
            if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
              (markers || (markers = [])).push(mark);
            }
          }
        }
      });
      if (!markers) {
        return null;
      }
      var parts = [{ from, to }];
      for (var i2 = 0; i2 < markers.length; ++i2) {
        var mk2 = markers[i2], m2 = mk2.find(0);
        for (var j = 0; j < parts.length; ++j) {
          var p2 = parts[j];
          if (cmp(p2.to, m2.from) < 0 || cmp(p2.from, m2.to) > 0) {
            continue;
          }
          var newParts = [j, 1], dfrom = cmp(p2.from, m2.from), dto = cmp(p2.to, m2.to);
          if (dfrom < 0 || !mk2.inclusiveLeft && !dfrom) {
            newParts.push({ from: p2.from, to: m2.from });
          }
          if (dto > 0 || !mk2.inclusiveRight && !dto) {
            newParts.push({ from: m2.to, to: p2.to });
          }
          parts.splice.apply(parts, newParts);
          j += newParts.length - 3;
        }
      }
      return parts;
    }
    function detachMarkedSpans(line) {
      var spans = line.markedSpans;
      if (!spans) {
        return;
      }
      for (var i2 = 0; i2 < spans.length; ++i2) {
        spans[i2].marker.detachLine(line);
      }
      line.markedSpans = null;
    }
    function attachMarkedSpans(line, spans) {
      if (!spans) {
        return;
      }
      for (var i2 = 0; i2 < spans.length; ++i2) {
        spans[i2].marker.attachLine(line);
      }
      line.markedSpans = spans;
    }
    function extraLeft(marker2) {
      return marker2.inclusiveLeft ? -1 : 0;
    }
    function extraRight(marker2) {
      return marker2.inclusiveRight ? 1 : 0;
    }
    function compareCollapsedMarkers(a, b) {
      var lenDiff = a.lines.length - b.lines.length;
      if (lenDiff != 0) {
        return lenDiff;
      }
      var aPos = a.find(), bPos = b.find();
      var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
      if (fromCmp) {
        return -fromCmp;
      }
      var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
      if (toCmp) {
        return toCmp;
      }
      return b.id - a.id;
    }
    function collapsedSpanAtSide(line, start2) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) {
        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
          sp = sps[i2];
          if (sp.marker.collapsed && (start2 ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function collapsedSpanAtStart(line) {
      return collapsedSpanAtSide(line, true);
    }
    function collapsedSpanAtEnd(line) {
      return collapsedSpanAtSide(line, false);
    }
    function collapsedSpanAround(line, ch2) {
      var sps = sawCollapsedSpans && line.markedSpans, found;
      if (sps) {
        for (var i2 = 0; i2 < sps.length; ++i2) {
          var sp = sps[i2];
          if (sp.marker.collapsed && (sp.from == null || sp.from < ch2) && (sp.to == null || sp.to > ch2) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
            found = sp.marker;
          }
        }
      }
      return found;
    }
    function conflictingCollapsedRange(doc, lineNo2, from, to, marker2) {
      var line = getLine2(doc, lineNo2);
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) {
        for (var i2 = 0; i2 < sps.length; ++i2) {
          var sp = sps[i2];
          if (!sp.marker.collapsed) {
            continue;
          }
          var found = sp.marker.find(0);
          var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker2);
          var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker2);
          if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
            continue;
          }
          if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker2.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker2.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
            return true;
          }
        }
      }
    }
    function visualLine(line) {
      var merged;
      while (merged = collapsedSpanAtStart(line)) {
        line = merged.find(-1, true).line;
      }
      return line;
    }
    function visualLineEnd(line) {
      var merged;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
      }
      return line;
    }
    function visualLineContinued(line) {
      var merged, lines;
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
        (lines || (lines = [])).push(line);
      }
      return lines;
    }
    function visualLineNo(doc, lineN) {
      var line = getLine2(doc, lineN), vis = visualLine(line);
      if (line == vis) {
        return lineN;
      }
      return lineNo(vis);
    }
    function visualLineEndNo(doc, lineN) {
      if (lineN > doc.lastLine()) {
        return lineN;
      }
      var line = getLine2(doc, lineN), merged;
      if (!lineIsHidden(doc, line)) {
        return lineN;
      }
      while (merged = collapsedSpanAtEnd(line)) {
        line = merged.find(1, true).line;
      }
      return lineNo(line) + 1;
    }
    function lineIsHidden(doc, line) {
      var sps = sawCollapsedSpans && line.markedSpans;
      if (sps) {
        for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
          sp = sps[i2];
          if (!sp.marker.collapsed) {
            continue;
          }
          if (sp.from == null) {
            return true;
          }
          if (sp.marker.widgetNode) {
            continue;
          }
          if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      }
    }
    function lineIsHiddenInner(doc, line, span) {
      if (span.to == null) {
        var end2 = span.marker.find(1, true);
        return lineIsHiddenInner(doc, end2.line, getMarkedSpanFor(end2.line.markedSpans, span.marker));
      }
      if (span.marker.inclusiveRight && span.to == line.text.length) {
        return true;
      }
      for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
        sp = line.markedSpans[i2];
        if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
          return true;
        }
      }
    }
    function heightAtLine(lineObj) {
      lineObj = visualLine(lineObj);
      var h = 0, chunk = lineObj.parent;
      for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
        var line = chunk.lines[i2];
        if (line == lineObj) {
          break;
        } else {
          h += line.height;
        }
      }
      for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
        for (var i$12 = 0; i$12 < p2.children.length; ++i$12) {
          var cur = p2.children[i$12];
          if (cur == chunk) {
            break;
          } else {
            h += cur.height;
          }
        }
      }
      return h;
    }
    function lineLength(line) {
      if (line.height == 0) {
        return 0;
      }
      var len = line.text.length, merged, cur = line;
      while (merged = collapsedSpanAtStart(cur)) {
        var found = merged.find(0, true);
        cur = found.from.line;
        len += found.from.ch - found.to.ch;
      }
      cur = line;
      while (merged = collapsedSpanAtEnd(cur)) {
        var found$1 = merged.find(0, true);
        len -= cur.text.length - found$1.from.ch;
        cur = found$1.to.line;
        len += cur.text.length - found$1.to.ch;
      }
      return len;
    }
    function findMaxLine(cm) {
      var d = cm.display, doc = cm.doc;
      d.maxLine = getLine2(doc, doc.first);
      d.maxLineLength = lineLength(d.maxLine);
      d.maxLineChanged = true;
      doc.iter(function(line) {
        var len = lineLength(line);
        if (len > d.maxLineLength) {
          d.maxLineLength = len;
          d.maxLine = line;
        }
      });
    }
    var Line = function(text3, markedSpans, estimateHeight2) {
      this.text = text3;
      attachMarkedSpans(this, markedSpans);
      this.height = estimateHeight2 ? estimateHeight2(this) : 1;
    };
    Line.prototype.lineNo = function() {
      return lineNo(this);
    };
    eventMixin(Line);
    function updateLine(line, text3, markedSpans, estimateHeight2) {
      line.text = text3;
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      if (line.styles) {
        line.styles = null;
      }
      if (line.order != null) {
        line.order = null;
      }
      detachMarkedSpans(line);
      attachMarkedSpans(line, markedSpans);
      var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
      if (estHeight != line.height) {
        updateLineHeight(line, estHeight);
      }
    }
    function cleanUpLine(line) {
      line.parent = null;
      detachMarkedSpans(line);
    }
    var styleToClassCache = {}, styleToClassCacheWithMode = {};
    function interpretTokenStyle(style, options) {
      if (!style || /^\s*$/.test(style)) {
        return null;
      }
      var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
      return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
    }
    function buildLineContent(cm, lineView) {
      var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
      var builder = {
        pre: eltP("pre", [content], "CodeMirror-line"),
        content,
        col: 0,
        pos: 0,
        cm,
        trailingSpace: false,
        splitSpaces: cm.getOption("lineWrapping")
      };
      lineView.measure = {};
      for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
        var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order2 = void 0;
        builder.pos = 0;
        builder.addToken = buildToken2;
        if (hasBadBidiRects(cm.display.measure) && (order2 = getOrder(line, cm.doc.direction))) {
          builder.addToken = buildTokenBadBidi(builder.addToken, order2);
        }
        builder.map = [];
        var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
        insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
        if (line.styleClasses) {
          if (line.styleClasses.bgClass) {
            builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
          }
          if (line.styleClasses.textClass) {
            builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
          }
        }
        if (builder.map.length == 0) {
          builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
        }
        if (i2 == 0) {
          lineView.measure.map = builder.map;
          lineView.measure.cache = {};
        } else {
          (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
          (lineView.measure.caches || (lineView.measure.caches = [])).push({});
        }
      }
      if (webkit) {
        var last = builder.content.lastChild;
        if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
          builder.content.className = "cm-tab-wrap-hack";
        }
      }
      signal(cm, "renderLine", cm, lineView.line, builder.pre);
      if (builder.pre.className) {
        builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
      }
      return builder;
    }
    function defaultSpecialCharPlaceholder(ch2) {
      var token2 = elt("span", "\u2022", "cm-invalidchar");
      token2.title = "\\u" + ch2.charCodeAt(0).toString(16);
      token2.setAttribute("aria-label", token2.title);
      return token2;
    }
    function buildToken2(builder, text3, style, startStyle, endStyle, css, attributes) {
      if (!text3) {
        return;
      }
      var displayText = builder.splitSpaces ? splitSpaces(text3, builder.trailingSpace) : text3;
      var special = builder.cm.state.specialChars, mustWrap = false;
      var content;
      if (!special.test(text3)) {
        builder.col += text3.length;
        content = document.createTextNode(displayText);
        builder.map.push(builder.pos, builder.pos + text3.length, content);
        if (ie2 && ie_version < 9) {
          mustWrap = true;
        }
        builder.pos += text3.length;
      } else {
        content = document.createDocumentFragment();
        var pos = 0;
        while (true) {
          special.lastIndex = pos;
          var m2 = special.exec(text3);
          var skipped = m2 ? m2.index - pos : text3.length - pos;
          if (skipped) {
            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
            if (ie2 && ie_version < 9) {
              content.appendChild(elt("span", [txt]));
            } else {
              content.appendChild(txt);
            }
            builder.map.push(builder.pos, builder.pos + skipped, txt);
            builder.col += skipped;
            builder.pos += skipped;
          }
          if (!m2) {
            break;
          }
          pos += skipped + 1;
          var txt$1 = void 0;
          if (m2[0] == "	") {
            var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
            txt$1.setAttribute("role", "presentation");
            txt$1.setAttribute("cm-text", "	");
            builder.col += tabWidth;
          } else if (m2[0] == "\r" || m2[0] == "\n") {
            txt$1 = content.appendChild(elt("span", m2[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
            txt$1.setAttribute("cm-text", m2[0]);
            builder.col += 1;
          } else {
            txt$1 = builder.cm.options.specialCharPlaceholder(m2[0]);
            txt$1.setAttribute("cm-text", m2[0]);
            if (ie2 && ie_version < 9) {
              content.appendChild(elt("span", [txt$1]));
            } else {
              content.appendChild(txt$1);
            }
            builder.col += 1;
          }
          builder.map.push(builder.pos, builder.pos + 1, txt$1);
          builder.pos++;
        }
      }
      builder.trailingSpace = displayText.charCodeAt(text3.length - 1) == 32;
      if (style || startStyle || endStyle || mustWrap || css || attributes) {
        var fullStyle = style || "";
        if (startStyle) {
          fullStyle += startStyle;
        }
        if (endStyle) {
          fullStyle += endStyle;
        }
        var token2 = elt("span", [content], fullStyle, css);
        if (attributes) {
          for (var attr in attributes) {
            if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
              token2.setAttribute(attr, attributes[attr]);
            }
          }
        }
        return builder.content.appendChild(token2);
      }
      builder.content.appendChild(content);
    }
    function splitSpaces(text3, trailingBefore) {
      if (text3.length > 1 && !/  /.test(text3)) {
        return text3;
      }
      var spaceBefore = trailingBefore, result2 = "";
      for (var i2 = 0; i2 < text3.length; i2++) {
        var ch2 = text3.charAt(i2);
        if (ch2 == " " && spaceBefore && (i2 == text3.length - 1 || text3.charCodeAt(i2 + 1) == 32)) {
          ch2 = "\xA0";
        }
        result2 += ch2;
        spaceBefore = ch2 == " ";
      }
      return result2;
    }
    function buildTokenBadBidi(inner, order2) {
      return function(builder, text3, style, startStyle, endStyle, css, attributes) {
        style = style ? style + " cm-force-border" : "cm-force-border";
        var start2 = builder.pos, end2 = start2 + text3.length;
        for (; ; ) {
          var part2 = void 0;
          for (var i2 = 0; i2 < order2.length; i2++) {
            part2 = order2[i2];
            if (part2.to > start2 && part2.from <= start2) {
              break;
            }
          }
          if (part2.to >= end2) {
            return inner(builder, text3, style, startStyle, endStyle, css, attributes);
          }
          inner(builder, text3.slice(0, part2.to - start2), style, startStyle, null, css, attributes);
          startStyle = null;
          text3 = text3.slice(part2.to - start2);
          start2 = part2.to;
        }
      };
    }
    function buildCollapsedSpan(builder, size, marker2, ignoreWidget) {
      var widget = !ignoreWidget && marker2.widgetNode;
      if (widget) {
        builder.map.push(builder.pos, builder.pos + size, widget);
      }
      if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
        if (!widget) {
          widget = builder.content.appendChild(document.createElement("span"));
        }
        widget.setAttribute("cm-marker", marker2.id);
      }
      if (widget) {
        builder.cm.display.input.setUneditable(widget);
        builder.content.appendChild(widget);
      }
      builder.pos += size;
      builder.trailingSpace = false;
    }
    function insertLineContent(line, builder, styles2) {
      var spans = line.markedSpans, allText = line.text, at = 0;
      if (!spans) {
        for (var i$12 = 1; i$12 < styles2.length; i$12 += 2) {
          builder.addToken(builder, allText.slice(at, at = styles2[i$12]), interpretTokenStyle(styles2[i$12 + 1], builder.cm.options));
        }
        return;
      }
      var len = allText.length, pos = 0, i2 = 1, text3 = "", style, css;
      var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
      for (; ; ) {
        if (nextChange == pos) {
          spanStyle = spanEndStyle = spanStartStyle = css = "";
          attributes = null;
          collapsed = null;
          nextChange = Infinity;
          var foundBookmarks = [], endStyles = void 0;
          for (var j = 0; j < spans.length; ++j) {
            var sp = spans[j], m2 = sp.marker;
            if (m2.type == "bookmark" && sp.from == pos && m2.widgetNode) {
              foundBookmarks.push(m2);
            } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m2.collapsed && sp.to == pos && sp.from == pos)) {
              if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                nextChange = sp.to;
                spanEndStyle = "";
              }
              if (m2.className) {
                spanStyle += " " + m2.className;
              }
              if (m2.css) {
                css = (css ? css + ";" : "") + m2.css;
              }
              if (m2.startStyle && sp.from == pos) {
                spanStartStyle += " " + m2.startStyle;
              }
              if (m2.endStyle && sp.to == nextChange) {
                (endStyles || (endStyles = [])).push(m2.endStyle, sp.to);
              }
              if (m2.title) {
                (attributes || (attributes = {})).title = m2.title;
              }
              if (m2.attributes) {
                for (var attr in m2.attributes) {
                  (attributes || (attributes = {}))[attr] = m2.attributes[attr];
                }
              }
              if (m2.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m2) < 0)) {
                collapsed = sp;
              }
            } else if (sp.from > pos && nextChange > sp.from) {
              nextChange = sp.from;
            }
          }
          if (endStyles) {
            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
              if (endStyles[j$1 + 1] == nextChange) {
                spanEndStyle += " " + endStyles[j$1];
              }
            }
          }
          if (!collapsed || collapsed.from == pos) {
            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
              buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
            }
          }
          if (collapsed && (collapsed.from || 0) == pos) {
            buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
            if (collapsed.to == null) {
              return;
            }
            if (collapsed.to == pos) {
              collapsed = false;
            }
          }
        }
        if (pos >= len) {
          break;
        }
        var upto = Math.min(len, nextChange);
        while (true) {
          if (text3) {
            var end2 = pos + text3.length;
            if (!collapsed) {
              var tokenText = end2 > upto ? text3.slice(0, upto - pos) : text3;
              builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
            }
            if (end2 >= upto) {
              text3 = text3.slice(upto - pos);
              pos = upto;
              break;
            }
            pos = end2;
            spanStartStyle = "";
          }
          text3 = allText.slice(at, at = styles2[i2++]);
          style = interpretTokenStyle(styles2[i2++], builder.cm.options);
        }
      }
    }
    function LineView(doc, line, lineN) {
      this.line = line;
      this.rest = visualLineContinued(line);
      this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
      this.node = this.text = null;
      this.hidden = lineIsHidden(doc, line);
    }
    function buildViewArray(cm, from, to) {
      var array = [], nextPos;
      for (var pos = from; pos < to; pos = nextPos) {
        var view = new LineView(cm.doc, getLine2(cm.doc, pos), pos);
        nextPos = pos + view.size;
        array.push(view);
      }
      return array;
    }
    var operationGroup = null;
    function pushOperation(op) {
      if (operationGroup) {
        operationGroup.ops.push(op);
      } else {
        op.ownsGroup = operationGroup = {
          ops: [op],
          delayedCallbacks: []
        };
      }
    }
    function fireCallbacksForOps(group) {
      var callbacks = group.delayedCallbacks, i2 = 0;
      do {
        for (; i2 < callbacks.length; i2++) {
          callbacks[i2].call(null);
        }
        for (var j = 0; j < group.ops.length; j++) {
          var op = group.ops[j];
          if (op.cursorActivityHandlers) {
            while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
              op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
            }
          }
        }
      } while (i2 < callbacks.length);
    }
    function finishOperation(op, endCb) {
      var group = op.ownsGroup;
      if (!group) {
        return;
      }
      try {
        fireCallbacksForOps(group);
      } finally {
        operationGroup = null;
        endCb(group);
      }
    }
    var orphanDelayedCallbacks = null;
    function signalLater(emitter, type2) {
      var arr = getHandlers(emitter, type2);
      if (!arr.length) {
        return;
      }
      var args = Array.prototype.slice.call(arguments, 2), list3;
      if (operationGroup) {
        list3 = operationGroup.delayedCallbacks;
      } else if (orphanDelayedCallbacks) {
        list3 = orphanDelayedCallbacks;
      } else {
        list3 = orphanDelayedCallbacks = [];
        setTimeout(fireOrphanDelayed, 0);
      }
      var loop = function(i3) {
        list3.push(function() {
          return arr[i3].apply(null, args);
        });
      };
      for (var i2 = 0; i2 < arr.length; ++i2)
        loop(i2);
    }
    function fireOrphanDelayed() {
      var delayed = orphanDelayedCallbacks;
      orphanDelayedCallbacks = null;
      for (var i2 = 0; i2 < delayed.length; ++i2) {
        delayed[i2]();
      }
    }
    function updateLineForChanges(cm, lineView, lineN, dims) {
      for (var j = 0; j < lineView.changes.length; j++) {
        var type2 = lineView.changes[j];
        if (type2 == "text") {
          updateLineText(cm, lineView);
        } else if (type2 == "gutter") {
          updateLineGutter(cm, lineView, lineN, dims);
        } else if (type2 == "class") {
          updateLineClasses(cm, lineView);
        } else if (type2 == "widget") {
          updateLineWidgets(cm, lineView, dims);
        }
      }
      lineView.changes = null;
    }
    function ensureLineWrapped(lineView) {
      if (lineView.node == lineView.text) {
        lineView.node = elt("div", null, null, "position: relative");
        if (lineView.text.parentNode) {
          lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
        }
        lineView.node.appendChild(lineView.text);
        if (ie2 && ie_version < 8) {
          lineView.node.style.zIndex = 2;
        }
      }
      return lineView.node;
    }
    function updateLineBackground(cm, lineView) {
      var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
      if (cls) {
        cls += " CodeMirror-linebackground";
      }
      if (lineView.background) {
        if (cls) {
          lineView.background.className = cls;
        } else {
          lineView.background.parentNode.removeChild(lineView.background);
          lineView.background = null;
        }
      } else if (cls) {
        var wrap2 = ensureLineWrapped(lineView);
        lineView.background = wrap2.insertBefore(elt("div", null, cls), wrap2.firstChild);
        cm.display.input.setUneditable(lineView.background);
      }
    }
    function getLineContent(cm, lineView) {
      var ext = cm.display.externalMeasured;
      if (ext && ext.line == lineView.line) {
        cm.display.externalMeasured = null;
        lineView.measure = ext.measure;
        return ext.built;
      }
      return buildLineContent(cm, lineView);
    }
    function updateLineText(cm, lineView) {
      var cls = lineView.text.className;
      var built = getLineContent(cm, lineView);
      if (lineView.text == lineView.node) {
        lineView.node = built.pre;
      }
      lineView.text.parentNode.replaceChild(built.pre, lineView.text);
      lineView.text = built.pre;
      if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
        lineView.bgClass = built.bgClass;
        lineView.textClass = built.textClass;
        updateLineClasses(cm, lineView);
      } else if (cls) {
        lineView.text.className = cls;
      }
    }
    function updateLineClasses(cm, lineView) {
      updateLineBackground(cm, lineView);
      if (lineView.line.wrapClass) {
        ensureLineWrapped(lineView).className = lineView.line.wrapClass;
      } else if (lineView.node != lineView.text) {
        lineView.node.className = "";
      }
      var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
      lineView.text.className = textClass || "";
    }
    function updateLineGutter(cm, lineView, lineN, dims) {
      if (lineView.gutter) {
        lineView.node.removeChild(lineView.gutter);
        lineView.gutter = null;
      }
      if (lineView.gutterBackground) {
        lineView.node.removeChild(lineView.gutterBackground);
        lineView.gutterBackground = null;
      }
      if (lineView.line.gutterClass) {
        var wrap2 = ensureLineWrapped(lineView);
        lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
        cm.display.input.setUneditable(lineView.gutterBackground);
        wrap2.insertBefore(lineView.gutterBackground, lineView.text);
      }
      var markers = lineView.line.gutterMarkers;
      if (cm.options.lineNumbers || markers) {
        var wrap$12 = ensureLineWrapped(lineView);
        var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
        gutterWrap.setAttribute("aria-hidden", "true");
        cm.display.input.setUneditable(gutterWrap);
        wrap$12.insertBefore(gutterWrap, lineView.text);
        if (lineView.line.gutterClass) {
          gutterWrap.className += " " + lineView.line.gutterClass;
        }
        if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
          lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
        }
        if (markers) {
          for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
            var id2 = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id2) && markers[id2];
            if (found) {
              gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id2] + "px; width: " + dims.gutterWidth[id2] + "px"));
            }
          }
        }
      }
    }
    function updateLineWidgets(cm, lineView, dims) {
      if (lineView.alignable) {
        lineView.alignable = null;
      }
      var isWidget = classTest("CodeMirror-linewidget");
      for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
        next = node.nextSibling;
        if (isWidget.test(node.className)) {
          lineView.node.removeChild(node);
        }
      }
      insertLineWidgets(cm, lineView, dims);
    }
    function buildLineElement(cm, lineView, lineN, dims) {
      var built = getLineContent(cm, lineView);
      lineView.text = lineView.node = built.pre;
      if (built.bgClass) {
        lineView.bgClass = built.bgClass;
      }
      if (built.textClass) {
        lineView.textClass = built.textClass;
      }
      updateLineClasses(cm, lineView);
      updateLineGutter(cm, lineView, lineN, dims);
      insertLineWidgets(cm, lineView, dims);
      return lineView.node;
    }
    function insertLineWidgets(cm, lineView, dims) {
      insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
        }
      }
    }
    function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
      if (!line.widgets) {
        return;
      }
      var wrap2 = ensureLineWrapped(lineView);
      for (var i2 = 0, ws2 = line.widgets; i2 < ws2.length; ++i2) {
        var widget = ws2[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
        if (!widget.handleMouseEvents) {
          node.setAttribute("cm-ignore-events", "true");
        }
        positionLineWidget(widget, node, lineView, dims);
        cm.display.input.setUneditable(node);
        if (allowAbove && widget.above) {
          wrap2.insertBefore(node, lineView.gutter || lineView.text);
        } else {
          wrap2.appendChild(node);
        }
        signalLater(widget, "redraw");
      }
    }
    function positionLineWidget(widget, node, lineView, dims) {
      if (widget.noHScroll) {
        (lineView.alignable || (lineView.alignable = [])).push(node);
        var width = dims.wrapperWidth;
        node.style.left = dims.fixedPos + "px";
        if (!widget.coverGutter) {
          width -= dims.gutterTotalWidth;
          node.style.paddingLeft = dims.gutterTotalWidth + "px";
        }
        node.style.width = width + "px";
      }
      if (widget.coverGutter) {
        node.style.zIndex = 5;
        node.style.position = "relative";
        if (!widget.noHScroll) {
          node.style.marginLeft = -dims.gutterTotalWidth + "px";
        }
      }
    }
    function widgetHeight(widget) {
      if (widget.height != null) {
        return widget.height;
      }
      var cm = widget.doc.cm;
      if (!cm) {
        return 0;
      }
      if (!contains(document.body, widget.node)) {
        var parentStyle = "position: relative;";
        if (widget.coverGutter) {
          parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
        }
        if (widget.noHScroll) {
          parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
        }
        removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
      }
      return widget.height = widget.node.parentNode.offsetHeight;
    }
    function eventInWidget(display, e) {
      for (var n2 = e_target(e); n2 != display.wrapper; n2 = n2.parentNode) {
        if (!n2 || n2.nodeType == 1 && n2.getAttribute("cm-ignore-events") == "true" || n2.parentNode == display.sizer && n2 != display.mover) {
          return true;
        }
      }
    }
    function paddingTop(display) {
      return display.lineSpace.offsetTop;
    }
    function paddingVert(display) {
      return display.mover.offsetHeight - display.lineSpace.offsetHeight;
    }
    function paddingH(display) {
      if (display.cachedPaddingH) {
        return display.cachedPaddingH;
      }
      var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
      var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
      var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
      if (!isNaN(data.left) && !isNaN(data.right)) {
        display.cachedPaddingH = data;
      }
      return data;
    }
    function scrollGap(cm) {
      return scrollerGap - cm.display.nativeBarWidth;
    }
    function displayWidth(cm) {
      return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
    }
    function displayHeight(cm) {
      return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
    }
    function ensureLineHeights(cm, lineView, rect2) {
      var wrapping = cm.options.lineWrapping;
      var curWidth = wrapping && displayWidth(cm);
      if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
        var heights = lineView.measure.heights = [];
        if (wrapping) {
          lineView.measure.width = curWidth;
          var rects = lineView.text.firstChild.getClientRects();
          for (var i2 = 0; i2 < rects.length - 1; i2++) {
            var cur = rects[i2], next = rects[i2 + 1];
            if (Math.abs(cur.bottom - next.bottom) > 2) {
              heights.push((cur.bottom + next.top) / 2 - rect2.top);
            }
          }
        }
        heights.push(rect2.bottom - rect2.top);
      }
    }
    function mapFromLineView(lineView, line, lineN) {
      if (lineView.line == line) {
        return { map: lineView.measure.map, cache: lineView.measure.cache };
      }
      if (lineView.rest) {
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          if (lineView.rest[i2] == line) {
            return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
          }
        }
        for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
          if (lineNo(lineView.rest[i$12]) > lineN) {
            return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
          }
        }
      }
    }
    function updateExternalMeasurement(cm, line) {
      line = visualLine(line);
      var lineN = lineNo(line);
      var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
      view.lineN = lineN;
      var built = view.built = buildLineContent(cm, view);
      view.text = built.pre;
      removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
      return view;
    }
    function measureChar(cm, line, ch2, bias) {
      return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch2, bias);
    }
    function findViewForLine(cm, lineN) {
      if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
        return cm.display.view[findViewIndex(cm, lineN)];
      }
      var ext = cm.display.externalMeasured;
      if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
        return ext;
      }
    }
    function prepareMeasureForLine(cm, line) {
      var lineN = lineNo(line);
      var view = findViewForLine(cm, lineN);
      if (view && !view.text) {
        view = null;
      } else if (view && view.changes) {
        updateLineForChanges(cm, view, lineN, getDimensions(cm));
        cm.curOp.forceUpdate = true;
      }
      if (!view) {
        view = updateExternalMeasurement(cm, line);
      }
      var info2 = mapFromLineView(view, line, lineN);
      return {
        line,
        view,
        rect: null,
        map: info2.map,
        cache: info2.cache,
        before: info2.before,
        hasHeights: false
      };
    }
    function measureCharPrepared(cm, prepared, ch2, bias, varHeight) {
      if (prepared.before) {
        ch2 = -1;
      }
      var key = ch2 + (bias || ""), found;
      if (prepared.cache.hasOwnProperty(key)) {
        found = prepared.cache[key];
      } else {
        if (!prepared.rect) {
          prepared.rect = prepared.view.text.getBoundingClientRect();
        }
        if (!prepared.hasHeights) {
          ensureLineHeights(cm, prepared.view, prepared.rect);
          prepared.hasHeights = true;
        }
        found = measureCharInner(cm, prepared, ch2, bias);
        if (!found.bogus) {
          prepared.cache[key] = found;
        }
      }
      return {
        left: found.left,
        right: found.right,
        top: varHeight ? found.rtop : found.top,
        bottom: varHeight ? found.rbottom : found.bottom
      };
    }
    var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
    function nodeAndOffsetInLineMap(map3, ch2, bias) {
      var node, start2, end2, collapse, mStart, mEnd;
      for (var i2 = 0; i2 < map3.length; i2 += 3) {
        mStart = map3[i2];
        mEnd = map3[i2 + 1];
        if (ch2 < mStart) {
          start2 = 0;
          end2 = 1;
          collapse = "left";
        } else if (ch2 < mEnd) {
          start2 = ch2 - mStart;
          end2 = start2 + 1;
        } else if (i2 == map3.length - 3 || ch2 == mEnd && map3[i2 + 3] > ch2) {
          end2 = mEnd - mStart;
          start2 = end2 - 1;
          if (ch2 >= mEnd) {
            collapse = "right";
          }
        }
        if (start2 != null) {
          node = map3[i2 + 2];
          if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
            collapse = bias;
          }
          if (bias == "left" && start2 == 0) {
            while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {
              node = map3[(i2 -= 3) + 2];
              collapse = "left";
            }
          }
          if (bias == "right" && start2 == mEnd - mStart) {
            while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {
              node = map3[(i2 += 3) + 2];
              collapse = "right";
            }
          }
          break;
        }
      }
      return { node, start: start2, end: end2, collapse, coverStart: mStart, coverEnd: mEnd };
    }
    function getUsefulRect(rects, bias) {
      var rect2 = nullRect;
      if (bias == "left") {
        for (var i2 = 0; i2 < rects.length; i2++) {
          if ((rect2 = rects[i2]).left != rect2.right) {
            break;
          }
        }
      } else {
        for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
          if ((rect2 = rects[i$12]).left != rect2.right) {
            break;
          }
        }
      }
      return rect2;
    }
    function measureCharInner(cm, prepared, ch2, bias) {
      var place = nodeAndOffsetInLineMap(prepared.map, ch2, bias);
      var node = place.node, start2 = place.start, end2 = place.end, collapse = place.collapse;
      var rect2;
      if (node.nodeType == 3) {
        for (var i$12 = 0; i$12 < 4; i$12++) {
          while (start2 && isExtendingChar(prepared.line.text.charAt(place.coverStart + start2))) {
            --start2;
          }
          while (place.coverStart + end2 < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end2))) {
            ++end2;
          }
          if (ie2 && ie_version < 9 && start2 == 0 && end2 == place.coverEnd - place.coverStart) {
            rect2 = node.parentNode.getBoundingClientRect();
          } else {
            rect2 = getUsefulRect(range2(node, start2, end2).getClientRects(), bias);
          }
          if (rect2.left || rect2.right || start2 == 0) {
            break;
          }
          end2 = start2;
          start2 = start2 - 1;
          collapse = "right";
        }
        if (ie2 && ie_version < 11) {
          rect2 = maybeUpdateRectForZooming(cm.display.measure, rect2);
        }
      } else {
        if (start2 > 0) {
          collapse = bias = "right";
        }
        var rects;
        if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
          rect2 = rects[bias == "right" ? rects.length - 1 : 0];
        } else {
          rect2 = node.getBoundingClientRect();
        }
      }
      if (ie2 && ie_version < 9 && !start2 && (!rect2 || !rect2.left && !rect2.right)) {
        var rSpan = node.parentNode.getClientRects()[0];
        if (rSpan) {
          rect2 = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
        } else {
          rect2 = nullRect;
        }
      }
      var rtop = rect2.top - prepared.rect.top, rbot = rect2.bottom - prepared.rect.top;
      var mid2 = (rtop + rbot) / 2;
      var heights = prepared.view.measure.heights;
      var i2 = 0;
      for (; i2 < heights.length - 1; i2++) {
        if (mid2 < heights[i2]) {
          break;
        }
      }
      var top2 = i2 ? heights[i2 - 1] : 0, bot2 = heights[i2];
      var result2 = {
        left: (collapse == "right" ? rect2.right : rect2.left) - prepared.rect.left,
        right: (collapse == "left" ? rect2.left : rect2.right) - prepared.rect.left,
        top: top2,
        bottom: bot2
      };
      if (!rect2.left && !rect2.right) {
        result2.bogus = true;
      }
      if (!cm.options.singleCursorHeightPerLine) {
        result2.rtop = rtop;
        result2.rbottom = rbot;
      }
      return result2;
    }
    function maybeUpdateRectForZooming(measure, rect2) {
      if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
        return rect2;
      }
      var scaleX = screen.logicalXDPI / screen.deviceXDPI;
      var scaleY = screen.logicalYDPI / screen.deviceYDPI;
      return {
        left: rect2.left * scaleX,
        right: rect2.right * scaleX,
        top: rect2.top * scaleY,
        bottom: rect2.bottom * scaleY
      };
    }
    function clearLineMeasurementCacheFor(lineView) {
      if (lineView.measure) {
        lineView.measure.cache = {};
        lineView.measure.heights = null;
        if (lineView.rest) {
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            lineView.measure.caches[i2] = {};
          }
        }
      }
    }
    function clearLineMeasurementCache(cm) {
      cm.display.externalMeasure = null;
      removeChildren(cm.display.lineMeasure);
      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
        clearLineMeasurementCacheFor(cm.display.view[i2]);
      }
    }
    function clearCaches(cm) {
      clearLineMeasurementCache(cm);
      cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
      if (!cm.options.lineWrapping) {
        cm.display.maxLineChanged = true;
      }
      cm.display.lineNumChars = null;
    }
    function pageScrollX() {
      if (chrome && android) {
        return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
      }
      return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
    }
    function pageScrollY() {
      if (chrome && android) {
        return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
      }
      return window.pageYOffset || (document.documentElement || document.body).scrollTop;
    }
    function widgetTopHeight(lineObj) {
      var ref = visualLine(lineObj);
      var widgets = ref.widgets;
      var height = 0;
      if (widgets) {
        for (var i2 = 0; i2 < widgets.length; ++i2) {
          if (widgets[i2].above) {
            height += widgetHeight(widgets[i2]);
          }
        }
      }
      return height;
    }
    function intoCoordSystem(cm, lineObj, rect2, context, includeWidgets) {
      if (!includeWidgets) {
        var height = widgetTopHeight(lineObj);
        rect2.top += height;
        rect2.bottom += height;
      }
      if (context == "line") {
        return rect2;
      }
      if (!context) {
        context = "local";
      }
      var yOff = heightAtLine(lineObj);
      if (context == "local") {
        yOff += paddingTop(cm.display);
      } else {
        yOff -= cm.display.viewOffset;
      }
      if (context == "page" || context == "window") {
        var lOff = cm.display.lineSpace.getBoundingClientRect();
        yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
        var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
        rect2.left += xOff;
        rect2.right += xOff;
      }
      rect2.top += yOff;
      rect2.bottom += yOff;
      return rect2;
    }
    function fromCoordSystem(cm, coords, context) {
      if (context == "div") {
        return coords;
      }
      var left = coords.left, top2 = coords.top;
      if (context == "page") {
        left -= pageScrollX();
        top2 -= pageScrollY();
      } else if (context == "local" || !context) {
        var localBox = cm.display.sizer.getBoundingClientRect();
        left += localBox.left;
        top2 += localBox.top;
      }
      var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
      return { left: left - lineSpaceBox.left, top: top2 - lineSpaceBox.top };
    }
    function charCoords(cm, pos, context, lineObj, bias) {
      if (!lineObj) {
        lineObj = getLine2(cm.doc, pos.line);
      }
      return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
    }
    function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
      lineObj = lineObj || getLine2(cm.doc, pos.line);
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      function get(ch3, right) {
        var m2 = measureCharPrepared(cm, preparedMeasure, ch3, right ? "right" : "left", varHeight);
        if (right) {
          m2.left = m2.right;
        } else {
          m2.right = m2.left;
        }
        return intoCoordSystem(cm, lineObj, m2, context);
      }
      var order2 = getOrder(lineObj, cm.doc.direction), ch2 = pos.ch, sticky = pos.sticky;
      if (ch2 >= lineObj.text.length) {
        ch2 = lineObj.text.length;
        sticky = "before";
      } else if (ch2 <= 0) {
        ch2 = 0;
        sticky = "after";
      }
      if (!order2) {
        return get(sticky == "before" ? ch2 - 1 : ch2, sticky == "before");
      }
      function getBidi(ch3, partPos2, invert) {
        var part2 = order2[partPos2], right = part2.level == 1;
        return get(invert ? ch3 - 1 : ch3, right != invert);
      }
      var partPos = getBidiPartAt(order2, ch2, sticky);
      var other = bidiOther;
      var val = getBidi(ch2, partPos, sticky == "before");
      if (other != null) {
        val.other = getBidi(ch2, other, sticky != "before");
      }
      return val;
    }
    function estimateCoords(cm, pos) {
      var left = 0;
      pos = clipPos(cm.doc, pos);
      if (!cm.options.lineWrapping) {
        left = charWidth(cm.display) * pos.ch;
      }
      var lineObj = getLine2(cm.doc, pos.line);
      var top2 = heightAtLine(lineObj) + paddingTop(cm.display);
      return { left, right: left, top: top2, bottom: top2 + lineObj.height };
    }
    function PosWithInfo(line, ch2, sticky, outside, xRel) {
      var pos = Pos(line, ch2, sticky);
      pos.xRel = xRel;
      if (outside) {
        pos.outside = outside;
      }
      return pos;
    }
    function coordsChar(cm, x2, y2) {
      var doc = cm.doc;
      y2 += cm.display.viewOffset;
      if (y2 < 0) {
        return PosWithInfo(doc.first, 0, null, -1, -1);
      }
      var lineN = lineAtHeight(doc, y2), last = doc.first + doc.size - 1;
      if (lineN > last) {
        return PosWithInfo(doc.first + doc.size - 1, getLine2(doc, last).text.length, null, 1, 1);
      }
      if (x2 < 0) {
        x2 = 0;
      }
      var lineObj = getLine2(doc, lineN);
      for (; ; ) {
        var found = coordsCharInner(cm, lineObj, lineN, x2, y2);
        var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
        if (!collapsed) {
          return found;
        }
        var rangeEnd = collapsed.find(1);
        if (rangeEnd.line == lineN) {
          return rangeEnd;
        }
        lineObj = getLine2(doc, lineN = rangeEnd.line);
      }
    }
    function wrappedLineExtent(cm, lineObj, preparedMeasure, y2) {
      y2 -= widgetTopHeight(lineObj);
      var end2 = lineObj.text.length;
      var begin = findFirst(function(ch2) {
        return measureCharPrepared(cm, preparedMeasure, ch2 - 1).bottom <= y2;
      }, end2, 0);
      end2 = findFirst(function(ch2) {
        return measureCharPrepared(cm, preparedMeasure, ch2).top > y2;
      }, begin, end2);
      return { begin, end: end2 };
    }
    function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target2) {
      if (!preparedMeasure) {
        preparedMeasure = prepareMeasureForLine(cm, lineObj);
      }
      var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target2), "line").top;
      return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
    }
    function boxIsAfter(box, x2, y2, left) {
      return box.bottom <= y2 ? false : box.top > y2 ? true : (left ? box.left : box.right) > x2;
    }
    function coordsCharInner(cm, lineObj, lineNo2, x2, y2) {
      y2 -= heightAtLine(lineObj);
      var preparedMeasure = prepareMeasureForLine(cm, lineObj);
      var widgetHeight2 = widgetTopHeight(lineObj);
      var begin = 0, end2 = lineObj.text.length, ltr = true;
      var order2 = getOrder(lineObj, cm.doc.direction);
      if (order2) {
        var part2 = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2);
        ltr = part2.level != 1;
        begin = ltr ? part2.from : part2.to - 1;
        end2 = ltr ? part2.to : part2.from - 1;
      }
      var chAround = null, boxAround = null;
      var ch2 = findFirst(function(ch3) {
        var box = measureCharPrepared(cm, preparedMeasure, ch3);
        box.top += widgetHeight2;
        box.bottom += widgetHeight2;
        if (!boxIsAfter(box, x2, y2, false)) {
          return false;
        }
        if (box.top <= y2 && box.left <= x2) {
          chAround = ch3;
          boxAround = box;
        }
        return true;
      }, begin, end2);
      var baseX, sticky, outside = false;
      if (boxAround) {
        var atLeft = x2 - boxAround.left < boxAround.right - x2, atStart = atLeft == ltr;
        ch2 = chAround + (atStart ? 0 : 1);
        sticky = atStart ? "after" : "before";
        baseX = atLeft ? boxAround.left : boxAround.right;
      } else {
        if (!ltr && (ch2 == end2 || ch2 == begin)) {
          ch2++;
        }
        sticky = ch2 == 0 ? "after" : ch2 == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch2 - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y2 == ltr ? "after" : "before";
        var coords = cursorCoords(cm, Pos(lineNo2, ch2, sticky), "line", lineObj, preparedMeasure);
        baseX = coords.left;
        outside = y2 < coords.top ? -1 : y2 >= coords.bottom ? 1 : 0;
      }
      ch2 = skipExtendingChars(lineObj.text, ch2, 1);
      return PosWithInfo(lineNo2, ch2, sticky, outside, x2 - baseX);
    }
    function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order2, x2, y2) {
      var index = findFirst(function(i2) {
        var part3 = order2[i2], ltr2 = part3.level != 1;
        return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part3.to : part3.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x2, y2, true);
      }, 0, order2.length - 1);
      var part2 = order2[index];
      if (index > 0) {
        var ltr = part2.level != 1;
        var start2 = cursorCoords(cm, Pos(lineNo2, ltr ? part2.from : part2.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
        if (boxIsAfter(start2, x2, y2, true) && start2.top > y2) {
          part2 = order2[index - 1];
        }
      }
      return part2;
    }
    function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order2, x2, y2) {
      var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y2);
      var begin = ref.begin;
      var end2 = ref.end;
      if (/\s/.test(lineObj.text.charAt(end2 - 1))) {
        end2--;
      }
      var part2 = null, closestDist = null;
      for (var i2 = 0; i2 < order2.length; i2++) {
        var p2 = order2[i2];
        if (p2.from >= end2 || p2.to <= begin) {
          continue;
        }
        var ltr = p2.level != 1;
        var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end2, p2.to) - 1 : Math.max(begin, p2.from)).right;
        var dist2 = endX < x2 ? x2 - endX + 1e9 : endX - x2;
        if (!part2 || closestDist > dist2) {
          part2 = p2;
          closestDist = dist2;
        }
      }
      if (!part2) {
        part2 = order2[order2.length - 1];
      }
      if (part2.from < begin) {
        part2 = { from: begin, to: part2.to, level: part2.level };
      }
      if (part2.to > end2) {
        part2 = { from: part2.from, to: end2, level: part2.level };
      }
      return part2;
    }
    var measureText;
    function textHeight(display) {
      if (display.cachedTextHeight != null) {
        return display.cachedTextHeight;
      }
      if (measureText == null) {
        measureText = elt("pre", null, "CodeMirror-line-like");
        for (var i2 = 0; i2 < 49; ++i2) {
          measureText.appendChild(document.createTextNode("x"));
          measureText.appendChild(elt("br"));
        }
        measureText.appendChild(document.createTextNode("x"));
      }
      removeChildrenAndAdd(display.measure, measureText);
      var height = measureText.offsetHeight / 50;
      if (height > 3) {
        display.cachedTextHeight = height;
      }
      removeChildren(display.measure);
      return height || 1;
    }
    function charWidth(display) {
      if (display.cachedCharWidth != null) {
        return display.cachedCharWidth;
      }
      var anchor = elt("span", "xxxxxxxxxx");
      var pre2 = elt("pre", [anchor], "CodeMirror-line-like");
      removeChildrenAndAdd(display.measure, pre2);
      var rect2 = anchor.getBoundingClientRect(), width = (rect2.right - rect2.left) / 10;
      if (width > 2) {
        display.cachedCharWidth = width;
      }
      return width || 10;
    }
    function getDimensions(cm) {
      var d = cm.display, left = {}, width = {};
      var gutterLeft = d.gutters.clientLeft;
      for (var n2 = d.gutters.firstChild, i2 = 0; n2; n2 = n2.nextSibling, ++i2) {
        var id2 = cm.display.gutterSpecs[i2].className;
        left[id2] = n2.offsetLeft + n2.clientLeft + gutterLeft;
        width[id2] = n2.clientWidth;
      }
      return {
        fixedPos: compensateForHScroll(d),
        gutterTotalWidth: d.gutters.offsetWidth,
        gutterLeft: left,
        gutterWidth: width,
        wrapperWidth: d.wrapper.clientWidth
      };
    }
    function compensateForHScroll(display) {
      return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
    }
    function estimateHeight(cm) {
      var th2 = textHeight(cm.display), wrapping = cm.options.lineWrapping;
      var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
      return function(line) {
        if (lineIsHidden(cm.doc, line)) {
          return 0;
        }
        var widgetsHeight = 0;
        if (line.widgets) {
          for (var i2 = 0; i2 < line.widgets.length; i2++) {
            if (line.widgets[i2].height) {
              widgetsHeight += line.widgets[i2].height;
            }
          }
        }
        if (wrapping) {
          return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th2;
        } else {
          return widgetsHeight + th2;
        }
      };
    }
    function estimateLineHeights(cm) {
      var doc = cm.doc, est = estimateHeight(cm);
      doc.iter(function(line) {
        var estHeight = est(line);
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      });
    }
    function posFromMouse(cm, e, liberal, forRect) {
      var display = cm.display;
      if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
        return null;
      }
      var x2, y2, space = display.lineSpace.getBoundingClientRect();
      try {
        x2 = e.clientX - space.left;
        y2 = e.clientY - space.top;
      } catch (e$1) {
        return null;
      }
      var coords = coordsChar(cm, x2, y2), line;
      if (forRect && coords.xRel > 0 && (line = getLine2(cm.doc, coords.line).text).length == coords.ch) {
        var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
        coords = Pos(coords.line, Math.max(0, Math.round((x2 - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
      }
      return coords;
    }
    function findViewIndex(cm, n2) {
      if (n2 >= cm.display.viewTo) {
        return null;
      }
      n2 -= cm.display.viewFrom;
      if (n2 < 0) {
        return null;
      }
      var view = cm.display.view;
      for (var i2 = 0; i2 < view.length; i2++) {
        n2 -= view[i2].size;
        if (n2 < 0) {
          return i2;
        }
      }
    }
    function regChange(cm, from, to, lendiff) {
      if (from == null) {
        from = cm.doc.first;
      }
      if (to == null) {
        to = cm.doc.first + cm.doc.size;
      }
      if (!lendiff) {
        lendiff = 0;
      }
      var display = cm.display;
      if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
        display.updateLineNumbers = from;
      }
      cm.curOp.viewChanged = true;
      if (from >= display.viewTo) {
        if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
          resetView(cm);
        }
      } else if (to <= display.viewFrom) {
        if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
          resetView(cm);
        } else {
          display.viewFrom += lendiff;
          display.viewTo += lendiff;
        }
      } else if (from <= display.viewFrom && to >= display.viewTo) {
        resetView(cm);
      } else if (from <= display.viewFrom) {
        var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cut) {
          display.view = display.view.slice(cut.index);
          display.viewFrom = cut.lineN;
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      } else if (to >= display.viewTo) {
        var cut$1 = viewCuttingPoint(cm, from, from, -1);
        if (cut$1) {
          display.view = display.view.slice(0, cut$1.index);
          display.viewTo = cut$1.lineN;
        } else {
          resetView(cm);
        }
      } else {
        var cutTop = viewCuttingPoint(cm, from, from, -1);
        var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
        if (cutTop && cutBot) {
          display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
          display.viewTo += lendiff;
        } else {
          resetView(cm);
        }
      }
      var ext = display.externalMeasured;
      if (ext) {
        if (to < ext.lineN) {
          ext.lineN += lendiff;
        } else if (from < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
      }
    }
    function regLineChange(cm, line, type2) {
      cm.curOp.viewChanged = true;
      var display = cm.display, ext = cm.display.externalMeasured;
      if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
        display.externalMeasured = null;
      }
      if (line < display.viewFrom || line >= display.viewTo) {
        return;
      }
      var lineView = display.view[findViewIndex(cm, line)];
      if (lineView.node == null) {
        return;
      }
      var arr = lineView.changes || (lineView.changes = []);
      if (indexOf(arr, type2) == -1) {
        arr.push(type2);
      }
    }
    function resetView(cm) {
      cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
      cm.display.view = [];
      cm.display.viewOffset = 0;
    }
    function viewCuttingPoint(cm, oldN, newN, dir) {
      var index = findViewIndex(cm, oldN), diff2, view = cm.display.view;
      if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
        return { index, lineN: newN };
      }
      var n2 = cm.display.viewFrom;
      for (var i2 = 0; i2 < index; i2++) {
        n2 += view[i2].size;
      }
      if (n2 != oldN) {
        if (dir > 0) {
          if (index == view.length - 1) {
            return null;
          }
          diff2 = n2 + view[index].size - oldN;
          index++;
        } else {
          diff2 = n2 - oldN;
        }
        oldN += diff2;
        newN += diff2;
      }
      while (visualLineNo(cm.doc, newN) != newN) {
        if (index == (dir < 0 ? 0 : view.length - 1)) {
          return null;
        }
        newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
        index += dir;
      }
      return { index, lineN: newN };
    }
    function adjustView(cm, from, to) {
      var display = cm.display, view = display.view;
      if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
        display.view = buildViewArray(cm, from, to);
        display.viewFrom = from;
      } else {
        if (display.viewFrom > from) {
          display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
        } else if (display.viewFrom < from) {
          display.view = display.view.slice(findViewIndex(cm, from));
        }
        display.viewFrom = from;
        if (display.viewTo < to) {
          display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
        } else if (display.viewTo > to) {
          display.view = display.view.slice(0, findViewIndex(cm, to));
        }
      }
      display.viewTo = to;
    }
    function countDirtyView(cm) {
      var view = cm.display.view, dirty = 0;
      for (var i2 = 0; i2 < view.length; i2++) {
        var lineView = view[i2];
        if (!lineView.hidden && (!lineView.node || lineView.changes)) {
          ++dirty;
        }
      }
      return dirty;
    }
    function updateSelection(cm) {
      cm.display.input.showSelection(cm.display.input.prepareSelection());
    }
    function prepareSelection(cm, primary) {
      if (primary === void 0)
        primary = true;
      var doc = cm.doc, result2 = {};
      var curFragment = result2.cursors = document.createDocumentFragment();
      var selFragment = result2.selection = document.createDocumentFragment();
      var customCursor = cm.options.$customCursor;
      if (customCursor) {
        primary = true;
      }
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        if (!primary && i2 == doc.sel.primIndex) {
          continue;
        }
        var range3 = doc.sel.ranges[i2];
        if (range3.from().line >= cm.display.viewTo || range3.to().line < cm.display.viewFrom) {
          continue;
        }
        var collapsed = range3.empty();
        if (customCursor) {
          var head = customCursor(cm, range3);
          if (head) {
            drawSelectionCursor(cm, head, curFragment);
          }
        } else if (collapsed || cm.options.showCursorWhenSelecting) {
          drawSelectionCursor(cm, range3.head, curFragment);
        }
        if (!collapsed) {
          drawSelectionRange(cm, range3, selFragment);
        }
      }
      return result2;
    }
    function drawSelectionCursor(cm, head, output) {
      var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
      var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
      cursor.style.left = pos.left + "px";
      cursor.style.top = pos.top + "px";
      cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
      if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
        var charPos = charCoords(cm, head, "div", null, null);
        var width = charPos.right - charPos.left;
        cursor.style.width = (width > 0 ? width : cm.defaultCharWidth()) + "px";
      }
      if (pos.other) {
        var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
        otherCursor.style.display = "";
        otherCursor.style.left = pos.other.left + "px";
        otherCursor.style.top = pos.other.top + "px";
        otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
      }
    }
    function cmpCoords(a, b) {
      return a.top - b.top || a.left - b.left;
    }
    function drawSelectionRange(cm, range3, output) {
      var display = cm.display, doc = cm.doc;
      var fragment = document.createDocumentFragment();
      var padding = paddingH(cm.display), leftSide = padding.left;
      var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
      var docLTR = doc.direction == "ltr";
      function add2(left, top2, width, bottom2) {
        if (top2 < 0) {
          top2 = 0;
        }
        top2 = Math.round(top2);
        bottom2 = Math.round(bottom2);
        fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top2 + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom2 - top2) + "px"));
      }
      function drawForLine(line, fromArg, toArg) {
        var lineObj = getLine2(doc, line);
        var lineLen = lineObj.text.length;
        var start2, end2;
        function coords(ch2, bias) {
          return charCoords(cm, Pos(line, ch2), "div", lineObj, bias);
        }
        function wrapX(pos, dir, side) {
          var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
          var prop3 = dir == "ltr" == (side == "after") ? "left" : "right";
          var ch2 = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
          return coords(ch2, prop3)[prop3];
        }
        var order2 = getOrder(lineObj, doc.direction);
        iterateBidiSections(order2, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
          var ltr = dir == "ltr";
          var fromPos = coords(from, ltr ? "left" : "right");
          var toPos = coords(to - 1, ltr ? "right" : "left");
          var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
          var first = i2 == 0, last = !order2 || i2 == order2.length - 1;
          if (toPos.top - fromPos.top <= 3) {
            var openLeft = (docLTR ? openStart : openEnd) && first;
            var openRight = (docLTR ? openEnd : openStart) && last;
            var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
            var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
            add2(left, fromPos.top, right - left, fromPos.bottom);
          } else {
            var topLeft, topRight, botLeft, botRight;
            if (ltr) {
              topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
              topRight = docLTR ? rightSide : wrapX(from, dir, "before");
              botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
              botRight = docLTR && openEnd && last ? rightSide : toPos.right;
            } else {
              topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
              topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
              botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
              botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
            }
            add2(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
            if (fromPos.bottom < toPos.top) {
              add2(leftSide, fromPos.bottom, null, toPos.top);
            }
            add2(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
          }
          if (!start2 || cmpCoords(fromPos, start2) < 0) {
            start2 = fromPos;
          }
          if (cmpCoords(toPos, start2) < 0) {
            start2 = toPos;
          }
          if (!end2 || cmpCoords(fromPos, end2) < 0) {
            end2 = fromPos;
          }
          if (cmpCoords(toPos, end2) < 0) {
            end2 = toPos;
          }
        });
        return { start: start2, end: end2 };
      }
      var sFrom = range3.from(), sTo = range3.to();
      if (sFrom.line == sTo.line) {
        drawForLine(sFrom.line, sFrom.ch, sTo.ch);
      } else {
        var fromLine = getLine2(doc, sFrom.line), toLine = getLine2(doc, sTo.line);
        var singleVLine = visualLine(fromLine) == visualLine(toLine);
        var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
        var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
        if (singleVLine) {
          if (leftEnd.top < rightStart.top - 2) {
            add2(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
            add2(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
          } else {
            add2(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
          }
        }
        if (leftEnd.bottom < rightStart.top) {
          add2(leftSide, leftEnd.bottom, null, rightStart.top);
        }
      }
      output.appendChild(fragment);
    }
    function restartBlink(cm) {
      if (!cm.state.focused) {
        return;
      }
      var display = cm.display;
      clearInterval(display.blinker);
      var on2 = true;
      display.cursorDiv.style.visibility = "";
      if (cm.options.cursorBlinkRate > 0) {
        display.blinker = setInterval(function() {
          if (!cm.hasFocus()) {
            onBlur(cm);
          }
          display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
        }, cm.options.cursorBlinkRate);
      } else if (cm.options.cursorBlinkRate < 0) {
        display.cursorDiv.style.visibility = "hidden";
      }
    }
    function ensureFocus(cm) {
      if (!cm.hasFocus()) {
        cm.display.input.focus();
        if (!cm.state.focused) {
          onFocus(cm);
        }
      }
    }
    function delayBlurEvent(cm) {
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        if (cm.state.delayingBlurEvent) {
          cm.state.delayingBlurEvent = false;
          if (cm.state.focused) {
            onBlur(cm);
          }
        }
      }, 100);
    }
    function onFocus(cm, e) {
      if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
        cm.state.delayingBlurEvent = false;
      }
      if (cm.options.readOnly == "nocursor") {
        return;
      }
      if (!cm.state.focused) {
        signal(cm, "focus", cm, e);
        cm.state.focused = true;
        addClass(cm.display.wrapper, "CodeMirror-focused");
        if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
          cm.display.input.reset();
          if (webkit) {
            setTimeout(function() {
              return cm.display.input.reset(true);
            }, 20);
          }
        }
        cm.display.input.receivedFocus();
      }
      restartBlink(cm);
    }
    function onBlur(cm, e) {
      if (cm.state.delayingBlurEvent) {
        return;
      }
      if (cm.state.focused) {
        signal(cm, "blur", cm, e);
        cm.state.focused = false;
        rmClass(cm.display.wrapper, "CodeMirror-focused");
      }
      clearInterval(cm.display.blinker);
      setTimeout(function() {
        if (!cm.state.focused) {
          cm.display.shift = false;
        }
      }, 150);
    }
    function updateHeightsInViewport(cm) {
      var display = cm.display;
      var prevBottom = display.lineDiv.offsetTop;
      var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
      var oldHeight = display.lineDiv.getBoundingClientRect().top;
      var mustScroll = 0;
      for (var i2 = 0; i2 < display.view.length; i2++) {
        var cur = display.view[i2], wrapping = cm.options.lineWrapping;
        var height = void 0, width = 0;
        if (cur.hidden) {
          continue;
        }
        oldHeight += cur.line.height;
        if (ie2 && ie_version < 8) {
          var bot2 = cur.node.offsetTop + cur.node.offsetHeight;
          height = bot2 - prevBottom;
          prevBottom = bot2;
        } else {
          var box = cur.node.getBoundingClientRect();
          height = box.bottom - box.top;
          if (!wrapping && cur.text.firstChild) {
            width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
          }
        }
        var diff2 = cur.line.height - height;
        if (diff2 > 5e-3 || diff2 < -5e-3) {
          if (oldHeight < viewTop) {
            mustScroll -= diff2;
          }
          updateLineHeight(cur.line, height);
          updateWidgetHeight(cur.line);
          if (cur.rest) {
            for (var j = 0; j < cur.rest.length; j++) {
              updateWidgetHeight(cur.rest[j]);
            }
          }
        }
        if (width > cm.display.sizerWidth) {
          var chWidth = Math.ceil(width / charWidth(cm.display));
          if (chWidth > cm.display.maxLineLength) {
            cm.display.maxLineLength = chWidth;
            cm.display.maxLine = cur.line;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (Math.abs(mustScroll) > 2) {
        display.scroller.scrollTop += mustScroll;
      }
    }
    function updateWidgetHeight(line) {
      if (line.widgets) {
        for (var i2 = 0; i2 < line.widgets.length; ++i2) {
          var w = line.widgets[i2], parent = w.node.parentNode;
          if (parent) {
            w.height = parent.offsetHeight;
          }
        }
      }
    }
    function visibleLines(display, doc, viewport) {
      var top2 = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
      top2 = Math.floor(top2 - paddingTop(display));
      var bottom2 = viewport && viewport.bottom != null ? viewport.bottom : top2 + display.wrapper.clientHeight;
      var from = lineAtHeight(doc, top2), to = lineAtHeight(doc, bottom2);
      if (viewport && viewport.ensure) {
        var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
        if (ensureFrom < from) {
          from = ensureFrom;
          to = lineAtHeight(doc, heightAtLine(getLine2(doc, ensureFrom)) + display.wrapper.clientHeight);
        } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
          from = lineAtHeight(doc, heightAtLine(getLine2(doc, ensureTo)) - display.wrapper.clientHeight);
          to = ensureTo;
        }
      }
      return { from, to: Math.max(to, from + 1) };
    }
    function maybeScrollWindow(cm, rect2) {
      if (signalDOMEvent(cm, "scrollCursorIntoView")) {
        return;
      }
      var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
      if (rect2.top + box.top < 0) {
        doScroll = true;
      } else if (rect2.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
        doScroll = false;
      }
      if (doScroll != null && !phantom) {
        var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect2.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect2.bottom - rect2.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect2.left + "px; width: " + Math.max(2, rect2.right - rect2.left) + "px;");
        cm.display.lineSpace.appendChild(scrollNode);
        scrollNode.scrollIntoView(doScroll);
        cm.display.lineSpace.removeChild(scrollNode);
      }
    }
    function scrollPosIntoView(cm, pos, end2, margin) {
      if (margin == null) {
        margin = 0;
      }
      var rect2;
      if (!cm.options.lineWrapping && pos == end2) {
        end2 = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
        pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      }
      for (var limit = 0; limit < 5; limit++) {
        var changed = false;
        var coords = cursorCoords(cm, pos);
        var endCoords = !end2 || end2 == pos ? coords : cursorCoords(cm, end2);
        rect2 = {
          left: Math.min(coords.left, endCoords.left),
          top: Math.min(coords.top, endCoords.top) - margin,
          right: Math.max(coords.left, endCoords.left),
          bottom: Math.max(coords.bottom, endCoords.bottom) + margin
        };
        var scrollPos = calculateScrollPos(cm, rect2);
        var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
          if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
            changed = true;
          }
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
          if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
            changed = true;
          }
        }
        if (!changed) {
          break;
        }
      }
      return rect2;
    }
    function scrollIntoView(cm, rect2) {
      var scrollPos = calculateScrollPos(cm, rect2);
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
      }
    }
    function calculateScrollPos(cm, rect2) {
      var display = cm.display, snapMargin = textHeight(cm.display);
      if (rect2.top < 0) {
        rect2.top = 0;
      }
      var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
      var screen2 = displayHeight(cm), result2 = {};
      if (rect2.bottom - rect2.top > screen2) {
        rect2.bottom = rect2.top + screen2;
      }
      var docBottom = cm.doc.height + paddingVert(display);
      var atTop = rect2.top < snapMargin, atBottom = rect2.bottom > docBottom - snapMargin;
      if (rect2.top < screentop) {
        result2.scrollTop = atTop ? 0 : rect2.top;
      } else if (rect2.bottom > screentop + screen2) {
        var newTop = Math.min(rect2.top, (atBottom ? docBottom : rect2.bottom) - screen2);
        if (newTop != screentop) {
          result2.scrollTop = newTop;
        }
      }
      var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
      var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
      var screenw = displayWidth(cm) - display.gutters.offsetWidth;
      var tooWide = rect2.right - rect2.left > screenw;
      if (tooWide) {
        rect2.right = rect2.left + screenw;
      }
      if (rect2.left < 10) {
        result2.scrollLeft = 0;
      } else if (rect2.left < screenleft) {
        result2.scrollLeft = Math.max(0, rect2.left + gutterSpace - (tooWide ? 0 : 10));
      } else if (rect2.right > screenw + screenleft - 3) {
        result2.scrollLeft = rect2.right + (tooWide ? 0 : 10) - screenw;
      }
      return result2;
    }
    function addToScrollTop(cm, top2) {
      if (top2 == null) {
        return;
      }
      resolveScrollToPos(cm);
      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top2;
    }
    function ensureCursorVisible(cm) {
      resolveScrollToPos(cm);
      var cur = cm.getCursor();
      cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
    }
    function scrollToCoords(cm, x2, y2) {
      if (x2 != null || y2 != null) {
        resolveScrollToPos(cm);
      }
      if (x2 != null) {
        cm.curOp.scrollLeft = x2;
      }
      if (y2 != null) {
        cm.curOp.scrollTop = y2;
      }
    }
    function scrollToRange(cm, range3) {
      resolveScrollToPos(cm);
      cm.curOp.scrollToPos = range3;
    }
    function resolveScrollToPos(cm) {
      var range3 = cm.curOp.scrollToPos;
      if (range3) {
        cm.curOp.scrollToPos = null;
        var from = estimateCoords(cm, range3.from), to = estimateCoords(cm, range3.to);
        scrollToCoordsRange(cm, from, to, range3.margin);
      }
    }
    function scrollToCoordsRange(cm, from, to, margin) {
      var sPos = calculateScrollPos(cm, {
        left: Math.min(from.left, to.left),
        top: Math.min(from.top, to.top) - margin,
        right: Math.max(from.right, to.right),
        bottom: Math.max(from.bottom, to.bottom) + margin
      });
      scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
    }
    function updateScrollTop(cm, val) {
      if (Math.abs(cm.doc.scrollTop - val) < 2) {
        return;
      }
      if (!gecko) {
        updateDisplaySimple(cm, { top: val });
      }
      setScrollTop(cm, val, true);
      if (gecko) {
        updateDisplaySimple(cm);
      }
      startWorker(cm, 100);
    }
    function setScrollTop(cm, val, forceScroll) {
      val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
      if (cm.display.scroller.scrollTop == val && !forceScroll) {
        return;
      }
      cm.doc.scrollTop = val;
      cm.display.scrollbars.setScrollTop(val);
      if (cm.display.scroller.scrollTop != val) {
        cm.display.scroller.scrollTop = val;
      }
    }
    function setScrollLeft(cm, val, isScroller, forceScroll) {
      val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
      if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
        return;
      }
      cm.doc.scrollLeft = val;
      alignHorizontally(cm);
      if (cm.display.scroller.scrollLeft != val) {
        cm.display.scroller.scrollLeft = val;
      }
      cm.display.scrollbars.setScrollLeft(val);
    }
    function measureForScrollbars(cm) {
      var d = cm.display, gutterW = d.gutters.offsetWidth;
      var docH = Math.round(cm.doc.height + paddingVert(cm.display));
      return {
        clientHeight: d.scroller.clientHeight,
        viewHeight: d.wrapper.clientHeight,
        scrollWidth: d.scroller.scrollWidth,
        clientWidth: d.scroller.clientWidth,
        viewWidth: d.wrapper.clientWidth,
        barLeft: cm.options.fixedGutter ? gutterW : 0,
        docHeight: docH,
        scrollHeight: docH + scrollGap(cm) + d.barHeight,
        nativeBarWidth: d.nativeBarWidth,
        gutterWidth: gutterW
      };
    }
    var NativeScrollbars = function(place, scroll, cm) {
      this.cm = cm;
      var vert2 = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
      var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
      vert2.tabIndex = horiz.tabIndex = -1;
      place(vert2);
      place(horiz);
      on(vert2, "scroll", function() {
        if (vert2.clientHeight) {
          scroll(vert2.scrollTop, "vertical");
        }
      });
      on(horiz, "scroll", function() {
        if (horiz.clientWidth) {
          scroll(horiz.scrollLeft, "horizontal");
        }
      });
      this.checkedZeroWidth = false;
      if (ie2 && ie_version < 8) {
        this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
      }
    };
    NativeScrollbars.prototype.update = function(measure) {
      var needsH = measure.scrollWidth > measure.clientWidth + 1;
      var needsV = measure.scrollHeight > measure.clientHeight + 1;
      var sWidth = measure.nativeBarWidth;
      if (needsV) {
        this.vert.style.display = "block";
        this.vert.style.bottom = needsH ? sWidth + "px" : "0";
        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
        this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
      } else {
        this.vert.scrollTop = 0;
        this.vert.style.display = "";
        this.vert.firstChild.style.height = "0";
      }
      if (needsH) {
        this.horiz.style.display = "block";
        this.horiz.style.right = needsV ? sWidth + "px" : "0";
        this.horiz.style.left = measure.barLeft + "px";
        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
        this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
      } else {
        this.horiz.style.display = "";
        this.horiz.firstChild.style.width = "0";
      }
      if (!this.checkedZeroWidth && measure.clientHeight > 0) {
        if (sWidth == 0) {
          this.zeroWidthHack();
        }
        this.checkedZeroWidth = true;
      }
      return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
    };
    NativeScrollbars.prototype.setScrollLeft = function(pos) {
      if (this.horiz.scrollLeft != pos) {
        this.horiz.scrollLeft = pos;
      }
      if (this.disableHoriz) {
        this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }
    };
    NativeScrollbars.prototype.setScrollTop = function(pos) {
      if (this.vert.scrollTop != pos) {
        this.vert.scrollTop = pos;
      }
      if (this.disableVert) {
        this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }
    };
    NativeScrollbars.prototype.zeroWidthHack = function() {
      var w = mac && !mac_geMountainLion ? "12px" : "18px";
      this.horiz.style.height = this.vert.style.width = w;
      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
      this.disableHoriz = new Delayed();
      this.disableVert = new Delayed();
    };
    NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type2) {
      bar.style.pointerEvents = "auto";
      function maybeDisable() {
        var box = bar.getBoundingClientRect();
        var elt2 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
        if (elt2 != bar) {
          bar.style.pointerEvents = "none";
        } else {
          delay.set(1e3, maybeDisable);
        }
      }
      delay.set(1e3, maybeDisable);
    };
    NativeScrollbars.prototype.clear = function() {
      var parent = this.horiz.parentNode;
      parent.removeChild(this.horiz);
      parent.removeChild(this.vert);
    };
    var NullScrollbars = function() {
    };
    NullScrollbars.prototype.update = function() {
      return { bottom: 0, right: 0 };
    };
    NullScrollbars.prototype.setScrollLeft = function() {
    };
    NullScrollbars.prototype.setScrollTop = function() {
    };
    NullScrollbars.prototype.clear = function() {
    };
    function updateScrollbars(cm, measure) {
      if (!measure) {
        measure = measureForScrollbars(cm);
      }
      var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
      updateScrollbarsInner(cm, measure);
      for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
        if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
          updateHeightsInViewport(cm);
        }
        updateScrollbarsInner(cm, measureForScrollbars(cm));
        startWidth = cm.display.barWidth;
        startHeight = cm.display.barHeight;
      }
    }
    function updateScrollbarsInner(cm, measure) {
      var d = cm.display;
      var sizes = d.scrollbars.update(measure);
      d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
      d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
      d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
      if (sizes.right && sizes.bottom) {
        d.scrollbarFiller.style.display = "block";
        d.scrollbarFiller.style.height = sizes.bottom + "px";
        d.scrollbarFiller.style.width = sizes.right + "px";
      } else {
        d.scrollbarFiller.style.display = "";
      }
      if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
        d.gutterFiller.style.display = "block";
        d.gutterFiller.style.height = sizes.bottom + "px";
        d.gutterFiller.style.width = measure.gutterWidth + "px";
      } else {
        d.gutterFiller.style.display = "";
      }
    }
    var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
    function initScrollbars(cm) {
      if (cm.display.scrollbars) {
        cm.display.scrollbars.clear();
        if (cm.display.scrollbars.addClass) {
          rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
        cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
        on(node, "mousedown", function() {
          if (cm.state.focused) {
            setTimeout(function() {
              return cm.display.input.focus();
            }, 0);
          }
        });
        node.setAttribute("cm-not-content", "true");
      }, function(pos, axis) {
        if (axis == "horizontal") {
          setScrollLeft(cm, pos);
        } else {
          updateScrollTop(cm, pos);
        }
      }, cm);
      if (cm.display.scrollbars.addClass) {
        addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
      }
    }
    var nextOpId = 0;
    function startOperation(cm) {
      cm.curOp = {
        cm,
        viewChanged: false,
        startHeight: cm.doc.height,
        forceUpdate: false,
        updateInput: 0,
        typing: false,
        changeObjs: null,
        cursorActivityHandlers: null,
        cursorActivityCalled: 0,
        selectionChanged: false,
        updateMaxLine: false,
        scrollLeft: null,
        scrollTop: null,
        scrollToPos: null,
        focus: false,
        id: ++nextOpId,
        markArrays: null
      };
      pushOperation(cm.curOp);
    }
    function endOperation(cm) {
      var op = cm.curOp;
      if (op) {
        finishOperation(op, function(group) {
          for (var i2 = 0; i2 < group.ops.length; i2++) {
            group.ops[i2].cm.curOp = null;
          }
          endOperations(group);
        });
      }
    }
    function endOperations(group) {
      var ops = group.ops;
      for (var i2 = 0; i2 < ops.length; i2++) {
        endOperation_R1(ops[i2]);
      }
      for (var i$12 = 0; i$12 < ops.length; i$12++) {
        endOperation_W1(ops[i$12]);
      }
      for (var i$22 = 0; i$22 < ops.length; i$22++) {
        endOperation_R2(ops[i$22]);
      }
      for (var i$3 = 0; i$3 < ops.length; i$3++) {
        endOperation_W2(ops[i$3]);
      }
      for (var i$4 = 0; i$4 < ops.length; i$4++) {
        endOperation_finish(ops[i$4]);
      }
    }
    function endOperation_R1(op) {
      var cm = op.cm, display = cm.display;
      maybeClipScrollbars(cm);
      if (op.updateMaxLine) {
        findMaxLine(cm);
      }
      op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
      op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
    }
    function endOperation_W1(op) {
      op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
    }
    function endOperation_R2(op) {
      var cm = op.cm, display = cm.display;
      if (op.updatedDisplay) {
        updateHeightsInViewport(cm);
      }
      op.barMeasure = measureForScrollbars(cm);
      if (display.maxLineChanged && !cm.options.lineWrapping) {
        op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
        cm.display.sizerWidth = op.adjustWidthTo;
        op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
        op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
      }
      if (op.updatedDisplay || op.selectionChanged) {
        op.preparedSelection = display.input.prepareSelection();
      }
    }
    function endOperation_W2(op) {
      var cm = op.cm;
      if (op.adjustWidthTo != null) {
        cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
        if (op.maxScrollLeft < cm.doc.scrollLeft) {
          setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
        }
        cm.display.maxLineChanged = false;
      }
      var takeFocus = op.focus && op.focus == activeElt();
      if (op.preparedSelection) {
        cm.display.input.showSelection(op.preparedSelection, takeFocus);
      }
      if (op.updatedDisplay || op.startHeight != cm.doc.height) {
        updateScrollbars(cm, op.barMeasure);
      }
      if (op.updatedDisplay) {
        setDocumentHeight(cm, op.barMeasure);
      }
      if (op.selectionChanged) {
        restartBlink(cm);
      }
      if (cm.state.focused && op.updateInput) {
        cm.display.input.reset(op.typing);
      }
      if (takeFocus) {
        ensureFocus(op.cm);
      }
    }
    function endOperation_finish(op) {
      var cm = op.cm, display = cm.display, doc = cm.doc;
      if (op.updatedDisplay) {
        postUpdateDisplay(cm, op.update);
      }
      if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
        display.wheelStartX = display.wheelStartY = null;
      }
      if (op.scrollTop != null) {
        setScrollTop(cm, op.scrollTop, op.forceScroll);
      }
      if (op.scrollLeft != null) {
        setScrollLeft(cm, op.scrollLeft, true, true);
      }
      if (op.scrollToPos) {
        var rect2 = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
        maybeScrollWindow(cm, rect2);
      }
      var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
      if (hidden) {
        for (var i2 = 0; i2 < hidden.length; ++i2) {
          if (!hidden[i2].lines.length) {
            signal(hidden[i2], "hide");
          }
        }
      }
      if (unhidden) {
        for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
          if (unhidden[i$12].lines.length) {
            signal(unhidden[i$12], "unhide");
          }
        }
      }
      if (display.wrapper.offsetHeight) {
        doc.scrollTop = cm.display.scroller.scrollTop;
      }
      if (op.changeObjs) {
        signal(cm, "changes", cm, op.changeObjs);
      }
      if (op.update) {
        op.update.finish();
      }
    }
    function runInOp(cm, f) {
      if (cm.curOp) {
        return f();
      }
      startOperation(cm);
      try {
        return f();
      } finally {
        endOperation(cm);
      }
    }
    function operation(cm, f) {
      return function() {
        if (cm.curOp) {
          return f.apply(cm, arguments);
        }
        startOperation(cm);
        try {
          return f.apply(cm, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function methodOp(f) {
      return function() {
        if (this.curOp) {
          return f.apply(this, arguments);
        }
        startOperation(this);
        try {
          return f.apply(this, arguments);
        } finally {
          endOperation(this);
        }
      };
    }
    function docMethodOp(f) {
      return function() {
        var cm = this.cm;
        if (!cm || cm.curOp) {
          return f.apply(this, arguments);
        }
        startOperation(cm);
        try {
          return f.apply(this, arguments);
        } finally {
          endOperation(cm);
        }
      };
    }
    function startWorker(cm, time) {
      if (cm.doc.highlightFrontier < cm.display.viewTo) {
        cm.state.highlight.set(time, bind(highlightWorker, cm));
      }
    }
    function highlightWorker(cm) {
      var doc = cm.doc;
      if (doc.highlightFrontier >= cm.display.viewTo) {
        return;
      }
      var end2 = +new Date() + cm.options.workTime;
      var context = getContextBefore(cm, doc.highlightFrontier);
      var changedLines = [];
      doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
        if (context.line >= cm.display.viewFrom) {
          var oldStyles = line.styles;
          var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
          var highlighted = highlightLine(cm, line, context, true);
          if (resetState) {
            context.state = resetState;
          }
          line.styles = highlighted.styles;
          var oldCls = line.styleClasses, newCls = highlighted.classes;
          if (newCls) {
            line.styleClasses = newCls;
          } else if (oldCls) {
            line.styleClasses = null;
          }
          var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
          for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
            ischange = oldStyles[i2] != line.styles[i2];
          }
          if (ischange) {
            changedLines.push(context.line);
          }
          line.stateAfter = context.save();
          context.nextLine();
        } else {
          if (line.text.length <= cm.options.maxHighlightLength) {
            processLine(cm, line.text, context);
          }
          line.stateAfter = context.line % 5 == 0 ? context.save() : null;
          context.nextLine();
        }
        if (+new Date() > end2) {
          startWorker(cm, cm.options.workDelay);
          return true;
        }
      });
      doc.highlightFrontier = context.line;
      doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
      if (changedLines.length) {
        runInOp(cm, function() {
          for (var i2 = 0; i2 < changedLines.length; i2++) {
            regLineChange(cm, changedLines[i2], "text");
          }
        });
      }
    }
    var DisplayUpdate = function(cm, viewport, force) {
      var display = cm.display;
      this.viewport = viewport;
      this.visible = visibleLines(display, cm.doc, viewport);
      this.editorIsHidden = !display.wrapper.offsetWidth;
      this.wrapperHeight = display.wrapper.clientHeight;
      this.wrapperWidth = display.wrapper.clientWidth;
      this.oldDisplayWidth = displayWidth(cm);
      this.force = force;
      this.dims = getDimensions(cm);
      this.events = [];
    };
    DisplayUpdate.prototype.signal = function(emitter, type2) {
      if (hasHandler(emitter, type2)) {
        this.events.push(arguments);
      }
    };
    DisplayUpdate.prototype.finish = function() {
      for (var i2 = 0; i2 < this.events.length; i2++) {
        signal.apply(null, this.events[i2]);
      }
    };
    function maybeClipScrollbars(cm) {
      var display = cm.display;
      if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
        display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
        display.heightForcer.style.height = scrollGap(cm) + "px";
        display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
        display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
        display.scrollbarsClipped = true;
      }
    }
    function selectionSnapshot(cm) {
      if (cm.hasFocus()) {
        return null;
      }
      var active = activeElt();
      if (!active || !contains(cm.display.lineDiv, active)) {
        return null;
      }
      var result2 = { activeElt: active };
      if (window.getSelection) {
        var sel = window.getSelection();
        if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
          result2.anchorNode = sel.anchorNode;
          result2.anchorOffset = sel.anchorOffset;
          result2.focusNode = sel.focusNode;
          result2.focusOffset = sel.focusOffset;
        }
      }
      return result2;
    }
    function restoreSelection(snapshot) {
      if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
        return;
      }
      snapshot.activeElt.focus();
      if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
        var sel = window.getSelection(), range3 = document.createRange();
        range3.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
        range3.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range3);
        sel.extend(snapshot.focusNode, snapshot.focusOffset);
      }
    }
    function updateDisplayIfNeeded(cm, update) {
      var display = cm.display, doc = cm.doc;
      if (update.editorIsHidden) {
        resetView(cm);
        return false;
      }
      if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
        return false;
      }
      if (maybeUpdateLineNumberWidth(cm)) {
        resetView(cm);
        update.dims = getDimensions(cm);
      }
      var end2 = doc.first + doc.size;
      var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
      var to = Math.min(end2, update.visible.to + cm.options.viewportMargin);
      if (display.viewFrom < from && from - display.viewFrom < 20) {
        from = Math.max(doc.first, display.viewFrom);
      }
      if (display.viewTo > to && display.viewTo - to < 20) {
        to = Math.min(end2, display.viewTo);
      }
      if (sawCollapsedSpans) {
        from = visualLineNo(cm.doc, from);
        to = visualLineEndNo(cm.doc, to);
      }
      var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
      adjustView(cm, from, to);
      display.viewOffset = heightAtLine(getLine2(cm.doc, display.viewFrom));
      cm.display.mover.style.top = display.viewOffset + "px";
      var toUpdate = countDirtyView(cm);
      if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
        return false;
      }
      var selSnapshot = selectionSnapshot(cm);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "none";
      }
      patchDisplay(cm, display.updateLineNumbers, update.dims);
      if (toUpdate > 4) {
        display.lineDiv.style.display = "";
      }
      display.renderedView = display.view;
      restoreSelection(selSnapshot);
      removeChildren(display.cursorDiv);
      removeChildren(display.selectionDiv);
      display.gutters.style.height = display.sizer.style.minHeight = 0;
      if (different) {
        display.lastWrapHeight = update.wrapperHeight;
        display.lastWrapWidth = update.wrapperWidth;
        startWorker(cm, 400);
      }
      display.updateLineNumbers = null;
      return true;
    }
    function postUpdateDisplay(cm, update) {
      var viewport = update.viewport;
      for (var first = true; ; first = false) {
        if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
          if (viewport && viewport.top != null) {
            viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
          }
          update.visible = visibleLines(cm.display, cm.doc, viewport);
          if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
            break;
          }
        } else if (first) {
          update.visible = visibleLines(cm.display, cm.doc, viewport);
        }
        if (!updateDisplayIfNeeded(cm, update)) {
          break;
        }
        updateHeightsInViewport(cm);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.force = false;
      }
      update.signal(cm, "update", cm);
      if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
        update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
        cm.display.reportedViewFrom = cm.display.viewFrom;
        cm.display.reportedViewTo = cm.display.viewTo;
      }
    }
    function updateDisplaySimple(cm, viewport) {
      var update = new DisplayUpdate(cm, viewport);
      if (updateDisplayIfNeeded(cm, update)) {
        updateHeightsInViewport(cm);
        postUpdateDisplay(cm, update);
        var barMeasure = measureForScrollbars(cm);
        updateSelection(cm);
        updateScrollbars(cm, barMeasure);
        setDocumentHeight(cm, barMeasure);
        update.finish();
      }
    }
    function patchDisplay(cm, updateNumbersFrom, dims) {
      var display = cm.display, lineNumbers = cm.options.lineNumbers;
      var container = display.lineDiv, cur = container.firstChild;
      function rm(node2) {
        var next = node2.nextSibling;
        if (webkit && mac && cm.display.currentWheelTarget == node2) {
          node2.style.display = "none";
        } else {
          node2.parentNode.removeChild(node2);
        }
        return next;
      }
      var view = display.view, lineN = display.viewFrom;
      for (var i2 = 0; i2 < view.length; i2++) {
        var lineView = view[i2];
        if (lineView.hidden)
          ;
        else if (!lineView.node || lineView.node.parentNode != container) {
          var node = buildLineElement(cm, lineView, lineN, dims);
          container.insertBefore(node, cur);
        } else {
          while (cur != lineView.node) {
            cur = rm(cur);
          }
          var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
          if (lineView.changes) {
            if (indexOf(lineView.changes, "gutter") > -1) {
              updateNumber = false;
            }
            updateLineForChanges(cm, lineView, lineN, dims);
          }
          if (updateNumber) {
            removeChildren(lineView.lineNumber);
            lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
          }
          cur = lineView.node.nextSibling;
        }
        lineN += lineView.size;
      }
      while (cur) {
        cur = rm(cur);
      }
    }
    function updateGutterSpace(display) {
      var width = display.gutters.offsetWidth;
      display.sizer.style.marginLeft = width + "px";
      signalLater(display, "gutterChanged", display);
    }
    function setDocumentHeight(cm, measure) {
      cm.display.sizer.style.minHeight = measure.docHeight + "px";
      cm.display.heightForcer.style.top = measure.docHeight + "px";
      cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
    }
    function alignHorizontally(cm) {
      var display = cm.display, view = display.view;
      if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
        return;
      }
      var comp2 = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
      var gutterW = display.gutters.offsetWidth, left = comp2 + "px";
      for (var i2 = 0; i2 < view.length; i2++) {
        if (!view[i2].hidden) {
          if (cm.options.fixedGutter) {
            if (view[i2].gutter) {
              view[i2].gutter.style.left = left;
            }
            if (view[i2].gutterBackground) {
              view[i2].gutterBackground.style.left = left;
            }
          }
          var align = view[i2].alignable;
          if (align) {
            for (var j = 0; j < align.length; j++) {
              align[j].style.left = left;
            }
          }
        }
      }
      if (cm.options.fixedGutter) {
        display.gutters.style.left = comp2 + gutterW + "px";
      }
    }
    function maybeUpdateLineNumberWidth(cm) {
      if (!cm.options.lineNumbers) {
        return false;
      }
      var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
      if (last.length != display.lineNumChars) {
        var test2 = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
        var innerW = test2.firstChild.offsetWidth, padding = test2.offsetWidth - innerW;
        display.lineGutter.style.width = "";
        display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
        display.lineNumWidth = display.lineNumInnerWidth + padding;
        display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
        display.lineGutter.style.width = display.lineNumWidth + "px";
        updateGutterSpace(cm.display);
        return true;
      }
      return false;
    }
    function getGutters(gutters, lineNumbers) {
      var result2 = [], sawLineNumbers = false;
      for (var i2 = 0; i2 < gutters.length; i2++) {
        var name2 = gutters[i2], style = null;
        if (typeof name2 != "string") {
          style = name2.style;
          name2 = name2.className;
        }
        if (name2 == "CodeMirror-linenumbers") {
          if (!lineNumbers) {
            continue;
          } else {
            sawLineNumbers = true;
          }
        }
        result2.push({ className: name2, style });
      }
      if (lineNumbers && !sawLineNumbers) {
        result2.push({ className: "CodeMirror-linenumbers", style: null });
      }
      return result2;
    }
    function renderGutters(display) {
      var gutters = display.gutters, specs = display.gutterSpecs;
      removeChildren(gutters);
      display.lineGutter = null;
      for (var i2 = 0; i2 < specs.length; ++i2) {
        var ref = specs[i2];
        var className = ref.className;
        var style = ref.style;
        var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
        if (style) {
          gElt.style.cssText = style;
        }
        if (className == "CodeMirror-linenumbers") {
          display.lineGutter = gElt;
          gElt.style.width = (display.lineNumWidth || 1) + "px";
        }
      }
      gutters.style.display = specs.length ? "" : "none";
      updateGutterSpace(display);
    }
    function updateGutters(cm) {
      renderGutters(cm.display);
      regChange(cm);
      alignHorizontally(cm);
    }
    function Display(place, doc, input, options) {
      var d = this;
      this.input = input;
      d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
      d.scrollbarFiller.setAttribute("cm-not-content", "true");
      d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
      d.gutterFiller.setAttribute("cm-not-content", "true");
      d.lineDiv = eltP("div", null, "CodeMirror-code");
      d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
      d.cursorDiv = elt("div", null, "CodeMirror-cursors");
      d.measure = elt("div", null, "CodeMirror-measure");
      d.lineMeasure = elt("div", null, "CodeMirror-measure");
      d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
      var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
      d.mover = elt("div", [lines], null, "position: relative");
      d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
      d.sizerWidth = null;
      d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
      d.gutters = elt("div", null, "CodeMirror-gutters");
      d.lineGutter = null;
      d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
      d.scroller.setAttribute("tabIndex", "-1");
      d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
      d.wrapper.setAttribute("translate", "no");
      if (ie2 && ie_version < 8) {
        d.gutters.style.zIndex = -1;
        d.scroller.style.paddingRight = 0;
      }
      if (!webkit && !(gecko && mobile)) {
        d.scroller.draggable = true;
      }
      if (place) {
        if (place.appendChild) {
          place.appendChild(d.wrapper);
        } else {
          place(d.wrapper);
        }
      }
      d.viewFrom = d.viewTo = doc.first;
      d.reportedViewFrom = d.reportedViewTo = doc.first;
      d.view = [];
      d.renderedView = null;
      d.externalMeasured = null;
      d.viewOffset = 0;
      d.lastWrapHeight = d.lastWrapWidth = 0;
      d.updateLineNumbers = null;
      d.nativeBarWidth = d.barHeight = d.barWidth = 0;
      d.scrollbarsClipped = false;
      d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
      d.alignWidgets = false;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.maxLine = null;
      d.maxLineLength = 0;
      d.maxLineChanged = false;
      d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
      d.shift = false;
      d.selForContextMenu = null;
      d.activeTouch = null;
      d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
      renderGutters(d);
      input.init(d);
    }
    var wheelSamples = 0, wheelPixelsPerUnit = null;
    if (ie2) {
      wheelPixelsPerUnit = -0.53;
    } else if (gecko) {
      wheelPixelsPerUnit = 15;
    } else if (chrome) {
      wheelPixelsPerUnit = -0.7;
    } else if (safari) {
      wheelPixelsPerUnit = -1 / 3;
    }
    function wheelEventDelta(e) {
      var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
      if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
        dx = e.detail;
      }
      if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
        dy = e.detail;
      } else if (dy == null) {
        dy = e.wheelDelta;
      }
      return { x: dx, y: dy };
    }
    function wheelEventPixels(e) {
      var delta2 = wheelEventDelta(e);
      delta2.x *= wheelPixelsPerUnit;
      delta2.y *= wheelPixelsPerUnit;
      return delta2;
    }
    function onScrollWheel(cm, e) {
      var delta2 = wheelEventDelta(e), dx = delta2.x, dy = delta2.y;
      var pixelsPerUnit = wheelPixelsPerUnit;
      if (e.deltaMode === 0) {
        dx = e.deltaX;
        dy = e.deltaY;
        pixelsPerUnit = 1;
      }
      var display = cm.display, scroll = display.scroller;
      var canScrollX = scroll.scrollWidth > scroll.clientWidth;
      var canScrollY = scroll.scrollHeight > scroll.clientHeight;
      if (!(dx && canScrollX || dy && canScrollY)) {
        return;
      }
      if (dy && mac && webkit) {
        outer:
          for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
            for (var i2 = 0; i2 < view.length; i2++) {
              if (view[i2].node == cur) {
                cm.display.currentWheelTarget = cur;
                break outer;
              }
            }
          }
      }
      if (dx && !gecko && !presto && pixelsPerUnit != null) {
        if (dy && canScrollY) {
          updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
        }
        setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
        if (!dy || dy && canScrollY) {
          e_preventDefault(e);
        }
        display.wheelStartX = null;
        return;
      }
      if (dy && pixelsPerUnit != null) {
        var pixels = dy * pixelsPerUnit;
        var top2 = cm.doc.scrollTop, bot2 = top2 + display.wrapper.clientHeight;
        if (pixels < 0) {
          top2 = Math.max(0, top2 + pixels - 50);
        } else {
          bot2 = Math.min(cm.doc.height, bot2 + pixels + 50);
        }
        updateDisplaySimple(cm, { top: top2, bottom: bot2 });
      }
      if (wheelSamples < 20 && e.deltaMode !== 0) {
        if (display.wheelStartX == null) {
          display.wheelStartX = scroll.scrollLeft;
          display.wheelStartY = scroll.scrollTop;
          display.wheelDX = dx;
          display.wheelDY = dy;
          setTimeout(function() {
            if (display.wheelStartX == null) {
              return;
            }
            var movedX = scroll.scrollLeft - display.wheelStartX;
            var movedY = scroll.scrollTop - display.wheelStartY;
            var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
            display.wheelStartX = display.wheelStartY = null;
            if (!sample) {
              return;
            }
            wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
            ++wheelSamples;
          }, 200);
        } else {
          display.wheelDX += dx;
          display.wheelDY += dy;
        }
      }
    }
    var Selection = function(ranges, primIndex) {
      this.ranges = ranges;
      this.primIndex = primIndex;
    };
    Selection.prototype.primary = function() {
      return this.ranges[this.primIndex];
    };
    Selection.prototype.equals = function(other) {
      if (other == this) {
        return true;
      }
      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
        return false;
      }
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        var here = this.ranges[i2], there = other.ranges[i2];
        if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
          return false;
        }
      }
      return true;
    };
    Selection.prototype.deepCopy = function() {
      var out = [];
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        out[i2] = new Range2(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
      }
      return new Selection(out, this.primIndex);
    };
    Selection.prototype.somethingSelected = function() {
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        if (!this.ranges[i2].empty()) {
          return true;
        }
      }
      return false;
    };
    Selection.prototype.contains = function(pos, end2) {
      if (!end2) {
        end2 = pos;
      }
      for (var i2 = 0; i2 < this.ranges.length; i2++) {
        var range3 = this.ranges[i2];
        if (cmp(end2, range3.from()) >= 0 && cmp(pos, range3.to()) <= 0) {
          return i2;
        }
      }
      return -1;
    };
    var Range2 = function(anchor, head) {
      this.anchor = anchor;
      this.head = head;
    };
    Range2.prototype.from = function() {
      return minPos(this.anchor, this.head);
    };
    Range2.prototype.to = function() {
      return maxPos(this.anchor, this.head);
    };
    Range2.prototype.empty = function() {
      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
    };
    function normalizeSelection(cm, ranges, primIndex) {
      var mayTouch = cm && cm.options.selectionsMayTouch;
      var prim = ranges[primIndex];
      ranges.sort(function(a, b) {
        return cmp(a.from(), b.from());
      });
      primIndex = indexOf(ranges, prim);
      for (var i2 = 1; i2 < ranges.length; i2++) {
        var cur = ranges[i2], prev = ranges[i2 - 1];
        var diff2 = cmp(prev.to(), cur.from());
        if (mayTouch && !cur.empty() ? diff2 > 0 : diff2 >= 0) {
          var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
          var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
          if (i2 <= primIndex) {
            --primIndex;
          }
          ranges.splice(--i2, 2, new Range2(inv ? to : from, inv ? from : to));
        }
      }
      return new Selection(ranges, primIndex);
    }
    function simpleSelection(anchor, head) {
      return new Selection([new Range2(anchor, head || anchor)], 0);
    }
    function changeEnd(change) {
      if (!change.text) {
        return change.to;
      }
      return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
    }
    function adjustForChange(pos, change) {
      if (cmp(pos, change.from) < 0) {
        return pos;
      }
      if (cmp(pos, change.to) <= 0) {
        return changeEnd(change);
      }
      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch2 = pos.ch;
      if (pos.line == change.to.line) {
        ch2 += changeEnd(change).ch - change.to.ch;
      }
      return Pos(line, ch2);
    }
    function computeSelAfterChange(doc, change) {
      var out = [];
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        var range3 = doc.sel.ranges[i2];
        out.push(new Range2(adjustForChange(range3.anchor, change), adjustForChange(range3.head, change)));
      }
      return normalizeSelection(doc.cm, out, doc.sel.primIndex);
    }
    function offsetPos(pos, old, nw) {
      if (pos.line == old.line) {
        return Pos(nw.line, pos.ch - old.ch + nw.ch);
      } else {
        return Pos(nw.line + (pos.line - old.line), pos.ch);
      }
    }
    function computeReplacedSel(doc, changes, hint2) {
      var out = [];
      var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
      for (var i2 = 0; i2 < changes.length; i2++) {
        var change = changes[i2];
        var from = offsetPos(change.from, oldPrev, newPrev);
        var to = offsetPos(changeEnd(change), oldPrev, newPrev);
        oldPrev = change.to;
        newPrev = to;
        if (hint2 == "around") {
          var range3 = doc.sel.ranges[i2], inv = cmp(range3.head, range3.anchor) < 0;
          out[i2] = new Range2(inv ? to : from, inv ? from : to);
        } else {
          out[i2] = new Range2(from, from);
        }
      }
      return new Selection(out, doc.sel.primIndex);
    }
    function loadMode(cm) {
      cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
      resetModeState(cm);
    }
    function resetModeState(cm) {
      cm.doc.iter(function(line) {
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
      });
      cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
      startWorker(cm, 100);
      cm.state.modeGen++;
      if (cm.curOp) {
        regChange(cm);
      }
    }
    function isWholeLineUpdate(doc, change) {
      return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
    }
    function updateDoc(doc, change, markedSpans, estimateHeight2) {
      function spansFor(n2) {
        return markedSpans ? markedSpans[n2] : null;
      }
      function update(line, text4, spans) {
        updateLine(line, text4, spans, estimateHeight2);
        signalLater(line, "change", line, change);
      }
      function linesFor(start2, end2) {
        var result2 = [];
        for (var i2 = start2; i2 < end2; ++i2) {
          result2.push(new Line(text3[i2], spansFor(i2), estimateHeight2));
        }
        return result2;
      }
      var from = change.from, to = change.to, text3 = change.text;
      var firstLine = getLine2(doc, from.line), lastLine = getLine2(doc, to.line);
      var lastText = lst(text3), lastSpans = spansFor(text3.length - 1), nlines = to.line - from.line;
      if (change.full) {
        doc.insert(0, linesFor(0, text3.length));
        doc.remove(text3.length, doc.size - text3.length);
      } else if (isWholeLineUpdate(doc, change)) {
        var added = linesFor(0, text3.length - 1);
        update(lastLine, lastLine.text, lastSpans);
        if (nlines) {
          doc.remove(from.line, nlines);
        }
        if (added.length) {
          doc.insert(from.line, added);
        }
      } else if (firstLine == lastLine) {
        if (text3.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
        } else {
          var added$1 = linesFor(1, text3.length - 1);
          added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
          update(firstLine, firstLine.text.slice(0, from.ch) + text3[0], spansFor(0));
          doc.insert(from.line + 1, added$1);
        }
      } else if (text3.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + text3[0] + lastLine.text.slice(to.ch), spansFor(0));
        doc.remove(from.line + 1, nlines);
      } else {
        update(firstLine, firstLine.text.slice(0, from.ch) + text3[0], spansFor(0));
        update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
        var added$2 = linesFor(1, text3.length - 1);
        if (nlines > 1) {
          doc.remove(from.line + 1, nlines - 1);
        }
        doc.insert(from.line + 1, added$2);
      }
      signalLater(doc, "change", doc, change);
    }
    function linkedDocs(doc, f, sharedHistOnly) {
      function propagate(doc2, skip2, sharedHist) {
        if (doc2.linked) {
          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
            var rel = doc2.linked[i2];
            if (rel.doc == skip2) {
              continue;
            }
            var shared = sharedHist && rel.sharedHist;
            if (sharedHistOnly && !shared) {
              continue;
            }
            f(rel.doc, shared);
            propagate(rel.doc, doc2, shared);
          }
        }
      }
      propagate(doc, null, true);
    }
    function attachDoc(cm, doc) {
      if (doc.cm) {
        throw new Error("This document is already in use.");
      }
      cm.doc = doc;
      doc.cm = cm;
      estimateLineHeights(cm);
      loadMode(cm);
      setDirectionClass(cm);
      cm.options.direction = doc.direction;
      if (!cm.options.lineWrapping) {
        findMaxLine(cm);
      }
      cm.options.mode = doc.modeOption;
      regChange(cm);
    }
    function setDirectionClass(cm) {
      (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
    }
    function directionChanged(cm) {
      runInOp(cm, function() {
        setDirectionClass(cm);
        regChange(cm);
      });
    }
    function History(prev) {
      this.done = [];
      this.undone = [];
      this.undoDepth = prev ? prev.undoDepth : Infinity;
      this.lastModTime = this.lastSelTime = 0;
      this.lastOp = this.lastSelOp = null;
      this.lastOrigin = this.lastSelOrigin = null;
      this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
    }
    function historyChangeFromChange(doc, change) {
      var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
      attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
      linkedDocs(doc, function(doc2) {
        return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
      }, true);
      return histChange;
    }
    function clearSelectionEvents(array) {
      while (array.length) {
        var last = lst(array);
        if (last.ranges) {
          array.pop();
        } else {
          break;
        }
      }
    }
    function lastChangeEvent(hist, force) {
      if (force) {
        clearSelectionEvents(hist.done);
        return lst(hist.done);
      } else if (hist.done.length && !lst(hist.done).ranges) {
        return lst(hist.done);
      } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
        hist.done.pop();
        return lst(hist.done);
      }
    }
    function addChangeToHistory(doc, change, selAfter, opId) {
      var hist = doc.history;
      hist.undone.length = 0;
      var time = +new Date(), cur;
      var last;
      if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
        last = lst(cur.changes);
        if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
          last.to = changeEnd(change);
        } else {
          cur.changes.push(historyChangeFromChange(doc, change));
        }
      } else {
        var before = lst(hist.done);
        if (!before || !before.ranges) {
          pushSelectionToHistory(doc.sel, hist.done);
        }
        cur = {
          changes: [historyChangeFromChange(doc, change)],
          generation: hist.generation
        };
        hist.done.push(cur);
        while (hist.done.length > hist.undoDepth) {
          hist.done.shift();
          if (!hist.done[0].ranges) {
            hist.done.shift();
          }
        }
      }
      hist.done.push(selAfter);
      hist.generation = ++hist.maxGeneration;
      hist.lastModTime = hist.lastSelTime = time;
      hist.lastOp = hist.lastSelOp = opId;
      hist.lastOrigin = hist.lastSelOrigin = change.origin;
      if (!last) {
        signal(doc, "historyAdded");
      }
    }
    function selectionEventCanBeMerged(doc, origin, prev, sel) {
      var ch2 = origin.charAt(0);
      return ch2 == "*" || ch2 == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
    }
    function addSelectionToHistory(doc, sel, opId, options) {
      var hist = doc.history, origin = options && options.origin;
      if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
        hist.done[hist.done.length - 1] = sel;
      } else {
        pushSelectionToHistory(sel, hist.done);
      }
      hist.lastSelTime = +new Date();
      hist.lastSelOrigin = origin;
      hist.lastSelOp = opId;
      if (options && options.clearRedo !== false) {
        clearSelectionEvents(hist.undone);
      }
    }
    function pushSelectionToHistory(sel, dest) {
      var top2 = lst(dest);
      if (!(top2 && top2.ranges && top2.equals(sel))) {
        dest.push(sel);
      }
    }
    function attachLocalSpans(doc, change, from, to) {
      var existing = change["spans_" + doc.id], n2 = 0;
      doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
        if (line.markedSpans) {
          (existing || (existing = change["spans_" + doc.id] = {}))[n2] = line.markedSpans;
        }
        ++n2;
      });
    }
    function removeClearedSpans(spans) {
      if (!spans) {
        return null;
      }
      var out;
      for (var i2 = 0; i2 < spans.length; ++i2) {
        if (spans[i2].marker.explicitlyCleared) {
          if (!out) {
            out = spans.slice(0, i2);
          }
        } else if (out) {
          out.push(spans[i2]);
        }
      }
      return !out ? spans : out.length ? out : null;
    }
    function getOldSpans(doc, change) {
      var found = change["spans_" + doc.id];
      if (!found) {
        return null;
      }
      var nw = [];
      for (var i2 = 0; i2 < change.text.length; ++i2) {
        nw.push(removeClearedSpans(found[i2]));
      }
      return nw;
    }
    function mergeOldSpans(doc, change) {
      var old = getOldSpans(doc, change);
      var stretched = stretchSpansOverChange(doc, change);
      if (!old) {
        return stretched;
      }
      if (!stretched) {
        return old;
      }
      for (var i2 = 0; i2 < old.length; ++i2) {
        var oldCur = old[i2], stretchCur = stretched[i2];
        if (oldCur && stretchCur) {
          spans:
            for (var j = 0; j < stretchCur.length; ++j) {
              var span = stretchCur[j];
              for (var k = 0; k < oldCur.length; ++k) {
                if (oldCur[k].marker == span.marker) {
                  continue spans;
                }
              }
              oldCur.push(span);
            }
        } else if (stretchCur) {
          old[i2] = stretchCur;
        }
      }
      return old;
    }
    function copyHistoryArray(events, newGroup, instantiateSel) {
      var copy2 = [];
      for (var i2 = 0; i2 < events.length; ++i2) {
        var event = events[i2];
        if (event.ranges) {
          copy2.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
          continue;
        }
        var changes = event.changes, newChanges = [];
        copy2.push({ changes: newChanges });
        for (var j = 0; j < changes.length; ++j) {
          var change = changes[j], m2 = void 0;
          newChanges.push({ from: change.from, to: change.to, text: change.text });
          if (newGroup) {
            for (var prop3 in change) {
              if (m2 = prop3.match(/^spans_(\d+)$/)) {
                if (indexOf(newGroup, Number(m2[1])) > -1) {
                  lst(newChanges)[prop3] = change[prop3];
                  delete change[prop3];
                }
              }
            }
          }
        }
      }
      return copy2;
    }
    function extendRange(range3, head, other, extend) {
      if (extend) {
        var anchor = range3.anchor;
        if (other) {
          var posBefore = cmp(head, anchor) < 0;
          if (posBefore != cmp(other, anchor) < 0) {
            anchor = head;
            head = other;
          } else if (posBefore != cmp(head, other) < 0) {
            head = other;
          }
        }
        return new Range2(anchor, head);
      } else {
        return new Range2(other || head, head);
      }
    }
    function extendSelection(doc, head, other, options, extend) {
      if (extend == null) {
        extend = doc.cm && (doc.cm.display.shift || doc.extend);
      }
      setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
    }
    function extendSelections(doc, heads, options) {
      var out = [];
      var extend = doc.cm && (doc.cm.display.shift || doc.extend);
      for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
        out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend);
      }
      var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
      setSelection(doc, newSel, options);
    }
    function replaceOneSelection(doc, i2, range3, options) {
      var ranges = doc.sel.ranges.slice(0);
      ranges[i2] = range3;
      setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
    }
    function setSimpleSelection(doc, anchor, head, options) {
      setSelection(doc, simpleSelection(anchor, head), options);
    }
    function filterSelectionChange(doc, sel, options) {
      var obj = {
        ranges: sel.ranges,
        update: function(ranges) {
          this.ranges = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            this.ranges[i2] = new Range2(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));
          }
        },
        origin: options && options.origin
      };
      signal(doc, "beforeSelectionChange", doc, obj);
      if (doc.cm) {
        signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
      }
      if (obj.ranges != sel.ranges) {
        return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
      } else {
        return sel;
      }
    }
    function setSelectionReplaceHistory(doc, sel, options) {
      var done = doc.history.done, last = lst(done);
      if (last && last.ranges) {
        done[done.length - 1] = sel;
        setSelectionNoUndo(doc, sel, options);
      } else {
        setSelection(doc, sel, options);
      }
    }
    function setSelection(doc, sel, options) {
      setSelectionNoUndo(doc, sel, options);
      addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
    }
    function setSelectionNoUndo(doc, sel, options) {
      if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
        sel = filterSelectionChange(doc, sel, options);
      }
      var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
      setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
      if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
        ensureCursorVisible(doc.cm);
      }
    }
    function setSelectionInner(doc, sel) {
      if (sel.equals(doc.sel)) {
        return;
      }
      doc.sel = sel;
      if (doc.cm) {
        doc.cm.curOp.updateInput = 1;
        doc.cm.curOp.selectionChanged = true;
        signalCursorActivity(doc.cm);
      }
      signalLater(doc, "cursorActivity", doc);
    }
    function reCheckSelection(doc) {
      setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
    }
    function skipAtomicInSelection(doc, sel, bias, mayClear) {
      var out;
      for (var i2 = 0; i2 < sel.ranges.length; i2++) {
        var range3 = sel.ranges[i2];
        var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];
        var newAnchor = skipAtomic(doc, range3.anchor, old && old.anchor, bias, mayClear);
        var newHead = skipAtomic(doc, range3.head, old && old.head, bias, mayClear);
        if (out || newAnchor != range3.anchor || newHead != range3.head) {
          if (!out) {
            out = sel.ranges.slice(0, i2);
          }
          out[i2] = new Range2(newAnchor, newHead);
        }
      }
      return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
    }
    function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
      var line = getLine2(doc, pos.line);
      if (line.markedSpans) {
        for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
          var sp = line.markedSpans[i2], m2 = sp.marker;
          var preventCursorLeft = "selectLeft" in m2 ? !m2.selectLeft : m2.inclusiveLeft;
          var preventCursorRight = "selectRight" in m2 ? !m2.selectRight : m2.inclusiveRight;
          if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
            if (mayClear) {
              signal(m2, "beforeCursorEnter");
              if (m2.explicitlyCleared) {
                if (!line.markedSpans) {
                  break;
                } else {
                  --i2;
                  continue;
                }
              }
            }
            if (!m2.atomic) {
              continue;
            }
            if (oldPos) {
              var near = m2.find(dir < 0 ? 1 : -1), diff2 = void 0;
              if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
              }
              if (near && near.line == pos.line && (diff2 = cmp(near, oldPos)) && (dir < 0 ? diff2 < 0 : diff2 > 0)) {
                return skipAtomicInner(doc, near, pos, dir, mayClear);
              }
            }
            var far = m2.find(dir < 0 ? -1 : 1);
            if (dir < 0 ? preventCursorLeft : preventCursorRight) {
              far = movePos(doc, far, dir, far.line == pos.line ? line : null);
            }
            return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
          }
        }
      }
      return pos;
    }
    function skipAtomic(doc, pos, oldPos, bias, mayClear) {
      var dir = bias || 1;
      var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
      if (!found) {
        doc.cantEdit = true;
        return Pos(doc.first, 0);
      }
      return found;
    }
    function movePos(doc, pos, dir, line) {
      if (dir < 0 && pos.ch == 0) {
        if (pos.line > doc.first) {
          return clipPos(doc, Pos(pos.line - 1));
        } else {
          return null;
        }
      } else if (dir > 0 && pos.ch == (line || getLine2(doc, pos.line)).text.length) {
        if (pos.line < doc.first + doc.size - 1) {
          return Pos(pos.line + 1, 0);
        } else {
          return null;
        }
      } else {
        return new Pos(pos.line, pos.ch + dir);
      }
    }
    function selectAll(cm) {
      cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
    }
    function filterChange(doc, change, update) {
      var obj = {
        canceled: false,
        from: change.from,
        to: change.to,
        text: change.text,
        origin: change.origin,
        cancel: function() {
          return obj.canceled = true;
        }
      };
      if (update) {
        obj.update = function(from, to, text3, origin) {
          if (from) {
            obj.from = clipPos(doc, from);
          }
          if (to) {
            obj.to = clipPos(doc, to);
          }
          if (text3) {
            obj.text = text3;
          }
          if (origin !== void 0) {
            obj.origin = origin;
          }
        };
      }
      signal(doc, "beforeChange", doc, obj);
      if (doc.cm) {
        signal(doc.cm, "beforeChange", doc.cm, obj);
      }
      if (obj.canceled) {
        if (doc.cm) {
          doc.cm.curOp.updateInput = 2;
        }
        return null;
      }
      return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
    }
    function makeChange(doc, change, ignoreReadOnly) {
      if (doc.cm) {
        if (!doc.cm.curOp) {
          return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
        }
        if (doc.cm.state.suppressEdits) {
          return;
        }
      }
      if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
        change = filterChange(doc, change, true);
        if (!change) {
          return;
        }
      }
      var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
      if (split) {
        for (var i2 = split.length - 1; i2 >= 0; --i2) {
          makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
        }
      } else {
        makeChangeInner(doc, change);
      }
    }
    function makeChangeInner(doc, change) {
      if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
        return;
      }
      var selAfter = computeSelAfterChange(doc, change);
      addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
      makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
      var rebased = [];
      linkedDocs(doc, function(doc2, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
          rebaseHist(doc2.history, change);
          rebased.push(doc2.history);
        }
        makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
      });
    }
    function makeChangeFromHistory(doc, type2, allowSelectionOnly) {
      var suppress = doc.cm && doc.cm.state.suppressEdits;
      if (suppress && !allowSelectionOnly) {
        return;
      }
      var hist = doc.history, event, selAfter = doc.sel;
      var source = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
      var i2 = 0;
      for (; i2 < source.length; i2++) {
        event = source[i2];
        if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
          break;
        }
      }
      if (i2 == source.length) {
        return;
      }
      hist.lastOrigin = hist.lastSelOrigin = null;
      for (; ; ) {
        event = source.pop();
        if (event.ranges) {
          pushSelectionToHistory(event, dest);
          if (allowSelectionOnly && !event.equals(doc.sel)) {
            setSelection(doc, event, { clearRedo: false });
            return;
          }
          selAfter = event;
        } else if (suppress) {
          source.push(event);
          return;
        } else {
          break;
        }
      }
      var antiChanges = [];
      pushSelectionToHistory(selAfter, dest);
      dest.push({ changes: antiChanges, generation: hist.generation });
      hist.generation = event.generation || ++hist.maxGeneration;
      var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
      var loop = function(i3) {
        var change = event.changes[i3];
        change.origin = type2;
        if (filter && !filterChange(doc, change, false)) {
          source.length = 0;
          return {};
        }
        antiChanges.push(historyChangeFromChange(doc, change));
        var after = i3 ? computeSelAfterChange(doc, change) : lst(source);
        makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
        if (!i3 && doc.cm) {
          doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
        }
        var rebased = [];
        linkedDocs(doc, function(doc2, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
            rebaseHist(doc2.history, change);
            rebased.push(doc2.history);
          }
          makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
        });
      };
      for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
        var returned = loop(i$12);
        if (returned)
          return returned.v;
      }
    }
    function shiftDoc(doc, distance) {
      if (distance == 0) {
        return;
      }
      doc.first += distance;
      doc.sel = new Selection(map2(doc.sel.ranges, function(range3) {
        return new Range2(Pos(range3.anchor.line + distance, range3.anchor.ch), Pos(range3.head.line + distance, range3.head.ch));
      }), doc.sel.primIndex);
      if (doc.cm) {
        regChange(doc.cm, doc.first, doc.first - distance, distance);
        for (var d = doc.cm.display, l2 = d.viewFrom; l2 < d.viewTo; l2++) {
          regLineChange(doc.cm, l2, "gutter");
        }
      }
    }
    function makeChangeSingleDoc(doc, change, selAfter, spans) {
      if (doc.cm && !doc.cm.curOp) {
        return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
      }
      if (change.to.line < doc.first) {
        shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
        return;
      }
      if (change.from.line > doc.lastLine()) {
        return;
      }
      if (change.from.line < doc.first) {
        var shift = change.text.length - 1 - (doc.first - change.from.line);
        shiftDoc(doc, shift);
        change = {
          from: Pos(doc.first, 0),
          to: Pos(change.to.line + shift, change.to.ch),
          text: [lst(change.text)],
          origin: change.origin
        };
      }
      var last = doc.lastLine();
      if (change.to.line > last) {
        change = {
          from: change.from,
          to: Pos(last, getLine2(doc, last).text.length),
          text: [change.text[0]],
          origin: change.origin
        };
      }
      change.removed = getBetween(doc, change.from, change.to);
      if (!selAfter) {
        selAfter = computeSelAfterChange(doc, change);
      }
      if (doc.cm) {
        makeChangeSingleDocInEditor(doc.cm, change, spans);
      } else {
        updateDoc(doc, change, spans);
      }
      setSelectionNoUndo(doc, selAfter, sel_dontScroll);
      if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
        doc.cantEdit = false;
      }
    }
    function makeChangeSingleDocInEditor(cm, change, spans) {
      var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
      var recomputeMaxLength = false, checkWidthStart = from.line;
      if (!cm.options.lineWrapping) {
        checkWidthStart = lineNo(visualLine(getLine2(doc, from.line)));
        doc.iter(checkWidthStart, to.line + 1, function(line) {
          if (line == display.maxLine) {
            recomputeMaxLength = true;
            return true;
          }
        });
      }
      if (doc.sel.contains(change.from, change.to) > -1) {
        signalCursorActivity(cm);
      }
      updateDoc(doc, change, spans, estimateHeight(cm));
      if (!cm.options.lineWrapping) {
        doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
          var len = lineLength(line);
          if (len > display.maxLineLength) {
            display.maxLine = line;
            display.maxLineLength = len;
            display.maxLineChanged = true;
            recomputeMaxLength = false;
          }
        });
        if (recomputeMaxLength) {
          cm.curOp.updateMaxLine = true;
        }
      }
      retreatFrontier(doc, from.line);
      startWorker(cm, 400);
      var lendiff = change.text.length - (to.line - from.line) - 1;
      if (change.full) {
        regChange(cm);
      } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
        regLineChange(cm, from.line, "text");
      } else {
        regChange(cm, from.line, to.line + 1, lendiff);
      }
      var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
      if (changeHandler || changesHandler) {
        var obj = {
          from,
          to,
          text: change.text,
          removed: change.removed,
          origin: change.origin
        };
        if (changeHandler) {
          signalLater(cm, "change", cm, obj);
        }
        if (changesHandler) {
          (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
        }
      }
      cm.display.selForContextMenu = null;
    }
    function replaceRange(doc, code3, from, to, origin) {
      var assign2;
      if (!to) {
        to = from;
      }
      if (cmp(to, from) < 0) {
        assign2 = [to, from], from = assign2[0], to = assign2[1];
      }
      if (typeof code3 == "string") {
        code3 = doc.splitLines(code3);
      }
      makeChange(doc, { from, to, text: code3, origin });
    }
    function rebaseHistSelSingle(pos, from, to, diff2) {
      if (to < pos.line) {
        pos.line += diff2;
      } else if (from < pos.line) {
        pos.line = from;
        pos.ch = 0;
      }
    }
    function rebaseHistArray(array, from, to, diff2) {
      for (var i2 = 0; i2 < array.length; ++i2) {
        var sub2 = array[i2], ok2 = true;
        if (sub2.ranges) {
          if (!sub2.copied) {
            sub2 = array[i2] = sub2.deepCopy();
            sub2.copied = true;
          }
          for (var j = 0; j < sub2.ranges.length; j++) {
            rebaseHistSelSingle(sub2.ranges[j].anchor, from, to, diff2);
            rebaseHistSelSingle(sub2.ranges[j].head, from, to, diff2);
          }
          continue;
        }
        for (var j$1 = 0; j$1 < sub2.changes.length; ++j$1) {
          var cur = sub2.changes[j$1];
          if (to < cur.from.line) {
            cur.from = Pos(cur.from.line + diff2, cur.from.ch);
            cur.to = Pos(cur.to.line + diff2, cur.to.ch);
          } else if (from <= cur.to.line) {
            ok2 = false;
            break;
          }
        }
        if (!ok2) {
          array.splice(0, i2 + 1);
          i2 = 0;
        }
      }
    }
    function rebaseHist(hist, change) {
      var from = change.from.line, to = change.to.line, diff2 = change.text.length - (to - from) - 1;
      rebaseHistArray(hist.done, from, to, diff2);
      rebaseHistArray(hist.undone, from, to, diff2);
    }
    function changeLine(doc, handle, changeType, op) {
      var no = handle, line = handle;
      if (typeof handle == "number") {
        line = getLine2(doc, clipLine(doc, handle));
      } else {
        no = lineNo(handle);
      }
      if (no == null) {
        return null;
      }
      if (op(line, no) && doc.cm) {
        regLineChange(doc.cm, no, changeType);
      }
      return line;
    }
    function LeafChunk(lines) {
      this.lines = lines;
      this.parent = null;
      var height = 0;
      for (var i2 = 0; i2 < lines.length; ++i2) {
        lines[i2].parent = this;
        height += lines[i2].height;
      }
      this.height = height;
    }
    LeafChunk.prototype = {
      chunkSize: function() {
        return this.lines.length;
      },
      removeInner: function(at, n2) {
        for (var i2 = at, e = at + n2; i2 < e; ++i2) {
          var line = this.lines[i2];
          this.height -= line.height;
          cleanUpLine(line);
          signalLater(line, "delete");
        }
        this.lines.splice(at, n2);
      },
      collapse: function(lines) {
        lines.push.apply(lines, this.lines);
      },
      insertInner: function(at, lines, height) {
        this.height += height;
        this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
        for (var i2 = 0; i2 < lines.length; ++i2) {
          lines[i2].parent = this;
        }
      },
      iterN: function(at, n2, op) {
        for (var e = at + n2; at < e; ++at) {
          if (op(this.lines[at])) {
            return true;
          }
        }
      }
    };
    function BranchChunk(children) {
      this.children = children;
      var size = 0, height = 0;
      for (var i2 = 0; i2 < children.length; ++i2) {
        var ch2 = children[i2];
        size += ch2.chunkSize();
        height += ch2.height;
        ch2.parent = this;
      }
      this.size = size;
      this.height = height;
      this.parent = null;
    }
    BranchChunk.prototype = {
      chunkSize: function() {
        return this.size;
      },
      removeInner: function(at, n2) {
        this.size -= n2;
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at < sz) {
            var rm = Math.min(n2, sz - at), oldHeight = child.height;
            child.removeInner(at, rm);
            this.height -= oldHeight - child.height;
            if (sz == rm) {
              this.children.splice(i2--, 1);
              child.parent = null;
            }
            if ((n2 -= rm) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
        if (this.size - n2 < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
          var lines = [];
          this.collapse(lines);
          this.children = [new LeafChunk(lines)];
          this.children[0].parent = this;
        }
      },
      collapse: function(lines) {
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          this.children[i2].collapse(lines);
        }
      },
      insertInner: function(at, lines, height) {
        this.size += lines.length;
        this.height += height;
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at <= sz) {
            child.insertInner(at, lines, height);
            if (child.lines && child.lines.length > 50) {
              var remaining = child.lines.length % 25 + 25;
              for (var pos = remaining; pos < child.lines.length; ) {
                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                child.height -= leaf.height;
                this.children.splice(++i2, 0, leaf);
                leaf.parent = this;
              }
              child.lines = child.lines.slice(0, remaining);
              this.maybeSpill();
            }
            break;
          }
          at -= sz;
        }
      },
      maybeSpill: function() {
        if (this.children.length <= 10) {
          return;
        }
        var me2 = this;
        do {
          var spilled = me2.children.splice(me2.children.length - 5, 5);
          var sibling = new BranchChunk(spilled);
          if (!me2.parent) {
            var copy2 = new BranchChunk(me2.children);
            copy2.parent = me2;
            me2.children = [copy2, sibling];
            me2 = copy2;
          } else {
            me2.size -= sibling.size;
            me2.height -= sibling.height;
            var myIndex = indexOf(me2.parent.children, me2);
            me2.parent.children.splice(myIndex + 1, 0, sibling);
          }
          sibling.parent = me2.parent;
        } while (me2.children.length > 10);
        me2.parent.maybeSpill();
      },
      iterN: function(at, n2, op) {
        for (var i2 = 0; i2 < this.children.length; ++i2) {
          var child = this.children[i2], sz = child.chunkSize();
          if (at < sz) {
            var used = Math.min(n2, sz - at);
            if (child.iterN(at, used, op)) {
              return true;
            }
            if ((n2 -= used) == 0) {
              break;
            }
            at = 0;
          } else {
            at -= sz;
          }
        }
      }
    };
    var LineWidget = function(doc, node, options) {
      if (options) {
        for (var opt2 in options) {
          if (options.hasOwnProperty(opt2)) {
            this[opt2] = options[opt2];
          }
        }
      }
      this.doc = doc;
      this.node = node;
    };
    LineWidget.prototype.clear = function() {
      var cm = this.doc.cm, ws2 = this.line.widgets, line = this.line, no = lineNo(line);
      if (no == null || !ws2) {
        return;
      }
      for (var i2 = 0; i2 < ws2.length; ++i2) {
        if (ws2[i2] == this) {
          ws2.splice(i2--, 1);
        }
      }
      if (!ws2.length) {
        line.widgets = null;
      }
      var height = widgetHeight(this);
      updateLineHeight(line, Math.max(0, line.height - height));
      if (cm) {
        runInOp(cm, function() {
          adjustScrollWhenAboveVisible(cm, line, -height);
          regLineChange(cm, no, "widget");
        });
        signalLater(cm, "lineWidgetCleared", cm, this, no);
      }
    };
    LineWidget.prototype.changed = function() {
      var this$1$1 = this;
      var oldH = this.height, cm = this.doc.cm, line = this.line;
      this.height = null;
      var diff2 = widgetHeight(this) - oldH;
      if (!diff2) {
        return;
      }
      if (!lineIsHidden(this.doc, line)) {
        updateLineHeight(line, line.height + diff2);
      }
      if (cm) {
        runInOp(cm, function() {
          cm.curOp.forceUpdate = true;
          adjustScrollWhenAboveVisible(cm, line, diff2);
          signalLater(cm, "lineWidgetChanged", cm, this$1$1, lineNo(line));
        });
      }
    };
    eventMixin(LineWidget);
    function adjustScrollWhenAboveVisible(cm, line, diff2) {
      if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
        addToScrollTop(cm, diff2);
      }
    }
    function addLineWidget(doc, handle, node, options) {
      var widget = new LineWidget(doc, node, options);
      var cm = doc.cm;
      if (cm && widget.noHScroll) {
        cm.display.alignWidgets = true;
      }
      changeLine(doc, handle, "widget", function(line) {
        var widgets = line.widgets || (line.widgets = []);
        if (widget.insertAt == null) {
          widgets.push(widget);
        } else {
          widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
        }
        widget.line = line;
        if (cm && !lineIsHidden(doc, line)) {
          var aboveVisible = heightAtLine(line) < doc.scrollTop;
          updateLineHeight(line, line.height + widgetHeight(widget));
          if (aboveVisible) {
            addToScrollTop(cm, widget.height);
          }
          cm.curOp.forceUpdate = true;
        }
        return true;
      });
      if (cm) {
        signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
      }
      return widget;
    }
    var nextMarkerId = 0;
    var TextMarker = function(doc, type2) {
      this.lines = [];
      this.type = type2;
      this.doc = doc;
      this.id = ++nextMarkerId;
    };
    TextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      var cm = this.doc.cm, withOp = cm && !cm.curOp;
      if (withOp) {
        startOperation(cm);
      }
      if (hasHandler(this, "clear")) {
        var found = this.find();
        if (found) {
          signalLater(this, "clear", found.from, found.to);
        }
      }
      var min = null, max = null;
      for (var i2 = 0; i2 < this.lines.length; ++i2) {
        var line = this.lines[i2];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (cm && !this.collapsed) {
          regLineChange(cm, lineNo(line), "text");
        } else if (cm) {
          if (span.to != null) {
            max = lineNo(line);
          }
          if (span.from != null) {
            min = lineNo(line);
          }
        }
        line.markedSpans = removeMarkedSpan(line.markedSpans, span);
        if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
          updateLineHeight(line, textHeight(cm.display));
        }
      }
      if (cm && this.collapsed && !cm.options.lineWrapping) {
        for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
          var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
          if (len > cm.display.maxLineLength) {
            cm.display.maxLine = visual;
            cm.display.maxLineLength = len;
            cm.display.maxLineChanged = true;
          }
        }
      }
      if (min != null && cm && this.collapsed) {
        regChange(cm, min, max + 1);
      }
      this.lines.length = 0;
      this.explicitlyCleared = true;
      if (this.atomic && this.doc.cantEdit) {
        this.doc.cantEdit = false;
        if (cm) {
          reCheckSelection(cm.doc);
        }
      }
      if (cm) {
        signalLater(cm, "markerCleared", cm, this, min, max);
      }
      if (withOp) {
        endOperation(cm);
      }
      if (this.parent) {
        this.parent.clear();
      }
    };
    TextMarker.prototype.find = function(side, lineObj) {
      if (side == null && this.type == "bookmark") {
        side = 1;
      }
      var from, to;
      for (var i2 = 0; i2 < this.lines.length; ++i2) {
        var line = this.lines[i2];
        var span = getMarkedSpanFor(line.markedSpans, this);
        if (span.from != null) {
          from = Pos(lineObj ? line : lineNo(line), span.from);
          if (side == -1) {
            return from;
          }
        }
        if (span.to != null) {
          to = Pos(lineObj ? line : lineNo(line), span.to);
          if (side == 1) {
            return to;
          }
        }
      }
      return from && { from, to };
    };
    TextMarker.prototype.changed = function() {
      var this$1$1 = this;
      var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
      if (!pos || !cm) {
        return;
      }
      runInOp(cm, function() {
        var line = pos.line, lineN = lineNo(pos.line);
        var view = findViewForLine(cm, lineN);
        if (view) {
          clearLineMeasurementCacheFor(view);
          cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
        }
        cm.curOp.updateMaxLine = true;
        if (!lineIsHidden(widget.doc, line) && widget.height != null) {
          var oldHeight = widget.height;
          widget.height = null;
          var dHeight = widgetHeight(widget) - oldHeight;
          if (dHeight) {
            updateLineHeight(line, line.height + dHeight);
          }
        }
        signalLater(cm, "markerChanged", cm, this$1$1);
      });
    };
    TextMarker.prototype.attachLine = function(line) {
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
          (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
        }
      }
      this.lines.push(line);
    };
    TextMarker.prototype.detachLine = function(line) {
      this.lines.splice(indexOf(this.lines, line), 1);
      if (!this.lines.length && this.doc.cm) {
        var op = this.doc.cm.curOp;
        (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
      }
    };
    eventMixin(TextMarker);
    function markText(doc, from, to, options, type2) {
      if (options && options.shared) {
        return markTextShared(doc, from, to, options, type2);
      }
      if (doc.cm && !doc.cm.curOp) {
        return operation(doc.cm, markText)(doc, from, to, options, type2);
      }
      var marker2 = new TextMarker(doc, type2), diff2 = cmp(from, to);
      if (options) {
        copyObj(options, marker2, false);
      }
      if (diff2 > 0 || diff2 == 0 && marker2.clearWhenEmpty !== false) {
        return marker2;
      }
      if (marker2.replacedWith) {
        marker2.collapsed = true;
        marker2.widgetNode = eltP("span", [marker2.replacedWith], "CodeMirror-widget");
        if (!options.handleMouseEvents) {
          marker2.widgetNode.setAttribute("cm-ignore-events", "true");
        }
        if (options.insertLeft) {
          marker2.widgetNode.insertLeft = true;
        }
      }
      if (marker2.collapsed) {
        if (conflictingCollapsedRange(doc, from.line, from, to, marker2) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker2)) {
          throw new Error("Inserting collapsed marker partially overlapping an existing one");
        }
        seeCollapsedSpans();
      }
      if (marker2.addToHistory) {
        addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
      }
      var curLine = from.line, cm = doc.cm, updateMaxLine;
      doc.iter(curLine, to.line + 1, function(line) {
        if (cm && marker2.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
          updateMaxLine = true;
        }
        if (marker2.collapsed && curLine != from.line) {
          updateLineHeight(line, 0);
        }
        addMarkedSpan(line, new MarkedSpan(marker2, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
        ++curLine;
      });
      if (marker2.collapsed) {
        doc.iter(from.line, to.line + 1, function(line) {
          if (lineIsHidden(doc, line)) {
            updateLineHeight(line, 0);
          }
        });
      }
      if (marker2.clearOnEnter) {
        on(marker2, "beforeCursorEnter", function() {
          return marker2.clear();
        });
      }
      if (marker2.readOnly) {
        seeReadOnlySpans();
        if (doc.history.done.length || doc.history.undone.length) {
          doc.clearHistory();
        }
      }
      if (marker2.collapsed) {
        marker2.id = ++nextMarkerId;
        marker2.atomic = true;
      }
      if (cm) {
        if (updateMaxLine) {
          cm.curOp.updateMaxLine = true;
        }
        if (marker2.collapsed) {
          regChange(cm, from.line, to.line + 1);
        } else if (marker2.className || marker2.startStyle || marker2.endStyle || marker2.css || marker2.attributes || marker2.title) {
          for (var i2 = from.line; i2 <= to.line; i2++) {
            regLineChange(cm, i2, "text");
          }
        }
        if (marker2.atomic) {
          reCheckSelection(cm.doc);
        }
        signalLater(cm, "markerAdded", cm, marker2);
      }
      return marker2;
    }
    var SharedTextMarker = function(markers, primary) {
      this.markers = markers;
      this.primary = primary;
      for (var i2 = 0; i2 < markers.length; ++i2) {
        markers[i2].parent = this;
      }
    };
    SharedTextMarker.prototype.clear = function() {
      if (this.explicitlyCleared) {
        return;
      }
      this.explicitlyCleared = true;
      for (var i2 = 0; i2 < this.markers.length; ++i2) {
        this.markers[i2].clear();
      }
      signalLater(this, "clear");
    };
    SharedTextMarker.prototype.find = function(side, lineObj) {
      return this.primary.find(side, lineObj);
    };
    eventMixin(SharedTextMarker);
    function markTextShared(doc, from, to, options, type2) {
      options = copyObj(options);
      options.shared = false;
      var markers = [markText(doc, from, to, options, type2)], primary = markers[0];
      var widget = options.widgetNode;
      linkedDocs(doc, function(doc2) {
        if (widget) {
          options.widgetNode = widget.cloneNode(true);
        }
        markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type2));
        for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
          if (doc2.linked[i2].isParent) {
            return;
          }
        }
        primary = lst(markers);
      });
      return new SharedTextMarker(markers, primary);
    }
    function findSharedMarkers(doc) {
      return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m2) {
        return m2.parent;
      });
    }
    function copySharedMarkers(doc, markers) {
      for (var i2 = 0; i2 < markers.length; i2++) {
        var marker2 = markers[i2], pos = marker2.find();
        var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
        if (cmp(mFrom, mTo)) {
          var subMark = markText(doc, mFrom, mTo, marker2.primary, marker2.primary.type);
          marker2.markers.push(subMark);
          subMark.parent = marker2;
        }
      }
    }
    function detachSharedMarkers(markers) {
      var loop = function(i3) {
        var marker2 = markers[i3], linked = [marker2.primary.doc];
        linkedDocs(marker2.primary.doc, function(d) {
          return linked.push(d);
        });
        for (var j = 0; j < marker2.markers.length; j++) {
          var subMarker = marker2.markers[j];
          if (indexOf(linked, subMarker.doc) == -1) {
            subMarker.parent = null;
            marker2.markers.splice(j--, 1);
          }
        }
      };
      for (var i2 = 0; i2 < markers.length; i2++)
        loop(i2);
    }
    var nextDocId = 0;
    var Doc = function(text3, mode2, firstLine, lineSep, direction) {
      if (!(this instanceof Doc)) {
        return new Doc(text3, mode2, firstLine, lineSep, direction);
      }
      if (firstLine == null) {
        firstLine = 0;
      }
      BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
      this.first = firstLine;
      this.scrollTop = this.scrollLeft = 0;
      this.cantEdit = false;
      this.cleanGeneration = 1;
      this.modeFrontier = this.highlightFrontier = firstLine;
      var start2 = Pos(firstLine, 0);
      this.sel = simpleSelection(start2);
      this.history = new History(null);
      this.id = ++nextDocId;
      this.modeOption = mode2;
      this.lineSep = lineSep;
      this.direction = direction == "rtl" ? "rtl" : "ltr";
      this.extend = false;
      if (typeof text3 == "string") {
        text3 = this.splitLines(text3);
      }
      updateDoc(this, { from: start2, to: start2, text: text3 });
      setSelection(this, simpleSelection(start2), sel_dontScroll);
    };
    Doc.prototype = createObj(BranchChunk.prototype, {
      constructor: Doc,
      iter: function(from, to, op) {
        if (op) {
          this.iterN(from - this.first, to - from, op);
        } else {
          this.iterN(this.first, this.first + this.size, from);
        }
      },
      insert: function(at, lines) {
        var height = 0;
        for (var i2 = 0; i2 < lines.length; ++i2) {
          height += lines[i2].height;
        }
        this.insertInner(at - this.first, lines, height);
      },
      remove: function(at, n2) {
        this.removeInner(at - this.first, n2);
      },
      getValue: function(lineSep) {
        var lines = getLines2(this, this.first, this.first + this.size);
        if (lineSep === false) {
          return lines;
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      setValue: docMethodOp(function(code3) {
        var top2 = Pos(this.first, 0), last = this.first + this.size - 1;
        makeChange(this, {
          from: top2,
          to: Pos(last, getLine2(this, last).text.length),
          text: this.splitLines(code3),
          origin: "setValue",
          full: true
        }, true);
        if (this.cm) {
          scrollToCoords(this.cm, 0, 0);
        }
        setSelection(this, simpleSelection(top2), sel_dontScroll);
      }),
      replaceRange: function(code3, from, to, origin) {
        from = clipPos(this, from);
        to = to ? clipPos(this, to) : from;
        replaceRange(this, code3, from, to, origin);
      },
      getRange: function(from, to, lineSep) {
        var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
        if (lineSep === false) {
          return lines;
        }
        if (lineSep === "") {
          return lines.join("");
        }
        return lines.join(lineSep || this.lineSeparator());
      },
      getLine: function(line) {
        var l2 = this.getLineHandle(line);
        return l2 && l2.text;
      },
      getLineHandle: function(line) {
        if (isLine(this, line)) {
          return getLine2(this, line);
        }
      },
      getLineNumber: function(line) {
        return lineNo(line);
      },
      getLineHandleVisualStart: function(line) {
        if (typeof line == "number") {
          line = getLine2(this, line);
        }
        return visualLine(line);
      },
      lineCount: function() {
        return this.size;
      },
      firstLine: function() {
        return this.first;
      },
      lastLine: function() {
        return this.first + this.size - 1;
      },
      clipPos: function(pos) {
        return clipPos(this, pos);
      },
      getCursor: function(start2) {
        var range3 = this.sel.primary(), pos;
        if (start2 == null || start2 == "head") {
          pos = range3.head;
        } else if (start2 == "anchor") {
          pos = range3.anchor;
        } else if (start2 == "end" || start2 == "to" || start2 === false) {
          pos = range3.to();
        } else {
          pos = range3.from();
        }
        return pos;
      },
      listSelections: function() {
        return this.sel.ranges;
      },
      somethingSelected: function() {
        return this.sel.somethingSelected();
      },
      setCursor: docMethodOp(function(line, ch2, options) {
        setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch2 || 0) : line), null, options);
      }),
      setSelection: docMethodOp(function(anchor, head, options) {
        setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
      }),
      extendSelection: docMethodOp(function(head, other, options) {
        extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
      }),
      extendSelections: docMethodOp(function(heads, options) {
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      extendSelectionsBy: docMethodOp(function(f, options) {
        var heads = map2(this.sel.ranges, f);
        extendSelections(this, clipPosArray(this, heads), options);
      }),
      setSelections: docMethodOp(function(ranges, primary, options) {
        if (!ranges.length) {
          return;
        }
        var out = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          out[i2] = new Range2(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
        }
        if (primary == null) {
          primary = Math.min(ranges.length - 1, this.sel.primIndex);
        }
        setSelection(this, normalizeSelection(this.cm, out, primary), options);
      }),
      addSelection: docMethodOp(function(anchor, head, options) {
        var ranges = this.sel.ranges.slice(0);
        ranges.push(new Range2(clipPos(this, anchor), clipPos(this, head || anchor)));
        setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
      }),
      getSelection: function(lineSep) {
        var ranges = this.sel.ranges, lines;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
          lines = lines ? lines.concat(sel) : sel;
        }
        if (lineSep === false) {
          return lines;
        } else {
          return lines.join(lineSep || this.lineSeparator());
        }
      },
      getSelections: function(lineSep) {
        var parts = [], ranges = this.sel.ranges;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
          if (lineSep !== false) {
            sel = sel.join(lineSep || this.lineSeparator());
          }
          parts[i2] = sel;
        }
        return parts;
      },
      replaceSelection: function(code3, collapse, origin) {
        var dup = [];
        for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
          dup[i2] = code3;
        }
        this.replaceSelections(dup, collapse, origin || "+input");
      },
      replaceSelections: docMethodOp(function(code3, collapse, origin) {
        var changes = [], sel = this.sel;
        for (var i2 = 0; i2 < sel.ranges.length; i2++) {
          var range3 = sel.ranges[i2];
          changes[i2] = { from: range3.from(), to: range3.to(), text: this.splitLines(code3[i2]), origin };
        }
        var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
        for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
          makeChange(this, changes[i$12]);
        }
        if (newSel) {
          setSelectionReplaceHistory(this, newSel);
        } else if (this.cm) {
          ensureCursorVisible(this.cm);
        }
      }),
      undo: docMethodOp(function() {
        makeChangeFromHistory(this, "undo");
      }),
      redo: docMethodOp(function() {
        makeChangeFromHistory(this, "redo");
      }),
      undoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "undo", true);
      }),
      redoSelection: docMethodOp(function() {
        makeChangeFromHistory(this, "redo", true);
      }),
      setExtending: function(val) {
        this.extend = val;
      },
      getExtending: function() {
        return this.extend;
      },
      historySize: function() {
        var hist = this.history, done = 0, undone = 0;
        for (var i2 = 0; i2 < hist.done.length; i2++) {
          if (!hist.done[i2].ranges) {
            ++done;
          }
        }
        for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
          if (!hist.undone[i$12].ranges) {
            ++undone;
          }
        }
        return { undo: done, redo: undone };
      },
      clearHistory: function() {
        var this$1$1 = this;
        this.history = new History(this.history);
        linkedDocs(this, function(doc) {
          return doc.history = this$1$1.history;
        }, true);
      },
      markClean: function() {
        this.cleanGeneration = this.changeGeneration(true);
      },
      changeGeneration: function(forceSplit) {
        if (forceSplit) {
          this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
        }
        return this.history.generation;
      },
      isClean: function(gen) {
        return this.history.generation == (gen || this.cleanGeneration);
      },
      getHistory: function() {
        return {
          done: copyHistoryArray(this.history.done),
          undone: copyHistoryArray(this.history.undone)
        };
      },
      setHistory: function(histData) {
        var hist = this.history = new History(this.history);
        hist.done = copyHistoryArray(histData.done.slice(0), null, true);
        hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
      },
      setGutterMarker: docMethodOp(function(line, gutterID, value) {
        return changeLine(this, line, "gutter", function(line2) {
          var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
          markers[gutterID] = value;
          if (!value && isEmpty2(markers)) {
            line2.gutterMarkers = null;
          }
          return true;
        });
      }),
      clearGutter: docMethodOp(function(gutterID) {
        var this$1$1 = this;
        this.iter(function(line) {
          if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
            changeLine(this$1$1, line, "gutter", function() {
              line.gutterMarkers[gutterID] = null;
              if (isEmpty2(line.gutterMarkers)) {
                line.gutterMarkers = null;
              }
              return true;
            });
          }
        });
      }),
      lineInfo: function(line) {
        var n2;
        if (typeof line == "number") {
          if (!isLine(this, line)) {
            return null;
          }
          n2 = line;
          line = getLine2(this, line);
          if (!line) {
            return null;
          }
        } else {
          n2 = lineNo(line);
          if (n2 == null) {
            return null;
          }
        }
        return {
          line: n2,
          handle: line,
          text: line.text,
          gutterMarkers: line.gutterMarkers,
          textClass: line.textClass,
          bgClass: line.bgClass,
          wrapClass: line.wrapClass,
          widgets: line.widgets
        };
      },
      addLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop3 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          if (!line[prop3]) {
            line[prop3] = cls;
          } else if (classTest(cls).test(line[prop3])) {
            return false;
          } else {
            line[prop3] += " " + cls;
          }
          return true;
        });
      }),
      removeLineClass: docMethodOp(function(handle, where, cls) {
        return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
          var prop3 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
          var cur = line[prop3];
          if (!cur) {
            return false;
          } else if (cls == null) {
            line[prop3] = null;
          } else {
            var found = cur.match(classTest(cls));
            if (!found) {
              return false;
            }
            var end2 = found.index + found[0].length;
            line[prop3] = cur.slice(0, found.index) + (!found.index || end2 == cur.length ? "" : " ") + cur.slice(end2) || null;
          }
          return true;
        });
      }),
      addLineWidget: docMethodOp(function(handle, node, options) {
        return addLineWidget(this, handle, node, options);
      }),
      removeLineWidget: function(widget) {
        widget.clear();
      },
      markText: function(from, to, options) {
        return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
      },
      setBookmark: function(pos, options) {
        var realOpts = {
          replacedWith: options && (options.nodeType == null ? options.widget : options),
          insertLeft: options && options.insertLeft,
          clearWhenEmpty: false,
          shared: options && options.shared,
          handleMouseEvents: options && options.handleMouseEvents
        };
        pos = clipPos(this, pos);
        return markText(this, pos, pos, realOpts, "bookmark");
      },
      findMarksAt: function(pos) {
        pos = clipPos(this, pos);
        var markers = [], spans = getLine2(this, pos.line).markedSpans;
        if (spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
              markers.push(span.marker.parent || span.marker);
            }
          }
        }
        return markers;
      },
      findMarks: function(from, to, filter) {
        from = clipPos(this, from);
        to = clipPos(this, to);
        var found = [], lineNo2 = from.line;
        this.iter(from.line, to.line + 1, function(line) {
          var spans = line.markedSpans;
          if (spans) {
            for (var i2 = 0; i2 < spans.length; i2++) {
              var span = spans[i2];
              if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                found.push(span.marker.parent || span.marker);
              }
            }
          }
          ++lineNo2;
        });
        return found;
      },
      getAllMarks: function() {
        var markers = [];
        this.iter(function(line) {
          var sps = line.markedSpans;
          if (sps) {
            for (var i2 = 0; i2 < sps.length; ++i2) {
              if (sps[i2].from != null) {
                markers.push(sps[i2].marker);
              }
            }
          }
        });
        return markers;
      },
      posFromIndex: function(off2) {
        var ch2, lineNo2 = this.first, sepSize = this.lineSeparator().length;
        this.iter(function(line) {
          var sz = line.text.length + sepSize;
          if (sz > off2) {
            ch2 = off2;
            return true;
          }
          off2 -= sz;
          ++lineNo2;
        });
        return clipPos(this, Pos(lineNo2, ch2));
      },
      indexFromPos: function(coords) {
        coords = clipPos(this, coords);
        var index = coords.ch;
        if (coords.line < this.first || coords.ch < 0) {
          return 0;
        }
        var sepSize = this.lineSeparator().length;
        this.iter(this.first, coords.line, function(line) {
          index += line.text.length + sepSize;
        });
        return index;
      },
      copy: function(copyHistory) {
        var doc = new Doc(getLines2(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
        doc.scrollTop = this.scrollTop;
        doc.scrollLeft = this.scrollLeft;
        doc.sel = this.sel;
        doc.extend = false;
        if (copyHistory) {
          doc.history.undoDepth = this.history.undoDepth;
          doc.setHistory(this.getHistory());
        }
        return doc;
      },
      linkedDoc: function(options) {
        if (!options) {
          options = {};
        }
        var from = this.first, to = this.first + this.size;
        if (options.from != null && options.from > from) {
          from = options.from;
        }
        if (options.to != null && options.to < to) {
          to = options.to;
        }
        var copy2 = new Doc(getLines2(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
        if (options.sharedHist) {
          copy2.history = this.history;
        }
        (this.linked || (this.linked = [])).push({ doc: copy2, sharedHist: options.sharedHist });
        copy2.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
        copySharedMarkers(copy2, findSharedMarkers(this));
        return copy2;
      },
      unlinkDoc: function(other) {
        if (other instanceof CodeMirror2) {
          other = other.doc;
        }
        if (this.linked) {
          for (var i2 = 0; i2 < this.linked.length; ++i2) {
            var link3 = this.linked[i2];
            if (link3.doc != other) {
              continue;
            }
            this.linked.splice(i2, 1);
            other.unlinkDoc(this);
            detachSharedMarkers(findSharedMarkers(this));
            break;
          }
        }
        if (other.history == this.history) {
          var splitIds = [other.id];
          linkedDocs(other, function(doc) {
            return splitIds.push(doc.id);
          }, true);
          other.history = new History(null);
          other.history.done = copyHistoryArray(this.history.done, splitIds);
          other.history.undone = copyHistoryArray(this.history.undone, splitIds);
        }
      },
      iterLinkedDocs: function(f) {
        linkedDocs(this, f);
      },
      getMode: function() {
        return this.mode;
      },
      getEditor: function() {
        return this.cm;
      },
      splitLines: function(str) {
        if (this.lineSep) {
          return str.split(this.lineSep);
        }
        return splitLinesAuto(str);
      },
      lineSeparator: function() {
        return this.lineSep || "\n";
      },
      setDirection: docMethodOp(function(dir) {
        if (dir != "rtl") {
          dir = "ltr";
        }
        if (dir == this.direction) {
          return;
        }
        this.direction = dir;
        this.iter(function(line) {
          return line.order = null;
        });
        if (this.cm) {
          directionChanged(this.cm);
        }
      })
    });
    Doc.prototype.eachLine = Doc.prototype.iter;
    var lastDrop = 0;
    function onDrop(e) {
      var cm = this;
      clearDragCursor(cm);
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
        return;
      }
      e_preventDefault(e);
      if (ie2) {
        lastDrop = +new Date();
      }
      var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
      if (!pos || cm.isReadOnly()) {
        return;
      }
      if (files && files.length && window.FileReader && window.File) {
        var n2 = files.length, text3 = Array(n2), read = 0;
        var markAsReadAndPasteIfAllFilesAreRead = function() {
          if (++read == n2) {
            operation(cm, function() {
              pos = clipPos(cm.doc, pos);
              var change = {
                from: pos,
                to: pos,
                text: cm.doc.splitLines(text3.filter(function(t2) {
                  return t2 != null;
                }).join(cm.doc.lineSeparator())),
                origin: "paste"
              };
              makeChange(cm.doc, change);
              setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
            })();
          }
        };
        var readTextFromFile = function(file, i3) {
          if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
            markAsReadAndPasteIfAllFilesAreRead();
            return;
          }
          var reader = new FileReader();
          reader.onerror = function() {
            return markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.onload = function() {
            var content = reader.result;
            if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            text3[i3] = content;
            markAsReadAndPasteIfAllFilesAreRead();
          };
          reader.readAsText(file);
        };
        for (var i2 = 0; i2 < files.length; i2++) {
          readTextFromFile(files[i2], i2);
        }
      } else {
        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
          cm.state.draggingText(e);
          setTimeout(function() {
            return cm.display.input.focus();
          }, 20);
          return;
        }
        try {
          var text$12 = e.dataTransfer.getData("Text");
          if (text$12) {
            var selected;
            if (cm.state.draggingText && !cm.state.draggingText.copy) {
              selected = cm.listSelections();
            }
            setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
            if (selected) {
              for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
              }
            }
            cm.replaceSelection(text$12, "around", "paste");
            cm.display.input.focus();
          }
        } catch (e$1) {
        }
      }
    }
    function onDragStart(cm, e) {
      if (ie2 && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
        e_stop(e);
        return;
      }
      if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
        return;
      }
      e.dataTransfer.setData("Text", cm.getSelection());
      e.dataTransfer.effectAllowed = "copyMove";
      if (e.dataTransfer.setDragImage && !safari) {
        var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
        img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        if (presto) {
          img.width = img.height = 1;
          cm.display.wrapper.appendChild(img);
          img._top = img.offsetTop;
        }
        e.dataTransfer.setDragImage(img, 0, 0);
        if (presto) {
          img.parentNode.removeChild(img);
        }
      }
    }
    function onDragOver(cm, e) {
      var pos = posFromMouse(cm, e);
      if (!pos) {
        return;
      }
      var frag = document.createDocumentFragment();
      drawSelectionCursor(cm, pos, frag);
      if (!cm.display.dragCursor) {
        cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
        cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
      }
      removeChildrenAndAdd(cm.display.dragCursor, frag);
    }
    function clearDragCursor(cm) {
      if (cm.display.dragCursor) {
        cm.display.lineSpace.removeChild(cm.display.dragCursor);
        cm.display.dragCursor = null;
      }
    }
    function forEachCodeMirror(f) {
      if (!document.getElementsByClassName) {
        return;
      }
      var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
      for (var i2 = 0; i2 < byClass.length; i2++) {
        var cm = byClass[i2].CodeMirror;
        if (cm) {
          editors.push(cm);
        }
      }
      if (editors.length) {
        editors[0].operation(function() {
          for (var i3 = 0; i3 < editors.length; i3++) {
            f(editors[i3]);
          }
        });
      }
    }
    var globalsRegistered = false;
    function ensureGlobalHandlers() {
      if (globalsRegistered) {
        return;
      }
      registerGlobalHandlers();
      globalsRegistered = true;
    }
    function registerGlobalHandlers() {
      var resizeTimer;
      on(window, "resize", function() {
        if (resizeTimer == null) {
          resizeTimer = setTimeout(function() {
            resizeTimer = null;
            forEachCodeMirror(onResize);
          }, 100);
        }
      });
      on(window, "blur", function() {
        return forEachCodeMirror(onBlur);
      });
    }
    function onResize(cm) {
      var d = cm.display;
      d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
      d.scrollbarsClipped = false;
      cm.setSize();
    }
    var keyNames = {
      3: "Pause",
      8: "Backspace",
      9: "Tab",
      13: "Enter",
      16: "Shift",
      17: "Ctrl",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Esc",
      32: "Space",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "Left",
      38: "Up",
      39: "Right",
      40: "Down",
      44: "PrintScrn",
      45: "Insert",
      46: "Delete",
      59: ";",
      61: "=",
      91: "Mod",
      92: "Mod",
      93: "Mod",
      106: "*",
      107: "=",
      109: "-",
      110: ".",
      111: "/",
      145: "ScrollLock",
      173: "-",
      186: ";",
      187: "=",
      188: ",",
      189: "-",
      190: ".",
      191: "/",
      192: "`",
      219: "[",
      220: "\\",
      221: "]",
      222: "'",
      224: "Mod",
      63232: "Up",
      63233: "Down",
      63234: "Left",
      63235: "Right",
      63272: "Delete",
      63273: "Home",
      63275: "End",
      63276: "PageUp",
      63277: "PageDown",
      63302: "Insert"
    };
    for (var i = 0; i < 10; i++) {
      keyNames[i + 48] = keyNames[i + 96] = String(i);
    }
    for (var i$1 = 65; i$1 <= 90; i$1++) {
      keyNames[i$1] = String.fromCharCode(i$1);
    }
    for (var i$2 = 1; i$2 <= 12; i$2++) {
      keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
    }
    var keyMap2 = {};
    keyMap2.basic = {
      "Left": "goCharLeft",
      "Right": "goCharRight",
      "Up": "goLineUp",
      "Down": "goLineDown",
      "End": "goLineEnd",
      "Home": "goLineStartSmart",
      "PageUp": "goPageUp",
      "PageDown": "goPageDown",
      "Delete": "delCharAfter",
      "Backspace": "delCharBefore",
      "Shift-Backspace": "delCharBefore",
      "Tab": "defaultTab",
      "Shift-Tab": "indentAuto",
      "Enter": "newlineAndIndent",
      "Insert": "toggleOverwrite",
      "Esc": "singleSelection"
    };
    keyMap2.pcDefault = {
      "Ctrl-A": "selectAll",
      "Ctrl-D": "deleteLine",
      "Ctrl-Z": "undo",
      "Shift-Ctrl-Z": "redo",
      "Ctrl-Y": "redo",
      "Ctrl-Home": "goDocStart",
      "Ctrl-End": "goDocEnd",
      "Ctrl-Up": "goLineUp",
      "Ctrl-Down": "goLineDown",
      "Ctrl-Left": "goGroupLeft",
      "Ctrl-Right": "goGroupRight",
      "Alt-Left": "goLineStart",
      "Alt-Right": "goLineEnd",
      "Ctrl-Backspace": "delGroupBefore",
      "Ctrl-Delete": "delGroupAfter",
      "Ctrl-S": "save",
      "Ctrl-F": "find",
      "Ctrl-G": "findNext",
      "Shift-Ctrl-G": "findPrev",
      "Shift-Ctrl-F": "replace",
      "Shift-Ctrl-R": "replaceAll",
      "Ctrl-[": "indentLess",
      "Ctrl-]": "indentMore",
      "Ctrl-U": "undoSelection",
      "Shift-Ctrl-U": "redoSelection",
      "Alt-U": "redoSelection",
      "fallthrough": "basic"
    };
    keyMap2.emacsy = {
      "Ctrl-F": "goCharRight",
      "Ctrl-B": "goCharLeft",
      "Ctrl-P": "goLineUp",
      "Ctrl-N": "goLineDown",
      "Ctrl-A": "goLineStart",
      "Ctrl-E": "goLineEnd",
      "Ctrl-V": "goPageDown",
      "Shift-Ctrl-V": "goPageUp",
      "Ctrl-D": "delCharAfter",
      "Ctrl-H": "delCharBefore",
      "Alt-Backspace": "delWordBefore",
      "Ctrl-K": "killLine",
      "Ctrl-T": "transposeChars",
      "Ctrl-O": "openLine"
    };
    keyMap2.macDefault = {
      "Cmd-A": "selectAll",
      "Cmd-D": "deleteLine",
      "Cmd-Z": "undo",
      "Shift-Cmd-Z": "redo",
      "Cmd-Y": "redo",
      "Cmd-Home": "goDocStart",
      "Cmd-Up": "goDocStart",
      "Cmd-End": "goDocEnd",
      "Cmd-Down": "goDocEnd",
      "Alt-Left": "goGroupLeft",
      "Alt-Right": "goGroupRight",
      "Cmd-Left": "goLineLeft",
      "Cmd-Right": "goLineRight",
      "Alt-Backspace": "delGroupBefore",
      "Ctrl-Alt-Backspace": "delGroupAfter",
      "Alt-Delete": "delGroupAfter",
      "Cmd-S": "save",
      "Cmd-F": "find",
      "Cmd-G": "findNext",
      "Shift-Cmd-G": "findPrev",
      "Cmd-Alt-F": "replace",
      "Shift-Cmd-Alt-F": "replaceAll",
      "Cmd-[": "indentLess",
      "Cmd-]": "indentMore",
      "Cmd-Backspace": "delWrappedLineLeft",
      "Cmd-Delete": "delWrappedLineRight",
      "Cmd-U": "undoSelection",
      "Shift-Cmd-U": "redoSelection",
      "Ctrl-Up": "goDocStart",
      "Ctrl-Down": "goDocEnd",
      "fallthrough": ["basic", "emacsy"]
    };
    keyMap2["default"] = mac ? keyMap2.macDefault : keyMap2.pcDefault;
    function normalizeKeyName(name2) {
      var parts = name2.split(/-(?!$)/);
      name2 = parts[parts.length - 1];
      var alt, ctrl, shift, cmd;
      for (var i2 = 0; i2 < parts.length - 1; i2++) {
        var mod = parts[i2];
        if (/^(cmd|meta|m)$/i.test(mod)) {
          cmd = true;
        } else if (/^a(lt)?$/i.test(mod)) {
          alt = true;
        } else if (/^(c|ctrl|control)$/i.test(mod)) {
          ctrl = true;
        } else if (/^s(hift)?$/i.test(mod)) {
          shift = true;
        } else {
          throw new Error("Unrecognized modifier name: " + mod);
        }
      }
      if (alt) {
        name2 = "Alt-" + name2;
      }
      if (ctrl) {
        name2 = "Ctrl-" + name2;
      }
      if (cmd) {
        name2 = "Cmd-" + name2;
      }
      if (shift) {
        name2 = "Shift-" + name2;
      }
      return name2;
    }
    function normalizeKeyMap(keymap) {
      var copy2 = {};
      for (var keyname in keymap) {
        if (keymap.hasOwnProperty(keyname)) {
          var value = keymap[keyname];
          if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
            continue;
          }
          if (value == "...") {
            delete keymap[keyname];
            continue;
          }
          var keys = map2(keyname.split(" "), normalizeKeyName);
          for (var i2 = 0; i2 < keys.length; i2++) {
            var val = void 0, name2 = void 0;
            if (i2 == keys.length - 1) {
              name2 = keys.join(" ");
              val = value;
            } else {
              name2 = keys.slice(0, i2 + 1).join(" ");
              val = "...";
            }
            var prev = copy2[name2];
            if (!prev) {
              copy2[name2] = val;
            } else if (prev != val) {
              throw new Error("Inconsistent bindings for " + name2);
            }
          }
          delete keymap[keyname];
        }
      }
      for (var prop3 in copy2) {
        keymap[prop3] = copy2[prop3];
      }
      return keymap;
    }
    function lookupKey(key, map3, handle, context) {
      map3 = getKeyMap(map3);
      var found = map3.call ? map3.call(key, context) : map3[key];
      if (found === false) {
        return "nothing";
      }
      if (found === "...") {
        return "multi";
      }
      if (found != null && handle(found)) {
        return "handled";
      }
      if (map3.fallthrough) {
        if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
          return lookupKey(key, map3.fallthrough, handle, context);
        }
        for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {
          var result2 = lookupKey(key, map3.fallthrough[i2], handle, context);
          if (result2) {
            return result2;
          }
        }
      }
    }
    function isModifierKey(value) {
      var name2 = typeof value == "string" ? value : keyNames[value.keyCode];
      return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
    }
    function addModifierNames(name2, event, noShift) {
      var base2 = name2;
      if (event.altKey && base2 != "Alt") {
        name2 = "Alt-" + name2;
      }
      if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != "Ctrl") {
        name2 = "Ctrl-" + name2;
      }
      if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != "Mod") {
        name2 = "Cmd-" + name2;
      }
      if (!noShift && event.shiftKey && base2 != "Shift") {
        name2 = "Shift-" + name2;
      }
      return name2;
    }
    function keyName(event, noShift) {
      if (presto && event.keyCode == 34 && event["char"]) {
        return false;
      }
      var name2 = keyNames[event.keyCode];
      if (name2 == null || event.altGraphKey) {
        return false;
      }
      if (event.keyCode == 3 && event.code) {
        name2 = event.code;
      }
      return addModifierNames(name2, event, noShift);
    }
    function getKeyMap(val) {
      return typeof val == "string" ? keyMap2[val] : val;
    }
    function deleteNearSelection(cm, compute) {
      var ranges = cm.doc.sel.ranges, kill = [];
      for (var i2 = 0; i2 < ranges.length; i2++) {
        var toKill = compute(ranges[i2]);
        while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
          var replaced = kill.pop();
          if (cmp(replaced.from, toKill.from) < 0) {
            toKill.from = replaced.from;
            break;
          }
        }
        kill.push(toKill);
      }
      runInOp(cm, function() {
        for (var i3 = kill.length - 1; i3 >= 0; i3--) {
          replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
        }
        ensureCursorVisible(cm);
      });
    }
    function moveCharLogically(line, ch2, dir) {
      var target2 = skipExtendingChars(line.text, ch2 + dir, dir);
      return target2 < 0 || target2 > line.text.length ? null : target2;
    }
    function moveLogically(line, start2, dir) {
      var ch2 = moveCharLogically(line, start2.ch, dir);
      return ch2 == null ? null : new Pos(start2.line, ch2, dir < 0 ? "after" : "before");
    }
    function endOfLine(visually, cm, lineObj, lineNo2, dir) {
      if (visually) {
        if (cm.doc.direction == "rtl") {
          dir = -dir;
        }
        var order2 = getOrder(lineObj, cm.doc.direction);
        if (order2) {
          var part2 = dir < 0 ? lst(order2) : order2[0];
          var moveInStorageOrder = dir < 0 == (part2.level == 1);
          var sticky = moveInStorageOrder ? "after" : "before";
          var ch2;
          if (part2.level > 0 || cm.doc.direction == "rtl") {
            var prep = prepareMeasureForLine(cm, lineObj);
            ch2 = dir < 0 ? lineObj.text.length - 1 : 0;
            var targetTop = measureCharPrepared(cm, prep, ch2).top;
            ch2 = findFirst(function(ch3) {
              return measureCharPrepared(cm, prep, ch3).top == targetTop;
            }, dir < 0 == (part2.level == 1) ? part2.from : part2.to - 1, ch2);
            if (sticky == "before") {
              ch2 = moveCharLogically(lineObj, ch2, 1);
            }
          } else {
            ch2 = dir < 0 ? part2.to : part2.from;
          }
          return new Pos(lineNo2, ch2, sticky);
        }
      }
      return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
    }
    function moveVisually(cm, line, start2, dir) {
      var bidi = getOrder(line, cm.doc.direction);
      if (!bidi) {
        return moveLogically(line, start2, dir);
      }
      if (start2.ch >= line.text.length) {
        start2.ch = line.text.length;
        start2.sticky = "before";
      } else if (start2.ch <= 0) {
        start2.ch = 0;
        start2.sticky = "after";
      }
      var partPos = getBidiPartAt(bidi, start2.ch, start2.sticky), part2 = bidi[partPos];
      if (cm.doc.direction == "ltr" && part2.level % 2 == 0 && (dir > 0 ? part2.to > start2.ch : part2.from < start2.ch)) {
        return moveLogically(line, start2, dir);
      }
      var mv = function(pos, dir2) {
        return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
      };
      var prep;
      var getWrappedLineExtent = function(ch3) {
        if (!cm.options.lineWrapping) {
          return { begin: 0, end: line.text.length };
        }
        prep = prep || prepareMeasureForLine(cm, line);
        return wrappedLineExtentChar(cm, line, prep, ch3);
      };
      var wrappedLineExtent2 = getWrappedLineExtent(start2.sticky == "before" ? mv(start2, -1) : start2.ch);
      if (cm.doc.direction == "rtl" || part2.level == 1) {
        var moveInStorageOrder = part2.level == 1 == dir < 0;
        var ch2 = mv(start2, moveInStorageOrder ? 1 : -1);
        if (ch2 != null && (!moveInStorageOrder ? ch2 >= part2.from && ch2 >= wrappedLineExtent2.begin : ch2 <= part2.to && ch2 <= wrappedLineExtent2.end)) {
          var sticky = moveInStorageOrder ? "before" : "after";
          return new Pos(start2.line, ch2, sticky);
        }
      }
      var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
        var getRes = function(ch4, moveInStorageOrder3) {
          return moveInStorageOrder3 ? new Pos(start2.line, mv(ch4, 1), "before") : new Pos(start2.line, ch4, "after");
        };
        for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
          var part3 = bidi[partPos2];
          var moveInStorageOrder2 = dir2 > 0 == (part3.level != 1);
          var ch3 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
          if (part3.from <= ch3 && ch3 < part3.to) {
            return getRes(ch3, moveInStorageOrder2);
          }
          ch3 = moveInStorageOrder2 ? part3.from : mv(part3.to, -1);
          if (wrappedLineExtent3.begin <= ch3 && ch3 < wrappedLineExtent3.end) {
            return getRes(ch3, moveInStorageOrder2);
          }
        }
      };
      var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
      if (res) {
        return res;
      }
      var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
      if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
        res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
        if (res) {
          return res;
        }
      }
      return null;
    }
    var commands = {
      selectAll,
      singleSelection: function(cm) {
        return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
      },
      killLine: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          if (range3.empty()) {
            var len = getLine2(cm.doc, range3.head.line).text.length;
            if (range3.head.ch == len && range3.head.line < cm.lastLine()) {
              return { from: range3.head, to: Pos(range3.head.line + 1, 0) };
            } else {
              return { from: range3.head, to: Pos(range3.head.line, len) };
            }
          } else {
            return { from: range3.from(), to: range3.to() };
          }
        });
      },
      deleteLine: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          return {
            from: Pos(range3.from().line, 0),
            to: clipPos(cm.doc, Pos(range3.to().line + 1, 0))
          };
        });
      },
      delLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          return {
            from: Pos(range3.from().line, 0),
            to: range3.from()
          };
        });
      },
      delWrappedLineLeft: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          var top2 = cm.charCoords(range3.head, "div").top + 5;
          var leftPos = cm.coordsChar({ left: 0, top: top2 }, "div");
          return { from: leftPos, to: range3.from() };
        });
      },
      delWrappedLineRight: function(cm) {
        return deleteNearSelection(cm, function(range3) {
          var top2 = cm.charCoords(range3.head, "div").top + 5;
          var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
          return { from: range3.from(), to: rightPos };
        });
      },
      undo: function(cm) {
        return cm.undo();
      },
      redo: function(cm) {
        return cm.redo();
      },
      undoSelection: function(cm) {
        return cm.undoSelection();
      },
      redoSelection: function(cm) {
        return cm.redoSelection();
      },
      goDocStart: function(cm) {
        return cm.extendSelection(Pos(cm.firstLine(), 0));
      },
      goDocEnd: function(cm) {
        return cm.extendSelection(Pos(cm.lastLine()));
      },
      goLineStart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineStart(cm, range3.head.line);
        }, { origin: "+move", bias: 1 });
      },
      goLineStartSmart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineStartSmart(cm, range3.head);
        }, { origin: "+move", bias: 1 });
      },
      goLineEnd: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          return lineEnd(cm, range3.head.line);
        }, { origin: "+move", bias: -1 });
      },
      goLineRight: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top: top2 }, "div");
        }, sel_move);
      },
      goLineLeft: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          return cm.coordsChar({ left: 0, top: top2 }, "div");
        }, sel_move);
      },
      goLineLeftSmart: function(cm) {
        return cm.extendSelectionsBy(function(range3) {
          var top2 = cm.cursorCoords(range3.head, "div").top + 5;
          var pos = cm.coordsChar({ left: 0, top: top2 }, "div");
          if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
            return lineStartSmart(cm, range3.head);
          }
          return pos;
        }, sel_move);
      },
      goLineUp: function(cm) {
        return cm.moveV(-1, "line");
      },
      goLineDown: function(cm) {
        return cm.moveV(1, "line");
      },
      goPageUp: function(cm) {
        return cm.moveV(-1, "page");
      },
      goPageDown: function(cm) {
        return cm.moveV(1, "page");
      },
      goCharLeft: function(cm) {
        return cm.moveH(-1, "char");
      },
      goCharRight: function(cm) {
        return cm.moveH(1, "char");
      },
      goColumnLeft: function(cm) {
        return cm.moveH(-1, "column");
      },
      goColumnRight: function(cm) {
        return cm.moveH(1, "column");
      },
      goWordLeft: function(cm) {
        return cm.moveH(-1, "word");
      },
      goGroupRight: function(cm) {
        return cm.moveH(1, "group");
      },
      goGroupLeft: function(cm) {
        return cm.moveH(-1, "group");
      },
      goWordRight: function(cm) {
        return cm.moveH(1, "word");
      },
      delCharBefore: function(cm) {
        return cm.deleteH(-1, "codepoint");
      },
      delCharAfter: function(cm) {
        return cm.deleteH(1, "char");
      },
      delWordBefore: function(cm) {
        return cm.deleteH(-1, "word");
      },
      delWordAfter: function(cm) {
        return cm.deleteH(1, "word");
      },
      delGroupBefore: function(cm) {
        return cm.deleteH(-1, "group");
      },
      delGroupAfter: function(cm) {
        return cm.deleteH(1, "group");
      },
      indentAuto: function(cm) {
        return cm.indentSelection("smart");
      },
      indentMore: function(cm) {
        return cm.indentSelection("add");
      },
      indentLess: function(cm) {
        return cm.indentSelection("subtract");
      },
      insertTab: function(cm) {
        return cm.replaceSelection("	");
      },
      insertSoftTab: function(cm) {
        var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var pos = ranges[i2].from();
          var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
          spaces.push(spaceStr(tabSize - col % tabSize));
        }
        cm.replaceSelections(spaces);
      },
      defaultTab: function(cm) {
        if (cm.somethingSelected()) {
          cm.indentSelection("add");
        } else {
          cm.execCommand("insertTab");
        }
      },
      transposeChars: function(cm) {
        return runInOp(cm, function() {
          var ranges = cm.listSelections(), newSel = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            if (!ranges[i2].empty()) {
              continue;
            }
            var cur = ranges[i2].head, line = getLine2(cm.doc, cur.line).text;
            if (line) {
              if (cur.ch == line.length) {
                cur = new Pos(cur.line, cur.ch - 1);
              }
              if (cur.ch > 0) {
                cur = new Pos(cur.line, cur.ch + 1);
                cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
              } else if (cur.line > cm.doc.first) {
                var prev = getLine2(cm.doc, cur.line - 1).text;
                if (prev) {
                  cur = new Pos(cur.line, 1);
                  cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                }
              }
            }
            newSel.push(new Range2(cur, cur));
          }
          cm.setSelections(newSel);
        });
      },
      newlineAndIndent: function(cm) {
        return runInOp(cm, function() {
          var sels = cm.listSelections();
          for (var i2 = sels.length - 1; i2 >= 0; i2--) {
            cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
          }
          sels = cm.listSelections();
          for (var i$12 = 0; i$12 < sels.length; i$12++) {
            cm.indentLine(sels[i$12].from().line, null, true);
          }
          ensureCursorVisible(cm);
        });
      },
      openLine: function(cm) {
        return cm.replaceSelection("\n", "start");
      },
      toggleOverwrite: function(cm) {
        return cm.toggleOverwrite();
      }
    };
    function lineStart(cm, lineN) {
      var line = getLine2(cm.doc, lineN);
      var visual = visualLine(line);
      if (visual != line) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, visual, lineN, 1);
    }
    function lineEnd(cm, lineN) {
      var line = getLine2(cm.doc, lineN);
      var visual = visualLineEnd(line);
      if (visual != line) {
        lineN = lineNo(visual);
      }
      return endOfLine(true, cm, line, lineN, -1);
    }
    function lineStartSmart(cm, pos) {
      var start2 = lineStart(cm, pos.line);
      var line = getLine2(cm.doc, start2.line);
      var order2 = getOrder(line, cm.doc.direction);
      if (!order2 || order2[0].level == 0) {
        var firstNonWS = Math.max(start2.ch, line.text.search(/\S/));
        var inWS = pos.line == start2.line && pos.ch <= firstNonWS && pos.ch;
        return Pos(start2.line, inWS ? 0 : firstNonWS, start2.sticky);
      }
      return start2;
    }
    function doHandleBinding(cm, bound, dropShift) {
      if (typeof bound == "string") {
        bound = commands[bound];
        if (!bound) {
          return false;
        }
      }
      cm.display.input.ensurePolled();
      var prevShift = cm.display.shift, done = false;
      try {
        if (cm.isReadOnly()) {
          cm.state.suppressEdits = true;
        }
        if (dropShift) {
          cm.display.shift = false;
        }
        done = bound(cm) != Pass;
      } finally {
        cm.display.shift = prevShift;
        cm.state.suppressEdits = false;
      }
      return done;
    }
    function lookupKeyForEditor(cm, name2, handle) {
      for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
        var result2 = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
        if (result2) {
          return result2;
        }
      }
      return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
    }
    var stopSeq = new Delayed();
    function dispatchKey(cm, name2, e, handle) {
      var seq = cm.state.keySeq;
      if (seq) {
        if (isModifierKey(name2)) {
          return "handled";
        }
        if (/\'$/.test(name2)) {
          cm.state.keySeq = null;
        } else {
          stopSeq.set(50, function() {
            if (cm.state.keySeq == seq) {
              cm.state.keySeq = null;
              cm.display.input.reset();
            }
          });
        }
        if (dispatchKeyInner(cm, seq + " " + name2, e, handle)) {
          return true;
        }
      }
      return dispatchKeyInner(cm, name2, e, handle);
    }
    function dispatchKeyInner(cm, name2, e, handle) {
      var result2 = lookupKeyForEditor(cm, name2, handle);
      if (result2 == "multi") {
        cm.state.keySeq = name2;
      }
      if (result2 == "handled") {
        signalLater(cm, "keyHandled", cm, name2, e);
      }
      if (result2 == "handled" || result2 == "multi") {
        e_preventDefault(e);
        restartBlink(cm);
      }
      return !!result2;
    }
    function handleKeyBinding(cm, e) {
      var name2 = keyName(e, true);
      if (!name2) {
        return false;
      }
      if (e.shiftKey && !cm.state.keySeq) {
        return dispatchKey(cm, "Shift-" + name2, e, function(b) {
          return doHandleBinding(cm, b, true);
        }) || dispatchKey(cm, name2, e, function(b) {
          if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
            return doHandleBinding(cm, b);
          }
        });
      } else {
        return dispatchKey(cm, name2, e, function(b) {
          return doHandleBinding(cm, b);
        });
      }
    }
    function handleCharBinding(cm, e, ch2) {
      return dispatchKey(cm, "'" + ch2 + "'", e, function(b) {
        return doHandleBinding(cm, b, true);
      });
    }
    var lastStoppedKey = null;
    function onKeyDown2(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      cm.curOp.focus = activeElt();
      if (signalDOMEvent(cm, e)) {
        return;
      }
      if (ie2 && ie_version < 11 && e.keyCode == 27) {
        e.returnValue = false;
      }
      var code3 = e.keyCode;
      cm.display.shift = code3 == 16 || e.shiftKey;
      var handled = handleKeyBinding(cm, e);
      if (presto) {
        lastStoppedKey = handled ? code3 : null;
        if (!handled && code3 == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
          cm.replaceSelection("", null, "cut");
        }
      }
      if (gecko && !mac && !handled && code3 == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
        document.execCommand("cut");
      }
      if (code3 == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
        showCrossHair(cm);
      }
    }
    function showCrossHair(cm) {
      var lineDiv = cm.display.lineDiv;
      addClass(lineDiv, "CodeMirror-crosshair");
      function up(e) {
        if (e.keyCode == 18 || !e.altKey) {
          rmClass(lineDiv, "CodeMirror-crosshair");
          off(document, "keyup", up);
          off(document, "mouseover", up);
        }
      }
      on(document, "keyup", up);
      on(document, "mouseover", up);
    }
    function onKeyUp(e) {
      if (e.keyCode == 16) {
        this.doc.sel.shift = false;
      }
      signalDOMEvent(this, e);
    }
    function onKeyPress(e) {
      var cm = this;
      if (e.target && e.target != cm.display.input.getField()) {
        return;
      }
      if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
        return;
      }
      var keyCode = e.keyCode, charCode = e.charCode;
      if (presto && keyCode == lastStoppedKey) {
        lastStoppedKey = null;
        e_preventDefault(e);
        return;
      }
      if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
        return;
      }
      var ch2 = String.fromCharCode(charCode == null ? keyCode : charCode);
      if (ch2 == "\b") {
        return;
      }
      if (handleCharBinding(cm, e, ch2)) {
        return;
      }
      cm.display.input.onKeyPress(e);
    }
    var DOUBLECLICK_DELAY = 400;
    var PastClick = function(time, pos, button) {
      this.time = time;
      this.pos = pos;
      this.button = button;
    };
    PastClick.prototype.compare = function(time, pos, button) {
      return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
    };
    var lastClick, lastDoubleClick;
    function clickRepeat(pos, button) {
      var now = +new Date();
      if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
        lastClick = lastDoubleClick = null;
        return "triple";
      } else if (lastClick && lastClick.compare(now, pos, button)) {
        lastDoubleClick = new PastClick(now, pos, button);
        lastClick = null;
        return "double";
      } else {
        lastClick = new PastClick(now, pos, button);
        lastDoubleClick = null;
        return "single";
      }
    }
    function onMouseDown(e) {
      var cm = this, display = cm.display;
      if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
        return;
      }
      display.input.ensurePolled();
      display.shift = e.shiftKey;
      if (eventInWidget(display, e)) {
        if (!webkit) {
          display.scroller.draggable = false;
          setTimeout(function() {
            return display.scroller.draggable = true;
          }, 100);
        }
        return;
      }
      if (clickInGutter(cm, e)) {
        return;
      }
      var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
      window.focus();
      if (button == 1 && cm.state.selectingText) {
        cm.state.selectingText(e);
      }
      if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
        return;
      }
      if (button == 1) {
        if (pos) {
          leftButtonDown(cm, pos, repeat, e);
        } else if (e_target(e) == display.scroller) {
          e_preventDefault(e);
        }
      } else if (button == 2) {
        if (pos) {
          extendSelection(cm.doc, pos);
        }
        setTimeout(function() {
          return display.input.focus();
        }, 20);
      } else if (button == 3) {
        if (captureRightClick) {
          cm.display.input.onContextMenu(e);
        } else {
          delayBlurEvent(cm);
        }
      }
    }
    function handleMappedButton(cm, button, pos, repeat, event) {
      var name2 = "Click";
      if (repeat == "double") {
        name2 = "Double" + name2;
      } else if (repeat == "triple") {
        name2 = "Triple" + name2;
      }
      name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
      return dispatchKey(cm, addModifierNames(name2, event), event, function(bound) {
        if (typeof bound == "string") {
          bound = commands[bound];
        }
        if (!bound) {
          return false;
        }
        var done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          done = bound(cm, pos) != Pass;
        } finally {
          cm.state.suppressEdits = false;
        }
        return done;
      });
    }
    function configureMouse(cm, repeat, event) {
      var option = cm.getOption("configureMouse");
      var value = option ? option(cm, repeat, event) : {};
      if (value.unit == null) {
        var rect2 = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
        value.unit = rect2 ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
      }
      if (value.extend == null || cm.doc.extend) {
        value.extend = cm.doc.extend || event.shiftKey;
      }
      if (value.addNew == null) {
        value.addNew = mac ? event.metaKey : event.ctrlKey;
      }
      if (value.moveOnDrag == null) {
        value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
      }
      return value;
    }
    function leftButtonDown(cm, pos, repeat, event) {
      if (ie2) {
        setTimeout(bind(ensureFocus, cm), 0);
      } else {
        cm.curOp.focus = activeElt();
      }
      var behavior = configureMouse(cm, repeat, event);
      var sel = cm.doc.sel, contained;
      if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
        leftButtonStartDrag(cm, event, pos, behavior);
      } else {
        leftButtonSelect(cm, event, pos, behavior);
      }
    }
    function leftButtonStartDrag(cm, event, pos, behavior) {
      var display = cm.display, moved = false;
      var dragEnd = operation(cm, function(e) {
        if (webkit) {
          display.scroller.draggable = false;
        }
        cm.state.draggingText = false;
        if (cm.state.delayingBlurEvent) {
          if (cm.hasFocus()) {
            cm.state.delayingBlurEvent = false;
          } else {
            delayBlurEvent(cm);
          }
        }
        off(display.wrapper.ownerDocument, "mouseup", dragEnd);
        off(display.wrapper.ownerDocument, "mousemove", mouseMove);
        off(display.scroller, "dragstart", dragStart);
        off(display.scroller, "drop", dragEnd);
        if (!moved) {
          e_preventDefault(e);
          if (!behavior.addNew) {
            extendSelection(cm.doc, pos, null, null, behavior.extend);
          }
          if (webkit && !safari || ie2 && ie_version == 9) {
            setTimeout(function() {
              display.wrapper.ownerDocument.body.focus({ preventScroll: true });
              display.input.focus();
            }, 20);
          } else {
            display.input.focus();
          }
        }
      });
      var mouseMove = function(e2) {
        moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
      };
      var dragStart = function() {
        return moved = true;
      };
      if (webkit) {
        display.scroller.draggable = true;
      }
      cm.state.draggingText = dragEnd;
      dragEnd.copy = !behavior.moveOnDrag;
      on(display.wrapper.ownerDocument, "mouseup", dragEnd);
      on(display.wrapper.ownerDocument, "mousemove", mouseMove);
      on(display.scroller, "dragstart", dragStart);
      on(display.scroller, "drop", dragEnd);
      cm.state.delayingBlurEvent = true;
      setTimeout(function() {
        return display.input.focus();
      }, 20);
      if (display.scroller.dragDrop) {
        display.scroller.dragDrop();
      }
    }
    function rangeForUnit(cm, pos, unit) {
      if (unit == "char") {
        return new Range2(pos, pos);
      }
      if (unit == "word") {
        return cm.findWordAt(pos);
      }
      if (unit == "line") {
        return new Range2(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
      }
      var result2 = unit(cm, pos);
      return new Range2(result2.from, result2.to);
    }
    function leftButtonSelect(cm, event, start2, behavior) {
      if (ie2) {
        delayBlurEvent(cm);
      }
      var display = cm.display, doc = cm.doc;
      e_preventDefault(event);
      var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
      if (behavior.addNew && !behavior.extend) {
        ourIndex = doc.sel.contains(start2);
        if (ourIndex > -1) {
          ourRange = ranges[ourIndex];
        } else {
          ourRange = new Range2(start2, start2);
        }
      } else {
        ourRange = doc.sel.primary();
        ourIndex = doc.sel.primIndex;
      }
      if (behavior.unit == "rectangle") {
        if (!behavior.addNew) {
          ourRange = new Range2(start2, start2);
        }
        start2 = posFromMouse(cm, event, true, true);
        ourIndex = -1;
      } else {
        var range3 = rangeForUnit(cm, start2, behavior.unit);
        if (behavior.extend) {
          ourRange = extendRange(ourRange, range3.anchor, range3.head, behavior.extend);
        } else {
          ourRange = range3;
        }
      }
      if (!behavior.addNew) {
        ourIndex = 0;
        setSelection(doc, new Selection([ourRange], 0), sel_mouse);
        startSel = doc.sel;
      } else if (ourIndex == -1) {
        ourIndex = ranges.length;
        setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
      } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
        setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
        startSel = doc.sel;
      } else {
        replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
      }
      var lastPos = start2;
      function extendTo(pos) {
        if (cmp(lastPos, pos) == 0) {
          return;
        }
        lastPos = pos;
        if (behavior.unit == "rectangle") {
          var ranges2 = [], tabSize = cm.options.tabSize;
          var startCol = countColumn(getLine2(doc, start2.line).text, start2.ch, tabSize);
          var posCol = countColumn(getLine2(doc, pos.line).text, pos.ch, tabSize);
          var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
          for (var line = Math.min(start2.line, pos.line), end2 = Math.min(cm.lastLine(), Math.max(start2.line, pos.line)); line <= end2; line++) {
            var text3 = getLine2(doc, line).text, leftPos = findColumn(text3, left, tabSize);
            if (left == right) {
              ranges2.push(new Range2(Pos(line, leftPos), Pos(line, leftPos)));
            } else if (text3.length > leftPos) {
              ranges2.push(new Range2(Pos(line, leftPos), Pos(line, findColumn(text3, right, tabSize))));
            }
          }
          if (!ranges2.length) {
            ranges2.push(new Range2(start2, start2));
          }
          setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
          cm.scrollIntoView(pos);
        } else {
          var oldRange = ourRange;
          var range4 = rangeForUnit(cm, pos, behavior.unit);
          var anchor = oldRange.anchor, head;
          if (cmp(range4.anchor, anchor) > 0) {
            head = range4.head;
            anchor = minPos(oldRange.from(), range4.anchor);
          } else {
            head = range4.anchor;
            anchor = maxPos(oldRange.to(), range4.head);
          }
          var ranges$1 = startSel.ranges.slice(0);
          ranges$1[ourIndex] = bidiSimplify(cm, new Range2(clipPos(doc, anchor), head));
          setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
        }
      }
      var editorSize = display.wrapper.getBoundingClientRect();
      var counter = 0;
      function extend(e) {
        var curCount = ++counter;
        var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
        if (!cur) {
          return;
        }
        if (cmp(cur, lastPos) != 0) {
          cm.curOp.focus = activeElt();
          extendTo(cur);
          var visible = visibleLines(display, doc);
          if (cur.line >= visible.to || cur.line < visible.from) {
            setTimeout(operation(cm, function() {
              if (counter == curCount) {
                extend(e);
              }
            }), 150);
          }
        } else {
          var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
          if (outside) {
            setTimeout(operation(cm, function() {
              if (counter != curCount) {
                return;
              }
              display.scroller.scrollTop += outside;
              extend(e);
            }), 50);
          }
        }
      }
      function done(e) {
        cm.state.selectingText = false;
        counter = Infinity;
        if (e) {
          e_preventDefault(e);
          display.input.focus();
        }
        off(display.wrapper.ownerDocument, "mousemove", move);
        off(display.wrapper.ownerDocument, "mouseup", up);
        doc.history.lastSelOrigin = null;
      }
      var move = operation(cm, function(e) {
        if (e.buttons === 0 || !e_button(e)) {
          done(e);
        } else {
          extend(e);
        }
      });
      var up = operation(cm, done);
      cm.state.selectingText = up;
      on(display.wrapper.ownerDocument, "mousemove", move);
      on(display.wrapper.ownerDocument, "mouseup", up);
    }
    function bidiSimplify(cm, range3) {
      var anchor = range3.anchor;
      var head = range3.head;
      var anchorLine = getLine2(cm.doc, anchor.line);
      if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
        return range3;
      }
      var order2 = getOrder(anchorLine);
      if (!order2) {
        return range3;
      }
      var index = getBidiPartAt(order2, anchor.ch, anchor.sticky), part2 = order2[index];
      if (part2.from != anchor.ch && part2.to != anchor.ch) {
        return range3;
      }
      var boundary = index + (part2.from == anchor.ch == (part2.level != 1) ? 0 : 1);
      if (boundary == 0 || boundary == order2.length) {
        return range3;
      }
      var leftSide;
      if (head.line != anchor.line) {
        leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
      } else {
        var headIndex = getBidiPartAt(order2, head.ch, head.sticky);
        var dir = headIndex - index || (head.ch - anchor.ch) * (part2.level == 1 ? -1 : 1);
        if (headIndex == boundary - 1 || headIndex == boundary) {
          leftSide = dir < 0;
        } else {
          leftSide = dir > 0;
        }
      }
      var usePart = order2[boundary + (leftSide ? -1 : 0)];
      var from = leftSide == (usePart.level == 1);
      var ch2 = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
      return anchor.ch == ch2 && anchor.sticky == sticky ? range3 : new Range2(new Pos(anchor.line, ch2, sticky), head);
    }
    function gutterEvent(cm, e, type2, prevent) {
      var mX, mY;
      if (e.touches) {
        mX = e.touches[0].clientX;
        mY = e.touches[0].clientY;
      } else {
        try {
          mX = e.clientX;
          mY = e.clientY;
        } catch (e$1) {
          return false;
        }
      }
      if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
        return false;
      }
      if (prevent) {
        e_preventDefault(e);
      }
      var display = cm.display;
      var lineBox = display.lineDiv.getBoundingClientRect();
      if (mY > lineBox.bottom || !hasHandler(cm, type2)) {
        return e_defaultPrevented(e);
      }
      mY -= lineBox.top - display.viewOffset;
      for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
        var g = display.gutters.childNodes[i2];
        if (g && g.getBoundingClientRect().right >= mX) {
          var line = lineAtHeight(cm.doc, mY);
          var gutter = cm.display.gutterSpecs[i2];
          signal(cm, type2, cm, line, gutter.className, e);
          return e_defaultPrevented(e);
        }
      }
    }
    function clickInGutter(cm, e) {
      return gutterEvent(cm, e, "gutterClick", true);
    }
    function onContextMenu(cm, e) {
      if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
        return;
      }
      if (signalDOMEvent(cm, e, "contextmenu")) {
        return;
      }
      if (!captureRightClick) {
        cm.display.input.onContextMenu(e);
      }
    }
    function contextMenuInGutter(cm, e) {
      if (!hasHandler(cm, "gutterContextMenu")) {
        return false;
      }
      return gutterEvent(cm, e, "gutterContextMenu", false);
    }
    function themeChanged(cm) {
      cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
      clearCaches(cm);
    }
    var Init = { toString: function() {
      return "CodeMirror.Init";
    } };
    var defaults2 = {};
    var optionHandlers = {};
    function defineOptions(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      function option(name2, deflt, handle, notOnInit) {
        CodeMirror3.defaults[name2] = deflt;
        if (handle) {
          optionHandlers2[name2] = notOnInit ? function(cm, val, old) {
            if (old != Init) {
              handle(cm, val, old);
            }
          } : handle;
        }
      }
      CodeMirror3.defineOption = option;
      CodeMirror3.Init = Init;
      option("value", "", function(cm, val) {
        return cm.setValue(val);
      }, true);
      option("mode", null, function(cm, val) {
        cm.doc.modeOption = val;
        loadMode(cm);
      }, true);
      option("indentUnit", 2, loadMode, true);
      option("indentWithTabs", false);
      option("smartIndent", true);
      option("tabSize", 4, function(cm) {
        resetModeState(cm);
        clearCaches(cm);
        regChange(cm);
      }, true);
      option("lineSeparator", null, function(cm, val) {
        cm.doc.lineSep = val;
        if (!val) {
          return;
        }
        var newBreaks = [], lineNo2 = cm.doc.first;
        cm.doc.iter(function(line) {
          for (var pos = 0; ; ) {
            var found = line.text.indexOf(val, pos);
            if (found == -1) {
              break;
            }
            pos = found + val.length;
            newBreaks.push(Pos(lineNo2, found));
          }
          lineNo2++;
        });
        for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
          replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
        }
      });
      option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
        cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
        if (old != Init) {
          cm.refresh();
        }
      });
      option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
        return cm.refresh();
      }, true);
      option("electricChars", true);
      option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
        throw new Error("inputStyle can not (yet) be changed in a running editor");
      }, true);
      option("spellcheck", false, function(cm, val) {
        return cm.getInputField().spellcheck = val;
      }, true);
      option("autocorrect", false, function(cm, val) {
        return cm.getInputField().autocorrect = val;
      }, true);
      option("autocapitalize", false, function(cm, val) {
        return cm.getInputField().autocapitalize = val;
      }, true);
      option("rtlMoveVisually", !windows);
      option("wholeLineUpdateBefore", true);
      option("theme", "default", function(cm) {
        themeChanged(cm);
        updateGutters(cm);
      }, true);
      option("keyMap", "default", function(cm, val, old) {
        var next = getKeyMap(val);
        var prev = old != Init && getKeyMap(old);
        if (prev && prev.detach) {
          prev.detach(cm, next);
        }
        if (next.attach) {
          next.attach(cm, prev || null);
        }
      });
      option("extraKeys", null);
      option("configureMouse", null);
      option("lineWrapping", false, wrappingChanged, true);
      option("gutters", [], function(cm, val) {
        cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
        updateGutters(cm);
      }, true);
      option("fixedGutter", true, function(cm, val) {
        cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
        cm.refresh();
      }, true);
      option("coverGutterNextToScrollbar", false, function(cm) {
        return updateScrollbars(cm);
      }, true);
      option("scrollbarStyle", "native", function(cm) {
        initScrollbars(cm);
        updateScrollbars(cm);
        cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
        cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
      }, true);
      option("lineNumbers", false, function(cm, val) {
        cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
        updateGutters(cm);
      }, true);
      option("firstLineNumber", 1, updateGutters, true);
      option("lineNumberFormatter", function(integer2) {
        return integer2;
      }, updateGutters, true);
      option("showCursorWhenSelecting", false, updateSelection, true);
      option("resetSelectionOnContextMenu", true);
      option("lineWiseCopyCut", true);
      option("pasteLinesPerSelection", true);
      option("selectionsMayTouch", false);
      option("readOnly", false, function(cm, val) {
        if (val == "nocursor") {
          onBlur(cm);
          cm.display.input.blur();
        }
        cm.display.input.readOnlyChanged(val);
      });
      option("screenReaderLabel", null, function(cm, val) {
        val = val === "" ? null : val;
        cm.display.input.screenReaderLabelChanged(val);
      });
      option("disableInput", false, function(cm, val) {
        if (!val) {
          cm.display.input.reset();
        }
      }, true);
      option("dragDrop", true, dragDropChanged);
      option("allowDropFileTypes", null);
      option("cursorBlinkRate", 530);
      option("cursorScrollMargin", 0);
      option("cursorHeight", 1, updateSelection, true);
      option("singleCursorHeightPerLine", true, updateSelection, true);
      option("workTime", 100);
      option("workDelay", 100);
      option("flattenSpans", true, resetModeState, true);
      option("addModeClass", false, resetModeState, true);
      option("pollInterval", 100);
      option("undoDepth", 200, function(cm, val) {
        return cm.doc.history.undoDepth = val;
      });
      option("historyEventDelay", 1250);
      option("viewportMargin", 10, function(cm) {
        return cm.refresh();
      }, true);
      option("maxHighlightLength", 1e4, resetModeState, true);
      option("moveInputWithCursor", true, function(cm, val) {
        if (!val) {
          cm.display.input.resetPosition();
        }
      });
      option("tabindex", null, function(cm, val) {
        return cm.display.input.getField().tabIndex = val || "";
      });
      option("autofocus", null);
      option("direction", "ltr", function(cm, val) {
        return cm.doc.setDirection(val);
      }, true);
      option("phrases", null);
    }
    function dragDropChanged(cm, value, old) {
      var wasOn = old && old != Init;
      if (!value != !wasOn) {
        var funcs = cm.display.dragFunctions;
        var toggle = value ? on : off;
        toggle(cm.display.scroller, "dragstart", funcs.start);
        toggle(cm.display.scroller, "dragenter", funcs.enter);
        toggle(cm.display.scroller, "dragover", funcs.over);
        toggle(cm.display.scroller, "dragleave", funcs.leave);
        toggle(cm.display.scroller, "drop", funcs.drop);
      }
    }
    function wrappingChanged(cm) {
      if (cm.options.lineWrapping) {
        addClass(cm.display.wrapper, "CodeMirror-wrap");
        cm.display.sizer.style.minWidth = "";
        cm.display.sizerWidth = null;
      } else {
        rmClass(cm.display.wrapper, "CodeMirror-wrap");
        findMaxLine(cm);
      }
      estimateLineHeights(cm);
      regChange(cm);
      clearCaches(cm);
      setTimeout(function() {
        return updateScrollbars(cm);
      }, 100);
    }
    function CodeMirror2(place, options) {
      var this$1$1 = this;
      if (!(this instanceof CodeMirror2)) {
        return new CodeMirror2(place, options);
      }
      this.options = options = options ? copyObj(options) : {};
      copyObj(defaults2, options, false);
      var doc = options.value;
      if (typeof doc == "string") {
        doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
      } else if (options.mode) {
        doc.modeOption = options.mode;
      }
      this.doc = doc;
      var input = new CodeMirror2.inputStyles[options.inputStyle](this);
      var display = this.display = new Display(place, doc, input, options);
      display.wrapper.CodeMirror = this;
      themeChanged(this);
      if (options.lineWrapping) {
        this.display.wrapper.className += " CodeMirror-wrap";
      }
      initScrollbars(this);
      this.state = {
        keyMaps: [],
        overlays: [],
        modeGen: 0,
        overwrite: false,
        delayingBlurEvent: false,
        focused: false,
        suppressEdits: false,
        pasteIncoming: -1,
        cutIncoming: -1,
        selectingText: false,
        draggingText: false,
        highlight: new Delayed(),
        keySeq: null,
        specialChars: null
      };
      if (options.autofocus && !mobile) {
        display.input.focus();
      }
      if (ie2 && ie_version < 11) {
        setTimeout(function() {
          return this$1$1.display.input.reset(true);
        }, 20);
      }
      registerEventHandlers(this);
      ensureGlobalHandlers();
      startOperation(this);
      this.curOp.forceUpdate = true;
      attachDoc(this, doc);
      if (options.autofocus && !mobile || this.hasFocus()) {
        setTimeout(function() {
          if (this$1$1.hasFocus() && !this$1$1.state.focused) {
            onFocus(this$1$1);
          }
        }, 20);
      } else {
        onBlur(this);
      }
      for (var opt2 in optionHandlers) {
        if (optionHandlers.hasOwnProperty(opt2)) {
          optionHandlers[opt2](this, options[opt2], Init);
        }
      }
      maybeUpdateLineNumberWidth(this);
      if (options.finishInit) {
        options.finishInit(this);
      }
      for (var i2 = 0; i2 < initHooks.length; ++i2) {
        initHooks[i2](this);
      }
      endOperation(this);
      if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
        display.lineDiv.style.textRendering = "auto";
      }
    }
    CodeMirror2.defaults = defaults2;
    CodeMirror2.optionHandlers = optionHandlers;
    function registerEventHandlers(cm) {
      var d = cm.display;
      on(d.scroller, "mousedown", operation(cm, onMouseDown));
      if (ie2 && ie_version < 11) {
        on(d.scroller, "dblclick", operation(cm, function(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }
          var pos = posFromMouse(cm, e);
          if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
            return;
          }
          e_preventDefault(e);
          var word2 = cm.findWordAt(pos);
          extendSelection(cm.doc, word2.anchor, word2.head);
        }));
      } else {
        on(d.scroller, "dblclick", function(e) {
          return signalDOMEvent(cm, e) || e_preventDefault(e);
        });
      }
      on(d.scroller, "contextmenu", function(e) {
        return onContextMenu(cm, e);
      });
      on(d.input.getField(), "contextmenu", function(e) {
        if (!d.scroller.contains(e.target)) {
          onContextMenu(cm, e);
        }
      });
      var touchFinished, prevTouch = { end: 0 };
      function finishTouch() {
        if (d.activeTouch) {
          touchFinished = setTimeout(function() {
            return d.activeTouch = null;
          }, 1e3);
          prevTouch = d.activeTouch;
          prevTouch.end = +new Date();
        }
      }
      function isMouseLikeTouchEvent(e) {
        if (e.touches.length != 1) {
          return false;
        }
        var touch = e.touches[0];
        return touch.radiusX <= 1 && touch.radiusY <= 1;
      }
      function farAway(touch, other) {
        if (other.left == null) {
          return true;
        }
        var dx = other.left - touch.left, dy = other.top - touch.top;
        return dx * dx + dy * dy > 20 * 20;
      }
      on(d.scroller, "touchstart", function(e) {
        if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
          d.input.ensurePolled();
          clearTimeout(touchFinished);
          var now = +new Date();
          d.activeTouch = {
            start: now,
            moved: false,
            prev: now - prevTouch.end <= 300 ? prevTouch : null
          };
          if (e.touches.length == 1) {
            d.activeTouch.left = e.touches[0].pageX;
            d.activeTouch.top = e.touches[0].pageY;
          }
        }
      });
      on(d.scroller, "touchmove", function() {
        if (d.activeTouch) {
          d.activeTouch.moved = true;
        }
      });
      on(d.scroller, "touchend", function(e) {
        var touch = d.activeTouch;
        if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
          var pos = cm.coordsChar(d.activeTouch, "page"), range3;
          if (!touch.prev || farAway(touch, touch.prev)) {
            range3 = new Range2(pos, pos);
          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
            range3 = cm.findWordAt(pos);
          } else {
            range3 = new Range2(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
          }
          cm.setSelection(range3.anchor, range3.head);
          cm.focus();
          e_preventDefault(e);
        }
        finishTouch();
      });
      on(d.scroller, "touchcancel", finishTouch);
      on(d.scroller, "scroll", function() {
        if (d.scroller.clientHeight) {
          updateScrollTop(cm, d.scroller.scrollTop);
          setScrollLeft(cm, d.scroller.scrollLeft, true);
          signal(cm, "scroll", cm);
        }
      });
      on(d.scroller, "mousewheel", function(e) {
        return onScrollWheel(cm, e);
      });
      on(d.scroller, "DOMMouseScroll", function(e) {
        return onScrollWheel(cm, e);
      });
      on(d.wrapper, "scroll", function() {
        return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
      });
      d.dragFunctions = {
        enter: function(e) {
          if (!signalDOMEvent(cm, e)) {
            e_stop(e);
          }
        },
        over: function(e) {
          if (!signalDOMEvent(cm, e)) {
            onDragOver(cm, e);
            e_stop(e);
          }
        },
        start: function(e) {
          return onDragStart(cm, e);
        },
        drop: operation(cm, onDrop),
        leave: function(e) {
          if (!signalDOMEvent(cm, e)) {
            clearDragCursor(cm);
          }
        }
      };
      var inp = d.input.getField();
      on(inp, "keyup", function(e) {
        return onKeyUp.call(cm, e);
      });
      on(inp, "keydown", operation(cm, onKeyDown2));
      on(inp, "keypress", operation(cm, onKeyPress));
      on(inp, "focus", function(e) {
        return onFocus(cm, e);
      });
      on(inp, "blur", function(e) {
        return onBlur(cm, e);
      });
    }
    var initHooks = [];
    CodeMirror2.defineInitHook = function(f) {
      return initHooks.push(f);
    };
    function indentLine(cm, n2, how, aggressive) {
      var doc = cm.doc, state;
      if (how == null) {
        how = "add";
      }
      if (how == "smart") {
        if (!doc.mode.indent) {
          how = "prev";
        } else {
          state = getContextBefore(cm, n2).state;
        }
      }
      var tabSize = cm.options.tabSize;
      var line = getLine2(doc, n2), curSpace = countColumn(line.text, null, tabSize);
      if (line.stateAfter) {
        line.stateAfter = null;
      }
      var curSpaceString = line.text.match(/^\s*/)[0], indentation;
      if (!aggressive && !/\S/.test(line.text)) {
        indentation = 0;
        how = "not";
      } else if (how == "smart") {
        indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
        if (indentation == Pass || indentation > 150) {
          if (!aggressive) {
            return;
          }
          how = "prev";
        }
      }
      if (how == "prev") {
        if (n2 > doc.first) {
          indentation = countColumn(getLine2(doc, n2 - 1).text, null, tabSize);
        } else {
          indentation = 0;
        }
      } else if (how == "add") {
        indentation = curSpace + cm.options.indentUnit;
      } else if (how == "subtract") {
        indentation = curSpace - cm.options.indentUnit;
      } else if (typeof how == "number") {
        indentation = curSpace + how;
      }
      indentation = Math.max(0, indentation);
      var indentString = "", pos = 0;
      if (cm.options.indentWithTabs) {
        for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
          pos += tabSize;
          indentString += "	";
        }
      }
      if (pos < indentation) {
        indentString += spaceStr(indentation - pos);
      }
      if (indentString != curSpaceString) {
        replaceRange(doc, indentString, Pos(n2, 0), Pos(n2, curSpaceString.length), "+input");
        line.stateAfter = null;
        return true;
      } else {
        for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
          var range3 = doc.sel.ranges[i$12];
          if (range3.head.line == n2 && range3.head.ch < curSpaceString.length) {
            var pos$1 = Pos(n2, curSpaceString.length);
            replaceOneSelection(doc, i$12, new Range2(pos$1, pos$1));
            break;
          }
        }
      }
    }
    var lastCopied = null;
    function setLastCopied(newLastCopied) {
      lastCopied = newLastCopied;
    }
    function applyTextInput(cm, inserted, deleted, sel, origin) {
      var doc = cm.doc;
      cm.display.shift = false;
      if (!sel) {
        sel = doc.sel;
      }
      var recent = +new Date() - 200;
      var paste = origin == "paste" || cm.state.pasteIncoming > recent;
      var textLines = splitLinesAuto(inserted), multiPaste = null;
      if (paste && sel.ranges.length > 1) {
        if (lastCopied && lastCopied.text.join("\n") == inserted) {
          if (sel.ranges.length % lastCopied.text.length == 0) {
            multiPaste = [];
            for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
              multiPaste.push(doc.splitLines(lastCopied.text[i2]));
            }
          }
        } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
          multiPaste = map2(textLines, function(l2) {
            return [l2];
          });
        }
      }
      var updateInput = cm.curOp.updateInput;
      for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
        var range3 = sel.ranges[i$12];
        var from = range3.from(), to = range3.to();
        if (range3.empty()) {
          if (deleted && deleted > 0) {
            from = Pos(from.line, from.ch - deleted);
          } else if (cm.state.overwrite && !paste) {
            to = Pos(to.line, Math.min(getLine2(doc, to.line).text.length, to.ch + lst(textLines).length));
          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
            from = to = Pos(from.line, 0);
          }
        }
        var changeEvent = {
          from,
          to,
          text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
          origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
        };
        makeChange(cm.doc, changeEvent);
        signalLater(cm, "inputRead", cm, changeEvent);
      }
      if (inserted && !paste) {
        triggerElectric(cm, inserted);
      }
      ensureCursorVisible(cm);
      if (cm.curOp.updateInput < 2) {
        cm.curOp.updateInput = updateInput;
      }
      cm.curOp.typing = true;
      cm.state.pasteIncoming = cm.state.cutIncoming = -1;
    }
    function handlePaste(e, cm) {
      var pasted = e.clipboardData && e.clipboardData.getData("Text");
      if (pasted) {
        e.preventDefault();
        if (!cm.isReadOnly() && !cm.options.disableInput) {
          runInOp(cm, function() {
            return applyTextInput(cm, pasted, 0, null, "paste");
          });
        }
        return true;
      }
    }
    function triggerElectric(cm, inserted) {
      if (!cm.options.electricChars || !cm.options.smartIndent) {
        return;
      }
      var sel = cm.doc.sel;
      for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
        var range3 = sel.ranges[i2];
        if (range3.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range3.head.line) {
          continue;
        }
        var mode2 = cm.getModeAt(range3.head);
        var indented = false;
        if (mode2.electricChars) {
          for (var j = 0; j < mode2.electricChars.length; j++) {
            if (inserted.indexOf(mode2.electricChars.charAt(j)) > -1) {
              indented = indentLine(cm, range3.head.line, "smart");
              break;
            }
          }
        } else if (mode2.electricInput) {
          if (mode2.electricInput.test(getLine2(cm.doc, range3.head.line).text.slice(0, range3.head.ch))) {
            indented = indentLine(cm, range3.head.line, "smart");
          }
        }
        if (indented) {
          signalLater(cm, "electricInput", cm, range3.head.line);
        }
      }
    }
    function copyableRanges(cm) {
      var text3 = [], ranges = [];
      for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
        var line = cm.doc.sel.ranges[i2].head.line;
        var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
        ranges.push(lineRange);
        text3.push(cm.getRange(lineRange.anchor, lineRange.head));
      }
      return { text: text3, ranges };
    }
    function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
      field.setAttribute("autocorrect", autocorrect ? "" : "off");
      field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
      field.setAttribute("spellcheck", !!spellcheck);
    }
    function hiddenTextarea() {
      var te2 = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
      var div2 = elt("div", [te2], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
      if (webkit) {
        te2.style.width = "1000px";
      } else {
        te2.setAttribute("wrap", "off");
      }
      if (ios) {
        te2.style.border = "1px solid black";
      }
      disableBrowserMagic(te2);
      return div2;
    }
    function addEditorMethods(CodeMirror3) {
      var optionHandlers2 = CodeMirror3.optionHandlers;
      var helpers2 = CodeMirror3.helpers = {};
      CodeMirror3.prototype = {
        constructor: CodeMirror3,
        focus: function() {
          window.focus();
          this.display.input.focus();
        },
        setOption: function(option, value) {
          var options = this.options, old = options[option];
          if (options[option] == value && option != "mode") {
            return;
          }
          options[option] = value;
          if (optionHandlers2.hasOwnProperty(option)) {
            operation(this, optionHandlers2[option])(this, value, old);
          }
          signal(this, "optionChange", this, option);
        },
        getOption: function(option) {
          return this.options[option];
        },
        getDoc: function() {
          return this.doc;
        },
        addKeyMap: function(map3, bottom2) {
          this.state.keyMaps[bottom2 ? "push" : "unshift"](getKeyMap(map3));
        },
        removeKeyMap: function(map3) {
          var maps = this.state.keyMaps;
          for (var i2 = 0; i2 < maps.length; ++i2) {
            if (maps[i2] == map3 || maps[i2].name == map3) {
              maps.splice(i2, 1);
              return true;
            }
          }
        },
        addOverlay: methodOp(function(spec, options) {
          var mode2 = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
          if (mode2.startState) {
            throw new Error("Overlays may not be stateful.");
          }
          insertSorted(this.state.overlays, {
            mode: mode2,
            modeSpec: spec,
            opaque: options && options.opaque,
            priority: options && options.priority || 0
          }, function(overlay) {
            return overlay.priority;
          });
          this.state.modeGen++;
          regChange(this);
        }),
        removeOverlay: methodOp(function(spec) {
          var overlays = this.state.overlays;
          for (var i2 = 0; i2 < overlays.length; ++i2) {
            var cur = overlays[i2].modeSpec;
            if (cur == spec || typeof spec == "string" && cur.name == spec) {
              overlays.splice(i2, 1);
              this.state.modeGen++;
              regChange(this);
              return;
            }
          }
        }),
        indentLine: methodOp(function(n2, dir, aggressive) {
          if (typeof dir != "string" && typeof dir != "number") {
            if (dir == null) {
              dir = this.options.smartIndent ? "smart" : "prev";
            } else {
              dir = dir ? "add" : "subtract";
            }
          }
          if (isLine(this.doc, n2)) {
            indentLine(this, n2, dir, aggressive);
          }
        }),
        indentSelection: methodOp(function(how) {
          var ranges = this.doc.sel.ranges, end2 = -1;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var range3 = ranges[i2];
            if (!range3.empty()) {
              var from = range3.from(), to = range3.to();
              var start2 = Math.max(end2, from.line);
              end2 = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
              for (var j = start2; j < end2; ++j) {
                indentLine(this, j, how);
              }
              var newRanges = this.doc.sel.ranges;
              if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                replaceOneSelection(this.doc, i2, new Range2(from, newRanges[i2].to()), sel_dontScroll);
              }
            } else if (range3.head.line > end2) {
              indentLine(this, range3.head.line, how, true);
              end2 = range3.head.line;
              if (i2 == this.doc.sel.primIndex) {
                ensureCursorVisible(this);
              }
            }
          }
        }),
        getTokenAt: function(pos, precise) {
          return takeToken(this, pos, precise);
        },
        getLineTokens: function(line, precise) {
          return takeToken(this, Pos(line), precise, true);
        },
        getTokenTypeAt: function(pos) {
          pos = clipPos(this.doc, pos);
          var styles2 = getLineStyles(this, getLine2(this.doc, pos.line));
          var before = 0, after = (styles2.length - 1) / 2, ch2 = pos.ch;
          var type2;
          if (ch2 == 0) {
            type2 = styles2[2];
          } else {
            for (; ; ) {
              var mid2 = before + after >> 1;
              if ((mid2 ? styles2[mid2 * 2 - 1] : 0) >= ch2) {
                after = mid2;
              } else if (styles2[mid2 * 2 + 1] < ch2) {
                before = mid2 + 1;
              } else {
                type2 = styles2[mid2 * 2 + 2];
                break;
              }
            }
          }
          var cut = type2 ? type2.indexOf("overlay ") : -1;
          return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
        },
        getModeAt: function(pos) {
          var mode2 = this.doc.mode;
          if (!mode2.innerMode) {
            return mode2;
          }
          return CodeMirror3.innerMode(mode2, this.getTokenAt(pos).state).mode;
        },
        getHelper: function(pos, type2) {
          return this.getHelpers(pos, type2)[0];
        },
        getHelpers: function(pos, type2) {
          var found = [];
          if (!helpers2.hasOwnProperty(type2)) {
            return found;
          }
          var help = helpers2[type2], mode2 = this.getModeAt(pos);
          if (typeof mode2[type2] == "string") {
            if (help[mode2[type2]]) {
              found.push(help[mode2[type2]]);
            }
          } else if (mode2[type2]) {
            for (var i2 = 0; i2 < mode2[type2].length; i2++) {
              var val = help[mode2[type2][i2]];
              if (val) {
                found.push(val);
              }
            }
          } else if (mode2.helperType && help[mode2.helperType]) {
            found.push(help[mode2.helperType]);
          } else if (help[mode2.name]) {
            found.push(help[mode2.name]);
          }
          for (var i$12 = 0; i$12 < help._global.length; i$12++) {
            var cur = help._global[i$12];
            if (cur.pred(mode2, this) && indexOf(found, cur.val) == -1) {
              found.push(cur.val);
            }
          }
          return found;
        },
        getStateAfter: function(line, precise) {
          var doc = this.doc;
          line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
          return getContextBefore(this, line + 1, precise).state;
        },
        cursorCoords: function(start2, mode2) {
          var pos, range3 = this.doc.sel.primary();
          if (start2 == null) {
            pos = range3.head;
          } else if (typeof start2 == "object") {
            pos = clipPos(this.doc, start2);
          } else {
            pos = start2 ? range3.from() : range3.to();
          }
          return cursorCoords(this, pos, mode2 || "page");
        },
        charCoords: function(pos, mode2) {
          return charCoords(this, clipPos(this.doc, pos), mode2 || "page");
        },
        coordsChar: function(coords, mode2) {
          coords = fromCoordSystem(this, coords, mode2 || "page");
          return coordsChar(this, coords.left, coords.top);
        },
        lineAtHeight: function(height, mode2) {
          height = fromCoordSystem(this, { top: height, left: 0 }, mode2 || "page").top;
          return lineAtHeight(this.doc, height + this.display.viewOffset);
        },
        heightAtLine: function(line, mode2, includeWidgets) {
          var end2 = false, lineObj;
          if (typeof line == "number") {
            var last = this.doc.first + this.doc.size - 1;
            if (line < this.doc.first) {
              line = this.doc.first;
            } else if (line > last) {
              line = last;
              end2 = true;
            }
            lineObj = getLine2(this.doc, line);
          } else {
            lineObj = line;
          }
          return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode2 || "page", includeWidgets || end2).top + (end2 ? this.doc.height - heightAtLine(lineObj) : 0);
        },
        defaultTextHeight: function() {
          return textHeight(this.display);
        },
        defaultCharWidth: function() {
          return charWidth(this.display);
        },
        getViewport: function() {
          return { from: this.display.viewFrom, to: this.display.viewTo };
        },
        addWidget: function(pos, node, scroll, vert2, horiz) {
          var display = this.display;
          pos = cursorCoords(this, clipPos(this.doc, pos));
          var top2 = pos.bottom, left = pos.left;
          node.style.position = "absolute";
          node.setAttribute("cm-ignore-events", "true");
          this.display.input.setUneditable(node);
          display.sizer.appendChild(node);
          if (vert2 == "over") {
            top2 = pos.top;
          } else if (vert2 == "above" || vert2 == "near") {
            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
            if ((vert2 == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
              top2 = pos.top - node.offsetHeight;
            } else if (pos.bottom + node.offsetHeight <= vspace) {
              top2 = pos.bottom;
            }
            if (left + node.offsetWidth > hspace) {
              left = hspace - node.offsetWidth;
            }
          }
          node.style.top = top2 + "px";
          node.style.left = node.style.right = "";
          if (horiz == "right") {
            left = display.sizer.clientWidth - node.offsetWidth;
            node.style.right = "0px";
          } else {
            if (horiz == "left") {
              left = 0;
            } else if (horiz == "middle") {
              left = (display.sizer.clientWidth - node.offsetWidth) / 2;
            }
            node.style.left = left + "px";
          }
          if (scroll) {
            scrollIntoView(this, { left, top: top2, right: left + node.offsetWidth, bottom: top2 + node.offsetHeight });
          }
        },
        triggerOnKeyDown: methodOp(onKeyDown2),
        triggerOnKeyPress: methodOp(onKeyPress),
        triggerOnKeyUp: onKeyUp,
        triggerOnMouseDown: methodOp(onMouseDown),
        execCommand: function(cmd) {
          if (commands.hasOwnProperty(cmd)) {
            return commands[cmd].call(null, this);
          }
        },
        triggerElectric: methodOp(function(text3) {
          triggerElectric(this, text3);
        }),
        findPosH: function(from, amount, unit, visually) {
          var dir = 1;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from);
          for (var i2 = 0; i2 < amount; ++i2) {
            cur = findPosH(this.doc, cur, dir, unit, visually);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveH: methodOp(function(dir, unit) {
          var this$1$1 = this;
          this.extendSelectionsBy(function(range3) {
            if (this$1$1.display.shift || this$1$1.doc.extend || range3.empty()) {
              return findPosH(this$1$1.doc, range3.head, dir, unit, this$1$1.options.rtlMoveVisually);
            } else {
              return dir < 0 ? range3.from() : range3.to();
            }
          }, sel_move);
        }),
        deleteH: methodOp(function(dir, unit) {
          var sel = this.doc.sel, doc = this.doc;
          if (sel.somethingSelected()) {
            doc.replaceSelection("", null, "+delete");
          } else {
            deleteNearSelection(this, function(range3) {
              var other = findPosH(doc, range3.head, dir, unit, false);
              return dir < 0 ? { from: other, to: range3.head } : { from: range3.head, to: other };
            });
          }
        }),
        findPosV: function(from, amount, unit, goalColumn) {
          var dir = 1, x2 = goalColumn;
          if (amount < 0) {
            dir = -1;
            amount = -amount;
          }
          var cur = clipPos(this.doc, from);
          for (var i2 = 0; i2 < amount; ++i2) {
            var coords = cursorCoords(this, cur, "div");
            if (x2 == null) {
              x2 = coords.left;
            } else {
              coords.left = x2;
            }
            cur = findPosV(this, coords, dir, unit);
            if (cur.hitSide) {
              break;
            }
          }
          return cur;
        },
        moveV: methodOp(function(dir, unit) {
          var this$1$1 = this;
          var doc = this.doc, goals = [];
          var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
          doc.extendSelectionsBy(function(range3) {
            if (collapse) {
              return dir < 0 ? range3.from() : range3.to();
            }
            var headPos = cursorCoords(this$1$1, range3.head, "div");
            if (range3.goalColumn != null) {
              headPos.left = range3.goalColumn;
            }
            goals.push(headPos.left);
            var pos = findPosV(this$1$1, headPos, dir, unit);
            if (unit == "page" && range3 == doc.sel.primary()) {
              addToScrollTop(this$1$1, charCoords(this$1$1, pos, "div").top - headPos.top);
            }
            return pos;
          }, sel_move);
          if (goals.length) {
            for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
              doc.sel.ranges[i2].goalColumn = goals[i2];
            }
          }
        }),
        findWordAt: function(pos) {
          var doc = this.doc, line = getLine2(doc, pos.line).text;
          var start2 = pos.ch, end2 = pos.ch;
          if (line) {
            var helper = this.getHelper(pos, "wordChars");
            if ((pos.sticky == "before" || end2 == line.length) && start2) {
              --start2;
            } else {
              ++end2;
            }
            var startChar = line.charAt(start2);
            var check2 = isWordChar(startChar, helper) ? function(ch2) {
              return isWordChar(ch2, helper);
            } : /\s/.test(startChar) ? function(ch2) {
              return /\s/.test(ch2);
            } : function(ch2) {
              return !/\s/.test(ch2) && !isWordChar(ch2);
            };
            while (start2 > 0 && check2(line.charAt(start2 - 1))) {
              --start2;
            }
            while (end2 < line.length && check2(line.charAt(end2))) {
              ++end2;
            }
          }
          return new Range2(Pos(pos.line, start2), Pos(pos.line, end2));
        },
        toggleOverwrite: function(value) {
          if (value != null && value == this.state.overwrite) {
            return;
          }
          if (this.state.overwrite = !this.state.overwrite) {
            addClass(this.display.cursorDiv, "CodeMirror-overwrite");
          } else {
            rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
          }
          signal(this, "overwriteToggle", this, this.state.overwrite);
        },
        hasFocus: function() {
          return this.display.input.getField() == activeElt();
        },
        isReadOnly: function() {
          return !!(this.options.readOnly || this.doc.cantEdit);
        },
        scrollTo: methodOp(function(x2, y2) {
          scrollToCoords(this, x2, y2);
        }),
        getScrollInfo: function() {
          var scroller = this.display.scroller;
          return {
            left: scroller.scrollLeft,
            top: scroller.scrollTop,
            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
            clientHeight: displayHeight(this),
            clientWidth: displayWidth(this)
          };
        },
        scrollIntoView: methodOp(function(range3, margin) {
          if (range3 == null) {
            range3 = { from: this.doc.sel.primary().head, to: null };
            if (margin == null) {
              margin = this.options.cursorScrollMargin;
            }
          } else if (typeof range3 == "number") {
            range3 = { from: Pos(range3, 0), to: null };
          } else if (range3.from == null) {
            range3 = { from: range3, to: null };
          }
          if (!range3.to) {
            range3.to = range3.from;
          }
          range3.margin = margin || 0;
          if (range3.from.line != null) {
            scrollToRange(this, range3);
          } else {
            scrollToCoordsRange(this, range3.from, range3.to, range3.margin);
          }
        }),
        setSize: methodOp(function(width, height) {
          var this$1$1 = this;
          var interpret = function(val) {
            return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
          };
          if (width != null) {
            this.display.wrapper.style.width = interpret(width);
          }
          if (height != null) {
            this.display.wrapper.style.height = interpret(height);
          }
          if (this.options.lineWrapping) {
            clearLineMeasurementCache(this);
          }
          var lineNo2 = this.display.viewFrom;
          this.doc.iter(lineNo2, this.display.viewTo, function(line) {
            if (line.widgets) {
              for (var i2 = 0; i2 < line.widgets.length; i2++) {
                if (line.widgets[i2].noHScroll) {
                  regLineChange(this$1$1, lineNo2, "widget");
                  break;
                }
              }
            }
            ++lineNo2;
          });
          this.curOp.forceUpdate = true;
          signal(this, "refresh", this);
        }),
        operation: function(f) {
          return runInOp(this, f);
        },
        startOperation: function() {
          return startOperation(this);
        },
        endOperation: function() {
          return endOperation(this);
        },
        refresh: methodOp(function() {
          var oldHeight = this.display.cachedTextHeight;
          regChange(this);
          this.curOp.forceUpdate = true;
          clearCaches(this);
          scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
          updateGutterSpace(this.display);
          if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
            estimateLineHeights(this);
          }
          signal(this, "refresh", this);
        }),
        swapDoc: methodOp(function(doc) {
          var old = this.doc;
          old.cm = null;
          if (this.state.selectingText) {
            this.state.selectingText();
          }
          attachDoc(this, doc);
          clearCaches(this);
          this.display.input.reset();
          scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
          this.curOp.forceScroll = true;
          signalLater(this, "swapDoc", this, old);
          return old;
        }),
        phrase: function(phraseText) {
          var phrases = this.options.phrases;
          return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
        },
        getInputField: function() {
          return this.display.input.getField();
        },
        getWrapperElement: function() {
          return this.display.wrapper;
        },
        getScrollerElement: function() {
          return this.display.scroller;
        },
        getGutterElement: function() {
          return this.display.gutters;
        }
      };
      eventMixin(CodeMirror3);
      CodeMirror3.registerHelper = function(type2, name2, value) {
        if (!helpers2.hasOwnProperty(type2)) {
          helpers2[type2] = CodeMirror3[type2] = { _global: [] };
        }
        helpers2[type2][name2] = value;
      };
      CodeMirror3.registerGlobalHelper = function(type2, name2, predicate, value) {
        CodeMirror3.registerHelper(type2, name2, value);
        helpers2[type2]._global.push({ pred: predicate, val: value });
      };
    }
    function findPosH(doc, pos, dir, unit, visually) {
      var oldPos = pos;
      var origDir = dir;
      var lineObj = getLine2(doc, pos.line);
      var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
      function findNextLine() {
        var l2 = pos.line + lineDir;
        if (l2 < doc.first || l2 >= doc.first + doc.size) {
          return false;
        }
        pos = new Pos(l2, pos.ch, pos.sticky);
        return lineObj = getLine2(doc, l2);
      }
      function moveOnce(boundToLine) {
        var next;
        if (unit == "codepoint") {
          var ch2 = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
          if (isNaN(ch2)) {
            next = null;
          } else {
            var astral = dir > 0 ? ch2 >= 55296 && ch2 < 56320 : ch2 >= 56320 && ch2 < 57343;
            next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
          }
        } else if (visually) {
          next = moveVisually(doc.cm, lineObj, pos, dir);
        } else {
          next = moveLogically(lineObj, pos, dir);
        }
        if (next == null) {
          if (!boundToLine && findNextLine()) {
            pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
          } else {
            return false;
          }
        } else {
          pos = next;
        }
        return true;
      }
      if (unit == "char" || unit == "codepoint") {
        moveOnce();
      } else if (unit == "column") {
        moveOnce(true);
      } else if (unit == "word" || unit == "group") {
        var sawType = null, group = unit == "group";
        var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
        for (var first = true; ; first = false) {
          if (dir < 0 && !moveOnce(!first)) {
            break;
          }
          var cur = lineObj.text.charAt(pos.ch) || "\n";
          var type2 = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
          if (group && !first && !type2) {
            type2 = "s";
          }
          if (sawType && sawType != type2) {
            if (dir < 0) {
              dir = 1;
              moveOnce();
              pos.sticky = "after";
            }
            break;
          }
          if (type2) {
            sawType = type2;
          }
          if (dir > 0 && !moveOnce(!first)) {
            break;
          }
        }
      }
      var result2 = skipAtomic(doc, pos, oldPos, origDir, true);
      if (equalCursorPos(oldPos, result2)) {
        result2.hitSide = true;
      }
      return result2;
    }
    function findPosV(cm, pos, dir, unit) {
      var doc = cm.doc, x2 = pos.left, y2;
      if (unit == "page") {
        var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
        var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
        y2 = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
      } else if (unit == "line") {
        y2 = dir > 0 ? pos.bottom + 3 : pos.top - 3;
      }
      var target2;
      for (; ; ) {
        target2 = coordsChar(cm, x2, y2);
        if (!target2.outside) {
          break;
        }
        if (dir < 0 ? y2 <= 0 : y2 >= doc.height) {
          target2.hitSide = true;
          break;
        }
        y2 += dir * 5;
      }
      return target2;
    }
    var ContentEditableInput = function(cm) {
      this.cm = cm;
      this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
      this.polling = new Delayed();
      this.composing = null;
      this.gracePeriod = false;
      this.readDOMTimeout = null;
    };
    ContentEditableInput.prototype.init = function(display) {
      var this$1$1 = this;
      var input = this, cm = input.cm;
      var div2 = input.div = display.lineDiv;
      div2.contentEditable = true;
      disableBrowserMagic(div2, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
      function belongsToInput(e) {
        for (var t2 = e.target; t2; t2 = t2.parentNode) {
          if (t2 == div2) {
            return true;
          }
          if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
            break;
          }
        }
        return false;
      }
      on(div2, "paste", function(e) {
        if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
          return;
        }
        if (ie_version <= 11) {
          setTimeout(operation(cm, function() {
            return this$1$1.updateFromDOM();
          }), 20);
        }
      });
      on(div2, "compositionstart", function(e) {
        this$1$1.composing = { data: e.data, done: false };
      });
      on(div2, "compositionupdate", function(e) {
        if (!this$1$1.composing) {
          this$1$1.composing = { data: e.data, done: false };
        }
      });
      on(div2, "compositionend", function(e) {
        if (this$1$1.composing) {
          if (e.data != this$1$1.composing.data) {
            this$1$1.readFromDOMSoon();
          }
          this$1$1.composing.done = true;
        }
      });
      on(div2, "touchstart", function() {
        return input.forceCompositionEnd();
      });
      on(div2, "input", function() {
        if (!this$1$1.composing) {
          this$1$1.readFromDOMSoon();
        }
      });
      function onCopyCut(e) {
        if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
          if (e.type == "cut") {
            cm.replaceSelection("", null, "cut");
          }
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.operation(function() {
              cm.setSelections(ranges.ranges, 0, sel_dontScroll);
              cm.replaceSelection("", null, "cut");
            });
          }
        }
        if (e.clipboardData) {
          e.clipboardData.clearData();
          var content = lastCopied.text.join("\n");
          e.clipboardData.setData("Text", content);
          if (e.clipboardData.getData("Text") == content) {
            e.preventDefault();
            return;
          }
        }
        var kludge = hiddenTextarea(), te2 = kludge.firstChild;
        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
        te2.value = lastCopied.text.join("\n");
        var hadFocus = activeElt();
        selectInput(te2);
        setTimeout(function() {
          cm.display.lineSpace.removeChild(kludge);
          hadFocus.focus();
          if (hadFocus == div2) {
            input.showPrimarySelection();
          }
        }, 50);
      }
      on(div2, "copy", onCopyCut);
      on(div2, "cut", onCopyCut);
    };
    ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.div.setAttribute("aria-label", label);
      } else {
        this.div.removeAttribute("aria-label");
      }
    };
    ContentEditableInput.prototype.prepareSelection = function() {
      var result2 = prepareSelection(this.cm, false);
      result2.focus = activeElt() == this.div;
      return result2;
    };
    ContentEditableInput.prototype.showSelection = function(info2, takeFocus) {
      if (!info2 || !this.cm.display.view.length) {
        return;
      }
      if (info2.focus || takeFocus) {
        this.showPrimarySelection();
      }
      this.showMultipleSelections(info2);
    };
    ContentEditableInput.prototype.getSelection = function() {
      return this.cm.display.wrapper.ownerDocument.getSelection();
    };
    ContentEditableInput.prototype.showPrimarySelection = function() {
      var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
      var from = prim.from(), to = prim.to();
      if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
        sel.removeAllRanges();
        return;
      }
      var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
        return;
      }
      var view = cm.display.view;
      var start2 = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
      var end2 = to.line < cm.display.viewTo && posToDOM(cm, to);
      if (!end2) {
        var measure = view[view.length - 1].measure;
        var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
        end2 = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
      }
      if (!start2 || !end2) {
        sel.removeAllRanges();
        return;
      }
      var old = sel.rangeCount && sel.getRangeAt(0), rng;
      try {
        rng = range2(start2.node, start2.offset, end2.offset, end2.node);
      } catch (e) {
      }
      if (rng) {
        if (!gecko && cm.state.focused) {
          sel.collapse(start2.node, start2.offset);
          if (!rng.collapsed) {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
        } else {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
        if (old && sel.anchorNode == null) {
          sel.addRange(old);
        } else if (gecko) {
          this.startGracePeriod();
        }
      }
      this.rememberSelection();
    };
    ContentEditableInput.prototype.startGracePeriod = function() {
      var this$1$1 = this;
      clearTimeout(this.gracePeriod);
      this.gracePeriod = setTimeout(function() {
        this$1$1.gracePeriod = false;
        if (this$1$1.selectionChanged()) {
          this$1$1.cm.operation(function() {
            return this$1$1.cm.curOp.selectionChanged = true;
          });
        }
      }, 20);
    };
    ContentEditableInput.prototype.showMultipleSelections = function(info2) {
      removeChildrenAndAdd(this.cm.display.cursorDiv, info2.cursors);
      removeChildrenAndAdd(this.cm.display.selectionDiv, info2.selection);
    };
    ContentEditableInput.prototype.rememberSelection = function() {
      var sel = this.getSelection();
      this.lastAnchorNode = sel.anchorNode;
      this.lastAnchorOffset = sel.anchorOffset;
      this.lastFocusNode = sel.focusNode;
      this.lastFocusOffset = sel.focusOffset;
    };
    ContentEditableInput.prototype.selectionInEditor = function() {
      var sel = this.getSelection();
      if (!sel.rangeCount) {
        return false;
      }
      var node = sel.getRangeAt(0).commonAncestorContainer;
      return contains(this.div, node);
    };
    ContentEditableInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor") {
        if (!this.selectionInEditor() || activeElt() != this.div) {
          this.showSelection(this.prepareSelection(), true);
        }
        this.div.focus();
      }
    };
    ContentEditableInput.prototype.blur = function() {
      this.div.blur();
    };
    ContentEditableInput.prototype.getField = function() {
      return this.div;
    };
    ContentEditableInput.prototype.supportsTouch = function() {
      return true;
    };
    ContentEditableInput.prototype.receivedFocus = function() {
      var this$1$1 = this;
      var input = this;
      if (this.selectionInEditor()) {
        setTimeout(function() {
          return this$1$1.pollSelection();
        }, 20);
      } else {
        runInOp(this.cm, function() {
          return input.cm.curOp.selectionChanged = true;
        });
      }
      function poll() {
        if (input.cm.state.focused) {
          input.pollSelection();
          input.polling.set(input.cm.options.pollInterval, poll);
        }
      }
      this.polling.set(this.cm.options.pollInterval, poll);
    };
    ContentEditableInput.prototype.selectionChanged = function() {
      var sel = this.getSelection();
      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
    };
    ContentEditableInput.prototype.pollSelection = function() {
      if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
        return;
      }
      var sel = this.getSelection(), cm = this.cm;
      if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
        this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
        this.blur();
        this.focus();
        return;
      }
      if (this.composing) {
        return;
      }
      this.rememberSelection();
      var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
      var head = domToPos(cm, sel.focusNode, sel.focusOffset);
      if (anchor && head) {
        runInOp(cm, function() {
          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
          if (anchor.bad || head.bad) {
            cm.curOp.selectionChanged = true;
          }
        });
      }
    };
    ContentEditableInput.prototype.pollContent = function() {
      if (this.readDOMTimeout != null) {
        clearTimeout(this.readDOMTimeout);
        this.readDOMTimeout = null;
      }
      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
      var from = sel.from(), to = sel.to();
      if (from.ch == 0 && from.line > cm.firstLine()) {
        from = Pos(from.line - 1, getLine2(cm.doc, from.line - 1).length);
      }
      if (to.ch == getLine2(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
        to = Pos(to.line + 1, 0);
      }
      if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
        return false;
      }
      var fromIndex, fromLine, fromNode;
      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
        fromLine = lineNo(display.view[0].line);
        fromNode = display.view[0].node;
      } else {
        fromLine = lineNo(display.view[fromIndex].line);
        fromNode = display.view[fromIndex - 1].node.nextSibling;
      }
      var toIndex = findViewIndex(cm, to.line);
      var toLine, toNode;
      if (toIndex == display.view.length - 1) {
        toLine = display.viewTo - 1;
        toNode = display.lineDiv.lastChild;
      } else {
        toLine = lineNo(display.view[toIndex + 1].line) - 1;
        toNode = display.view[toIndex + 1].node.previousSibling;
      }
      if (!fromNode) {
        return false;
      }
      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine2(cm.doc, toLine).text.length));
      while (newText.length > 1 && oldText.length > 1) {
        if (lst(newText) == lst(oldText)) {
          newText.pop();
          oldText.pop();
          toLine--;
        } else if (newText[0] == oldText[0]) {
          newText.shift();
          oldText.shift();
          fromLine++;
        } else {
          break;
        }
      }
      var cutFront = 0, cutEnd = 0;
      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
        ++cutFront;
      }
      var newBot = lst(newText), oldBot = lst(oldText);
      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
      while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        ++cutEnd;
      }
      if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
        while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          cutFront--;
          cutEnd++;
        }
      }
      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
      newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
      var chFrom = Pos(fromLine, cutFront);
      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
        replaceRange(cm.doc, newText, chFrom, chTo, "+input");
        return true;
      }
    };
    ContentEditableInput.prototype.ensurePolled = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.reset = function() {
      this.forceCompositionEnd();
    };
    ContentEditableInput.prototype.forceCompositionEnd = function() {
      if (!this.composing) {
        return;
      }
      clearTimeout(this.readDOMTimeout);
      this.composing = null;
      this.updateFromDOM();
      this.div.blur();
      this.div.focus();
    };
    ContentEditableInput.prototype.readFromDOMSoon = function() {
      var this$1$1 = this;
      if (this.readDOMTimeout != null) {
        return;
      }
      this.readDOMTimeout = setTimeout(function() {
        this$1$1.readDOMTimeout = null;
        if (this$1$1.composing) {
          if (this$1$1.composing.done) {
            this$1$1.composing = null;
          } else {
            return;
          }
        }
        this$1$1.updateFromDOM();
      }, 80);
    };
    ContentEditableInput.prototype.updateFromDOM = function() {
      var this$1$1 = this;
      if (this.cm.isReadOnly() || !this.pollContent()) {
        runInOp(this.cm, function() {
          return regChange(this$1$1.cm);
        });
      }
    };
    ContentEditableInput.prototype.setUneditable = function(node) {
      node.contentEditable = "false";
    };
    ContentEditableInput.prototype.onKeyPress = function(e) {
      if (e.charCode == 0 || this.composing) {
        return;
      }
      e.preventDefault();
      if (!this.cm.isReadOnly()) {
        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
      }
    };
    ContentEditableInput.prototype.readOnlyChanged = function(val) {
      this.div.contentEditable = String(val != "nocursor");
    };
    ContentEditableInput.prototype.onContextMenu = function() {
    };
    ContentEditableInput.prototype.resetPosition = function() {
    };
    ContentEditableInput.prototype.needsContentAttribute = true;
    function posToDOM(cm, pos) {
      var view = findViewForLine(cm, pos.line);
      if (!view || view.hidden) {
        return null;
      }
      var line = getLine2(cm.doc, pos.line);
      var info2 = mapFromLineView(view, line, pos.line);
      var order2 = getOrder(line, cm.doc.direction), side = "left";
      if (order2) {
        var partPos = getBidiPartAt(order2, pos.ch);
        side = partPos % 2 ? "right" : "left";
      }
      var result2 = nodeAndOffsetInLineMap(info2.map, pos.ch, side);
      result2.offset = result2.collapse == "right" ? result2.end : result2.start;
      return result2;
    }
    function isInGutter(node) {
      for (var scan = node; scan; scan = scan.parentNode) {
        if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
          return true;
        }
      }
      return false;
    }
    function badPos(pos, bad) {
      if (bad) {
        pos.bad = true;
      }
      return pos;
    }
    function domTextBetween(cm, from, to, fromLine, toLine) {
      var text3 = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
      function recognizeMarker(id2) {
        return function(marker2) {
          return marker2.id == id2;
        };
      }
      function close() {
        if (closing) {
          text3 += lineSep;
          if (extraLinebreak) {
            text3 += lineSep;
          }
          closing = extraLinebreak = false;
        }
      }
      function addText(str) {
        if (str) {
          close();
          text3 += str;
        }
      }
      function walk(node) {
        if (node.nodeType == 1) {
          var cmText = node.getAttribute("cm-text");
          if (cmText) {
            addText(cmText);
            return;
          }
          var markerID = node.getAttribute("cm-marker"), range3;
          if (markerID) {
            var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
            if (found.length && (range3 = found[0].find(0))) {
              addText(getBetween(cm.doc, range3.from, range3.to).join(lineSep));
            }
            return;
          }
          if (node.getAttribute("contenteditable") == "false") {
            return;
          }
          var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
          if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
            return;
          }
          if (isBlock) {
            close();
          }
          for (var i2 = 0; i2 < node.childNodes.length; i2++) {
            walk(node.childNodes[i2]);
          }
          if (/^(pre|p)$/i.test(node.nodeName)) {
            extraLinebreak = true;
          }
          if (isBlock) {
            closing = true;
          }
        } else if (node.nodeType == 3) {
          addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
      }
      for (; ; ) {
        walk(from);
        if (from == to) {
          break;
        }
        from = from.nextSibling;
        extraLinebreak = false;
      }
      return text3;
    }
    function domToPos(cm, node, offset) {
      var lineNode;
      if (node == cm.display.lineDiv) {
        lineNode = cm.display.lineDiv.childNodes[offset];
        if (!lineNode) {
          return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
        }
        node = null;
        offset = 0;
      } else {
        for (lineNode = node; ; lineNode = lineNode.parentNode) {
          if (!lineNode || lineNode == cm.display.lineDiv) {
            return null;
          }
          if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
            break;
          }
        }
      }
      for (var i2 = 0; i2 < cm.display.view.length; i2++) {
        var lineView = cm.display.view[i2];
        if (lineView.node == lineNode) {
          return locateNodeInLineView(lineView, node, offset);
        }
      }
    }
    function locateNodeInLineView(lineView, node, offset) {
      var wrapper = lineView.text.firstChild, bad = false;
      if (!node || !contains(wrapper, node)) {
        return badPos(Pos(lineNo(lineView.line), 0), true);
      }
      if (node == wrapper) {
        bad = true;
        node = wrapper.childNodes[offset];
        offset = 0;
        if (!node) {
          var line = lineView.rest ? lst(lineView.rest) : lineView.line;
          return badPos(Pos(lineNo(line), line.text.length), bad);
        }
      }
      var textNode = node.nodeType == 3 ? node : null, topNode = node;
      if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
        textNode = node.firstChild;
        if (offset) {
          offset = textNode.nodeValue.length;
        }
      }
      while (topNode.parentNode != wrapper) {
        topNode = topNode.parentNode;
      }
      var measure = lineView.measure, maps = measure.maps;
      function find2(textNode2, topNode2, offset2) {
        for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
          var map3 = i2 < 0 ? measure.map : maps[i2];
          for (var j = 0; j < map3.length; j += 3) {
            var curNode = map3[j + 2];
            if (curNode == textNode2 || curNode == topNode2) {
              var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
              var ch2 = map3[j] + offset2;
              if (offset2 < 0 || curNode != textNode2) {
                ch2 = map3[j + (offset2 ? 1 : 0)];
              }
              return Pos(line2, ch2);
            }
          }
        }
      }
      var found = find2(textNode, topNode, offset);
      if (found) {
        return badPos(found, bad);
      }
      for (var after = topNode.nextSibling, dist2 = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
        found = find2(after, after.firstChild, 0);
        if (found) {
          return badPos(Pos(found.line, found.ch - dist2), bad);
        } else {
          dist2 += after.textContent.length;
        }
      }
      for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
        found = find2(before, before.firstChild, -1);
        if (found) {
          return badPos(Pos(found.line, found.ch + dist$1), bad);
        } else {
          dist$1 += before.textContent.length;
        }
      }
    }
    var TextareaInput = function(cm) {
      this.cm = cm;
      this.prevInput = "";
      this.pollingFast = false;
      this.polling = new Delayed();
      this.hasSelection = false;
      this.composing = null;
    };
    TextareaInput.prototype.init = function(display) {
      var this$1$1 = this;
      var input = this, cm = this.cm;
      this.createField(display);
      var te2 = this.textarea;
      display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
      if (ios) {
        te2.style.width = "0px";
      }
      on(te2, "input", function() {
        if (ie2 && ie_version >= 9 && this$1$1.hasSelection) {
          this$1$1.hasSelection = null;
        }
        input.poll();
      });
      on(te2, "paste", function(e) {
        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
          return;
        }
        cm.state.pasteIncoming = +new Date();
        input.fastPoll();
      });
      function prepareCopyCut(e) {
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (cm.somethingSelected()) {
          setLastCopied({ lineWise: false, text: cm.getSelections() });
        } else if (!cm.options.lineWiseCopyCut) {
          return;
        } else {
          var ranges = copyableRanges(cm);
          setLastCopied({ lineWise: true, text: ranges.text });
          if (e.type == "cut") {
            cm.setSelections(ranges.ranges, null, sel_dontScroll);
          } else {
            input.prevInput = "";
            te2.value = ranges.text.join("\n");
            selectInput(te2);
          }
        }
        if (e.type == "cut") {
          cm.state.cutIncoming = +new Date();
        }
      }
      on(te2, "cut", prepareCopyCut);
      on(te2, "copy", prepareCopyCut);
      on(display.scroller, "paste", function(e) {
        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
          return;
        }
        if (!te2.dispatchEvent) {
          cm.state.pasteIncoming = +new Date();
          input.focus();
          return;
        }
        var event = new Event("paste");
        event.clipboardData = e.clipboardData;
        te2.dispatchEvent(event);
      });
      on(display.lineSpace, "selectstart", function(e) {
        if (!eventInWidget(display, e)) {
          e_preventDefault(e);
        }
      });
      on(te2, "compositionstart", function() {
        var start2 = cm.getCursor("from");
        if (input.composing) {
          input.composing.range.clear();
        }
        input.composing = {
          start: start2,
          range: cm.markText(start2, cm.getCursor("to"), { className: "CodeMirror-composing" })
        };
      });
      on(te2, "compositionend", function() {
        if (input.composing) {
          input.poll();
          input.composing.range.clear();
          input.composing = null;
        }
      });
    };
    TextareaInput.prototype.createField = function(_display) {
      this.wrapper = hiddenTextarea();
      this.textarea = this.wrapper.firstChild;
    };
    TextareaInput.prototype.screenReaderLabelChanged = function(label) {
      if (label) {
        this.textarea.setAttribute("aria-label", label);
      } else {
        this.textarea.removeAttribute("aria-label");
      }
    };
    TextareaInput.prototype.prepareSelection = function() {
      var cm = this.cm, display = cm.display, doc = cm.doc;
      var result2 = prepareSelection(cm);
      if (cm.options.moveInputWithCursor) {
        var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
        result2.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
        result2.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
      }
      return result2;
    };
    TextareaInput.prototype.showSelection = function(drawn) {
      var cm = this.cm, display = cm.display;
      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
      removeChildrenAndAdd(display.selectionDiv, drawn.selection);
      if (drawn.teTop != null) {
        this.wrapper.style.top = drawn.teTop + "px";
        this.wrapper.style.left = drawn.teLeft + "px";
      }
    };
    TextareaInput.prototype.reset = function(typing) {
      if (this.contextMenuPending || this.composing) {
        return;
      }
      var cm = this.cm;
      if (cm.somethingSelected()) {
        this.prevInput = "";
        var content = cm.getSelection();
        this.textarea.value = content;
        if (cm.state.focused) {
          selectInput(this.textarea);
        }
        if (ie2 && ie_version >= 9) {
          this.hasSelection = content;
        }
      } else if (!typing) {
        this.prevInput = this.textarea.value = "";
        if (ie2 && ie_version >= 9) {
          this.hasSelection = null;
        }
      }
    };
    TextareaInput.prototype.getField = function() {
      return this.textarea;
    };
    TextareaInput.prototype.supportsTouch = function() {
      return false;
    };
    TextareaInput.prototype.focus = function() {
      if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
        try {
          this.textarea.focus();
        } catch (e) {
        }
      }
    };
    TextareaInput.prototype.blur = function() {
      this.textarea.blur();
    };
    TextareaInput.prototype.resetPosition = function() {
      this.wrapper.style.top = this.wrapper.style.left = 0;
    };
    TextareaInput.prototype.receivedFocus = function() {
      this.slowPoll();
    };
    TextareaInput.prototype.slowPoll = function() {
      var this$1$1 = this;
      if (this.pollingFast) {
        return;
      }
      this.polling.set(this.cm.options.pollInterval, function() {
        this$1$1.poll();
        if (this$1$1.cm.state.focused) {
          this$1$1.slowPoll();
        }
      });
    };
    TextareaInput.prototype.fastPoll = function() {
      var missed = false, input = this;
      input.pollingFast = true;
      function p2() {
        var changed = input.poll();
        if (!changed && !missed) {
          missed = true;
          input.polling.set(60, p2);
        } else {
          input.pollingFast = false;
          input.slowPoll();
        }
      }
      input.polling.set(20, p2);
    };
    TextareaInput.prototype.poll = function() {
      var this$1$1 = this;
      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
      if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
        return false;
      }
      var text3 = input.value;
      if (text3 == prevInput && !cm.somethingSelected()) {
        return false;
      }
      if (ie2 && ie_version >= 9 && this.hasSelection === text3 || mac && /[\uf700-\uf7ff]/.test(text3)) {
        cm.display.input.reset();
        return false;
      }
      if (cm.doc.sel == cm.display.selForContextMenu) {
        var first = text3.charCodeAt(0);
        if (first == 8203 && !prevInput) {
          prevInput = "\u200B";
        }
        if (first == 8666) {
          this.reset();
          return this.cm.execCommand("undo");
        }
      }
      var same = 0, l2 = Math.min(prevInput.length, text3.length);
      while (same < l2 && prevInput.charCodeAt(same) == text3.charCodeAt(same)) {
        ++same;
      }
      runInOp(cm, function() {
        applyTextInput(cm, text3.slice(same), prevInput.length - same, null, this$1$1.composing ? "*compose" : null);
        if (text3.length > 1e3 || text3.indexOf("\n") > -1) {
          input.value = this$1$1.prevInput = "";
        } else {
          this$1$1.prevInput = text3;
        }
        if (this$1$1.composing) {
          this$1$1.composing.range.clear();
          this$1$1.composing.range = cm.markText(this$1$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
        }
      });
      return true;
    };
    TextareaInput.prototype.ensurePolled = function() {
      if (this.pollingFast && this.poll()) {
        this.pollingFast = false;
      }
    };
    TextareaInput.prototype.onKeyPress = function() {
      if (ie2 && ie_version >= 9) {
        this.hasSelection = null;
      }
      this.fastPoll();
    };
    TextareaInput.prototype.onContextMenu = function(e) {
      var input = this, cm = input.cm, display = cm.display, te2 = input.textarea;
      if (input.contextMenuPending) {
        input.contextMenuPending();
      }
      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
      if (!pos || presto) {
        return;
      }
      var reset = cm.options.resetSelectionOnContextMenu;
      if (reset && cm.doc.sel.contains(pos) == -1) {
        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
      }
      var oldCSS = te2.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
      var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
      input.wrapper.style.cssText = "position: static";
      te2.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie2 ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
      var oldScrollY;
      if (webkit) {
        oldScrollY = window.scrollY;
      }
      display.input.focus();
      if (webkit) {
        window.scrollTo(null, oldScrollY);
      }
      display.input.reset();
      if (!cm.somethingSelected()) {
        te2.value = input.prevInput = " ";
      }
      input.contextMenuPending = rehide;
      display.selForContextMenu = cm.doc.sel;
      clearTimeout(display.detectingSelectAll);
      function prepareSelectAllHack() {
        if (te2.selectionStart != null) {
          var selected = cm.somethingSelected();
          var extval = "\u200B" + (selected ? te2.value : "");
          te2.value = "\u21DA";
          te2.value = extval;
          input.prevInput = selected ? "" : "\u200B";
          te2.selectionStart = 1;
          te2.selectionEnd = extval.length;
          display.selForContextMenu = cm.doc.sel;
        }
      }
      function rehide() {
        if (input.contextMenuPending != rehide) {
          return;
        }
        input.contextMenuPending = false;
        input.wrapper.style.cssText = oldWrapperCSS;
        te2.style.cssText = oldCSS;
        if (ie2 && ie_version < 9) {
          display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
        }
        if (te2.selectionStart != null) {
          if (!ie2 || ie2 && ie_version < 9) {
            prepareSelectAllHack();
          }
          var i2 = 0, poll = function() {
            if (display.selForContextMenu == cm.doc.sel && te2.selectionStart == 0 && te2.selectionEnd > 0 && input.prevInput == "\u200B") {
              operation(cm, selectAll)(cm);
            } else if (i2++ < 10) {
              display.detectingSelectAll = setTimeout(poll, 500);
            } else {
              display.selForContextMenu = null;
              display.input.reset();
            }
          };
          display.detectingSelectAll = setTimeout(poll, 200);
        }
      }
      if (ie2 && ie_version >= 9) {
        prepareSelectAllHack();
      }
      if (captureRightClick) {
        e_stop(e);
        var mouseup = function() {
          off(window, "mouseup", mouseup);
          setTimeout(rehide, 20);
        };
        on(window, "mouseup", mouseup);
      } else {
        setTimeout(rehide, 50);
      }
    };
    TextareaInput.prototype.readOnlyChanged = function(val) {
      if (!val) {
        this.reset();
      }
      this.textarea.disabled = val == "nocursor";
      this.textarea.readOnly = !!val;
    };
    TextareaInput.prototype.setUneditable = function() {
    };
    TextareaInput.prototype.needsContentAttribute = false;
    function fromTextArea(textarea, options) {
      options = options ? copyObj(options) : {};
      options.value = textarea.value;
      if (!options.tabindex && textarea.tabIndex) {
        options.tabindex = textarea.tabIndex;
      }
      if (!options.placeholder && textarea.placeholder) {
        options.placeholder = textarea.placeholder;
      }
      if (options.autofocus == null) {
        var hasFocus = activeElt();
        options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
      }
      function save() {
        textarea.value = cm.getValue();
      }
      var realSubmit;
      if (textarea.form) {
        on(textarea.form, "submit", save);
        if (!options.leaveSubmitMethodAlone) {
          var form = textarea.form;
          realSubmit = form.submit;
          try {
            var wrappedSubmit = form.submit = function() {
              save();
              form.submit = realSubmit;
              form.submit();
              form.submit = wrappedSubmit;
            };
          } catch (e) {
          }
        }
      }
      options.finishInit = function(cm2) {
        cm2.save = save;
        cm2.getTextArea = function() {
          return textarea;
        };
        cm2.toTextArea = function() {
          cm2.toTextArea = isNaN;
          save();
          textarea.parentNode.removeChild(cm2.getWrapperElement());
          textarea.style.display = "";
          if (textarea.form) {
            off(textarea.form, "submit", save);
            if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
              textarea.form.submit = realSubmit;
            }
          }
        };
      };
      textarea.style.display = "none";
      var cm = CodeMirror2(function(node) {
        return textarea.parentNode.insertBefore(node, textarea.nextSibling);
      }, options);
      return cm;
    }
    function addLegacyProps(CodeMirror3) {
      CodeMirror3.off = off;
      CodeMirror3.on = on;
      CodeMirror3.wheelEventPixels = wheelEventPixels;
      CodeMirror3.Doc = Doc;
      CodeMirror3.splitLines = splitLinesAuto;
      CodeMirror3.countColumn = countColumn;
      CodeMirror3.findColumn = findColumn;
      CodeMirror3.isWordChar = isWordCharBasic;
      CodeMirror3.Pass = Pass;
      CodeMirror3.signal = signal;
      CodeMirror3.Line = Line;
      CodeMirror3.changeEnd = changeEnd;
      CodeMirror3.scrollbarModel = scrollbarModel;
      CodeMirror3.Pos = Pos;
      CodeMirror3.cmpPos = cmp;
      CodeMirror3.modes = modes;
      CodeMirror3.mimeModes = mimeModes;
      CodeMirror3.resolveMode = resolveMode;
      CodeMirror3.getMode = getMode;
      CodeMirror3.modeExtensions = modeExtensions;
      CodeMirror3.extendMode = extendMode;
      CodeMirror3.copyState = copyState;
      CodeMirror3.startState = startState;
      CodeMirror3.innerMode = innerMode;
      CodeMirror3.commands = commands;
      CodeMirror3.keyMap = keyMap2;
      CodeMirror3.keyName = keyName;
      CodeMirror3.isModifierKey = isModifierKey;
      CodeMirror3.lookupKey = lookupKey;
      CodeMirror3.normalizeKeyMap = normalizeKeyMap;
      CodeMirror3.StringStream = StringStream;
      CodeMirror3.SharedTextMarker = SharedTextMarker;
      CodeMirror3.TextMarker = TextMarker;
      CodeMirror3.LineWidget = LineWidget;
      CodeMirror3.e_preventDefault = e_preventDefault;
      CodeMirror3.e_stopPropagation = e_stopPropagation;
      CodeMirror3.e_stop = e_stop;
      CodeMirror3.addClass = addClass;
      CodeMirror3.contains = contains;
      CodeMirror3.rmClass = rmClass;
      CodeMirror3.keyNames = keyNames;
    }
    defineOptions(CodeMirror2);
    addEditorMethods(CodeMirror2);
    var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
    for (var prop2 in Doc.prototype) {
      if (Doc.prototype.hasOwnProperty(prop2) && indexOf(dontDelegate, prop2) < 0) {
        CodeMirror2.prototype[prop2] = function(method) {
          return function() {
            return method.apply(this.doc, arguments);
          };
        }(Doc.prototype[prop2]);
      }
    }
    eventMixin(Doc);
    CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
    CodeMirror2.defineMode = function(name2) {
      if (!CodeMirror2.defaults.mode && name2 != "null") {
        CodeMirror2.defaults.mode = name2;
      }
      defineMode.apply(this, arguments);
    };
    CodeMirror2.defineMIME = defineMIME;
    CodeMirror2.defineMode("null", function() {
      return { token: function(stream) {
        return stream.skipToEnd();
      } };
    });
    CodeMirror2.defineMIME("text/plain", "null");
    CodeMirror2.defineExtension = function(name2, func) {
      CodeMirror2.prototype[name2] = func;
    };
    CodeMirror2.defineDocExtension = function(name2, func) {
      Doc.prototype[name2] = func;
    };
    CodeMirror2.fromTextArea = fromTextArea;
    addLegacyProps(CodeMirror2);
    CodeMirror2.version = "5.65.1";
    return CodeMirror2;
  });
})(codemirror);
var CodeMirror = codemirror.exports;
var md$2 = new markdownIt();
function onHasCompletion(_cm, data, onHintInformationRender) {
  var information;
  var deprecation;
  CodeMirror.on(data, "select", function(ctx, el2) {
    if (!information) {
      var hintsUl_1 = el2.parentNode;
      information = document.createElement("div");
      information.className = "CodeMirror-hint-information";
      hintsUl_1.appendChild(information);
      deprecation = document.createElement("div");
      deprecation.className = "CodeMirror-hint-deprecation";
      hintsUl_1.appendChild(deprecation);
      var onRemoveFn_1;
      hintsUl_1.addEventListener("DOMNodeRemoved", onRemoveFn_1 = function(event) {
        if (event.target === hintsUl_1) {
          hintsUl_1.removeEventListener("DOMNodeRemoved", onRemoveFn_1);
          information = null;
          deprecation = null;
          onRemoveFn_1 = null;
        }
      });
    }
    var description = ctx.description ? md$2.render(ctx.description) : "Self descriptive.";
    var type2 = ctx.type ? '<span class="infoType">' + renderType$2(ctx.type) + "</span>" : "";
    information.innerHTML = '<div class="content">' + (description.slice(0, 3) === "<p>" ? "<p>" + type2 + description.slice(3) : type2 + description) + "</div>";
    if (ctx && deprecation && ctx.deprecationReason) {
      var reason = ctx.deprecationReason ? md$2.render(ctx.deprecationReason) : "";
      deprecation.innerHTML = '<span class="deprecation-label">Deprecated</span>' + reason;
      deprecation.style.display = "block";
    } else if (deprecation) {
      deprecation.style.display = "none";
    }
    if (onHintInformationRender) {
      onHintInformationRender(information);
    }
  });
}
function renderType$2(type2) {
  if (type2 instanceof GraphQLNonNull) {
    return renderType$2(type2.ofType) + "!";
  }
  if (type2 instanceof GraphQLList) {
    return "[" + renderType$2(type2.ofType) + "]";
  }
  return '<a class="typeName">' + escapeHtml_1(type2.name) + "</a>";
}
var _a;
var isMacOs = false;
if (typeof window === "object") {
  isMacOs = window.navigator.platform === "MacIntel";
}
var commonKeys = (_a = {}, _a[isMacOs ? "Cmd-F" : "Ctrl-F"] = "findPersistent", _a["Cmd-G"] = "findPersistent", _a["Ctrl-G"] = "findPersistent", _a["Ctrl-Left"] = "goSubwordLeft", _a["Ctrl-Right"] = "goSubwordRight", _a["Alt-Left"] = "goGroupLeft", _a["Alt-Right"] = "goGroupRight", _a);
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    var HINT_ELEMENT_CLASS = "CodeMirror-hint";
    var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
    CodeMirror2.showHint = function(cm, getHints, options) {
      if (!getHints)
        return cm.showHint(options);
      if (options && options.async)
        getHints.async = true;
      var newOpts = { hint: getHints };
      if (options)
        for (var prop2 in options)
          newOpts[prop2] = options[prop2];
      return cm.showHint(newOpts);
    };
    CodeMirror2.defineExtension("showHint", function(options) {
      options = parseOptions(this, this.getCursor("start"), options);
      var selections = this.listSelections();
      if (selections.length > 1)
        return;
      if (this.somethingSelected()) {
        if (!options.hint.supportsSelection)
          return;
        for (var i = 0; i < selections.length; i++)
          if (selections[i].head.line != selections[i].anchor.line)
            return;
      }
      if (this.state.completionActive)
        this.state.completionActive.close();
      var completion = this.state.completionActive = new Completion(this, options);
      if (!completion.options.hint)
        return;
      CodeMirror2.signal(this, "startCompletion", this);
      completion.update(true);
    });
    CodeMirror2.defineExtension("closeHint", function() {
      if (this.state.completionActive)
        this.state.completionActive.close();
    });
    function Completion(cm, options) {
      this.cm = cm;
      this.options = options;
      this.widget = null;
      this.debounce = 0;
      this.tick = 0;
      this.startPos = this.cm.getCursor("start");
      this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
      if (this.options.updateOnCursorActivity) {
        var self2 = this;
        cm.on("cursorActivity", this.activityFunc = function() {
          self2.cursorActivity();
        });
      }
    }
    var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
      return setTimeout(fn, 1e3 / 60);
    };
    var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
    Completion.prototype = {
      close: function() {
        if (!this.active())
          return;
        this.cm.state.completionActive = null;
        this.tick = null;
        if (this.options.updateOnCursorActivity) {
          this.cm.off("cursorActivity", this.activityFunc);
        }
        if (this.widget && this.data)
          CodeMirror2.signal(this.data, "close");
        if (this.widget)
          this.widget.close();
        CodeMirror2.signal(this.cm, "endCompletion", this.cm);
      },
      active: function() {
        return this.cm.state.completionActive == this;
      },
      pick: function(data, i) {
        var completion = data.list[i], self2 = this;
        this.cm.operation(function() {
          if (completion.hint)
            completion.hint(self2.cm, data, completion);
          else
            self2.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete");
          CodeMirror2.signal(data, "pick", completion);
          self2.cm.scrollIntoView();
        });
        if (this.options.closeOnPick) {
          this.close();
        }
      },
      cursorActivity: function() {
        if (this.debounce) {
          cancelAnimationFrame(this.debounce);
          this.debounce = 0;
        }
        var identStart = this.startPos;
        if (this.data) {
          identStart = this.data.from;
        }
        var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
        if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
          this.close();
        } else {
          var self2 = this;
          this.debounce = requestAnimationFrame(function() {
            self2.update();
          });
          if (this.widget)
            this.widget.disable();
        }
      },
      update: function(first) {
        if (this.tick == null)
          return;
        var self2 = this, myTick = ++this.tick;
        fetchHints(this.options.hint, this.cm, this.options, function(data) {
          if (self2.tick == myTick)
            self2.finishUpdate(data, first);
        });
      },
      finishUpdate: function(data, first) {
        if (this.data)
          CodeMirror2.signal(this.data, "update");
        var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
        if (this.widget)
          this.widget.close();
        this.data = data;
        if (data && data.list.length) {
          if (picked && data.list.length == 1) {
            this.pick(data, 0);
          } else {
            this.widget = new Widget(this, data);
            CodeMirror2.signal(data, "shown");
          }
        }
      }
    };
    function parseOptions(cm, pos, options) {
      var editor = cm.options.hintOptions;
      var out = {};
      for (var prop2 in defaultOptions2)
        out[prop2] = defaultOptions2[prop2];
      if (editor) {
        for (var prop2 in editor)
          if (editor[prop2] !== void 0)
            out[prop2] = editor[prop2];
      }
      if (options) {
        for (var prop2 in options)
          if (options[prop2] !== void 0)
            out[prop2] = options[prop2];
      }
      if (out.hint.resolve)
        out.hint = out.hint.resolve(cm, pos);
      return out;
    }
    function getText(completion) {
      if (typeof completion == "string")
        return completion;
      else
        return completion.text;
    }
    function buildKeyMap(completion, handle) {
      var baseMap = {
        Up: function() {
          handle.moveFocus(-1);
        },
        Down: function() {
          handle.moveFocus(1);
        },
        PageUp: function() {
          handle.moveFocus(-handle.menuSize() + 1, true);
        },
        PageDown: function() {
          handle.moveFocus(handle.menuSize() - 1, true);
        },
        Home: function() {
          handle.setFocus(0);
        },
        End: function() {
          handle.setFocus(handle.length - 1);
        },
        Enter: handle.pick,
        Tab: handle.pick,
        Esc: handle.close
      };
      var mac = /Mac/.test(navigator.platform);
      if (mac) {
        baseMap["Ctrl-P"] = function() {
          handle.moveFocus(-1);
        };
        baseMap["Ctrl-N"] = function() {
          handle.moveFocus(1);
        };
      }
      var custom = completion.options.customKeys;
      var ourMap = custom ? {} : baseMap;
      function addBinding(key2, val) {
        var bound;
        if (typeof val != "string")
          bound = function(cm) {
            return val(cm, handle);
          };
        else if (baseMap.hasOwnProperty(val))
          bound = baseMap[val];
        else
          bound = val;
        ourMap[key2] = bound;
      }
      if (custom) {
        for (var key in custom)
          if (custom.hasOwnProperty(key))
            addBinding(key, custom[key]);
      }
      var extra = completion.options.extraKeys;
      if (extra) {
        for (var key in extra)
          if (extra.hasOwnProperty(key))
            addBinding(key, extra[key]);
      }
      return ourMap;
    }
    function getHintElement(hintsElement, el2) {
      while (el2 && el2 != hintsElement) {
        if (el2.nodeName.toUpperCase() === "LI" && el2.parentNode == hintsElement)
          return el2;
        el2 = el2.parentNode;
      }
    }
    function Widget(completion, data) {
      this.id = "cm-complete-" + Math.floor(Math.random(1e6));
      this.completion = completion;
      this.data = data;
      this.picked = false;
      var widget = this, cm = completion.cm;
      var ownerDocument = cm.getInputField().ownerDocument;
      var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;
      var hints = this.hints = ownerDocument.createElement("ul");
      hints.setAttribute("role", "listbox");
      hints.setAttribute("aria-expanded", "true");
      hints.id = this.id;
      var theme = completion.cm.options.theme;
      hints.className = "CodeMirror-hints " + theme;
      this.selectedHint = data.selectedHint || 0;
      var completions = data.list;
      for (var i = 0; i < completions.length; ++i) {
        var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
        var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
        if (cur.className != null)
          className = cur.className + " " + className;
        elt.className = className;
        if (i == this.selectedHint)
          elt.setAttribute("aria-selected", "true");
        elt.id = this.id + "-" + i;
        elt.setAttribute("role", "option");
        if (cur.render)
          cur.render(elt, data, cur);
        else
          elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
        elt.hintId = i;
      }
      var container = completion.options.container || ownerDocument.body;
      var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
      var left = pos.left, top2 = pos.bottom, below = true;
      var offsetLeft = 0, offsetTop = 0;
      if (container !== ownerDocument.body) {
        var isContainerPositioned = ["absolute", "relative", "fixed"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
        var offsetParent = isContainerPositioned ? container : container.offsetParent;
        var offsetParentPosition = offsetParent.getBoundingClientRect();
        var bodyPosition = ownerDocument.body.getBoundingClientRect();
        offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;
        offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;
      }
      hints.style.left = left - offsetLeft + "px";
      hints.style.top = top2 - offsetTop + "px";
      var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
      var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
      container.appendChild(hints);
      cm.getInputField().setAttribute("aria-autocomplete", "list");
      cm.getInputField().setAttribute("aria-owns", this.id);
      cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);
      var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
      var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;
      var startScroll;
      setTimeout(function() {
        startScroll = cm.getScrollInfo();
      });
      var overlapY = box.bottom - winH;
      if (overlapY > 0) {
        var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
        if (curTop - height > 0) {
          hints.style.top = (top2 = pos.top - height - offsetTop) + "px";
          below = false;
        } else if (height > winH) {
          hints.style.height = winH - 5 + "px";
          hints.style.top = (top2 = pos.bottom - box.top - offsetTop) + "px";
          var cursor = cm.getCursor();
          if (data.from.ch != cursor.ch) {
            pos = cm.cursorCoords(cursor);
            hints.style.left = (left = pos.left - offsetLeft) + "px";
            box = hints.getBoundingClientRect();
          }
        }
      }
      var overlapX = box.right - winW;
      if (scrolls)
        overlapX += cm.display.nativeBarWidth;
      if (overlapX > 0) {
        if (box.right - box.left > winW) {
          hints.style.width = winW - 5 + "px";
          overlapX -= box.right - box.left - winW;
        }
        hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
      }
      if (scrolls)
        for (var node = hints.firstChild; node; node = node.nextSibling)
          node.style.paddingRight = cm.display.nativeBarWidth + "px";
      cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
        moveFocus: function(n2, avoidWrap) {
          widget.changeActive(widget.selectedHint + n2, avoidWrap);
        },
        setFocus: function(n2) {
          widget.changeActive(n2);
        },
        menuSize: function() {
          return widget.screenAmount();
        },
        length: completions.length,
        close: function() {
          completion.close();
        },
        pick: function() {
          widget.pick();
        },
        data
      }));
      if (completion.options.closeOnUnfocus) {
        var closingOnBlur;
        cm.on("blur", this.onBlur = function() {
          closingOnBlur = setTimeout(function() {
            completion.close();
          }, 100);
        });
        cm.on("focus", this.onFocus = function() {
          clearTimeout(closingOnBlur);
        });
      }
      cm.on("scroll", this.onScroll = function() {
        var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
        if (!startScroll)
          startScroll = cm.getScrollInfo();
        var newTop = top2 + startScroll.top - curScroll.top;
        var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
        if (!below)
          point += hints.offsetHeight;
        if (point <= editor.top || point >= editor.bottom)
          return completion.close();
        hints.style.top = newTop + "px";
        hints.style.left = left + startScroll.left - curScroll.left + "px";
      });
      CodeMirror2.on(hints, "dblclick", function(e) {
        var t2 = getHintElement(hints, e.target || e.srcElement);
        if (t2 && t2.hintId != null) {
          widget.changeActive(t2.hintId);
          widget.pick();
        }
      });
      CodeMirror2.on(hints, "click", function(e) {
        var t2 = getHintElement(hints, e.target || e.srcElement);
        if (t2 && t2.hintId != null) {
          widget.changeActive(t2.hintId);
          if (completion.options.completeOnSingleClick)
            widget.pick();
        }
      });
      CodeMirror2.on(hints, "mousedown", function() {
        setTimeout(function() {
          cm.focus();
        }, 20);
      });
      var selectedHintRange = this.getSelectedHintRange();
      if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
        this.scrollToActive();
      }
      CodeMirror2.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
      return true;
    }
    Widget.prototype = {
      close: function() {
        if (this.completion.widget != this)
          return;
        this.completion.widget = null;
        if (this.hints.parentNode)
          this.hints.parentNode.removeChild(this.hints);
        this.completion.cm.removeKeyMap(this.keyMap);
        var input = this.completion.cm.getInputField();
        input.removeAttribute("aria-activedescendant");
        input.removeAttribute("aria-owns");
        var cm = this.completion.cm;
        if (this.completion.options.closeOnUnfocus) {
          cm.off("blur", this.onBlur);
          cm.off("focus", this.onFocus);
        }
        cm.off("scroll", this.onScroll);
      },
      disable: function() {
        this.completion.cm.removeKeyMap(this.keyMap);
        var widget = this;
        this.keyMap = { Enter: function() {
          widget.picked = true;
        } };
        this.completion.cm.addKeyMap(this.keyMap);
      },
      pick: function() {
        this.completion.pick(this.data, this.selectedHint);
      },
      changeActive: function(i, avoidWrap) {
        if (i >= this.data.list.length)
          i = avoidWrap ? this.data.list.length - 1 : 0;
        else if (i < 0)
          i = avoidWrap ? 0 : this.data.list.length - 1;
        if (this.selectedHint == i)
          return;
        var node = this.hints.childNodes[this.selectedHint];
        if (node) {
          node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
          node.removeAttribute("aria-selected");
        }
        node = this.hints.childNodes[this.selectedHint = i];
        node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
        node.setAttribute("aria-selected", "true");
        this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id);
        this.scrollToActive();
        CodeMirror2.signal(this.data, "select", this.data.list[this.selectedHint], node);
      },
      scrollToActive: function() {
        var selectedHintRange = this.getSelectedHintRange();
        var node1 = this.hints.childNodes[selectedHintRange.from];
        var node2 = this.hints.childNodes[selectedHintRange.to];
        var firstNode = this.hints.firstChild;
        if (node1.offsetTop < this.hints.scrollTop)
          this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
        else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
          this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
      },
      screenAmount: function() {
        return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
      },
      getSelectedHintRange: function() {
        var margin = this.completion.options.scrollMargin || 0;
        return {
          from: Math.max(0, this.selectedHint - margin),
          to: Math.min(this.data.list.length - 1, this.selectedHint + margin)
        };
      }
    };
    function applicableHelpers(cm, helpers2) {
      if (!cm.somethingSelected())
        return helpers2;
      var result2 = [];
      for (var i = 0; i < helpers2.length; i++)
        if (helpers2[i].supportsSelection)
          result2.push(helpers2[i]);
      return result2;
    }
    function fetchHints(hint2, cm, options, callback) {
      if (hint2.async) {
        hint2(cm, callback, options);
      } else {
        var result2 = hint2(cm, options);
        if (result2 && result2.then)
          result2.then(callback);
        else
          callback(result2);
      }
    }
    function resolveAutoHints(cm, pos) {
      var helpers2 = cm.getHelpers(pos, "hint"), words;
      if (helpers2.length) {
        var resolved = function(cm2, callback, options) {
          var app = applicableHelpers(cm2, helpers2);
          function run(i) {
            if (i == app.length)
              return callback(null);
            fetchHints(app[i], cm2, options, function(result2) {
              if (result2 && result2.list.length > 0)
                callback(result2);
              else
                run(i + 1);
            });
          }
          run(0);
        };
        resolved.async = true;
        resolved.supportsSelection = true;
        return resolved;
      } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
        return function(cm2) {
          return CodeMirror2.hint.fromList(cm2, { words });
        };
      } else if (CodeMirror2.hint.anyword) {
        return function(cm2, options) {
          return CodeMirror2.hint.anyword(cm2, options);
        };
      } else {
        return function() {
        };
      }
    }
    CodeMirror2.registerHelper("hint", "auto", {
      resolve: resolveAutoHints
    });
    CodeMirror2.registerHelper("hint", "fromList", function(cm, options) {
      var cur = cm.getCursor(), token2 = cm.getTokenAt(cur);
      var term, from = CodeMirror2.Pos(cur.line, token2.start), to = cur;
      if (token2.start < cur.ch && /\w/.test(token2.string.charAt(cur.ch - token2.start - 1))) {
        term = token2.string.substr(0, cur.ch - token2.start);
      } else {
        term = "";
        from = cur;
      }
      var found = [];
      for (var i = 0; i < options.words.length; i++) {
        var word2 = options.words[i];
        if (word2.slice(0, term.length) == term)
          found.push(word2);
      }
      if (found.length)
        return { list: found, from, to };
    });
    CodeMirror2.commands.autocomplete = CodeMirror2.showHint;
    var defaultOptions2 = {
      hint: CodeMirror2.hint.auto,
      completeSingle: true,
      alignWithWord: true,
      closeCharacters: /[\s()\[\]{};:>,]/,
      closeOnPick: true,
      closeOnUnfocus: true,
      updateOnCursorActivity: true,
      completeOnSingleClick: true,
      container: null,
      customKeys: null,
      extraKeys: null,
      paddingForScrollbar: true,
      moveOnOverlap: true
    };
    CodeMirror2.defineOption("hintOptions", null);
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    var noOptions = {};
    var nonWS = /[^\s\u00a0]/;
    var Pos = CodeMirror2.Pos, cmp = CodeMirror2.cmpPos;
    function firstNonWS(str) {
      var found = str.search(nonWS);
      return found == -1 ? 0 : found;
    }
    CodeMirror2.commands.toggleComment = function(cm) {
      cm.toggleComment();
    };
    CodeMirror2.defineExtension("toggleComment", function(options) {
      if (!options)
        options = noOptions;
      var cm = this;
      var minLine = Infinity, ranges = this.listSelections(), mode2 = null;
      for (var i = ranges.length - 1; i >= 0; i--) {
        var from = ranges[i].from(), to = ranges[i].to();
        if (from.line >= minLine)
          continue;
        if (to.line >= minLine)
          to = Pos(minLine, 0);
        minLine = from.line;
        if (mode2 == null) {
          if (cm.uncomment(from, to, options))
            mode2 = "un";
          else {
            cm.lineComment(from, to, options);
            mode2 = "line";
          }
        } else if (mode2 == "un") {
          cm.uncomment(from, to, options);
        } else {
          cm.lineComment(from, to, options);
        }
      }
    });
    function probablyInsideString(cm, pos, line) {
      return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line);
    }
    function getMode(cm, pos) {
      var mode2 = cm.getMode();
      return mode2.useInnerComments === false || !mode2.innerMode ? mode2 : cm.getModeAt(pos);
    }
    CodeMirror2.defineExtension("lineComment", function(from, to, options) {
      if (!options)
        options = noOptions;
      var self2 = this, mode2 = getMode(self2, from);
      var firstLine = self2.getLine(from.line);
      if (firstLine == null || probablyInsideString(self2, from, firstLine))
        return;
      var commentString = options.lineComment || mode2.lineComment;
      if (!commentString) {
        if (options.blockCommentStart || mode2.blockCommentStart) {
          options.fullLines = true;
          self2.blockComment(from, to, options);
        }
        return;
      }
      var end2 = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self2.lastLine() + 1);
      var pad = options.padding == null ? " " : options.padding;
      var blankLines = options.commentBlankLines || from.line == to.line;
      self2.operation(function() {
        if (options.indent) {
          var baseString = null;
          for (var i = from.line; i < end2; ++i) {
            var line = self2.getLine(i);
            var whitespace = line.slice(0, firstNonWS(line));
            if (baseString == null || baseString.length > whitespace.length) {
              baseString = whitespace;
            }
          }
          for (var i = from.line; i < end2; ++i) {
            var line = self2.getLine(i), cut = baseString.length;
            if (!blankLines && !nonWS.test(line))
              continue;
            if (line.slice(0, cut) != baseString)
              cut = firstNonWS(line);
            self2.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
          }
        } else {
          for (var i = from.line; i < end2; ++i) {
            if (blankLines || nonWS.test(self2.getLine(i)))
              self2.replaceRange(commentString + pad, Pos(i, 0));
          }
        }
      });
    });
    CodeMirror2.defineExtension("blockComment", function(from, to, options) {
      if (!options)
        options = noOptions;
      var self2 = this, mode2 = getMode(self2, from);
      var startString = options.blockCommentStart || mode2.blockCommentStart;
      var endString = options.blockCommentEnd || mode2.blockCommentEnd;
      if (!startString || !endString) {
        if ((options.lineComment || mode2.lineComment) && options.fullLines != false)
          self2.lineComment(from, to, options);
        return;
      }
      if (/\bcomment\b/.test(self2.getTokenTypeAt(Pos(from.line, 0))))
        return;
      var end2 = Math.min(to.line, self2.lastLine());
      if (end2 != from.line && to.ch == 0 && nonWS.test(self2.getLine(end2)))
        --end2;
      var pad = options.padding == null ? " " : options.padding;
      if (from.line > end2)
        return;
      self2.operation(function() {
        if (options.fullLines != false) {
          var lastLineHasText = nonWS.test(self2.getLine(end2));
          self2.replaceRange(pad + endString, Pos(end2));
          self2.replaceRange(startString + pad, Pos(from.line, 0));
          var lead = options.blockCommentLead || mode2.blockCommentLead;
          if (lead != null) {
            for (var i = from.line + 1; i <= end2; ++i)
              if (i != end2 || lastLineHasText)
                self2.replaceRange(lead + pad, Pos(i, 0));
          }
        } else {
          var atCursor = cmp(self2.getCursor("to"), to) == 0, empty2 = !self2.somethingSelected();
          self2.replaceRange(endString, to);
          if (atCursor)
            self2.setSelection(empty2 ? to : self2.getCursor("from"), to);
          self2.replaceRange(startString, from);
        }
      });
    });
    CodeMirror2.defineExtension("uncomment", function(from, to, options) {
      if (!options)
        options = noOptions;
      var self2 = this, mode2 = getMode(self2, from);
      var end2 = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self2.lastLine()), start2 = Math.min(from.line, end2);
      var lineString = options.lineComment || mode2.lineComment, lines = [];
      var pad = options.padding == null ? " " : options.padding, didSomething;
      lineComment: {
        if (!lineString)
          break lineComment;
        for (var i = start2; i <= end2; ++i) {
          var line = self2.getLine(i);
          var found = line.indexOf(lineString);
          if (found > -1 && !/comment/.test(self2.getTokenTypeAt(Pos(i, found + 1))))
            found = -1;
          if (found == -1 && nonWS.test(line))
            break lineComment;
          if (found > -1 && nonWS.test(line.slice(0, found)))
            break lineComment;
          lines.push(line);
        }
        self2.operation(function() {
          for (var i2 = start2; i2 <= end2; ++i2) {
            var line2 = lines[i2 - start2];
            var pos = line2.indexOf(lineString), endPos = pos + lineString.length;
            if (pos < 0)
              continue;
            if (line2.slice(endPos, endPos + pad.length) == pad)
              endPos += pad.length;
            didSomething = true;
            self2.replaceRange("", Pos(i2, pos), Pos(i2, endPos));
          }
        });
        if (didSomething)
          return true;
      }
      var startString = options.blockCommentStart || mode2.blockCommentStart;
      var endString = options.blockCommentEnd || mode2.blockCommentEnd;
      if (!startString || !endString)
        return false;
      var lead = options.blockCommentLead || mode2.blockCommentLead;
      var startLine = self2.getLine(start2), open = startLine.indexOf(startString);
      if (open == -1)
        return false;
      var endLine = end2 == start2 ? startLine : self2.getLine(end2);
      var close = endLine.indexOf(endString, end2 == start2 ? open + startString.length : 0);
      var insideStart = Pos(start2, open + 1), insideEnd = Pos(end2, close + 1);
      if (close == -1 || !/comment/.test(self2.getTokenTypeAt(insideStart)) || !/comment/.test(self2.getTokenTypeAt(insideEnd)) || self2.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
        return false;
      var lastStart = startLine.lastIndexOf(startString, from.ch);
      var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
      if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch)
        return false;
      firstEnd = endLine.indexOf(endString, to.ch);
      var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
      lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;
      if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch)
        return false;
      self2.operation(function() {
        self2.replaceRange("", Pos(end2, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end2, close + endString.length));
        var openEnd = open + startString.length;
        if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad)
          openEnd += pad.length;
        self2.replaceRange("", Pos(start2, open), Pos(start2, openEnd));
        if (lead)
          for (var i2 = start2 + 1; i2 <= end2; ++i2) {
            var line2 = self2.getLine(i2), found2 = line2.indexOf(lead);
            if (found2 == -1 || nonWS.test(line2.slice(0, found2)))
              continue;
            var foundEnd = found2 + lead.length;
            if (pad && line2.slice(foundEnd, foundEnd + pad.length) == pad)
              foundEnd += pad.length;
            self2.replaceRange("", Pos(i2, found2), Pos(i2, foundEnd));
          }
      });
      return true;
    });
  });
})();
var matchbrackets = { exports: {} };
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
    var Pos = CodeMirror2.Pos;
    var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };
    function bracketRegex(config2) {
      return config2 && config2.bracketRegex || /[(){}[\]]/;
    }
    function findMatchingBracket(cm, where, config2) {
      var line = cm.getLineHandle(where.line), pos = where.ch - 1;
      var afterCursor = config2 && config2.afterCursor;
      if (afterCursor == null)
        afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
      var re2 = bracketRegex(config2);
      var match2 = !afterCursor && pos >= 0 && re2.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re2.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
      if (!match2)
        return null;
      var dir = match2.charAt(1) == ">" ? 1 : -1;
      if (config2 && config2.strict && dir > 0 != (pos == where.ch))
        return null;
      var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
      var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config2);
      if (found == null)
        return null;
      return {
        from: Pos(where.line, pos),
        to: found && found.pos,
        match: found && found.ch == match2.charAt(0),
        forward: dir > 0
      };
    }
    function scanForBracket(cm, where, dir, style, config2) {
      var maxScanLen = config2 && config2.maxScanLineLength || 1e4;
      var maxScanLines = config2 && config2.maxScanLines || 1e3;
      var stack = [];
      var re2 = bracketRegex(config2);
      var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
      for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
        var line = cm.getLine(lineNo);
        if (!line)
          continue;
        var pos = dir > 0 ? 0 : line.length - 1, end2 = dir > 0 ? line.length : -1;
        if (line.length > maxScanLen)
          continue;
        if (lineNo == where.line)
          pos = where.ch - (dir < 0 ? 1 : 0);
        for (; pos != end2; pos += dir) {
          var ch2 = line.charAt(pos);
          if (re2.test(ch2) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
            var match2 = matching[ch2];
            if (match2 && match2.charAt(1) == ">" == dir > 0)
              stack.push(ch2);
            else if (!stack.length)
              return { pos: Pos(lineNo, pos), ch: ch2 };
            else
              stack.pop();
          }
        }
      }
      return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
    }
    function matchBrackets(cm, autoclear, config2) {
      var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config2 && config2.highlightNonMatching;
      var marks = [], ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        var match2 = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config2);
        if (match2 && (match2.match || highlightNonMatching !== false) && cm.getLine(match2.from.line).length <= maxHighlightLen) {
          var style = match2.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
          marks.push(cm.markText(match2.from, Pos(match2.from.line, match2.from.ch + 1), { className: style }));
          if (match2.to && cm.getLine(match2.to.line).length <= maxHighlightLen)
            marks.push(cm.markText(match2.to, Pos(match2.to.line, match2.to.ch + 1), { className: style }));
        }
      }
      if (marks.length) {
        if (ie_lt8 && cm.state.focused)
          cm.focus();
        var clear = function() {
          cm.operation(function() {
            for (var i2 = 0; i2 < marks.length; i2++)
              marks[i2].clear();
          });
        };
        if (autoclear)
          setTimeout(clear, 800);
        else
          return clear;
      }
    }
    function doMatchBrackets(cm) {
      cm.operation(function() {
        if (cm.state.matchBrackets.currentlyHighlighted) {
          cm.state.matchBrackets.currentlyHighlighted();
          cm.state.matchBrackets.currentlyHighlighted = null;
        }
        cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
      });
    }
    function clearHighlighted(cm) {
      if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
        cm.state.matchBrackets.currentlyHighlighted();
        cm.state.matchBrackets.currentlyHighlighted = null;
      }
    }
    CodeMirror2.defineOption("matchBrackets", false, function(cm, val, old) {
      if (old && old != CodeMirror2.Init) {
        cm.off("cursorActivity", doMatchBrackets);
        cm.off("focus", doMatchBrackets);
        cm.off("blur", clearHighlighted);
        clearHighlighted(cm);
      }
      if (val) {
        cm.state.matchBrackets = typeof val == "object" ? val : {};
        cm.on("cursorActivity", doMatchBrackets);
        cm.on("focus", doMatchBrackets);
        cm.on("blur", clearHighlighted);
      }
    });
    CodeMirror2.defineExtension("matchBrackets", function() {
      matchBrackets(this, true);
    });
    CodeMirror2.defineExtension("findMatchingBracket", function(pos, config2, oldConfig) {
      if (oldConfig || typeof config2 == "boolean") {
        if (!oldConfig) {
          config2 = config2 ? { strict: true } : null;
        } else {
          oldConfig.strict = config2;
          config2 = oldConfig;
        }
      }
      return findMatchingBracket(this, pos, config2);
    });
    CodeMirror2.defineExtension("scanForBracket", function(pos, dir, style, config2) {
      return scanForBracket(this, pos, dir, style, config2);
    });
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    var defaults2 = {
      pairs: `()[]{}''""`,
      closeBefore: `)]}'":;>`,
      triples: "",
      explode: "[]{}"
    };
    var Pos = CodeMirror2.Pos;
    CodeMirror2.defineOption("autoCloseBrackets", false, function(cm, val, old) {
      if (old && old != CodeMirror2.Init) {
        cm.removeKeyMap(keyMap2);
        cm.state.closeBrackets = null;
      }
      if (val) {
        ensureBound(getOption(val, "pairs"));
        cm.state.closeBrackets = val;
        cm.addKeyMap(keyMap2);
      }
    });
    function getOption(conf, name2) {
      if (name2 == "pairs" && typeof conf == "string")
        return conf;
      if (typeof conf == "object" && conf[name2] != null)
        return conf[name2];
      return defaults2[name2];
    }
    var keyMap2 = { Backspace: handleBackspace, Enter: handleEnter };
    function ensureBound(chars) {
      for (var i = 0; i < chars.length; i++) {
        var ch2 = chars.charAt(i), key = "'" + ch2 + "'";
        if (!keyMap2[key])
          keyMap2[key] = handler(ch2);
      }
    }
    ensureBound(defaults2.pairs + "`");
    function handler(ch2) {
      return function(cm) {
        return handleChar(cm, ch2);
      };
    }
    function getConfig(cm) {
      var deflt = cm.state.closeBrackets;
      if (!deflt || deflt.override)
        return deflt;
      var mode2 = cm.getModeAt(cm.getCursor());
      return mode2.closeBrackets || deflt;
    }
    function handleBackspace(cm) {
      var conf = getConfig(cm);
      if (!conf || cm.getOption("disableInput"))
        return CodeMirror2.Pass;
      var pairs = getOption(conf, "pairs");
      var ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty())
          return CodeMirror2.Pass;
        var around = charsAround(cm, ranges[i].head);
        if (!around || pairs.indexOf(around) % 2 != 0)
          return CodeMirror2.Pass;
      }
      for (var i = ranges.length - 1; i >= 0; i--) {
        var cur = ranges[i].head;
        cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
      }
    }
    function handleEnter(cm) {
      var conf = getConfig(cm);
      var explode = conf && getOption(conf, "explode");
      if (!explode || cm.getOption("disableInput"))
        return CodeMirror2.Pass;
      var ranges = cm.listSelections();
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty())
          return CodeMirror2.Pass;
        var around = charsAround(cm, ranges[i].head);
        if (!around || explode.indexOf(around) % 2 != 0)
          return CodeMirror2.Pass;
      }
      cm.operation(function() {
        var linesep = cm.lineSeparator() || "\n";
        cm.replaceSelection(linesep + linesep, null);
        moveSel(cm, -1);
        ranges = cm.listSelections();
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var line = ranges[i2].head.line;
          cm.indentLine(line, null, true);
          cm.indentLine(line + 1, null, true);
        }
      });
    }
    function moveSel(cm, dir) {
      var newRanges = [], ranges = cm.listSelections(), primary = 0;
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i];
        if (range2.head == cm.getCursor())
          primary = i;
        var pos = range2.head.ch || dir > 0 ? { line: range2.head.line, ch: range2.head.ch + dir } : { line: range2.head.line - 1 };
        newRanges.push({ anchor: pos, head: pos });
      }
      cm.setSelections(newRanges, primary);
    }
    function contractSelection(sel) {
      var inverted = CodeMirror2.cmpPos(sel.anchor, sel.head) > 0;
      return {
        anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
        head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
      };
    }
    function handleChar(cm, ch2) {
      var conf = getConfig(cm);
      if (!conf || cm.getOption("disableInput"))
        return CodeMirror2.Pass;
      var pairs = getOption(conf, "pairs");
      var pos = pairs.indexOf(ch2);
      if (pos == -1)
        return CodeMirror2.Pass;
      var closeBefore = getOption(conf, "closeBefore");
      var triples = getOption(conf, "triples");
      var identical2 = pairs.charAt(pos + 1) == ch2;
      var ranges = cm.listSelections();
      var opening = pos % 2 == 0;
      var type2;
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i], cur = range2.head, curType;
        var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
        if (opening && !range2.empty()) {
          curType = "surround";
        } else if ((identical2 || !opening) && next == ch2) {
          if (identical2 && stringStartsAfter(cm, cur))
            curType = "both";
          else if (triples.indexOf(ch2) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch2 + ch2 + ch2)
            curType = "skipThree";
          else
            curType = "skip";
        } else if (identical2 && cur.ch > 1 && triples.indexOf(ch2) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch2 + ch2) {
          if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))))
            return CodeMirror2.Pass;
          curType = "addFour";
        } else if (identical2) {
          var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
          if (!CodeMirror2.isWordChar(next) && prev != ch2 && !CodeMirror2.isWordChar(prev))
            curType = "both";
          else
            return CodeMirror2.Pass;
        } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
          curType = "both";
        } else {
          return CodeMirror2.Pass;
        }
        if (!type2)
          type2 = curType;
        else if (type2 != curType)
          return CodeMirror2.Pass;
      }
      var left = pos % 2 ? pairs.charAt(pos - 1) : ch2;
      var right = pos % 2 ? ch2 : pairs.charAt(pos + 1);
      cm.operation(function() {
        if (type2 == "skip") {
          moveSel(cm, 1);
        } else if (type2 == "skipThree") {
          moveSel(cm, 3);
        } else if (type2 == "surround") {
          var sels = cm.getSelections();
          for (var i2 = 0; i2 < sels.length; i2++)
            sels[i2] = left + sels[i2] + right;
          cm.replaceSelections(sels, "around");
          sels = cm.listSelections().slice();
          for (var i2 = 0; i2 < sels.length; i2++)
            sels[i2] = contractSelection(sels[i2]);
          cm.setSelections(sels);
        } else if (type2 == "both") {
          cm.replaceSelection(left + right, null);
          cm.triggerElectric(left + right);
          moveSel(cm, -1);
        } else if (type2 == "addFour") {
          cm.replaceSelection(left + left + left + left, "before");
          moveSel(cm, 1);
        }
      });
    }
    function charsAround(cm, pos) {
      var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
      return str.length == 2 ? str : null;
    }
    function stringStartsAfter(cm, pos) {
      var token2 = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
      return /\bstring/.test(token2.type) && token2.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)));
    }
  });
})();
var foldcode = { exports: {} };
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    function doFold(cm, pos, options, force) {
      if (options && options.call) {
        var finder = options;
        options = null;
      } else {
        var finder = getOption(cm, options, "rangeFinder");
      }
      if (typeof pos == "number")
        pos = CodeMirror2.Pos(pos, 0);
      var minSize = getOption(cm, options, "minFoldSize");
      function getRange2(allowFolded) {
        var range3 = finder(cm, pos);
        if (!range3 || range3.to.line - range3.from.line < minSize)
          return null;
        if (force === "fold")
          return range3;
        var marks = cm.findMarksAt(range3.from);
        for (var i = 0; i < marks.length; ++i) {
          if (marks[i].__isFold) {
            if (!allowFolded)
              return null;
            range3.cleared = true;
            marks[i].clear();
          }
        }
        return range3;
      }
      var range2 = getRange2(true);
      if (getOption(cm, options, "scanUp"))
        while (!range2 && pos.line > cm.firstLine()) {
          pos = CodeMirror2.Pos(pos.line - 1, 0);
          range2 = getRange2(false);
        }
      if (!range2 || range2.cleared || force === "unfold")
        return;
      var myWidget = makeWidget(cm, options, range2);
      CodeMirror2.on(myWidget, "mousedown", function(e) {
        myRange.clear();
        CodeMirror2.e_preventDefault(e);
      });
      var myRange = cm.markText(range2.from, range2.to, {
        replacedWith: myWidget,
        clearOnEnter: getOption(cm, options, "clearOnEnter"),
        __isFold: true
      });
      myRange.on("clear", function(from, to) {
        CodeMirror2.signal(cm, "unfold", cm, from, to);
      });
      CodeMirror2.signal(cm, "fold", cm, range2.from, range2.to);
    }
    function makeWidget(cm, options, range2) {
      var widget = getOption(cm, options, "widget");
      if (typeof widget == "function") {
        widget = widget(range2.from, range2.to);
      }
      if (typeof widget == "string") {
        var text3 = document.createTextNode(widget);
        widget = document.createElement("span");
        widget.appendChild(text3);
        widget.className = "CodeMirror-foldmarker";
      } else if (widget) {
        widget = widget.cloneNode(true);
      }
      return widget;
    }
    CodeMirror2.newFoldFunction = function(rangeFinder, widget) {
      return function(cm, pos) {
        doFold(cm, pos, { rangeFinder, widget });
      };
    };
    CodeMirror2.defineExtension("foldCode", function(pos, options, force) {
      doFold(this, pos, options, force);
    });
    CodeMirror2.defineExtension("isFolded", function(pos) {
      var marks = this.findMarksAt(pos);
      for (var i = 0; i < marks.length; ++i)
        if (marks[i].__isFold)
          return true;
    });
    CodeMirror2.commands.toggleFold = function(cm) {
      cm.foldCode(cm.getCursor());
    };
    CodeMirror2.commands.fold = function(cm) {
      cm.foldCode(cm.getCursor(), null, "fold");
    };
    CodeMirror2.commands.unfold = function(cm) {
      cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
    };
    CodeMirror2.commands.foldAll = function(cm) {
      cm.operation(function() {
        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
          cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "fold");
      });
    };
    CodeMirror2.commands.unfoldAll = function(cm) {
      cm.operation(function() {
        for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
          cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "unfold");
      });
    };
    CodeMirror2.registerHelper("fold", "combine", function() {
      var funcs = Array.prototype.slice.call(arguments, 0);
      return function(cm, start2) {
        for (var i = 0; i < funcs.length; ++i) {
          var found = funcs[i](cm, start2);
          if (found)
            return found;
        }
      };
    });
    CodeMirror2.registerHelper("fold", "auto", function(cm, start2) {
      var helpers2 = cm.getHelpers(start2, "fold");
      for (var i = 0; i < helpers2.length; i++) {
        var cur = helpers2[i](cm, start2);
        if (cur)
          return cur;
      }
    });
    var defaultOptions2 = {
      rangeFinder: CodeMirror2.fold.auto,
      widget: "\u2194",
      minFoldSize: 0,
      scanUp: false,
      clearOnEnter: true
    };
    CodeMirror2.defineOption("foldOptions", null);
    function getOption(cm, options, name2) {
      if (options && options[name2] !== void 0)
        return options[name2];
      var editorOptions = cm.options.foldOptions;
      if (editorOptions && editorOptions[name2] !== void 0)
        return editorOptions[name2];
      return defaultOptions2[name2];
    }
    CodeMirror2.defineExtension("foldOption", function(options, name2) {
      return getOption(this, options, name2);
    });
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports, foldcode.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("foldGutter", false, function(cm, val, old) {
      if (old && old != CodeMirror2.Init) {
        cm.clearGutter(cm.state.foldGutter.options.gutter);
        cm.state.foldGutter = null;
        cm.off("gutterClick", onGutterClick);
        cm.off("changes", onChange);
        cm.off("viewportChange", onViewportChange);
        cm.off("fold", onFold);
        cm.off("unfold", onFold);
        cm.off("swapDoc", onChange);
      }
      if (val) {
        cm.state.foldGutter = new State(parseOptions(val));
        updateInViewport(cm);
        cm.on("gutterClick", onGutterClick);
        cm.on("changes", onChange);
        cm.on("viewportChange", onViewportChange);
        cm.on("fold", onFold);
        cm.on("unfold", onFold);
        cm.on("swapDoc", onChange);
      }
    });
    var Pos = CodeMirror2.Pos;
    function State(options) {
      this.options = options;
      this.from = this.to = 0;
    }
    function parseOptions(opts) {
      if (opts === true)
        opts = {};
      if (opts.gutter == null)
        opts.gutter = "CodeMirror-foldgutter";
      if (opts.indicatorOpen == null)
        opts.indicatorOpen = "CodeMirror-foldgutter-open";
      if (opts.indicatorFolded == null)
        opts.indicatorFolded = "CodeMirror-foldgutter-folded";
      return opts;
    }
    function isFolded(cm, line) {
      var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
      for (var i = 0; i < marks.length; ++i) {
        if (marks[i].__isFold) {
          var fromPos = marks[i].find(-1);
          if (fromPos && fromPos.line === line)
            return marks[i];
        }
      }
    }
    function marker2(spec) {
      if (typeof spec == "string") {
        var elt = document.createElement("div");
        elt.className = spec + " CodeMirror-guttermarker-subtle";
        return elt;
      } else {
        return spec.cloneNode(true);
      }
    }
    function updateFoldInfo(cm, from, to) {
      var opts = cm.state.foldGutter.options, cur = from - 1;
      var minSize = cm.foldOption(opts, "minFoldSize");
      var func = cm.foldOption(opts, "rangeFinder");
      var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);
      var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);
      cm.eachLine(from, to, function(line) {
        ++cur;
        var mark = null;
        var old = line.gutterMarkers;
        if (old)
          old = old[opts.gutter];
        if (isFolded(cm, cur)) {
          if (clsFolded && old && clsFolded.test(old.className))
            return;
          mark = marker2(opts.indicatorFolded);
        } else {
          var pos = Pos(cur, 0);
          var range2 = func && func(cm, pos);
          if (range2 && range2.to.line - range2.from.line >= minSize) {
            if (clsOpen && old && clsOpen.test(old.className))
              return;
            mark = marker2(opts.indicatorOpen);
          }
        }
        if (!mark && !old)
          return;
        cm.setGutterMarker(line, opts.gutter, mark);
      });
    }
    function classTest(cls) {
      return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
    }
    function updateInViewport(cm) {
      var vp = cm.getViewport(), state = cm.state.foldGutter;
      if (!state)
        return;
      cm.operation(function() {
        updateFoldInfo(cm, vp.from, vp.to);
      });
      state.from = vp.from;
      state.to = vp.to;
    }
    function onGutterClick(cm, line, gutter) {
      var state = cm.state.foldGutter;
      if (!state)
        return;
      var opts = state.options;
      if (gutter != opts.gutter)
        return;
      var folded = isFolded(cm, line);
      if (folded)
        folded.clear();
      else
        cm.foldCode(Pos(line, 0), opts);
    }
    function onChange(cm) {
      var state = cm.state.foldGutter;
      if (!state)
        return;
      var opts = state.options;
      state.from = state.to = 0;
      clearTimeout(state.changeUpdate);
      state.changeUpdate = setTimeout(function() {
        updateInViewport(cm);
      }, opts.foldOnChangeTimeSpan || 600);
    }
    function onViewportChange(cm) {
      var state = cm.state.foldGutter;
      if (!state)
        return;
      var opts = state.options;
      clearTimeout(state.changeUpdate);
      state.changeUpdate = setTimeout(function() {
        var vp = cm.getViewport();
        if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
          updateInViewport(cm);
        } else {
          cm.operation(function() {
            if (vp.from < state.from) {
              updateFoldInfo(cm, vp.from, state.from);
              state.from = vp.from;
            }
            if (vp.to > state.to) {
              updateFoldInfo(cm, state.to, vp.to);
              state.to = vp.to;
            }
          });
        }
      }, opts.updateViewportTimeSpan || 400);
    }
    function onFold(cm, from) {
      var state = cm.state.foldGutter;
      if (!state)
        return;
      var line = from.line;
      if (line >= state.from && line < state.to)
        updateFoldInfo(cm, line, line + 1);
    }
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    function bracketFolding(pairs) {
      return function(cm, start2) {
        var line = start2.line, lineText = cm.getLine(line);
        function findOpening(pair) {
          var tokenType;
          for (var at = start2.ch, pass = 0; ; ) {
            var found2 = at <= 0 ? -1 : lineText.lastIndexOf(pair[0], at - 1);
            if (found2 == -1) {
              if (pass == 1)
                break;
              pass = 1;
              at = lineText.length;
              continue;
            }
            if (pass == 1 && found2 < start2.ch)
              break;
            tokenType = cm.getTokenTypeAt(CodeMirror2.Pos(line, found2 + 1));
            if (!/^(comment|string)/.test(tokenType))
              return { ch: found2 + 1, tokenType, pair };
            at = found2 - 1;
          }
        }
        function findRange(found2) {
          var count = 1, lastLine = cm.lastLine(), end2, startCh = found2.ch, endCh;
          outer:
            for (var i2 = line; i2 <= lastLine; ++i2) {
              var text3 = cm.getLine(i2), pos = i2 == line ? startCh : 0;
              for (; ; ) {
                var nextOpen = text3.indexOf(found2.pair[0], pos), nextClose = text3.indexOf(found2.pair[1], pos);
                if (nextOpen < 0)
                  nextOpen = text3.length;
                if (nextClose < 0)
                  nextClose = text3.length;
                pos = Math.min(nextOpen, nextClose);
                if (pos == text3.length)
                  break;
                if (cm.getTokenTypeAt(CodeMirror2.Pos(i2, pos + 1)) == found2.tokenType) {
                  if (pos == nextOpen)
                    ++count;
                  else if (!--count) {
                    end2 = i2;
                    endCh = pos;
                    break outer;
                  }
                }
                ++pos;
              }
            }
          if (end2 == null || line == end2)
            return null;
          return {
            from: CodeMirror2.Pos(line, startCh),
            to: CodeMirror2.Pos(end2, endCh)
          };
        }
        var found = [];
        for (var i = 0; i < pairs.length; i++) {
          var open = findOpening(pairs[i]);
          if (open)
            found.push(open);
        }
        found.sort(function(a, b) {
          return a.ch - b.ch;
        });
        for (var i = 0; i < found.length; i++) {
          var range2 = findRange(found[i]);
          if (range2)
            return range2;
        }
        return null;
      };
    }
    CodeMirror2.registerHelper("fold", "brace", bracketFolding([["{", "}"], ["[", "]"]]));
    CodeMirror2.registerHelper("fold", "brace-paren", bracketFolding([["{", "}"], ["[", "]"], ["(", ")"]]));
    CodeMirror2.registerHelper("fold", "import", function(cm, start2) {
      function hasImport(line) {
        if (line < cm.firstLine() || line > cm.lastLine())
          return null;
        var start3 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
        if (!/\S/.test(start3.string))
          start3 = cm.getTokenAt(CodeMirror2.Pos(line, start3.end + 1));
        if (start3.type != "keyword" || start3.string != "import")
          return null;
        for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
          var text3 = cm.getLine(i), semi2 = text3.indexOf(";");
          if (semi2 != -1)
            return { startCh: start3.end, end: CodeMirror2.Pos(i, semi2) };
        }
      }
      var startLine = start2.line, has2 = hasImport(startLine), prev;
      if (!has2 || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)
        return null;
      for (var end2 = has2.end; ; ) {
        var next = hasImport(end2.line + 1);
        if (next == null)
          break;
        end2 = next.end;
      }
      return { from: cm.clipPos(CodeMirror2.Pos(startLine, has2.startCh + 1)), to: end2 };
    });
    CodeMirror2.registerHelper("fold", "include", function(cm, start2) {
      function hasInclude(line) {
        if (line < cm.firstLine() || line > cm.lastLine())
          return null;
        var start3 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
        if (!/\S/.test(start3.string))
          start3 = cm.getTokenAt(CodeMirror2.Pos(line, start3.end + 1));
        if (start3.type == "meta" && start3.string.slice(0, 8) == "#include")
          return start3.start + 8;
      }
      var startLine = start2.line, has2 = hasInclude(startLine);
      if (has2 == null || hasInclude(startLine - 1) != null)
        return null;
      for (var end2 = startLine; ; ) {
        var next = hasInclude(end2 + 1);
        if (next == null)
          break;
        ++end2;
      }
      return {
        from: CodeMirror2.Pos(startLine, has2 + 1),
        to: cm.clipPos(CodeMirror2.Pos(end2))
      };
    });
  });
})();
var searchcursor = { exports: {} };
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    var Pos = CodeMirror2.Pos;
    function regexpFlags(regexp) {
      var flags = regexp.flags;
      return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
    }
    function ensureFlags(regexp, flags) {
      var current = regexpFlags(regexp), target2 = current;
      for (var i = 0; i < flags.length; i++)
        if (target2.indexOf(flags.charAt(i)) == -1)
          target2 += flags.charAt(i);
      return current == target2 ? regexp : new RegExp(regexp.source, target2);
    }
    function maybeMultiline(regexp) {
      return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
    }
    function searchRegexpForward(doc, regexp, start2) {
      regexp = ensureFlags(regexp, "g");
      for (var line = start2.line, ch2 = start2.ch, last = doc.lastLine(); line <= last; line++, ch2 = 0) {
        regexp.lastIndex = ch2;
        var string2 = doc.getLine(line), match2 = regexp.exec(string2);
        if (match2)
          return {
            from: Pos(line, match2.index),
            to: Pos(line, match2.index + match2[0].length),
            match: match2
          };
      }
    }
    function searchRegexpForwardMultiline(doc, regexp, start2) {
      if (!maybeMultiline(regexp))
        return searchRegexpForward(doc, regexp, start2);
      regexp = ensureFlags(regexp, "gm");
      var string2, chunk = 1;
      for (var line = start2.line, last = doc.lastLine(); line <= last; ) {
        for (var i = 0; i < chunk; i++) {
          if (line > last)
            break;
          var curLine = doc.getLine(line++);
          string2 = string2 == null ? curLine : string2 + "\n" + curLine;
        }
        chunk = chunk * 2;
        regexp.lastIndex = start2.ch;
        var match2 = regexp.exec(string2);
        if (match2) {
          var before = string2.slice(0, match2.index).split("\n"), inside = match2[0].split("\n");
          var startLine = start2.line + before.length - 1, startCh = before[before.length - 1].length;
          return {
            from: Pos(startLine, startCh),
            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
            match: match2
          };
        }
      }
    }
    function lastMatchIn(string2, regexp, endMargin) {
      var match2, from = 0;
      while (from <= string2.length) {
        regexp.lastIndex = from;
        var newMatch = regexp.exec(string2);
        if (!newMatch)
          break;
        var end2 = newMatch.index + newMatch[0].length;
        if (end2 > string2.length - endMargin)
          break;
        if (!match2 || end2 > match2.index + match2[0].length)
          match2 = newMatch;
        from = newMatch.index + 1;
      }
      return match2;
    }
    function searchRegexpBackward(doc, regexp, start2) {
      regexp = ensureFlags(regexp, "g");
      for (var line = start2.line, ch2 = start2.ch, first = doc.firstLine(); line >= first; line--, ch2 = -1) {
        var string2 = doc.getLine(line);
        var match2 = lastMatchIn(string2, regexp, ch2 < 0 ? 0 : string2.length - ch2);
        if (match2)
          return {
            from: Pos(line, match2.index),
            to: Pos(line, match2.index + match2[0].length),
            match: match2
          };
      }
    }
    function searchRegexpBackwardMultiline(doc, regexp, start2) {
      if (!maybeMultiline(regexp))
        return searchRegexpBackward(doc, regexp, start2);
      regexp = ensureFlags(regexp, "gm");
      var string2, chunkSize = 1, endMargin = doc.getLine(start2.line).length - start2.ch;
      for (var line = start2.line, first = doc.firstLine(); line >= first; ) {
        for (var i = 0; i < chunkSize && line >= first; i++) {
          var curLine = doc.getLine(line--);
          string2 = string2 == null ? curLine : curLine + "\n" + string2;
        }
        chunkSize *= 2;
        var match2 = lastMatchIn(string2, regexp, endMargin);
        if (match2) {
          var before = string2.slice(0, match2.index).split("\n"), inside = match2[0].split("\n");
          var startLine = line + before.length, startCh = before[before.length - 1].length;
          return {
            from: Pos(startLine, startCh),
            to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
            match: match2
          };
        }
      }
    }
    var doFold, noFold;
    if (String.prototype.normalize) {
      doFold = function(str) {
        return str.normalize("NFD").toLowerCase();
      };
      noFold = function(str) {
        return str.normalize("NFD");
      };
    } else {
      doFold = function(str) {
        return str.toLowerCase();
      };
      noFold = function(str) {
        return str;
      };
    }
    function adjustPos(orig, folded, pos, foldFunc) {
      if (orig.length == folded.length)
        return pos;
      for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ; ) {
        if (min == max)
          return min;
        var mid2 = min + max >> 1;
        var len = foldFunc(orig.slice(0, mid2)).length;
        if (len == pos)
          return mid2;
        else if (len > pos)
          max = mid2;
        else
          min = mid2 + 1;
      }
    }
    function searchStringForward(doc, query, start2, caseFold) {
      if (!query.length)
        return null;
      var fold = caseFold ? doFold : noFold;
      var lines = fold(query).split(/\r|\n\r?/);
      search:
        for (var line = start2.line, ch2 = start2.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch2 = 0) {
          var orig = doc.getLine(line).slice(ch2), string2 = fold(orig);
          if (lines.length == 1) {
            var found = string2.indexOf(lines[0]);
            if (found == -1)
              continue search;
            var start2 = adjustPos(orig, string2, found, fold) + ch2;
            return {
              from: Pos(line, adjustPos(orig, string2, found, fold) + ch2),
              to: Pos(line, adjustPos(orig, string2, found + lines[0].length, fold) + ch2)
            };
          } else {
            var cutFrom = string2.length - lines[0].length;
            if (string2.slice(cutFrom) != lines[0])
              continue search;
            for (var i = 1; i < lines.length - 1; i++)
              if (fold(doc.getLine(line + i)) != lines[i])
                continue search;
            var end2 = doc.getLine(line + lines.length - 1), endString = fold(end2), lastLine = lines[lines.length - 1];
            if (endString.slice(0, lastLine.length) != lastLine)
              continue search;
            return {
              from: Pos(line, adjustPos(orig, string2, cutFrom, fold) + ch2),
              to: Pos(line + lines.length - 1, adjustPos(end2, endString, lastLine.length, fold))
            };
          }
        }
    }
    function searchStringBackward(doc, query, start2, caseFold) {
      if (!query.length)
        return null;
      var fold = caseFold ? doFold : noFold;
      var lines = fold(query).split(/\r|\n\r?/);
      search:
        for (var line = start2.line, ch2 = start2.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch2 = -1) {
          var orig = doc.getLine(line);
          if (ch2 > -1)
            orig = orig.slice(0, ch2);
          var string2 = fold(orig);
          if (lines.length == 1) {
            var found = string2.lastIndexOf(lines[0]);
            if (found == -1)
              continue search;
            return {
              from: Pos(line, adjustPos(orig, string2, found, fold)),
              to: Pos(line, adjustPos(orig, string2, found + lines[0].length, fold))
            };
          } else {
            var lastLine = lines[lines.length - 1];
            if (string2.slice(0, lastLine.length) != lastLine)
              continue search;
            for (var i = 1, start2 = line - lines.length + 1; i < lines.length - 1; i++)
              if (fold(doc.getLine(start2 + i)) != lines[i])
                continue search;
            var top2 = doc.getLine(line + 1 - lines.length), topString = fold(top2);
            if (topString.slice(topString.length - lines[0].length) != lines[0])
              continue search;
            return {
              from: Pos(line + 1 - lines.length, adjustPos(top2, topString, top2.length - lines[0].length, fold)),
              to: Pos(line, adjustPos(orig, string2, lastLine.length, fold))
            };
          }
        }
    }
    function SearchCursor(doc, query, pos, options) {
      this.atOccurrence = false;
      this.afterEmptyMatch = false;
      this.doc = doc;
      pos = pos ? doc.clipPos(pos) : Pos(0, 0);
      this.pos = { from: pos, to: pos };
      var caseFold;
      if (typeof options == "object") {
        caseFold = options.caseFold;
      } else {
        caseFold = options;
        options = null;
      }
      if (typeof query == "string") {
        if (caseFold == null)
          caseFold = false;
        this.matches = function(reverse, pos2) {
          return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);
        };
      } else {
        query = ensureFlags(query, "gm");
        if (!options || options.multiline !== false)
          this.matches = function(reverse, pos2) {
            return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);
          };
        else
          this.matches = function(reverse, pos2) {
            return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);
          };
      }
    }
    SearchCursor.prototype = {
      findNext: function() {
        return this.find(false);
      },
      findPrevious: function() {
        return this.find(true);
      },
      find: function(reverse) {
        var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
        if (this.afterEmptyMatch && this.atOccurrence) {
          head = Pos(head.line, head.ch);
          if (reverse) {
            head.ch--;
            if (head.ch < 0) {
              head.line--;
              head.ch = (this.doc.getLine(head.line) || "").length;
            }
          } else {
            head.ch++;
            if (head.ch > (this.doc.getLine(head.line) || "").length) {
              head.ch = 0;
              head.line++;
            }
          }
          if (CodeMirror2.cmpPos(head, this.doc.clipPos(head)) != 0) {
            return this.atOccurrence = false;
          }
        }
        var result2 = this.matches(reverse, head);
        this.afterEmptyMatch = result2 && CodeMirror2.cmpPos(result2.from, result2.to) == 0;
        if (result2) {
          this.pos = result2;
          this.atOccurrence = true;
          return this.pos.match || true;
        } else {
          var end2 = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
          this.pos = { from: end2, to: end2 };
          return this.atOccurrence = false;
        }
      },
      from: function() {
        if (this.atOccurrence)
          return this.pos.from;
      },
      to: function() {
        if (this.atOccurrence)
          return this.pos.to;
      },
      replace: function(newText, origin) {
        if (!this.atOccurrence)
          return;
        var lines = CodeMirror2.splitLines(newText);
        this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
        this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
      }
    };
    CodeMirror2.defineExtension("getSearchCursor", function(query, pos, caseFold) {
      return new SearchCursor(this.doc, query, pos, caseFold);
    });
    CodeMirror2.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
      return new SearchCursor(this, query, pos, caseFold);
    });
    CodeMirror2.defineExtension("selectMatches", function(query, caseFold) {
      var ranges = [];
      var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
      while (cur.findNext()) {
        if (CodeMirror2.cmpPos(cur.to(), this.getCursor("to")) > 0)
          break;
        ranges.push({ anchor: cur.from(), head: cur.to() });
      }
      if (ranges.length)
        this.setSelections(ranges, 0);
    });
  });
})();
var dialog = { exports: {} };
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    function dialogDiv(cm, template, bottom2) {
      var wrap2 = cm.getWrapperElement();
      var dialog2;
      dialog2 = wrap2.appendChild(document.createElement("div"));
      if (bottom2)
        dialog2.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
      else
        dialog2.className = "CodeMirror-dialog CodeMirror-dialog-top";
      if (typeof template == "string") {
        dialog2.innerHTML = template;
      } else {
        dialog2.appendChild(template);
      }
      CodeMirror2.addClass(wrap2, "dialog-opened");
      return dialog2;
    }
    function closeNotification(cm, newVal) {
      if (cm.state.currentNotificationClose)
        cm.state.currentNotificationClose();
      cm.state.currentNotificationClose = newVal;
    }
    CodeMirror2.defineExtension("openDialog", function(template, callback, options) {
      if (!options)
        options = {};
      closeNotification(this, null);
      var dialog2 = dialogDiv(this, template, options.bottom);
      var closed = false, me2 = this;
      function close(newVal) {
        if (typeof newVal == "string") {
          inp.value = newVal;
        } else {
          if (closed)
            return;
          closed = true;
          CodeMirror2.rmClass(dialog2.parentNode, "dialog-opened");
          dialog2.parentNode.removeChild(dialog2);
          me2.focus();
          if (options.onClose)
            options.onClose(dialog2);
        }
      }
      var inp = dialog2.getElementsByTagName("input")[0], button;
      if (inp) {
        inp.focus();
        if (options.value) {
          inp.value = options.value;
          if (options.selectValueOnOpen !== false) {
            inp.select();
          }
        }
        if (options.onInput)
          CodeMirror2.on(inp, "input", function(e) {
            options.onInput(e, inp.value, close);
          });
        if (options.onKeyUp)
          CodeMirror2.on(inp, "keyup", function(e) {
            options.onKeyUp(e, inp.value, close);
          });
        CodeMirror2.on(inp, "keydown", function(e) {
          if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {
            return;
          }
          if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {
            inp.blur();
            CodeMirror2.e_stop(e);
            close();
          }
          if (e.keyCode == 13)
            callback(inp.value, e);
        });
        if (options.closeOnBlur !== false)
          CodeMirror2.on(dialog2, "focusout", function(evt) {
            if (evt.relatedTarget !== null)
              close();
          });
      } else if (button = dialog2.getElementsByTagName("button")[0]) {
        CodeMirror2.on(button, "click", function() {
          close();
          me2.focus();
        });
        if (options.closeOnBlur !== false)
          CodeMirror2.on(button, "blur", close);
        button.focus();
      }
      return close;
    });
    CodeMirror2.defineExtension("openConfirm", function(template, callbacks, options) {
      closeNotification(this, null);
      var dialog2 = dialogDiv(this, template, options && options.bottom);
      var buttons = dialog2.getElementsByTagName("button");
      var closed = false, me2 = this, blurring = 1;
      function close() {
        if (closed)
          return;
        closed = true;
        CodeMirror2.rmClass(dialog2.parentNode, "dialog-opened");
        dialog2.parentNode.removeChild(dialog2);
        me2.focus();
      }
      buttons[0].focus();
      for (var i = 0; i < buttons.length; ++i) {
        var b = buttons[i];
        (function(callback) {
          CodeMirror2.on(b, "click", function(e) {
            CodeMirror2.e_preventDefault(e);
            close();
            if (callback)
              callback(me2);
          });
        })(callbacks[i]);
        CodeMirror2.on(b, "blur", function() {
          --blurring;
          setTimeout(function() {
            if (blurring <= 0)
              close();
          }, 200);
        });
        CodeMirror2.on(b, "focus", function() {
          ++blurring;
        });
      }
    });
    CodeMirror2.defineExtension("openNotification", function(template, options) {
      closeNotification(this, close);
      var dialog2 = dialogDiv(this, template, options && options.bottom);
      var closed = false, doneTimer;
      var duration = options && typeof options.duration !== "undefined" ? options.duration : 5e3;
      function close() {
        if (closed)
          return;
        closed = true;
        clearTimeout(doneTimer);
        CodeMirror2.rmClass(dialog2.parentNode, "dialog-opened");
        dialog2.parentNode.removeChild(dialog2);
      }
      CodeMirror2.on(dialog2, "click", function(e) {
        CodeMirror2.e_preventDefault(e);
        close();
      });
      if (duration)
        doneTimer = setTimeout(close, duration);
      return close;
    });
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports, searchcursor.exports, dialog.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("search", { bottom: false });
    function searchOverlay(query, caseInsensitive) {
      if (typeof query == "string")
        query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
      else if (!query.global)
        query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");
      return { token: function(stream) {
        query.lastIndex = stream.pos;
        var match2 = query.exec(stream.string);
        if (match2 && match2.index == stream.pos) {
          stream.pos += match2[0].length || 1;
          return "searching";
        } else if (match2) {
          stream.pos = match2.index;
        } else {
          stream.skipToEnd();
        }
      } };
    }
    function SearchState() {
      this.posFrom = this.posTo = this.lastQuery = this.query = null;
      this.overlay = null;
    }
    function getSearchState(cm) {
      return cm.state.search || (cm.state.search = new SearchState());
    }
    function queryCaseInsensitive(query) {
      return typeof query == "string" && query == query.toLowerCase();
    }
    function getSearchCursor(cm, query, pos) {
      return cm.getSearchCursor(query, pos, { caseFold: queryCaseInsensitive(query), multiline: true });
    }
    function persistentDialog(cm, text3, deflt, onEnter, onKeyDown2) {
      cm.openDialog(text3, onEnter, {
        value: deflt,
        selectValueOnOpen: true,
        closeOnEnter: false,
        onClose: function() {
          clearSearch(cm);
        },
        onKeyDown: onKeyDown2,
        bottom: cm.options.search.bottom
      });
    }
    function dialog2(cm, text3, shortText, deflt, f) {
      if (cm.openDialog)
        cm.openDialog(text3, f, { value: deflt, selectValueOnOpen: true, bottom: cm.options.search.bottom });
      else
        f(prompt(shortText, deflt));
    }
    function confirmDialog(cm, text3, shortText, fs) {
      if (cm.openConfirm)
        cm.openConfirm(text3, fs);
      else if (confirm(shortText))
        fs[0]();
    }
    function parseString(string2) {
      return string2.replace(/\\([nrt\\])/g, function(match2, ch2) {
        if (ch2 == "n")
          return "\n";
        if (ch2 == "r")
          return "\r";
        if (ch2 == "t")
          return "	";
        if (ch2 == "\\")
          return "\\";
        return match2;
      });
    }
    function parseQuery2(query) {
      var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
      if (isRE) {
        try {
          query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i");
        } catch (e) {
        }
      } else {
        query = parseString(query);
      }
      if (typeof query == "string" ? query == "" : query.test(""))
        query = /x^/;
      return query;
    }
    function startSearch(cm, state, query) {
      state.queryText = query;
      state.query = parseQuery2(query);
      cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
      state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
      cm.addOverlay(state.overlay);
      if (cm.showMatchesOnScrollbar) {
        if (state.annotate) {
          state.annotate.clear();
          state.annotate = null;
        }
        state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
      }
    }
    function doSearch(cm, rev, persistent, immediate) {
      var state = getSearchState(cm);
      if (state.query)
        return findNext(cm, rev);
      var q2 = cm.getSelection() || state.lastQuery;
      if (q2 instanceof RegExp && q2.source == "x^")
        q2 = null;
      if (persistent && cm.openDialog) {
        var hiding = null;
        var searchNext = function(query, event) {
          CodeMirror2.e_stop(event);
          if (!query)
            return;
          if (query != state.queryText) {
            startSearch(cm, state, query);
            state.posFrom = state.posTo = cm.getCursor();
          }
          if (hiding)
            hiding.style.opacity = 1;
          findNext(cm, event.shiftKey, function(_, to) {
            var dialog3;
            if (to.line < 3 && document.querySelector && (dialog3 = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog3.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)
              (hiding = dialog3).style.opacity = 0.4;
          });
        };
        persistentDialog(cm, getQueryDialog(cm), q2, searchNext, function(event, query) {
          var keyName = CodeMirror2.keyName(event);
          var extra = cm.getOption("extraKeys"), cmd = extra && extra[keyName] || CodeMirror2.keyMap[cm.getOption("keyMap")][keyName];
          if (cmd == "findNext" || cmd == "findPrev" || cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
            CodeMirror2.e_stop(event);
            startSearch(cm, getSearchState(cm), query);
            cm.execCommand(cmd);
          } else if (cmd == "find" || cmd == "findPersistent") {
            CodeMirror2.e_stop(event);
            searchNext(query, event);
          }
        });
        if (immediate && q2) {
          startSearch(cm, state, q2);
          findNext(cm, rev);
        }
      } else {
        dialog2(cm, getQueryDialog(cm), "Search for:", q2, function(query) {
          if (query && !state.query)
            cm.operation(function() {
              startSearch(cm, state, query);
              state.posFrom = state.posTo = cm.getCursor();
              findNext(cm, rev);
            });
        });
      }
    }
    function findNext(cm, rev, callback) {
      cm.operation(function() {
        var state = getSearchState(cm);
        var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
        if (!cursor.find(rev)) {
          cursor = getSearchCursor(cm, state.query, rev ? CodeMirror2.Pos(cm.lastLine()) : CodeMirror2.Pos(cm.firstLine(), 0));
          if (!cursor.find(rev))
            return;
        }
        cm.setSelection(cursor.from(), cursor.to());
        cm.scrollIntoView({ from: cursor.from(), to: cursor.to() }, 20);
        state.posFrom = cursor.from();
        state.posTo = cursor.to();
        if (callback)
          callback(cursor.from(), cursor.to());
      });
    }
    function clearSearch(cm) {
      cm.operation(function() {
        var state = getSearchState(cm);
        state.lastQuery = state.query;
        if (!state.query)
          return;
        state.query = state.queryText = null;
        cm.removeOverlay(state.overlay);
        if (state.annotate) {
          state.annotate.clear();
          state.annotate = null;
        }
      });
    }
    function el2(tag, attrs) {
      var element = tag ? document.createElement(tag) : document.createDocumentFragment();
      for (var key in attrs) {
        element[key] = attrs[key];
      }
      for (var i = 2; i < arguments.length; i++) {
        var child = arguments[i];
        element.appendChild(typeof child == "string" ? document.createTextNode(child) : child);
      }
      return element;
    }
    function getQueryDialog(cm) {
      return el2("", null, el2("span", { className: "CodeMirror-search-label" }, cm.phrase("Search:")), " ", el2("input", { type: "text", "style": "width: 10em", className: "CodeMirror-search-field" }), " ", el2("span", { style: "color: #888", className: "CodeMirror-search-hint" }, cm.phrase("(Use /re/ syntax for regexp search)")));
    }
    function getReplaceQueryDialog(cm) {
      return el2("", null, " ", el2("input", { type: "text", "style": "width: 10em", className: "CodeMirror-search-field" }), " ", el2("span", { style: "color: #888", className: "CodeMirror-search-hint" }, cm.phrase("(Use /re/ syntax for regexp search)")));
    }
    function getReplacementQueryDialog(cm) {
      return el2("", null, el2("span", { className: "CodeMirror-search-label" }, cm.phrase("With:")), " ", el2("input", { type: "text", "style": "width: 10em", className: "CodeMirror-search-field" }));
    }
    function getDoReplaceConfirm(cm) {
      return el2("", null, el2("span", { className: "CodeMirror-search-label" }, cm.phrase("Replace?")), " ", el2("button", {}, cm.phrase("Yes")), " ", el2("button", {}, cm.phrase("No")), " ", el2("button", {}, cm.phrase("All")), " ", el2("button", {}, cm.phrase("Stop")));
    }
    function replaceAll(cm, query, text3) {
      cm.operation(function() {
        for (var cursor = getSearchCursor(cm, query); cursor.findNext(); ) {
          if (typeof query != "string") {
            var match2 = cm.getRange(cursor.from(), cursor.to()).match(query);
            cursor.replace(text3.replace(/\$(\d)/g, function(_, i) {
              return match2[i];
            }));
          } else
            cursor.replace(text3);
        }
      });
    }
    function replace2(cm, all) {
      if (cm.getOption("readOnly"))
        return;
      var query = cm.getSelection() || getSearchState(cm).lastQuery;
      var dialogText = all ? cm.phrase("Replace all:") : cm.phrase("Replace:");
      var fragment = el2("", null, el2("span", { className: "CodeMirror-search-label" }, dialogText), getReplaceQueryDialog(cm));
      dialog2(cm, fragment, dialogText, query, function(query2) {
        if (!query2)
          return;
        query2 = parseQuery2(query2);
        dialog2(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function(text3) {
          text3 = parseString(text3);
          if (all) {
            replaceAll(cm, query2, text3);
          } else {
            clearSearch(cm);
            var cursor = getSearchCursor(cm, query2, cm.getCursor("from"));
            var advance = function() {
              var start2 = cursor.from(), match2;
              if (!(match2 = cursor.findNext())) {
                cursor = getSearchCursor(cm, query2);
                if (!(match2 = cursor.findNext()) || start2 && cursor.from().line == start2.line && cursor.from().ch == start2.ch)
                  return;
              }
              cm.setSelection(cursor.from(), cursor.to());
              cm.scrollIntoView({ from: cursor.from(), to: cursor.to() });
              confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"), [
                function() {
                  doReplace(match2);
                },
                advance,
                function() {
                  replaceAll(cm, query2, text3);
                }
              ]);
            };
            var doReplace = function(match2) {
              cursor.replace(typeof query2 == "string" ? text3 : text3.replace(/\$(\d)/g, function(_, i) {
                return match2[i];
              }));
              advance();
            };
            advance();
          }
        });
      });
    }
    CodeMirror2.commands.find = function(cm) {
      clearSearch(cm);
      doSearch(cm);
    };
    CodeMirror2.commands.findPersistent = function(cm) {
      clearSearch(cm);
      doSearch(cm, false, true);
    };
    CodeMirror2.commands.findPersistentNext = function(cm) {
      doSearch(cm, false, true, true);
    };
    CodeMirror2.commands.findPersistentPrev = function(cm) {
      doSearch(cm, true, true, true);
    };
    CodeMirror2.commands.findNext = doSearch;
    CodeMirror2.commands.findPrev = function(cm) {
      doSearch(cm, true);
    };
    CodeMirror2.commands.clearSearch = clearSearch;
    CodeMirror2.commands.replace = replace2;
    CodeMirror2.commands.replaceAll = function(cm) {
      replace2(cm, true);
    };
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports, dialog.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineOption("search", { bottom: false });
    function dialog2(cm, text3, shortText, deflt, f) {
      if (cm.openDialog)
        cm.openDialog(text3, f, { value: deflt, selectValueOnOpen: true, bottom: cm.options.search.bottom });
      else
        f(prompt(shortText, deflt));
    }
    function getJumpDialog(cm) {
      return cm.phrase("Jump to line:") + ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use line:column or scroll% syntax)") + "</span>";
    }
    function interpretLine(cm, string2) {
      var num2 = Number(string2);
      if (/^[-+]/.test(string2))
        return cm.getCursor().line + num2;
      else
        return num2 - 1;
    }
    CodeMirror2.commands.jumpToLine = function(cm) {
      var cur = cm.getCursor();
      dialog2(cm, getJumpDialog(cm), cm.phrase("Jump to line:"), cur.line + 1 + ":" + cur.ch, function(posStr) {
        if (!posStr)
          return;
        var match2;
        if (match2 = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) {
          cm.setCursor(interpretLine(cm, match2[1]), Number(match2[2]));
        } else if (match2 = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
          var line = Math.round(cm.lineCount() * Number(match2[1]) / 100);
          if (/^[-+]/.test(match2[1]))
            line = cur.line + line + 1;
          cm.setCursor(line - 1, cur.ch);
        } else if (match2 = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) {
          cm.setCursor(interpretLine(cm, match2[1]), cur.ch);
        }
      });
    };
    CodeMirror2.keyMap["default"]["Alt-G"] = "jumpToLine";
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    var GUTTER_ID = "CodeMirror-lint-markers";
    var LINT_LINE_ID = "CodeMirror-lint-line-";
    function showTooltip(cm, e, content) {
      var tt = document.createElement("div");
      tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;
      tt.appendChild(content.cloneNode(true));
      if (cm.state.lint.options.selfContain)
        cm.getWrapperElement().appendChild(tt);
      else
        document.body.appendChild(tt);
      function position(e2) {
        if (!tt.parentNode)
          return CodeMirror2.off(document, "mousemove", position);
        tt.style.top = Math.max(0, e2.clientY - tt.offsetHeight - 5) + "px";
        tt.style.left = e2.clientX + 5 + "px";
      }
      CodeMirror2.on(document, "mousemove", position);
      position(e);
      if (tt.style.opacity != null)
        tt.style.opacity = 1;
      return tt;
    }
    function rm(elt) {
      if (elt.parentNode)
        elt.parentNode.removeChild(elt);
    }
    function hideTooltip(tt) {
      if (!tt.parentNode)
        return;
      if (tt.style.opacity == null)
        rm(tt);
      tt.style.opacity = 0;
      setTimeout(function() {
        rm(tt);
      }, 600);
    }
    function showTooltipFor(cm, e, content, node) {
      var tooltip = showTooltip(cm, e, content);
      function hide() {
        CodeMirror2.off(node, "mouseout", hide);
        if (tooltip) {
          hideTooltip(tooltip);
          tooltip = null;
        }
      }
      var poll = setInterval(function() {
        if (tooltip)
          for (var n2 = node; ; n2 = n2.parentNode) {
            if (n2 && n2.nodeType == 11)
              n2 = n2.host;
            if (n2 == document.body)
              return;
            if (!n2) {
              hide();
              break;
            }
          }
        if (!tooltip)
          return clearInterval(poll);
      }, 400);
      CodeMirror2.on(node, "mouseout", hide);
    }
    function LintState(cm, conf, hasGutter) {
      this.marked = [];
      if (conf instanceof Function)
        conf = { getAnnotations: conf };
      if (!conf || conf === true)
        conf = {};
      this.options = {};
      this.linterOptions = conf.options || {};
      for (var prop2 in defaults2)
        this.options[prop2] = defaults2[prop2];
      for (var prop2 in conf) {
        if (defaults2.hasOwnProperty(prop2)) {
          if (conf[prop2] != null)
            this.options[prop2] = conf[prop2];
        } else if (!conf.options) {
          this.linterOptions[prop2] = conf[prop2];
        }
      }
      this.timeout = null;
      this.hasGutter = hasGutter;
      this.onMouseOver = function(e) {
        onMouseOver2(cm, e);
      };
      this.waitingFor = 0;
    }
    var defaults2 = {
      highlightLines: false,
      tooltips: true,
      delay: 500,
      lintOnChange: true,
      getAnnotations: null,
      async: false,
      selfContain: null,
      formatAnnotation: null,
      onUpdateLinting: null
    };
    function clearMarks(cm) {
      var state = cm.state.lint;
      if (state.hasGutter)
        cm.clearGutter(GUTTER_ID);
      if (state.options.highlightLines)
        clearErrorLines(cm);
      for (var i = 0; i < state.marked.length; ++i)
        state.marked[i].clear();
      state.marked.length = 0;
    }
    function clearErrorLines(cm) {
      cm.eachLine(function(line) {
        var has2 = line.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(line.wrapClass);
        if (has2)
          cm.removeLineClass(line, "wrap", has2[0]);
      });
    }
    function makeMarker(cm, labels, severity, multiple, tooltips) {
      var marker2 = document.createElement("div"), inner = marker2;
      marker2.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
      if (multiple) {
        inner = marker2.appendChild(document.createElement("div"));
        inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
      }
      if (tooltips != false)
        CodeMirror2.on(inner, "mouseover", function(e) {
          showTooltipFor(cm, e, labels, inner);
        });
      return marker2;
    }
    function getMaxSeverity(a, b) {
      if (a == "error")
        return a;
      else
        return b;
    }
    function groupByLine(annotations2) {
      var lines = [];
      for (var i = 0; i < annotations2.length; ++i) {
        var ann = annotations2[i], line = ann.from.line;
        (lines[line] || (lines[line] = [])).push(ann);
      }
      return lines;
    }
    function annotationTooltip(ann) {
      var severity = ann.severity;
      if (!severity)
        severity = "error";
      var tip = document.createElement("div");
      tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
      if (typeof ann.messageHTML != "undefined") {
        tip.innerHTML = ann.messageHTML;
      } else {
        tip.appendChild(document.createTextNode(ann.message));
      }
      return tip;
    }
    function lintAsync(cm, getAnnotations) {
      var state = cm.state.lint;
      var id2 = ++state.waitingFor;
      function abort() {
        id2 = -1;
        cm.off("change", abort);
      }
      cm.on("change", abort);
      getAnnotations(cm.getValue(), function(annotations2, arg2) {
        cm.off("change", abort);
        if (state.waitingFor != id2)
          return;
        if (arg2 && annotations2 instanceof CodeMirror2)
          annotations2 = arg2;
        cm.operation(function() {
          updateLinting(cm, annotations2);
        });
      }, state.linterOptions, cm);
    }
    function startLinting(cm) {
      var state = cm.state.lint;
      if (!state)
        return;
      var options = state.options;
      var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror2.Pos(0, 0), "lint");
      if (!getAnnotations)
        return;
      if (options.async || getAnnotations.async) {
        lintAsync(cm, getAnnotations);
      } else {
        var annotations2 = getAnnotations(cm.getValue(), state.linterOptions, cm);
        if (!annotations2)
          return;
        if (annotations2.then)
          annotations2.then(function(issues) {
            cm.operation(function() {
              updateLinting(cm, issues);
            });
          });
        else
          cm.operation(function() {
            updateLinting(cm, annotations2);
          });
      }
    }
    function updateLinting(cm, annotationsNotSorted) {
      var state = cm.state.lint;
      if (!state)
        return;
      var options = state.options;
      clearMarks(cm);
      var annotations2 = groupByLine(annotationsNotSorted);
      for (var line = 0; line < annotations2.length; ++line) {
        var anns = annotations2[line];
        if (!anns)
          continue;
        var message = [];
        anns = anns.filter(function(item) {
          return message.indexOf(item.message) > -1 ? false : message.push(item.message);
        });
        var maxSeverity = null;
        var tipLabel = state.hasGutter && document.createDocumentFragment();
        for (var i = 0; i < anns.length; ++i) {
          var ann = anns[i];
          var severity = ann.severity;
          if (!severity)
            severity = "error";
          maxSeverity = getMaxSeverity(maxSeverity, severity);
          if (options.formatAnnotation)
            ann = options.formatAnnotation(ann);
          if (state.hasGutter)
            tipLabel.appendChild(annotationTooltip(ann));
          if (ann.to)
            state.marked.push(cm.markText(ann.from, ann.to, {
              className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,
              __annotation: ann
            }));
        }
        if (state.hasGutter)
          cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations2[line].length > 1, options.tooltips));
        if (options.highlightLines)
          cm.addLineClass(line, "wrap", LINT_LINE_ID + maxSeverity);
      }
      if (options.onUpdateLinting)
        options.onUpdateLinting(annotationsNotSorted, annotations2, cm);
    }
    function onChange(cm) {
      var state = cm.state.lint;
      if (!state)
        return;
      clearTimeout(state.timeout);
      state.timeout = setTimeout(function() {
        startLinting(cm);
      }, state.options.delay);
    }
    function popupTooltips(cm, annotations2, e) {
      var target2 = e.target || e.srcElement;
      var tooltip = document.createDocumentFragment();
      for (var i = 0; i < annotations2.length; i++) {
        var ann = annotations2[i];
        tooltip.appendChild(annotationTooltip(ann));
      }
      showTooltipFor(cm, e, tooltip, target2);
    }
    function onMouseOver2(cm, e) {
      var target2 = e.target || e.srcElement;
      if (!/\bCodeMirror-lint-mark-/.test(target2.className))
        return;
      var box = target2.getBoundingClientRect(), x2 = (box.left + box.right) / 2, y2 = (box.top + box.bottom) / 2;
      var spans = cm.findMarksAt(cm.coordsChar({ left: x2, top: y2 }, "client"));
      var annotations2 = [];
      for (var i = 0; i < spans.length; ++i) {
        var ann = spans[i].__annotation;
        if (ann)
          annotations2.push(ann);
      }
      if (annotations2.length)
        popupTooltips(cm, annotations2, e);
    }
    CodeMirror2.defineOption("lint", false, function(cm, val, old) {
      if (old && old != CodeMirror2.Init) {
        clearMarks(cm);
        if (cm.state.lint.options.lintOnChange !== false)
          cm.off("change", onChange);
        CodeMirror2.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
        clearTimeout(cm.state.lint.timeout);
        delete cm.state.lint;
      }
      if (val) {
        var gutters = cm.getOption("gutters"), hasLintGutter = false;
        for (var i = 0; i < gutters.length; ++i)
          if (gutters[i] == GUTTER_ID)
            hasLintGutter = true;
        var state = cm.state.lint = new LintState(cm, val, hasLintGutter);
        if (state.options.lintOnChange)
          cm.on("change", onChange);
        if (state.options.tooltips != false && state.options.tooltips != "gutter")
          CodeMirror2.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
        startLinting(cm);
      }
    });
    CodeMirror2.defineExtension("performLint", function() {
      startLinting(this);
    });
  });
})();
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports, searchcursor.exports, matchbrackets.exports);
  })(function(CodeMirror2) {
    var cmds = CodeMirror2.commands;
    var Pos = CodeMirror2.Pos;
    function findPosSubword(doc, start2, dir) {
      if (dir < 0 && start2.ch == 0)
        return doc.clipPos(Pos(start2.line - 1));
      var line = doc.getLine(start2.line);
      if (dir > 0 && start2.ch >= line.length)
        return doc.clipPos(Pos(start2.line + 1, 0));
      var state = "start", type2, startPos = start2.ch;
      for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
        var next = line.charAt(dir < 0 ? pos - 1 : pos);
        var cat = next != "_" && CodeMirror2.isWordChar(next) ? "w" : "o";
        if (cat == "w" && next.toUpperCase() == next)
          cat = "W";
        if (state == "start") {
          if (cat != "o") {
            state = "in";
            type2 = cat;
          } else
            startPos = pos + dir;
        } else if (state == "in") {
          if (type2 != cat) {
            if (type2 == "w" && cat == "W" && dir < 0)
              pos--;
            if (type2 == "W" && cat == "w" && dir > 0) {
              if (pos == startPos + 1) {
                type2 = "w";
                continue;
              } else
                pos--;
            }
            break;
          }
        }
      }
      return Pos(start2.line, pos);
    }
    function moveSubword(cm, dir) {
      cm.extendSelectionsBy(function(range2) {
        if (cm.display.shift || cm.doc.extend || range2.empty())
          return findPosSubword(cm.doc, range2.head, dir);
        else
          return dir < 0 ? range2.from() : range2.to();
      });
    }
    cmds.goSubwordLeft = function(cm) {
      moveSubword(cm, -1);
    };
    cmds.goSubwordRight = function(cm) {
      moveSubword(cm, 1);
    };
    cmds.scrollLineUp = function(cm) {
      var info2 = cm.getScrollInfo();
      if (!cm.somethingSelected()) {
        var visibleBottomLine = cm.lineAtHeight(info2.top + info2.clientHeight, "local");
        if (cm.getCursor().line >= visibleBottomLine)
          cm.execCommand("goLineUp");
      }
      cm.scrollTo(null, info2.top - cm.defaultTextHeight());
    };
    cmds.scrollLineDown = function(cm) {
      var info2 = cm.getScrollInfo();
      if (!cm.somethingSelected()) {
        var visibleTopLine = cm.lineAtHeight(info2.top, "local") + 1;
        if (cm.getCursor().line <= visibleTopLine)
          cm.execCommand("goLineDown");
      }
      cm.scrollTo(null, info2.top + cm.defaultTextHeight());
    };
    cmds.splitSelectionByLine = function(cm) {
      var ranges = cm.listSelections(), lineRanges = [];
      for (var i = 0; i < ranges.length; i++) {
        var from = ranges[i].from(), to = ranges[i].to();
        for (var line = from.line; line <= to.line; ++line)
          if (!(to.line > from.line && line == to.line && to.ch == 0))
            lineRanges.push({
              anchor: line == from.line ? from : Pos(line, 0),
              head: line == to.line ? to : Pos(line)
            });
      }
      cm.setSelections(lineRanges, 0);
    };
    cmds.singleSelectionTop = function(cm) {
      var range2 = cm.listSelections()[0];
      cm.setSelection(range2.anchor, range2.head, { scroll: false });
    };
    cmds.selectLine = function(cm) {
      var ranges = cm.listSelections(), extended = [];
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i];
        extended.push({
          anchor: Pos(range2.from().line, 0),
          head: Pos(range2.to().line + 1, 0)
        });
      }
      cm.setSelections(extended);
    };
    function insertLine(cm, above) {
      if (cm.isReadOnly())
        return CodeMirror2.Pass;
      cm.operation(function() {
        var len = cm.listSelections().length, newSelection = [], last = -1;
        for (var i = 0; i < len; i++) {
          var head = cm.listSelections()[i].head;
          if (head.line <= last)
            continue;
          var at = Pos(head.line + (above ? 0 : 1), 0);
          cm.replaceRange("\n", at, null, "+insertLine");
          cm.indentLine(at.line, null, true);
          newSelection.push({ head: at, anchor: at });
          last = head.line + 1;
        }
        cm.setSelections(newSelection);
      });
      cm.execCommand("indentAuto");
    }
    cmds.insertLineAfter = function(cm) {
      return insertLine(cm, false);
    };
    cmds.insertLineBefore = function(cm) {
      return insertLine(cm, true);
    };
    function wordAt(cm, pos) {
      var start2 = pos.ch, end2 = start2, line = cm.getLine(pos.line);
      while (start2 && CodeMirror2.isWordChar(line.charAt(start2 - 1)))
        --start2;
      while (end2 < line.length && CodeMirror2.isWordChar(line.charAt(end2)))
        ++end2;
      return { from: Pos(pos.line, start2), to: Pos(pos.line, end2), word: line.slice(start2, end2) };
    }
    cmds.selectNextOccurrence = function(cm) {
      var from = cm.getCursor("from"), to = cm.getCursor("to");
      var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
      if (CodeMirror2.cmpPos(from, to) == 0) {
        var word2 = wordAt(cm, from);
        if (!word2.word)
          return;
        cm.setSelection(word2.from, word2.to);
        fullWord = true;
      } else {
        var text3 = cm.getRange(from, to);
        var query = fullWord ? new RegExp("\\b" + text3 + "\\b") : text3;
        var cur = cm.getSearchCursor(query, to);
        var found = cur.findNext();
        if (!found) {
          cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
          found = cur.findNext();
        }
        if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))
          return;
        cm.addSelection(cur.from(), cur.to());
      }
      if (fullWord)
        cm.state.sublimeFindFullWord = cm.doc.sel;
    };
    cmds.skipAndSelectNextOccurrence = function(cm) {
      var prevAnchor = cm.getCursor("anchor"), prevHead = cm.getCursor("head");
      cmds.selectNextOccurrence(cm);
      if (CodeMirror2.cmpPos(prevAnchor, prevHead) != 0) {
        cm.doc.setSelections(cm.doc.listSelections().filter(function(sel) {
          return sel.anchor != prevAnchor || sel.head != prevHead;
        }));
      }
    };
    function addCursorToSelection(cm, dir) {
      var ranges = cm.listSelections(), newRanges = [];
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i];
        var newAnchor = cm.findPosV(range2.anchor, dir, "line", range2.anchor.goalColumn);
        var newHead = cm.findPosV(range2.head, dir, "line", range2.head.goalColumn);
        newAnchor.goalColumn = range2.anchor.goalColumn != null ? range2.anchor.goalColumn : cm.cursorCoords(range2.anchor, "div").left;
        newHead.goalColumn = range2.head.goalColumn != null ? range2.head.goalColumn : cm.cursorCoords(range2.head, "div").left;
        var newRange = { anchor: newAnchor, head: newHead };
        newRanges.push(range2);
        newRanges.push(newRange);
      }
      cm.setSelections(newRanges);
    }
    cmds.addCursorToPrevLine = function(cm) {
      addCursorToSelection(cm, -1);
    };
    cmds.addCursorToNextLine = function(cm) {
      addCursorToSelection(cm, 1);
    };
    function isSelectedRange(ranges, from, to) {
      for (var i = 0; i < ranges.length; i++)
        if (CodeMirror2.cmpPos(ranges[i].from(), from) == 0 && CodeMirror2.cmpPos(ranges[i].to(), to) == 0)
          return true;
      return false;
    }
    var mirror = "(){}[]";
    function selectBetweenBrackets(cm) {
      var ranges = cm.listSelections(), newRanges = [];
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i], pos = range2.head, opening = cm.scanForBracket(pos, -1);
        if (!opening)
          return false;
        for (; ; ) {
          var closing = cm.scanForBracket(pos, 1);
          if (!closing)
            return false;
          if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
            var startPos = Pos(opening.pos.line, opening.pos.ch + 1);
            if (CodeMirror2.cmpPos(startPos, range2.from()) == 0 && CodeMirror2.cmpPos(closing.pos, range2.to()) == 0) {
              opening = cm.scanForBracket(opening.pos, -1);
              if (!opening)
                return false;
            } else {
              newRanges.push({ anchor: startPos, head: closing.pos });
              break;
            }
          }
          pos = Pos(closing.pos.line, closing.pos.ch + 1);
        }
      }
      cm.setSelections(newRanges);
      return true;
    }
    cmds.selectScope = function(cm) {
      selectBetweenBrackets(cm) || cm.execCommand("selectAll");
    };
    cmds.selectBetweenBrackets = function(cm) {
      if (!selectBetweenBrackets(cm))
        return CodeMirror2.Pass;
    };
    function puncType(type2) {
      return !type2 ? null : /\bpunctuation\b/.test(type2) ? type2 : void 0;
    }
    cmds.goToBracket = function(cm) {
      cm.extendSelectionsBy(function(range2) {
        var next = cm.scanForBracket(range2.head, 1, puncType(cm.getTokenTypeAt(range2.head)));
        if (next && CodeMirror2.cmpPos(next.pos, range2.head) != 0)
          return next.pos;
        var prev = cm.scanForBracket(range2.head, -1, puncType(cm.getTokenTypeAt(Pos(range2.head.line, range2.head.ch + 1))));
        return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range2.head;
      });
    };
    cmds.swapLineUp = function(cm) {
      if (cm.isReadOnly())
        return CodeMirror2.Pass;
      var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i], from = range2.from().line - 1, to = range2.to().line;
        newSels.push({
          anchor: Pos(range2.anchor.line - 1, range2.anchor.ch),
          head: Pos(range2.head.line - 1, range2.head.ch)
        });
        if (range2.to().ch == 0 && !range2.empty())
          --to;
        if (from > at)
          linesToMove.push(from, to);
        else if (linesToMove.length)
          linesToMove[linesToMove.length - 1] = to;
        at = to;
      }
      cm.operation(function() {
        for (var i2 = 0; i2 < linesToMove.length; i2 += 2) {
          var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];
          var line = cm.getLine(from2);
          cm.replaceRange("", Pos(from2, 0), Pos(from2 + 1, 0), "+swapLine");
          if (to2 > cm.lastLine())
            cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");
          else
            cm.replaceRange(line + "\n", Pos(to2, 0), null, "+swapLine");
        }
        cm.setSelections(newSels);
        cm.scrollIntoView();
      });
    };
    cmds.swapLineDown = function(cm) {
      if (cm.isReadOnly())
        return CodeMirror2.Pass;
      var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;
      for (var i = ranges.length - 1; i >= 0; i--) {
        var range2 = ranges[i], from = range2.to().line + 1, to = range2.from().line;
        if (range2.to().ch == 0 && !range2.empty())
          from--;
        if (from < at)
          linesToMove.push(from, to);
        else if (linesToMove.length)
          linesToMove[linesToMove.length - 1] = to;
        at = to;
      }
      cm.operation(function() {
        for (var i2 = linesToMove.length - 2; i2 >= 0; i2 -= 2) {
          var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];
          var line = cm.getLine(from2);
          if (from2 == cm.lastLine())
            cm.replaceRange("", Pos(from2 - 1), Pos(from2), "+swapLine");
          else
            cm.replaceRange("", Pos(from2, 0), Pos(from2 + 1, 0), "+swapLine");
          cm.replaceRange(line + "\n", Pos(to2, 0), null, "+swapLine");
        }
        cm.scrollIntoView();
      });
    };
    cmds.toggleCommentIndented = function(cm) {
      cm.toggleComment({ indent: true });
    };
    cmds.joinLines = function(cm) {
      var ranges = cm.listSelections(), joined = [];
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i], from = range2.from();
        var start2 = from.line, end2 = range2.to().line;
        while (i < ranges.length - 1 && ranges[i + 1].from().line == end2)
          end2 = ranges[++i].to().line;
        joined.push({ start: start2, end: end2, anchor: !range2.empty() && from });
      }
      cm.operation(function() {
        var offset = 0, ranges2 = [];
        for (var i2 = 0; i2 < joined.length; i2++) {
          var obj = joined[i2];
          var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;
          for (var line = obj.start; line <= obj.end; line++) {
            var actual = line - offset;
            if (line == obj.end)
              head = Pos(actual, cm.getLine(actual).length + 1);
            if (actual < cm.lastLine()) {
              cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
              ++offset;
            }
          }
          ranges2.push({ anchor: anchor || head, head });
        }
        cm.setSelections(ranges2, 0);
      });
    };
    cmds.duplicateLine = function(cm) {
      cm.operation(function() {
        var rangeCount = cm.listSelections().length;
        for (var i = 0; i < rangeCount; i++) {
          var range2 = cm.listSelections()[i];
          if (range2.empty())
            cm.replaceRange(cm.getLine(range2.head.line) + "\n", Pos(range2.head.line, 0));
          else
            cm.replaceRange(cm.getRange(range2.from(), range2.to()), range2.from());
        }
        cm.scrollIntoView();
      });
    };
    function sortLines(cm, caseSensitive, direction) {
      if (cm.isReadOnly())
        return CodeMirror2.Pass;
      var ranges = cm.listSelections(), toSort = [], selected;
      for (var i = 0; i < ranges.length; i++) {
        var range2 = ranges[i];
        if (range2.empty())
          continue;
        var from = range2.from().line, to = range2.to().line;
        while (i < ranges.length - 1 && ranges[i + 1].from().line == to)
          to = ranges[++i].to().line;
        if (!ranges[i].to().ch)
          to--;
        toSort.push(from, to);
      }
      if (toSort.length)
        selected = true;
      else
        toSort.push(cm.firstLine(), cm.lastLine());
      cm.operation(function() {
        var ranges2 = [];
        for (var i2 = 0; i2 < toSort.length; i2 += 2) {
          var from2 = toSort[i2], to2 = toSort[i2 + 1];
          var start2 = Pos(from2, 0), end2 = Pos(to2);
          var lines = cm.getRange(start2, end2, false);
          if (caseSensitive)
            lines.sort(function(a, b) {
              return a < b ? -direction : a == b ? 0 : direction;
            });
          else
            lines.sort(function(a, b) {
              var au = a.toUpperCase(), bu = b.toUpperCase();
              if (au != bu) {
                a = au;
                b = bu;
              }
              return a < b ? -direction : a == b ? 0 : direction;
            });
          cm.replaceRange(lines, start2, end2);
          if (selected)
            ranges2.push({ anchor: start2, head: Pos(to2 + 1, 0) });
        }
        if (selected)
          cm.setSelections(ranges2, 0);
      });
    }
    cmds.sortLines = function(cm) {
      sortLines(cm, true, 1);
    };
    cmds.reverseSortLines = function(cm) {
      sortLines(cm, true, -1);
    };
    cmds.sortLinesInsensitive = function(cm) {
      sortLines(cm, false, 1);
    };
    cmds.reverseSortLinesInsensitive = function(cm) {
      sortLines(cm, false, -1);
    };
    cmds.nextBookmark = function(cm) {
      var marks = cm.state.sublimeBookmarks;
      if (marks)
        while (marks.length) {
          var current = marks.shift();
          var found = current.find();
          if (found) {
            marks.push(current);
            return cm.setSelection(found.from, found.to);
          }
        }
    };
    cmds.prevBookmark = function(cm) {
      var marks = cm.state.sublimeBookmarks;
      if (marks)
        while (marks.length) {
          marks.unshift(marks.pop());
          var found = marks[marks.length - 1].find();
          if (!found)
            marks.pop();
          else
            return cm.setSelection(found.from, found.to);
        }
    };
    cmds.toggleBookmark = function(cm) {
      var ranges = cm.listSelections();
      var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
      for (var i = 0; i < ranges.length; i++) {
        var from = ranges[i].from(), to = ranges[i].to();
        var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);
        for (var j = 0; j < found.length; j++) {
          if (found[j].sublimeBookmark) {
            found[j].clear();
            for (var k = 0; k < marks.length; k++)
              if (marks[k] == found[j])
                marks.splice(k--, 1);
            break;
          }
        }
        if (j == found.length)
          marks.push(cm.markText(from, to, { sublimeBookmark: true, clearWhenEmpty: false }));
      }
    };
    cmds.clearBookmarks = function(cm) {
      var marks = cm.state.sublimeBookmarks;
      if (marks)
        for (var i = 0; i < marks.length; i++)
          marks[i].clear();
      marks.length = 0;
    };
    cmds.selectBookmarks = function(cm) {
      var marks = cm.state.sublimeBookmarks, ranges = [];
      if (marks)
        for (var i = 0; i < marks.length; i++) {
          var found = marks[i].find();
          if (!found)
            marks.splice(i--, 0);
          else
            ranges.push({ anchor: found.from, head: found.to });
        }
      if (ranges.length)
        cm.setSelections(ranges, 0);
    };
    function modifyWordOrSelection(cm, mod) {
      cm.operation(function() {
        var ranges = cm.listSelections(), indices = [], replacements2 = [];
        for (var i = 0; i < ranges.length; i++) {
          var range2 = ranges[i];
          if (range2.empty()) {
            indices.push(i);
            replacements2.push("");
          } else
            replacements2.push(mod(cm.getRange(range2.from(), range2.to())));
        }
        cm.replaceSelections(replacements2, "around", "case");
        for (var i = indices.length - 1, at; i >= 0; i--) {
          var range2 = ranges[indices[i]];
          if (at && CodeMirror2.cmpPos(range2.head, at) > 0)
            continue;
          var word2 = wordAt(cm, range2.head);
          at = word2.from;
          cm.replaceRange(mod(word2.word), word2.from, word2.to);
        }
      });
    }
    cmds.smartBackspace = function(cm) {
      if (cm.somethingSelected())
        return CodeMirror2.Pass;
      cm.operation(function() {
        var cursors = cm.listSelections();
        var indentUnit = cm.getOption("indentUnit");
        for (var i = cursors.length - 1; i >= 0; i--) {
          var cursor = cursors[i].head;
          var toStartOfLine = cm.getRange({ line: cursor.line, ch: 0 }, cursor);
          var column = CodeMirror2.countColumn(toStartOfLine, null, cm.getOption("tabSize"));
          var deletePos = cm.findPosH(cursor, -1, "char", false);
          if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
            var prevIndent = new Pos(cursor.line, CodeMirror2.findColumn(toStartOfLine, column - indentUnit, indentUnit));
            if (prevIndent.ch != cursor.ch)
              deletePos = prevIndent;
          }
          cm.replaceRange("", deletePos, cursor, "+delete");
        }
      });
    };
    cmds.delLineRight = function(cm) {
      cm.operation(function() {
        var ranges = cm.listSelections();
        for (var i = ranges.length - 1; i >= 0; i--)
          cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
        cm.scrollIntoView();
      });
    };
    cmds.upcaseAtCursor = function(cm) {
      modifyWordOrSelection(cm, function(str) {
        return str.toUpperCase();
      });
    };
    cmds.downcaseAtCursor = function(cm) {
      modifyWordOrSelection(cm, function(str) {
        return str.toLowerCase();
      });
    };
    cmds.setSublimeMark = function(cm) {
      if (cm.state.sublimeMark)
        cm.state.sublimeMark.clear();
      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
    };
    cmds.selectToSublimeMark = function(cm) {
      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
      if (found)
        cm.setSelection(cm.getCursor(), found);
    };
    cmds.deleteToSublimeMark = function(cm) {
      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
      if (found) {
        var from = cm.getCursor(), to = found;
        if (CodeMirror2.cmpPos(from, to) > 0) {
          var tmp = to;
          to = from;
          from = tmp;
        }
        cm.state.sublimeKilled = cm.getRange(from, to);
        cm.replaceRange("", from, to);
      }
    };
    cmds.swapWithSublimeMark = function(cm) {
      var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
      if (found) {
        cm.state.sublimeMark.clear();
        cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
        cm.setCursor(found);
      }
    };
    cmds.sublimeYank = function(cm) {
      if (cm.state.sublimeKilled != null)
        cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
    };
    cmds.showInCenter = function(cm) {
      var pos = cm.cursorCoords(null, "local");
      cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
    };
    function getTarget(cm) {
      var from = cm.getCursor("from"), to = cm.getCursor("to");
      if (CodeMirror2.cmpPos(from, to) == 0) {
        var word2 = wordAt(cm, from);
        if (!word2.word)
          return;
        from = word2.from;
        to = word2.to;
      }
      return { from, to, query: cm.getRange(from, to), word: word2 };
    }
    function findAndGoTo(cm, forward) {
      var target2 = getTarget(cm);
      if (!target2)
        return;
      var query = target2.query;
      var cur = cm.getSearchCursor(query, forward ? target2.to : target2.from);
      if (forward ? cur.findNext() : cur.findPrevious()) {
        cm.setSelection(cur.from(), cur.to());
      } else {
        cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));
        if (forward ? cur.findNext() : cur.findPrevious())
          cm.setSelection(cur.from(), cur.to());
        else if (target2.word)
          cm.setSelection(target2.from, target2.to);
      }
    }
    cmds.findUnder = function(cm) {
      findAndGoTo(cm, true);
    };
    cmds.findUnderPrevious = function(cm) {
      findAndGoTo(cm, false);
    };
    cmds.findAllUnder = function(cm) {
      var target2 = getTarget(cm);
      if (!target2)
        return;
      var cur = cm.getSearchCursor(target2.query);
      var matches = [];
      var primaryIndex = -1;
      while (cur.findNext()) {
        matches.push({ anchor: cur.from(), head: cur.to() });
        if (cur.from().line <= target2.from.line && cur.from().ch <= target2.from.ch)
          primaryIndex++;
      }
      cm.setSelections(matches, primaryIndex);
    };
    var keyMap2 = CodeMirror2.keyMap;
    keyMap2.macSublime = {
      "Cmd-Left": "goLineStartSmart",
      "Shift-Tab": "indentLess",
      "Shift-Ctrl-K": "deleteLine",
      "Alt-Q": "wrapLines",
      "Ctrl-Left": "goSubwordLeft",
      "Ctrl-Right": "goSubwordRight",
      "Ctrl-Alt-Up": "scrollLineUp",
      "Ctrl-Alt-Down": "scrollLineDown",
      "Cmd-L": "selectLine",
      "Shift-Cmd-L": "splitSelectionByLine",
      "Esc": "singleSelectionTop",
      "Cmd-Enter": "insertLineAfter",
      "Shift-Cmd-Enter": "insertLineBefore",
      "Cmd-D": "selectNextOccurrence",
      "Shift-Cmd-Space": "selectScope",
      "Shift-Cmd-M": "selectBetweenBrackets",
      "Cmd-M": "goToBracket",
      "Cmd-Ctrl-Up": "swapLineUp",
      "Cmd-Ctrl-Down": "swapLineDown",
      "Cmd-/": "toggleCommentIndented",
      "Cmd-J": "joinLines",
      "Shift-Cmd-D": "duplicateLine",
      "F5": "sortLines",
      "Shift-F5": "reverseSortLines",
      "Cmd-F5": "sortLinesInsensitive",
      "Shift-Cmd-F5": "reverseSortLinesInsensitive",
      "F2": "nextBookmark",
      "Shift-F2": "prevBookmark",
      "Cmd-F2": "toggleBookmark",
      "Shift-Cmd-F2": "clearBookmarks",
      "Alt-F2": "selectBookmarks",
      "Backspace": "smartBackspace",
      "Cmd-K Cmd-D": "skipAndSelectNextOccurrence",
      "Cmd-K Cmd-K": "delLineRight",
      "Cmd-K Cmd-U": "upcaseAtCursor",
      "Cmd-K Cmd-L": "downcaseAtCursor",
      "Cmd-K Cmd-Space": "setSublimeMark",
      "Cmd-K Cmd-A": "selectToSublimeMark",
      "Cmd-K Cmd-W": "deleteToSublimeMark",
      "Cmd-K Cmd-X": "swapWithSublimeMark",
      "Cmd-K Cmd-Y": "sublimeYank",
      "Cmd-K Cmd-C": "showInCenter",
      "Cmd-K Cmd-G": "clearBookmarks",
      "Cmd-K Cmd-Backspace": "delLineLeft",
      "Cmd-K Cmd-1": "foldAll",
      "Cmd-K Cmd-0": "unfoldAll",
      "Cmd-K Cmd-J": "unfoldAll",
      "Ctrl-Shift-Up": "addCursorToPrevLine",
      "Ctrl-Shift-Down": "addCursorToNextLine",
      "Cmd-F3": "findUnder",
      "Shift-Cmd-F3": "findUnderPrevious",
      "Alt-F3": "findAllUnder",
      "Shift-Cmd-[": "fold",
      "Shift-Cmd-]": "unfold",
      "Cmd-I": "findIncremental",
      "Shift-Cmd-I": "findIncrementalReverse",
      "Cmd-H": "replace",
      "F3": "findNext",
      "Shift-F3": "findPrev",
      "fallthrough": "macDefault"
    };
    CodeMirror2.normalizeKeyMap(keyMap2.macSublime);
    keyMap2.pcSublime = {
      "Shift-Tab": "indentLess",
      "Shift-Ctrl-K": "deleteLine",
      "Alt-Q": "wrapLines",
      "Ctrl-T": "transposeChars",
      "Alt-Left": "goSubwordLeft",
      "Alt-Right": "goSubwordRight",
      "Ctrl-Up": "scrollLineUp",
      "Ctrl-Down": "scrollLineDown",
      "Ctrl-L": "selectLine",
      "Shift-Ctrl-L": "splitSelectionByLine",
      "Esc": "singleSelectionTop",
      "Ctrl-Enter": "insertLineAfter",
      "Shift-Ctrl-Enter": "insertLineBefore",
      "Ctrl-D": "selectNextOccurrence",
      "Shift-Ctrl-Space": "selectScope",
      "Shift-Ctrl-M": "selectBetweenBrackets",
      "Ctrl-M": "goToBracket",
      "Shift-Ctrl-Up": "swapLineUp",
      "Shift-Ctrl-Down": "swapLineDown",
      "Ctrl-/": "toggleCommentIndented",
      "Ctrl-J": "joinLines",
      "Shift-Ctrl-D": "duplicateLine",
      "F9": "sortLines",
      "Shift-F9": "reverseSortLines",
      "Ctrl-F9": "sortLinesInsensitive",
      "Shift-Ctrl-F9": "reverseSortLinesInsensitive",
      "F2": "nextBookmark",
      "Shift-F2": "prevBookmark",
      "Ctrl-F2": "toggleBookmark",
      "Shift-Ctrl-F2": "clearBookmarks",
      "Alt-F2": "selectBookmarks",
      "Backspace": "smartBackspace",
      "Ctrl-K Ctrl-D": "skipAndSelectNextOccurrence",
      "Ctrl-K Ctrl-K": "delLineRight",
      "Ctrl-K Ctrl-U": "upcaseAtCursor",
      "Ctrl-K Ctrl-L": "downcaseAtCursor",
      "Ctrl-K Ctrl-Space": "setSublimeMark",
      "Ctrl-K Ctrl-A": "selectToSublimeMark",
      "Ctrl-K Ctrl-W": "deleteToSublimeMark",
      "Ctrl-K Ctrl-X": "swapWithSublimeMark",
      "Ctrl-K Ctrl-Y": "sublimeYank",
      "Ctrl-K Ctrl-C": "showInCenter",
      "Ctrl-K Ctrl-G": "clearBookmarks",
      "Ctrl-K Ctrl-Backspace": "delLineLeft",
      "Ctrl-K Ctrl-1": "foldAll",
      "Ctrl-K Ctrl-0": "unfoldAll",
      "Ctrl-K Ctrl-J": "unfoldAll",
      "Ctrl-Alt-Up": "addCursorToPrevLine",
      "Ctrl-Alt-Down": "addCursorToNextLine",
      "Ctrl-F3": "findUnder",
      "Shift-Ctrl-F3": "findUnderPrevious",
      "Alt-F3": "findAllUnder",
      "Shift-Ctrl-[": "fold",
      "Shift-Ctrl-]": "unfold",
      "Ctrl-I": "findIncremental",
      "Shift-Ctrl-I": "findIncrementalReverse",
      "Ctrl-H": "replace",
      "F3": "findNext",
      "Shift-F3": "findPrev",
      "fallthrough": "pcDefault"
    };
    CodeMirror2.normalizeKeyMap(keyMap2.pcSublime);
    var mac = keyMap2.default == keyMap2.macDefault;
    keyMap2.sublime = mac ? keyMap2.macSublime : keyMap2.pcSublime;
  });
})();
var hint$1 = {};
var require$$1$2 = /* @__PURE__ */ getAugmentedNamespace(esm);
var __importDefault$c = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(hint$1, "__esModule", { value: true });
var codemirror_1$a = __importDefault$c(codemirror.exports);
var graphql_language_service_1$4 = require$$1$2;
codemirror_1$a.default.registerHelper("hint", "graphql", function(editor, options) {
  var schema = options.schema;
  if (!schema) {
    return;
  }
  var cur = editor.getCursor();
  var token2 = editor.getTokenAt(cur);
  var tokenStart = token2.type !== null && /"|\w/.test(token2.string[0]) ? token2.start : token2.end;
  var position = new graphql_language_service_1$4.Position(cur.line, tokenStart);
  var rawResults = graphql_language_service_1$4.getAutocompleteSuggestions(schema, editor.getValue(), position, token2, options.externalFragments);
  var results = {
    list: rawResults.map(function(item) {
      return {
        text: item.label,
        type: item.type,
        description: item.documentation,
        isDeprecated: item.isDeprecated,
        deprecationReason: item.deprecationReason
      };
    }),
    from: { line: cur.line, ch: tokenStart },
    to: { line: cur.line, ch: token2.end }
  };
  if (results && results.list && results.list.length > 0) {
    results.from = codemirror_1$a.default.Pos(results.from.line, results.from.ch);
    results.to = codemirror_1$a.default.Pos(results.to.line, results.to.ch);
    codemirror_1$a.default.signal(editor, "hasCompletion", editor, results, token2);
  }
  return results;
});
var lint$1 = {};
var __importDefault$b = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(lint$1, "__esModule", { value: true });
var codemirror_1$9 = __importDefault$b(codemirror.exports);
var graphql_language_service_1$3 = require$$1$2;
var SEVERITY = ["error", "warning", "information", "hint"];
var TYPE = {
  "GraphQL: Validation": "validation",
  "GraphQL: Deprecation": "deprecation",
  "GraphQL: Syntax": "syntax"
};
codemirror_1$9.default.registerHelper("lint", "graphql", function(text3, options) {
  var schema = options.schema;
  var rawResults = graphql_language_service_1$3.getDiagnostics(text3, schema, options.validationRules, void 0, options.externalFragments);
  var results = rawResults.map(function(error2) {
    return {
      message: error2.message,
      severity: error2.severity ? SEVERITY[error2.severity - 1] : SEVERITY[0],
      type: error2.source ? TYPE[error2.source] : void 0,
      from: codemirror_1$9.default.Pos(error2.range.start.line, error2.range.start.character),
      to: codemirror_1$9.default.Pos(error2.range.end.line, error2.range.end.character)
    };
  });
  return results;
});
var info = {};
var require$$1$1 = /* @__PURE__ */ getAugmentedNamespace(graphql);
var getTypeInfo$2 = {};
var require$$1 = /* @__PURE__ */ getAugmentedNamespace(introspection);
var forEachState$1 = {};
Object.defineProperty(forEachState$1, "__esModule", { value: true });
function forEachState(stack, fn) {
  var reverseStateStack = [];
  var state = stack;
  while (state && state.kind) {
    reverseStateStack.push(state);
    state = state.prevState;
  }
  for (var i = reverseStateStack.length - 1; i >= 0; i--) {
    fn(reverseStateStack[i]);
  }
}
forEachState$1.default = forEachState;
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(getTypeInfo$2, "__esModule", { value: true });
var graphql_1$4 = require$$1$1;
var introspection_1 = require$$1;
var forEachState_1$1 = __importDefault$a(forEachState$1);
function getTypeInfo$1(schema, tokenState) {
  var info2 = {
    schema,
    type: null,
    parentType: null,
    inputType: null,
    directiveDef: null,
    fieldDef: null,
    argDef: null,
    argDefs: null,
    objectFieldDefs: null
  };
  forEachState_1$1.default(tokenState, function(state) {
    switch (state.kind) {
      case "Query":
      case "ShortQuery":
        info2.type = schema.getQueryType();
        break;
      case "Mutation":
        info2.type = schema.getMutationType();
        break;
      case "Subscription":
        info2.type = schema.getSubscriptionType();
        break;
      case "InlineFragment":
      case "FragmentDefinition":
        if (state.type) {
          info2.type = schema.getType(state.type);
        }
        break;
      case "Field":
      case "AliasedField":
        info2.fieldDef = info2.type && state.name ? getFieldDef(schema, info2.parentType, state.name) : null;
        info2.type = info2.fieldDef && info2.fieldDef.type;
        break;
      case "SelectionSet":
        info2.parentType = info2.type ? graphql_1$4.getNamedType(info2.type) : null;
        break;
      case "Directive":
        info2.directiveDef = state.name ? schema.getDirective(state.name) : null;
        break;
      case "Arguments":
        var parentDef = state.prevState ? state.prevState.kind === "Field" ? info2.fieldDef : state.prevState.kind === "Directive" ? info2.directiveDef : state.prevState.kind === "AliasedField" ? state.prevState.name && getFieldDef(schema, info2.parentType, state.prevState.name) : null : null;
        info2.argDefs = parentDef ? parentDef.args : null;
        break;
      case "Argument":
        info2.argDef = null;
        if (info2.argDefs) {
          for (var i = 0; i < info2.argDefs.length; i++) {
            if (info2.argDefs[i].name === state.name) {
              info2.argDef = info2.argDefs[i];
              break;
            }
          }
        }
        info2.inputType = info2.argDef && info2.argDef.type;
        break;
      case "EnumValue":
        var enumType = info2.inputType ? graphql_1$4.getNamedType(info2.inputType) : null;
        info2.enumValue = enumType instanceof graphql_1$4.GraphQLEnumType ? find$1(enumType.getValues(), function(val) {
          return val.value === state.name;
        }) : null;
        break;
      case "ListValue":
        var nullableType = info2.inputType ? graphql_1$4.getNullableType(info2.inputType) : null;
        info2.inputType = nullableType instanceof graphql_1$4.GraphQLList ? nullableType.ofType : null;
        break;
      case "ObjectValue":
        var objectType = info2.inputType ? graphql_1$4.getNamedType(info2.inputType) : null;
        info2.objectFieldDefs = objectType instanceof graphql_1$4.GraphQLInputObjectType ? objectType.getFields() : null;
        break;
      case "ObjectField":
        var objectField = state.name && info2.objectFieldDefs ? info2.objectFieldDefs[state.name] : null;
        info2.inputType = objectField && objectField.type;
        break;
      case "NamedType":
        info2.type = state.name ? schema.getType(state.name) : null;
        break;
    }
  });
  return info2;
}
getTypeInfo$2.default = getTypeInfo$1;
function getFieldDef(schema, type2, fieldName) {
  if (fieldName === introspection_1.SchemaMetaFieldDef.name && schema.getQueryType() === type2) {
    return introspection_1.SchemaMetaFieldDef;
  }
  if (fieldName === introspection_1.TypeMetaFieldDef.name && schema.getQueryType() === type2) {
    return introspection_1.TypeMetaFieldDef;
  }
  if (fieldName === introspection_1.TypeNameMetaFieldDef.name && graphql_1$4.isCompositeType(type2)) {
    return introspection_1.TypeNameMetaFieldDef;
  }
  if (type2 && type2.getFields) {
    return type2.getFields()[fieldName];
  }
}
function find$1(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return array[i];
    }
  }
}
var SchemaReference = {};
Object.defineProperty(SchemaReference, "__esModule", { value: true });
SchemaReference.getTypeReference = SchemaReference.getEnumValueReference = SchemaReference.getArgumentReference = SchemaReference.getDirectiveReference = SchemaReference.getFieldReference = void 0;
var graphql_1$3 = require$$1$1;
function getFieldReference(typeInfo) {
  return {
    kind: "Field",
    schema: typeInfo.schema,
    field: typeInfo.fieldDef,
    type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType
  };
}
SchemaReference.getFieldReference = getFieldReference;
function getDirectiveReference(typeInfo) {
  return {
    kind: "Directive",
    schema: typeInfo.schema,
    directive: typeInfo.directiveDef
  };
}
SchemaReference.getDirectiveReference = getDirectiveReference;
function getArgumentReference(typeInfo) {
  return typeInfo.directiveDef ? {
    kind: "Argument",
    schema: typeInfo.schema,
    argument: typeInfo.argDef,
    directive: typeInfo.directiveDef
  } : {
    kind: "Argument",
    schema: typeInfo.schema,
    argument: typeInfo.argDef,
    field: typeInfo.fieldDef,
    type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType
  };
}
SchemaReference.getArgumentReference = getArgumentReference;
function getEnumValueReference(typeInfo) {
  return {
    kind: "EnumValue",
    value: typeInfo.enumValue || void 0,
    type: typeInfo.inputType ? graphql_1$3.getNamedType(typeInfo.inputType) : void 0
  };
}
SchemaReference.getEnumValueReference = getEnumValueReference;
function getTypeReference(typeInfo, type2) {
  return {
    kind: "Type",
    schema: typeInfo.schema,
    type: type2 || typeInfo.type
  };
}
SchemaReference.getTypeReference = getTypeReference;
function isMetaField(fieldDef) {
  return fieldDef.name.slice(0, 2) === "__";
}
var infoAddon = {};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(infoAddon, "__esModule", { value: true });
var codemirror_1$8 = __importDefault$9(codemirror.exports);
codemirror_1$8.default.defineOption("info", false, function(cm, options, old) {
  if (old && old !== codemirror_1$8.default.Init) {
    var oldOnMouseOver = cm.state.info.onMouseOver;
    codemirror_1$8.default.off(cm.getWrapperElement(), "mouseover", oldOnMouseOver);
    clearTimeout(cm.state.info.hoverTimeout);
    delete cm.state.info;
  }
  if (options) {
    var state = cm.state.info = createState(options);
    state.onMouseOver = onMouseOver$1.bind(null, cm);
    codemirror_1$8.default.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
  }
});
function createState(options) {
  return {
    options: options instanceof Function ? { render: options } : options === true ? {} : options
  };
}
function getHoverTime(cm) {
  var options = cm.state.info.options;
  return options && options.hoverTime || 500;
}
function onMouseOver$1(cm, e) {
  var state = cm.state.info;
  var target2 = e.target || e.srcElement;
  if (!(target2 instanceof HTMLElement)) {
    return;
  }
  if (target2.nodeName !== "SPAN" || state.hoverTimeout !== void 0) {
    return;
  }
  var box = target2.getBoundingClientRect();
  var onMouseMove = function() {
    clearTimeout(state.hoverTimeout);
    state.hoverTimeout = setTimeout(onHover, hoverTime);
  };
  var onMouseOut2 = function() {
    codemirror_1$8.default.off(document, "mousemove", onMouseMove);
    codemirror_1$8.default.off(cm.getWrapperElement(), "mouseout", onMouseOut2);
    clearTimeout(state.hoverTimeout);
    state.hoverTimeout = void 0;
  };
  var onHover = function() {
    codemirror_1$8.default.off(document, "mousemove", onMouseMove);
    codemirror_1$8.default.off(cm.getWrapperElement(), "mouseout", onMouseOut2);
    state.hoverTimeout = void 0;
    onMouseHover(cm, box);
  };
  var hoverTime = getHoverTime(cm);
  state.hoverTimeout = setTimeout(onHover, hoverTime);
  codemirror_1$8.default.on(document, "mousemove", onMouseMove);
  codemirror_1$8.default.on(cm.getWrapperElement(), "mouseout", onMouseOut2);
}
function onMouseHover(cm, box) {
  var pos = cm.coordsChar({
    left: (box.left + box.right) / 2,
    top: (box.top + box.bottom) / 2
  });
  var state = cm.state.info;
  var options = state.options;
  var render = options.render || cm.getHelper(pos, "info");
  if (render) {
    var token2 = cm.getTokenAt(pos, true);
    if (token2) {
      var info2 = render(token2, options, cm, pos);
      if (info2) {
        showPopup(cm, box, info2);
      }
    }
  }
}
function showPopup(cm, box, info2) {
  var popup = document.createElement("div");
  popup.className = "CodeMirror-info";
  popup.appendChild(info2);
  document.body.appendChild(popup);
  var popupBox = popup.getBoundingClientRect();
  var popupStyle = window.getComputedStyle(popup);
  var popupWidth = popupBox.right - popupBox.left + parseFloat(popupStyle.marginLeft) + parseFloat(popupStyle.marginRight);
  var popupHeight = popupBox.bottom - popupBox.top + parseFloat(popupStyle.marginTop) + parseFloat(popupStyle.marginBottom);
  var topPos = box.bottom;
  if (popupHeight > window.innerHeight - box.bottom - 15 && box.top > window.innerHeight - box.bottom) {
    topPos = box.top - popupHeight;
  }
  if (topPos < 0) {
    topPos = box.bottom;
  }
  var leftPos = Math.max(0, window.innerWidth - popupWidth - 15);
  if (leftPos > box.left) {
    leftPos = box.left;
  }
  popup.style.opacity = "1";
  popup.style.top = topPos + "px";
  popup.style.left = leftPos + "px";
  var popupTimeout;
  var onMouseOverPopup = function() {
    clearTimeout(popupTimeout);
  };
  var onMouseOut2 = function() {
    clearTimeout(popupTimeout);
    popupTimeout = setTimeout(hidePopup, 200);
  };
  var hidePopup = function() {
    codemirror_1$8.default.off(popup, "mouseover", onMouseOverPopup);
    codemirror_1$8.default.off(popup, "mouseout", onMouseOut2);
    codemirror_1$8.default.off(cm.getWrapperElement(), "mouseout", onMouseOut2);
    if (popup.style.opacity) {
      popup.style.opacity = "0";
      setTimeout(function() {
        if (popup.parentNode) {
          popup.parentNode.removeChild(popup);
        }
      }, 600);
    } else if (popup.parentNode) {
      popup.parentNode.removeChild(popup);
    }
  };
  codemirror_1$8.default.on(popup, "mouseover", onMouseOverPopup);
  codemirror_1$8.default.on(popup, "mouseout", onMouseOut2);
  codemirror_1$8.default.on(cm.getWrapperElement(), "mouseout", onMouseOut2);
}
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(info, "__esModule", { value: true });
var graphql_1$2 = require$$1$1;
var codemirror_1$7 = __importDefault$8(codemirror.exports);
var getTypeInfo_1$1 = __importDefault$8(getTypeInfo$2);
var SchemaReference_1$1 = SchemaReference;
codemirror_1$7.default.registerHelper("info", "graphql", function(token2, options) {
  if (!options.schema || !token2.state) {
    return;
  }
  var state = token2.state;
  var kind2 = state.kind;
  var step = state.step;
  var typeInfo = getTypeInfo_1$1.default(options.schema, token2.state);
  if (kind2 === "Field" && step === 0 && typeInfo.fieldDef || kind2 === "AliasedField" && step === 2 && typeInfo.fieldDef) {
    var into = document.createElement("div");
    renderField(into, typeInfo, options);
    renderDescription(into, options, typeInfo.fieldDef);
    return into;
  } else if (kind2 === "Directive" && step === 1 && typeInfo.directiveDef) {
    var into = document.createElement("div");
    renderDirective(into, typeInfo, options);
    renderDescription(into, options, typeInfo.directiveDef);
    return into;
  } else if (kind2 === "Argument" && step === 0 && typeInfo.argDef) {
    var into = document.createElement("div");
    renderArg(into, typeInfo, options);
    renderDescription(into, options, typeInfo.argDef);
    return into;
  } else if (kind2 === "EnumValue" && typeInfo.enumValue && typeInfo.enumValue.description) {
    var into = document.createElement("div");
    renderEnumValue(into, typeInfo, options);
    renderDescription(into, options, typeInfo.enumValue);
    return into;
  } else if (kind2 === "NamedType" && typeInfo.type && typeInfo.type.description) {
    var into = document.createElement("div");
    renderType$1(into, typeInfo, options, typeInfo.type);
    renderDescription(into, options, typeInfo.type);
    return into;
  }
});
function renderField(into, typeInfo, options) {
  renderQualifiedField(into, typeInfo, options);
  renderTypeAnnotation(into, typeInfo, options, typeInfo.type);
}
function renderQualifiedField(into, typeInfo, options) {
  var _a2;
  var fieldName = ((_a2 = typeInfo.fieldDef) === null || _a2 === void 0 ? void 0 : _a2.name) || "";
  if (fieldName.slice(0, 2) !== "__") {
    renderType$1(into, typeInfo, options, typeInfo.parentType);
    text2(into, ".");
  }
  text2(into, fieldName, "field-name", options, SchemaReference_1$1.getFieldReference(typeInfo));
}
function renderDirective(into, typeInfo, options) {
  var _a2;
  var name2 = "@" + (((_a2 = typeInfo.directiveDef) === null || _a2 === void 0 ? void 0 : _a2.name) || "");
  text2(into, name2, "directive-name", options, SchemaReference_1$1.getDirectiveReference(typeInfo));
}
function renderArg(into, typeInfo, options) {
  var _a2;
  if (typeInfo.directiveDef) {
    renderDirective(into, typeInfo, options);
  } else if (typeInfo.fieldDef) {
    renderQualifiedField(into, typeInfo, options);
  }
  var name2 = ((_a2 = typeInfo.argDef) === null || _a2 === void 0 ? void 0 : _a2.name) || "";
  text2(into, "(");
  text2(into, name2, "arg-name", options, SchemaReference_1$1.getArgumentReference(typeInfo));
  renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);
  text2(into, ")");
}
function renderTypeAnnotation(into, typeInfo, options, t2) {
  text2(into, ": ");
  renderType$1(into, typeInfo, options, t2);
}
function renderEnumValue(into, typeInfo, options) {
  var _a2;
  var name2 = ((_a2 = typeInfo.enumValue) === null || _a2 === void 0 ? void 0 : _a2.name) || "";
  renderType$1(into, typeInfo, options, typeInfo.inputType);
  text2(into, ".");
  text2(into, name2, "enum-value", options, SchemaReference_1$1.getEnumValueReference(typeInfo));
}
function renderType$1(into, typeInfo, options, t2) {
  if (t2 instanceof graphql_1$2.GraphQLNonNull) {
    renderType$1(into, typeInfo, options, t2.ofType);
    text2(into, "!");
  } else if (t2 instanceof graphql_1$2.GraphQLList) {
    text2(into, "[");
    renderType$1(into, typeInfo, options, t2.ofType);
    text2(into, "]");
  } else {
    text2(into, (t2 === null || t2 === void 0 ? void 0 : t2.name) || "", "type-name", options, SchemaReference_1$1.getTypeReference(typeInfo, t2));
  }
}
function renderDescription(into, options, def) {
  var description = def.description;
  if (description) {
    var descriptionDiv = document.createElement("div");
    descriptionDiv.className = "info-description";
    if (options.renderDescription) {
      descriptionDiv.innerHTML = options.renderDescription(description);
    } else {
      descriptionDiv.appendChild(document.createTextNode(description));
    }
    into.appendChild(descriptionDiv);
  }
  renderDeprecation(into, options, def);
}
function renderDeprecation(into, options, def) {
  var reason = def.deprecationReason;
  if (reason) {
    var deprecationDiv = document.createElement("div");
    deprecationDiv.className = "info-deprecation";
    if (options.renderDescription) {
      deprecationDiv.innerHTML = options.renderDescription(reason);
    } else {
      deprecationDiv.appendChild(document.createTextNode(reason));
    }
    var label = document.createElement("span");
    label.className = "info-deprecation-label";
    label.appendChild(document.createTextNode("Deprecated: "));
    deprecationDiv.insertBefore(label, deprecationDiv.firstChild);
    into.appendChild(deprecationDiv);
  }
}
function text2(into, content, className, options, ref) {
  if (className === void 0) {
    className = "";
  }
  if (options === void 0) {
    options = { onClick: null };
  }
  if (ref === void 0) {
    ref = null;
  }
  if (className) {
    var onClick_1 = options.onClick;
    var node = void 0;
    if (onClick_1) {
      node = document.createElement("a");
      node.href = "javascript:void 0";
      node.addEventListener("click", function(e) {
        onClick_1(ref, e);
      });
    } else {
      node = document.createElement("span");
    }
    node.className = className;
    node.appendChild(document.createTextNode(content));
    into.appendChild(node);
  } else {
    into.appendChild(document.createTextNode(content));
  }
}
var jump = {};
var jumpAddon = {};
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(jumpAddon, "__esModule", { value: true });
var codemirror_1$6 = __importDefault$7(codemirror.exports);
codemirror_1$6.default.defineOption("jump", false, function(cm, options, old) {
  if (old && old !== codemirror_1$6.default.Init) {
    var oldOnMouseOver = cm.state.jump.onMouseOver;
    codemirror_1$6.default.off(cm.getWrapperElement(), "mouseover", oldOnMouseOver);
    var oldOnMouseOut = cm.state.jump.onMouseOut;
    codemirror_1$6.default.off(cm.getWrapperElement(), "mouseout", oldOnMouseOut);
    codemirror_1$6.default.off(document, "keydown", cm.state.jump.onKeyDown);
    delete cm.state.jump;
  }
  if (options) {
    var state = cm.state.jump = {
      options,
      onMouseOver: onMouseOver.bind(null, cm),
      onMouseOut: onMouseOut.bind(null, cm),
      onKeyDown: onKeyDown.bind(null, cm)
    };
    codemirror_1$6.default.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
    codemirror_1$6.default.on(cm.getWrapperElement(), "mouseout", state.onMouseOut);
    codemirror_1$6.default.on(document, "keydown", state.onKeyDown);
  }
});
function onMouseOver(cm, event) {
  var target2 = event.target || event.srcElement;
  if (!(target2 instanceof HTMLElement)) {
    return;
  }
  if ((target2 === null || target2 === void 0 ? void 0 : target2.nodeName) !== "SPAN") {
    return;
  }
  var box = target2.getBoundingClientRect();
  var cursor = {
    left: (box.left + box.right) / 2,
    top: (box.top + box.bottom) / 2
  };
  cm.state.jump.cursor = cursor;
  if (cm.state.jump.isHoldingModifier) {
    enableJumpMode(cm);
  }
}
function onMouseOut(cm) {
  if (!cm.state.jump.isHoldingModifier && cm.state.jump.cursor) {
    cm.state.jump.cursor = null;
    return;
  }
  if (cm.state.jump.isHoldingModifier && cm.state.jump.marker) {
    disableJumpMode(cm);
  }
}
function onKeyDown(cm, event) {
  if (cm.state.jump.isHoldingModifier || !isJumpModifier(event.key)) {
    return;
  }
  cm.state.jump.isHoldingModifier = true;
  if (cm.state.jump.cursor) {
    enableJumpMode(cm);
  }
  var onKeyUp = function(upEvent) {
    if (upEvent.code !== event.code) {
      return;
    }
    cm.state.jump.isHoldingModifier = false;
    if (cm.state.jump.marker) {
      disableJumpMode(cm);
    }
    codemirror_1$6.default.off(document, "keyup", onKeyUp);
    codemirror_1$6.default.off(document, "click", onClick);
    cm.off("mousedown", onMouseDown);
  };
  var onClick = function(clickEvent) {
    var destination = cm.state.jump.destination;
    if (destination) {
      cm.state.jump.options.onClick(destination, clickEvent);
    }
  };
  var onMouseDown = function(_, downEvent) {
    if (cm.state.jump.destination) {
      downEvent.codemirrorIgnore = true;
    }
  };
  codemirror_1$6.default.on(document, "keyup", onKeyUp);
  codemirror_1$6.default.on(document, "click", onClick);
  cm.on("mousedown", onMouseDown);
}
var isMac = typeof navigator !== "undefined" && navigator && navigator.appVersion.indexOf("Mac") !== -1;
function isJumpModifier(key) {
  return key === (isMac ? "Meta" : "Control");
}
function enableJumpMode(cm) {
  if (cm.state.jump.marker) {
    return;
  }
  var cursor = cm.state.jump.cursor;
  var pos = cm.coordsChar(cursor);
  var token2 = cm.getTokenAt(pos, true);
  var options = cm.state.jump.options;
  var getDestination = options.getDestination || cm.getHelper(pos, "jump");
  if (getDestination) {
    var destination = getDestination(token2, options, cm);
    if (destination) {
      var marker2 = cm.markText({ line: pos.line, ch: token2.start }, { line: pos.line, ch: token2.end }, { className: "CodeMirror-jump-token" });
      cm.state.jump.marker = marker2;
      cm.state.jump.destination = destination;
    }
  }
}
function disableJumpMode(cm) {
  var marker2 = cm.state.jump.marker;
  cm.state.jump.marker = null;
  cm.state.jump.destination = null;
  marker2.clear();
}
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(jump, "__esModule", { value: true });
var codemirror_1$5 = __importDefault$6(codemirror.exports);
var getTypeInfo_1 = __importDefault$6(getTypeInfo$2);
var SchemaReference_1 = SchemaReference;
codemirror_1$5.default.registerHelper("jump", "graphql", function(token2, options) {
  if (!options.schema || !options.onClick || !token2.state) {
    return;
  }
  var state = token2.state;
  var kind2 = state.kind;
  var step = state.step;
  var typeInfo = getTypeInfo_1.default(options.schema, state);
  if (kind2 === "Field" && step === 0 && typeInfo.fieldDef || kind2 === "AliasedField" && step === 2 && typeInfo.fieldDef) {
    return SchemaReference_1.getFieldReference(typeInfo);
  } else if (kind2 === "Directive" && step === 1 && typeInfo.directiveDef) {
    return SchemaReference_1.getDirectiveReference(typeInfo);
  } else if (kind2 === "Argument" && step === 0 && typeInfo.argDef) {
    return SchemaReference_1.getArgumentReference(typeInfo);
  } else if (kind2 === "EnumValue" && typeInfo.enumValue) {
    return SchemaReference_1.getEnumValueReference(typeInfo);
  } else if (kind2 === "NamedType" && typeInfo.type) {
    return SchemaReference_1.getTypeReference(typeInfo);
  }
});
var mode$2 = {};
var modeFactory = {};
var modeIndent = {};
Object.defineProperty(modeIndent, "__esModule", { value: true });
function indent$3(state, textAfter) {
  var _a2, _b;
  var levels = state.levels;
  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);
  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);
}
modeIndent.default = indent$3;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(modeFactory, "__esModule", { value: true });
var graphql_language_service_1$2 = require$$1$2;
var mode_indent_1 = __importDefault$5(modeIndent);
var graphqlModeFactory = function(config2) {
  var parser = graphql_language_service_1$2.onlineParser({
    eatWhitespace: function(stream) {
      return stream.eatWhile(graphql_language_service_1$2.isIgnored);
    },
    lexRules: graphql_language_service_1$2.LexRules,
    parseRules: graphql_language_service_1$2.ParseRules,
    editorConfig: { tabSize: config2.tabSize }
  });
  return {
    config: config2,
    startState: parser.startState,
    token: parser.token,
    indent: mode_indent_1.default,
    electricInput: /^\s*[})\]]/,
    fold: "brace",
    lineComment: "#",
    closeBrackets: {
      pairs: '()[]{}""',
      explode: "()[]{}"
    }
  };
};
modeFactory.default = graphqlModeFactory;
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(mode$2, "__esModule", { value: true });
var codemirror_1$4 = __importDefault$4(codemirror.exports);
var mode_factory_1 = __importDefault$4(modeFactory);
codemirror_1$4.default.defineMode("graphql", mode_factory_1.default);
var __extends$b = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$9 = globalThis && globalThis.__assign || function() {
  __assign$9 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$9.apply(this, arguments);
};
var md$1 = new markdownIt();
var AUTO_COMPLETE_AFTER_KEY = /^[a-zA-Z0-9_@(]$/;
var QueryEditor = function(_super2) {
  __extends$b(QueryEditor2, _super2);
  function QueryEditor2(props) {
    var _this = _super2.call(this, props) || this;
    _this.editor = null;
    _this.ignoreChangeEvent = false;
    _this._node = null;
    _this._onKeyUp = function(_cm, event) {
      if (AUTO_COMPLETE_AFTER_KEY.test(event.key) && _this.editor) {
        _this.editor.execCommand("autocomplete");
      }
    };
    _this._onEdit = function() {
      if (!_this.ignoreChangeEvent && _this.editor) {
        _this.cachedValue = _this.editor.getValue();
        if (_this.props.onEdit) {
          _this.props.onEdit(_this.cachedValue);
        }
      }
    };
    _this._onHasCompletion = function(cm, data) {
      onHasCompletion(cm, data, _this.props.onHintInformationRender);
    };
    _this.cachedValue = props.value || "";
    return _this;
  }
  QueryEditor2.prototype.componentDidMount = function() {
    var _this = this;
    var _a2, _b, _c;
    var editor = this.editor = CodeMirror(this._node, {
      value: this.props.value || "",
      lineNumbers: true,
      tabSize: 2,
      mode: "graphql",
      theme: this.props.editorTheme || "graphiql",
      keyMap: "sublime",
      autoCloseBrackets: true,
      matchBrackets: true,
      showCursorWhenSelecting: true,
      readOnly: this.props.readOnly ? "nocursor" : false,
      foldGutter: {
        minFoldSize: 4
      },
      lint: {
        schema: this.props.schema,
        validationRules: (_a2 = this.props.validationRules) !== null && _a2 !== void 0 ? _a2 : null,
        externalFragments: (_b = this.props) === null || _b === void 0 ? void 0 : _b.externalFragments
      },
      hintOptions: {
        schema: this.props.schema,
        closeOnUnfocus: false,
        completeSingle: false,
        container: this._node,
        externalFragments: (_c = this.props) === null || _c === void 0 ? void 0 : _c.externalFragments
      },
      info: {
        schema: this.props.schema,
        renderDescription: function(text3) {
          return md$1.render(text3);
        },
        onClick: function(reference3) {
          return _this.props.onClickReference && _this.props.onClickReference(reference3);
        }
      },
      jump: {
        schema: this.props.schema,
        onClick: function(reference3) {
          return _this.props.onClickReference && _this.props.onClickReference(reference3);
        }
      },
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: __assign$9(__assign$9({ "Cmd-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Ctrl-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Alt-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Shift-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Shift-Alt-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Cmd-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Ctrl-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Shift-Ctrl-C": function() {
        if (_this.props.onCopyQuery) {
          _this.props.onCopyQuery();
        }
      }, "Shift-Ctrl-P": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-F": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-M": function() {
        if (_this.props.onMergeQuery) {
          _this.props.onMergeQuery();
        }
      } }, commonKeys), { "Cmd-S": function() {
        if (_this.props.onRunQuery)
          ;
      }, "Ctrl-S": function() {
        if (_this.props.onRunQuery)
          ;
      } })
    });
    if (editor) {
      editor.on("change", this._onEdit);
      editor.on("keyup", this._onKeyUp);
      editor.on("hasCompletion", this._onHasCompletion);
      editor.on("beforeChange", this._onBeforeChange);
    }
  };
  QueryEditor2.prototype.componentDidUpdate = function(prevProps) {
    this.ignoreChangeEvent = true;
    if (this.props.schema !== prevProps.schema && this.editor) {
      this.editor.options.lint.schema = this.props.schema;
      this.editor.options.hintOptions.schema = this.props.schema;
      this.editor.options.info.schema = this.props.schema;
      this.editor.options.jump.schema = this.props.schema;
      CodeMirror.signal(this.editor, "change", this.editor);
    }
    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue && this.editor) {
      this.cachedValue = this.props.value;
      this.editor.setValue(this.props.value);
    }
    this.ignoreChangeEvent = false;
  };
  QueryEditor2.prototype.componentWillUnmount = function() {
    if (this.editor) {
      this.editor.off("change", this._onEdit);
      this.editor.off("keyup", this._onKeyUp);
      this.editor.off("hasCompletion", this._onHasCompletion);
      this.editor = null;
    }
  };
  QueryEditor2.prototype.render = function() {
    var _this = this;
    return React$1.createElement("section", { className: "query-editor", "aria-label": "Query Editor", ref: function(node) {
      _this._node = node;
    } });
  };
  QueryEditor2.prototype.getCodeMirror = function() {
    return this.editor;
  };
  QueryEditor2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  QueryEditor2.prototype._onBeforeChange = function(_instance, change) {
    if (change.origin === "paste") {
      var text3 = change.text.map(normalizeWhitespace);
      change.update(change.from, change.to, text3);
    }
  };
  return QueryEditor2;
}(React$1.Component);
var hint = {};
var hintList$1 = {};
Object.defineProperty(hintList$1, "__esModule", { value: true });
function hintList(cursor, token2, list3) {
  var hints = filterAndSortList(list3, normalizeText(token2.string));
  if (!hints) {
    return;
  }
  var tokenStart = token2.type !== null && /"|\w/.test(token2.string[0]) ? token2.start : token2.end;
  return {
    list: hints,
    from: { line: cursor.line, ch: tokenStart },
    to: { line: cursor.line, ch: token2.end }
  };
}
hintList$1.default = hintList;
function filterAndSortList(list3, text3) {
  if (!text3) {
    return filterNonEmpty(list3, function(entry) {
      return !entry.isDeprecated;
    });
  }
  var byProximity = list3.map(function(entry) {
    return {
      proximity: getProximity(normalizeText(entry.text), text3),
      entry
    };
  });
  var conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, function(pair) {
    return pair.proximity <= 2;
  }), function(pair) {
    return !pair.entry.isDeprecated;
  });
  var sortedMatches = conciseMatches.sort(function(a, b) {
    return (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;
  });
  return sortedMatches.map(function(pair) {
    return pair.entry;
  });
}
function filterNonEmpty(array, predicate) {
  var filtered = array.filter(predicate);
  return filtered.length === 0 ? array : filtered;
}
function normalizeText(text3) {
  return text3.toLowerCase().replace(/\W/g, "");
}
function getProximity(suggestion, text3) {
  var proximity = lexicalDistance(text3, suggestion);
  if (suggestion.length > text3.length) {
    proximity -= suggestion.length - text3.length - 1;
    proximity += suggestion.indexOf(text3) === 0 ? 0 : 0.5;
  }
  return proximity;
}
function lexicalDistance(a, b) {
  var i;
  var j;
  var d = [];
  var aLength = a.length;
  var bLength = b.length;
  for (i = 0; i <= aLength; i++) {
    d[i] = [i];
  }
  for (j = 1; j <= bLength; j++) {
    d[0][j] = j;
  }
  for (i = 1; i <= aLength; i++) {
    for (j = 1; j <= bLength; j++) {
      var cost = a[i - 1] === b[j - 1] ? 0 : 1;
      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }
  return d[aLength][bLength];
}
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(hint, "__esModule", { value: true });
var codemirror_1$3 = __importDefault$3(codemirror.exports);
var graphql_1$1 = require$$1$1;
var forEachState_1 = __importDefault$3(forEachState$1);
var hintList_1 = __importDefault$3(hintList$1);
codemirror_1$3.default.registerHelper("hint", "graphql-variables", function(editor, options) {
  var cur = editor.getCursor();
  var token2 = editor.getTokenAt(cur);
  var results = getVariablesHint(cur, token2, options);
  if (results && results.list && results.list.length > 0) {
    results.from = codemirror_1$3.default.Pos(results.from.line, results.from.ch);
    results.to = codemirror_1$3.default.Pos(results.to.line, results.to.ch);
    codemirror_1$3.default.signal(editor, "hasCompletion", editor, results, token2);
  }
  return results;
});
function getVariablesHint(cur, token2, options) {
  var state = token2.state.kind === "Invalid" ? token2.state.prevState : token2.state;
  var kind2 = state.kind;
  var step = state.step;
  if (kind2 === "Document" && step === 0) {
    return hintList_1.default(cur, token2, [{ text: "{" }]);
  }
  var variableToType = options.variableToType;
  if (!variableToType) {
    return;
  }
  var typeInfo = getTypeInfo(variableToType, token2.state);
  if (kind2 === "Document" || kind2 === "Variable" && step === 0) {
    var variableNames = Object.keys(variableToType);
    return hintList_1.default(cur, token2, variableNames.map(function(name2) {
      return {
        text: '"' + name2 + '": ',
        type: variableToType[name2]
      };
    }));
  }
  if (kind2 === "ObjectValue" || kind2 === "ObjectField" && step === 0) {
    if (typeInfo.fields) {
      var inputFields = Object.keys(typeInfo.fields).map(function(fieldName) {
        return typeInfo.fields[fieldName];
      });
      return hintList_1.default(cur, token2, inputFields.map(function(field) {
        return {
          text: '"' + field.name + '": ',
          type: field.type,
          description: field.description
        };
      }));
    }
  }
  if (kind2 === "StringValue" || kind2 === "NumberValue" || kind2 === "BooleanValue" || kind2 === "NullValue" || kind2 === "ListValue" && step === 1 || kind2 === "ObjectField" && step === 2 || kind2 === "Variable" && step === 2) {
    var namedInputType_1 = typeInfo.type ? graphql_1$1.getNamedType(typeInfo.type) : void 0;
    if (namedInputType_1 instanceof graphql_1$1.GraphQLInputObjectType) {
      return hintList_1.default(cur, token2, [{ text: "{" }]);
    } else if (namedInputType_1 instanceof graphql_1$1.GraphQLEnumType) {
      var values = namedInputType_1.getValues();
      return hintList_1.default(cur, token2, values.map(function(value) {
        return {
          text: '"' + value.name + '"',
          type: namedInputType_1,
          description: value.description
        };
      }));
    } else if (namedInputType_1 === graphql_1$1.GraphQLBoolean) {
      return hintList_1.default(cur, token2, [
        { text: "true", type: graphql_1$1.GraphQLBoolean, description: "Not false." },
        { text: "false", type: graphql_1$1.GraphQLBoolean, description: "Not true." }
      ]);
    }
  }
}
function getTypeInfo(variableToType, tokenState) {
  var info2 = {
    type: null,
    fields: null
  };
  forEachState_1.default(tokenState, function(state) {
    if (state.kind === "Variable") {
      info2.type = variableToType[state.name];
    } else if (state.kind === "ListValue") {
      var nullableType = info2.type ? graphql_1$1.getNullableType(info2.type) : void 0;
      info2.type = nullableType instanceof graphql_1$1.GraphQLList ? nullableType.ofType : null;
    } else if (state.kind === "ObjectValue") {
      var objectType = info2.type ? graphql_1$1.getNamedType(info2.type) : void 0;
      info2.fields = objectType instanceof graphql_1$1.GraphQLInputObjectType ? objectType.getFields() : null;
    } else if (state.kind === "ObjectField") {
      var objectField = state.name && info2.fields ? info2.fields[state.name] : null;
      info2.type = objectField && objectField.type;
    }
  });
  return info2;
}
var lint = {};
var jsonParse$1 = {};
Object.defineProperty(jsonParse$1, "__esModule", { value: true });
function jsonParse(str) {
  string = str;
  strLen = str.length;
  start = end = lastEnd = -1;
  ch();
  lex();
  var ast2 = parseObj();
  expect("EOF");
  return ast2;
}
jsonParse$1.default = jsonParse;
var string;
var strLen;
var start;
var end;
var lastEnd;
var code$1;
var kind;
function parseObj() {
  var nodeStart = start;
  var members = [];
  expect("{");
  if (!skip("}")) {
    do {
      members.push(parseMember());
    } while (skip(","));
    expect("}");
  }
  return {
    kind: "Object",
    start: nodeStart,
    end: lastEnd,
    members
  };
}
function parseMember() {
  var nodeStart = start;
  var key = kind === "String" ? curToken() : null;
  expect("String");
  expect(":");
  var value = parseVal();
  return {
    kind: "Member",
    start: nodeStart,
    end: lastEnd,
    key,
    value
  };
}
function parseArr() {
  var nodeStart = start;
  var values = [];
  expect("[");
  if (!skip("]")) {
    do {
      values.push(parseVal());
    } while (skip(","));
    expect("]");
  }
  return {
    kind: "Array",
    start: nodeStart,
    end: lastEnd,
    values
  };
}
function parseVal() {
  switch (kind) {
    case "[":
      return parseArr();
    case "{":
      return parseObj();
    case "String":
    case "Number":
    case "Boolean":
    case "Null":
      var token2 = curToken();
      lex();
      return token2;
  }
  expect("Value");
}
function curToken() {
  return { kind, start, end, value: JSON.parse(string.slice(start, end)) };
}
function expect(str) {
  if (kind === str) {
    lex();
    return;
  }
  var found;
  if (kind === "EOF") {
    found = "[end of file]";
  } else if (end - start > 1) {
    found = "`" + string.slice(start, end) + "`";
  } else {
    var match2 = string.slice(start).match(/^.+?\b/);
    found = "`" + (match2 ? match2[0] : string[start]) + "`";
  }
  throw syntaxError("Expected " + str + " but found " + found + ".");
}
function syntaxError(message) {
  return { message, start, end };
}
function skip(k) {
  if (kind === k) {
    lex();
    return true;
  }
}
function ch() {
  if (end < strLen) {
    end++;
    code$1 = end === strLen ? 0 : string.charCodeAt(end);
  }
  return code$1;
}
function lex() {
  lastEnd = end;
  while (code$1 === 9 || code$1 === 10 || code$1 === 13 || code$1 === 32) {
    ch();
  }
  if (code$1 === 0) {
    kind = "EOF";
    return;
  }
  start = end;
  switch (code$1) {
    case 34:
      kind = "String";
      return readString();
    case 45:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      kind = "Number";
      return readNumber();
    case 102:
      if (string.slice(start, start + 5) !== "false") {
        break;
      }
      end += 4;
      ch();
      kind = "Boolean";
      return;
    case 110:
      if (string.slice(start, start + 4) !== "null") {
        break;
      }
      end += 3;
      ch();
      kind = "Null";
      return;
    case 116:
      if (string.slice(start, start + 4) !== "true") {
        break;
      }
      end += 3;
      ch();
      kind = "Boolean";
      return;
  }
  kind = string[start];
  ch();
}
function readString() {
  ch();
  while (code$1 !== 34 && code$1 > 31) {
    if (code$1 === 92) {
      code$1 = ch();
      switch (code$1) {
        case 34:
        case 47:
        case 92:
        case 98:
        case 102:
        case 110:
        case 114:
        case 116:
          ch();
          break;
        case 117:
          ch();
          readHex();
          readHex();
          readHex();
          readHex();
          break;
        default:
          throw syntaxError("Bad character escape sequence.");
      }
    } else if (end === strLen) {
      throw syntaxError("Unterminated string.");
    } else {
      ch();
    }
  }
  if (code$1 === 34) {
    ch();
    return;
  }
  throw syntaxError("Unterminated string.");
}
function readHex() {
  if (code$1 >= 48 && code$1 <= 57 || code$1 >= 65 && code$1 <= 70 || code$1 >= 97 && code$1 <= 102) {
    return ch();
  }
  throw syntaxError("Expected hexadecimal digit.");
}
function readNumber() {
  if (code$1 === 45) {
    ch();
  }
  if (code$1 === 48) {
    ch();
  } else {
    readDigits();
  }
  if (code$1 === 46) {
    ch();
    readDigits();
  }
  if (code$1 === 69 || code$1 === 101) {
    code$1 = ch();
    if (code$1 === 43 || code$1 === 45) {
      ch();
    }
    readDigits();
  }
}
function readDigits() {
  if (code$1 < 48 || code$1 > 57) {
    throw syntaxError("Expected decimal digit.");
  }
  do {
    ch();
  } while (code$1 >= 48 && code$1 <= 57);
}
var __read$5 = commonjsGlobal && commonjsGlobal.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __importDefault$2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(lint, "__esModule", { value: true });
var codemirror_1$2 = __importDefault$2(codemirror.exports);
var graphql_1 = require$$1$1;
var jsonParse_1 = __importDefault$2(jsonParse$1);
codemirror_1$2.default.registerHelper("lint", "graphql-variables", function(text3, options, editor) {
  if (!text3) {
    return [];
  }
  var ast2;
  try {
    ast2 = jsonParse_1.default(text3);
  } catch (syntaxError2) {
    if (syntaxError2.stack) {
      throw syntaxError2;
    }
    return [lintError(editor, syntaxError2, syntaxError2.message)];
  }
  var variableToType = options.variableToType;
  if (!variableToType) {
    return [];
  }
  return validateVariables(editor, variableToType, ast2);
});
function validateVariables(editor, variableToType, variablesAST) {
  var errors2 = [];
  variablesAST.members.forEach(function(member) {
    var _a2;
    if (member) {
      var variableName = (_a2 = member.key) === null || _a2 === void 0 ? void 0 : _a2.value;
      var type2 = variableToType[variableName];
      if (!type2) {
        errors2.push(lintError(editor, member.key, 'Variable "$' + variableName + '" does not appear in any GraphQL query.'));
      } else {
        validateValue(type2, member.value).forEach(function(_a3) {
          var _b = __read$5(_a3, 2), node = _b[0], message = _b[1];
          errors2.push(lintError(editor, node, message));
        });
      }
    }
  });
  return errors2;
}
function validateValue(type2, valueAST) {
  if (!type2 || !valueAST) {
    return [];
  }
  if (type2 instanceof graphql_1.GraphQLNonNull) {
    if (valueAST.kind === "Null") {
      return [[valueAST, 'Type "' + type2 + '" is non-nullable and cannot be null.']];
    }
    return validateValue(type2.ofType, valueAST);
  }
  if (valueAST.kind === "Null") {
    return [];
  }
  if (type2 instanceof graphql_1.GraphQLList) {
    var itemType_1 = type2.ofType;
    if (valueAST.kind === "Array") {
      var values = valueAST.values || [];
      return mapCat(values, function(item) {
        return validateValue(itemType_1, item);
      });
    }
    return validateValue(itemType_1, valueAST);
  }
  if (type2 instanceof graphql_1.GraphQLInputObjectType) {
    if (valueAST.kind !== "Object") {
      return [[valueAST, 'Type "' + type2 + '" must be an Object.']];
    }
    var providedFields_1 = /* @__PURE__ */ Object.create(null);
    var fieldErrors_1 = mapCat(valueAST.members, function(member) {
      var _a2;
      var fieldName = (_a2 = member === null || member === void 0 ? void 0 : member.key) === null || _a2 === void 0 ? void 0 : _a2.value;
      providedFields_1[fieldName] = true;
      var inputField = type2.getFields()[fieldName];
      if (!inputField) {
        return [
          [
            member.key,
            'Type "' + type2 + '" does not have a field "' + fieldName + '".'
          ]
        ];
      }
      var fieldType = inputField ? inputField.type : void 0;
      return validateValue(fieldType, member.value);
    });
    Object.keys(type2.getFields()).forEach(function(fieldName) {
      if (!providedFields_1[fieldName]) {
        var fieldType = type2.getFields()[fieldName].type;
        if (fieldType instanceof graphql_1.GraphQLNonNull) {
          fieldErrors_1.push([
            valueAST,
            'Object of type "' + type2 + '" is missing required field "' + fieldName + '".'
          ]);
        }
      }
    });
    return fieldErrors_1;
  }
  if (type2.name === "Boolean" && valueAST.kind !== "Boolean" || type2.name === "String" && valueAST.kind !== "String" || type2.name === "ID" && valueAST.kind !== "Number" && valueAST.kind !== "String" || type2.name === "Float" && valueAST.kind !== "Number" || type2.name === "Int" && (valueAST.kind !== "Number" || (valueAST.value | 0) !== valueAST.value)) {
    return [[valueAST, 'Expected value of type "' + type2 + '".']];
  }
  if (type2 instanceof graphql_1.GraphQLEnumType || type2 instanceof graphql_1.GraphQLScalarType) {
    if (valueAST.kind !== "String" && valueAST.kind !== "Number" && valueAST.kind !== "Boolean" && valueAST.kind !== "Null" || isNullish(type2.parseValue(valueAST.value))) {
      return [[valueAST, 'Expected value of type "' + type2 + '".']];
    }
  }
  return [];
}
function lintError(editor, node, message) {
  return {
    message,
    severity: "error",
    type: "validation",
    from: editor.posFromIndex(node.start),
    to: editor.posFromIndex(node.end)
  };
}
function isNullish(value) {
  return value === null || value === void 0 || value !== value;
}
function mapCat(array, mapper) {
  return Array.prototype.concat.apply([], array.map(mapper));
}
var mode$1 = {};
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(mode$1, "__esModule", { value: true });
var codemirror_1$1 = __importDefault$1(codemirror.exports);
var graphql_language_service_1$1 = require$$1$2;
codemirror_1$1.default.defineMode("graphql-variables", function(config2) {
  var parser = graphql_language_service_1$1.onlineParser({
    eatWhitespace: function(stream) {
      return stream.eatSpace();
    },
    lexRules: LexRules$1,
    parseRules: ParseRules$1,
    editorConfig: { tabSize: config2.tabSize }
  });
  return {
    config: config2,
    startState: parser.startState,
    token: parser.token,
    indent: indent$2,
    electricInput: /^\s*[}\]]/,
    fold: "brace",
    closeBrackets: {
      pairs: '[]{}""',
      explode: "[]{}"
    }
  };
});
function indent$2(state, textAfter) {
  var _a2, _b;
  var levels = state.levels;
  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);
  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);
}
var LexRules$1 = {
  Punctuation: /^\[|]|\{|\}|:|,/,
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
  String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
  Keyword: /^true|false|null/
};
var ParseRules$1 = {
  Document: [graphql_language_service_1$1.p("{"), graphql_language_service_1$1.list("Variable", graphql_language_service_1$1.opt(graphql_language_service_1$1.p(","))), graphql_language_service_1$1.p("}")],
  Variable: [namedKey("variable"), graphql_language_service_1$1.p(":"), "Value"],
  Value: function(token2) {
    switch (token2.kind) {
      case "Number":
        return "NumberValue";
      case "String":
        return "StringValue";
      case "Punctuation":
        switch (token2.value) {
          case "[":
            return "ListValue";
          case "{":
            return "ObjectValue";
        }
        return null;
      case "Keyword":
        switch (token2.value) {
          case "true":
          case "false":
            return "BooleanValue";
          case "null":
            return "NullValue";
        }
        return null;
    }
  },
  NumberValue: [graphql_language_service_1$1.t("Number", "number")],
  StringValue: [graphql_language_service_1$1.t("String", "string")],
  BooleanValue: [graphql_language_service_1$1.t("Keyword", "builtin")],
  NullValue: [graphql_language_service_1$1.t("Keyword", "keyword")],
  ListValue: [graphql_language_service_1$1.p("["), graphql_language_service_1$1.list("Value", graphql_language_service_1$1.opt(graphql_language_service_1$1.p(","))), graphql_language_service_1$1.p("]")],
  ObjectValue: [graphql_language_service_1$1.p("{"), graphql_language_service_1$1.list("ObjectField", graphql_language_service_1$1.opt(graphql_language_service_1$1.p(","))), graphql_language_service_1$1.p("}")],
  ObjectField: [namedKey("attribute"), graphql_language_service_1$1.p(":"), "Value"]
};
function namedKey(style) {
  return {
    style,
    match: function(token2) {
      return token2.kind === "String";
    },
    update: function(state, token2) {
      state.name = token2.value.slice(1, -1);
    }
  };
}
var __extends$a = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$8 = globalThis && globalThis.__assign || function() {
  __assign$8 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$8.apply(this, arguments);
};
var VariableEditor = function(_super2) {
  __extends$a(VariableEditor2, _super2);
  function VariableEditor2(props) {
    var _this = _super2.call(this, props) || this;
    _this.editor = null;
    _this._node = null;
    _this.ignoreChangeEvent = false;
    _this._onKeyUp = function(_cm, event) {
      var code3 = event.keyCode;
      if (!_this.editor) {
        return;
      }
      if (code3 >= 65 && code3 <= 90 || !event.shiftKey && code3 >= 48 && code3 <= 57 || event.shiftKey && code3 === 189 || event.shiftKey && code3 === 222) {
        _this.editor.execCommand("autocomplete");
      }
    };
    _this._onEdit = function() {
      if (!_this.editor) {
        return;
      }
      if (!_this.ignoreChangeEvent) {
        _this.cachedValue = _this.editor.getValue();
        if (_this.props.onEdit) {
          _this.props.onEdit(_this.cachedValue);
        }
      }
    };
    _this._onHasCompletion = function(instance, changeObj) {
      onHasCompletion(instance, changeObj, _this.props.onHintInformationRender);
    };
    _this.cachedValue = props.value || "";
    return _this;
  }
  VariableEditor2.prototype.componentDidMount = function() {
    var _this = this;
    var editor = this.editor = CodeMirror(this._node, {
      value: this.props.value || "",
      lineNumbers: true,
      tabSize: 2,
      mode: "graphql-variables",
      theme: this.props.editorTheme || "graphiql",
      keyMap: "sublime",
      autoCloseBrackets: true,
      matchBrackets: true,
      showCursorWhenSelecting: true,
      readOnly: this.props.readOnly ? "nocursor" : false,
      foldGutter: {
        minFoldSize: 4
      },
      lint: {
        variableToType: this.props.variableToType
      },
      hintOptions: {
        variableToType: this.props.variableToType,
        closeOnUnfocus: false,
        completeSingle: false,
        container: this._node
      },
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: __assign$8({ "Cmd-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Ctrl-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Alt-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Shift-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Cmd-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Ctrl-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Shift-Ctrl-P": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-M": function() {
        if (_this.props.onMergeQuery) {
          _this.props.onMergeQuery();
        }
      } }, commonKeys)
    });
    editor.on("change", this._onEdit);
    editor.on("keyup", this._onKeyUp);
    editor.on("hasCompletion", this._onHasCompletion);
  };
  VariableEditor2.prototype.componentDidUpdate = function(prevProps) {
    if (!this.editor) {
      return;
    }
    this.ignoreChangeEvent = true;
    if (this.props.variableToType !== prevProps.variableToType) {
      this.editor.options.lint.variableToType = this.props.variableToType;
      this.editor.options.hintOptions.variableToType = this.props.variableToType;
      CodeMirror.signal(this.editor, "change", this.editor);
    }
    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {
      var thisValue = this.props.value || "";
      this.cachedValue = thisValue;
      this.editor.setValue(thisValue);
    }
    this.ignoreChangeEvent = false;
  };
  VariableEditor2.prototype.componentWillUnmount = function() {
    if (!this.editor) {
      return;
    }
    this.editor.off("change", this._onEdit);
    this.editor.off("keyup", this._onKeyUp);
    this.editor.off("hasCompletion", this._onHasCompletion);
    this.editor = null;
  };
  VariableEditor2.prototype.render = function() {
    var _this = this;
    return React$1.createElement("div", { className: "codemirrorWrap", style: {
      position: this.props.active ? "relative" : "absolute",
      visibility: this.props.active ? "visible" : "hidden"
    }, ref: function(node) {
      _this._node = node;
    } });
  };
  VariableEditor2.prototype.getCodeMirror = function() {
    return this.editor;
  };
  VariableEditor2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  return VariableEditor2;
}(React$1.Component);
(function(module2, exports) {
  (function(mod) {
    mod(codemirror.exports);
  })(function(CodeMirror2) {
    CodeMirror2.defineMode("javascript", function(config2, parserConfig) {
      var indentUnit = config2.indentUnit;
      var statementIndent = parserConfig.statementIndent;
      var jsonldMode = parserConfig.jsonld;
      var jsonMode = parserConfig.json || jsonldMode;
      var trackScope = parserConfig.trackScope !== false;
      var isTS = parserConfig.typescript;
      var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
      var keywords = function() {
        function kw(type3) {
          return { type: type3, style: "keyword" };
        }
        var A2 = kw("keyword a"), B2 = kw("keyword b"), C2 = kw("keyword c"), D2 = kw("keyword d");
        var operator = kw("operator"), atom = { type: "atom", style: "atom" };
        return {
          "if": kw("if"),
          "while": A2,
          "with": A2,
          "else": B2,
          "do": B2,
          "try": B2,
          "finally": B2,
          "return": D2,
          "break": D2,
          "continue": D2,
          "new": kw("new"),
          "delete": C2,
          "void": C2,
          "throw": C2,
          "debugger": kw("debugger"),
          "var": kw("var"),
          "const": kw("var"),
          "let": kw("var"),
          "function": kw("function"),
          "catch": kw("catch"),
          "for": kw("for"),
          "switch": kw("switch"),
          "case": kw("case"),
          "default": kw("default"),
          "in": operator,
          "typeof": operator,
          "instanceof": operator,
          "true": atom,
          "false": atom,
          "null": atom,
          "undefined": atom,
          "NaN": atom,
          "Infinity": atom,
          "this": kw("this"),
          "class": kw("class"),
          "super": kw("atom"),
          "yield": C2,
          "export": kw("export"),
          "import": kw("import"),
          "extends": C2,
          "await": C2
        };
      }();
      var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
      var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
      function readRegexp(stream) {
        var escaped = false, next, inSet = false;
        while ((next = stream.next()) != null) {
          if (!escaped) {
            if (next == "/" && !inSet)
              return;
            if (next == "[")
              inSet = true;
            else if (inSet && next == "]")
              inSet = false;
          }
          escaped = !escaped && next == "\\";
        }
      }
      var type2, content;
      function ret(tp, style, cont2) {
        type2 = tp;
        content = cont2;
        return style;
      }
      function tokenBase(stream, state) {
        var ch2 = stream.next();
        if (ch2 == '"' || ch2 == "'") {
          state.tokenize = tokenString(ch2);
          return state.tokenize(stream, state);
        } else if (ch2 == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
          return ret("number", "number");
        } else if (ch2 == "." && stream.match("..")) {
          return ret("spread", "meta");
        } else if (/[\[\]{}\(\),;\:\.]/.test(ch2)) {
          return ret(ch2);
        } else if (ch2 == "=" && stream.eat(">")) {
          return ret("=>", "operator");
        } else if (ch2 == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
          return ret("number", "number");
        } else if (/\d/.test(ch2)) {
          stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
          return ret("number", "number");
        } else if (ch2 == "/") {
          if (stream.eat("*")) {
            state.tokenize = tokenComment;
            return tokenComment(stream, state);
          } else if (stream.eat("/")) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (expressionAllowed(stream, state, 1)) {
            readRegexp(stream);
            stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
            return ret("regexp", "string-2");
          } else {
            stream.eat("=");
            return ret("operator", "operator", stream.current());
          }
        } else if (ch2 == "`") {
          state.tokenize = tokenQuasi;
          return tokenQuasi(stream, state);
        } else if (ch2 == "#" && stream.peek() == "!") {
          stream.skipToEnd();
          return ret("meta", "meta");
        } else if (ch2 == "#" && stream.eatWhile(wordRE)) {
          return ret("variable", "property");
        } else if (ch2 == "<" && stream.match("!--") || ch2 == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
          stream.skipToEnd();
          return ret("comment", "comment");
        } else if (isOperatorChar.test(ch2)) {
          if (ch2 != ">" || !state.lexical || state.lexical.type != ">") {
            if (stream.eat("=")) {
              if (ch2 == "!" || ch2 == "=")
                stream.eat("=");
            } else if (/[<>*+\-|&?]/.test(ch2)) {
              stream.eat(ch2);
              if (ch2 == ">")
                stream.eat(ch2);
            }
          }
          if (ch2 == "?" && stream.eat("."))
            return ret(".");
          return ret("operator", "operator", stream.current());
        } else if (wordRE.test(ch2)) {
          stream.eatWhile(wordRE);
          var word2 = stream.current();
          if (state.lastType != ".") {
            if (keywords.propertyIsEnumerable(word2)) {
              var kw = keywords[word2];
              return ret(kw.type, kw.style, word2);
            }
            if (word2 == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
              return ret("async", "keyword", word2);
          }
          return ret("variable", "variable", word2);
        }
      }
      function tokenString(quote) {
        return function(stream, state) {
          var escaped = false, next;
          if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
            state.tokenize = tokenBase;
            return ret("jsonld-keyword", "meta");
          }
          while ((next = stream.next()) != null) {
            if (next == quote && !escaped)
              break;
            escaped = !escaped && next == "\\";
          }
          if (!escaped)
            state.tokenize = tokenBase;
          return ret("string", "string");
        };
      }
      function tokenComment(stream, state) {
        var maybeEnd = false, ch2;
        while (ch2 = stream.next()) {
          if (ch2 == "/" && maybeEnd) {
            state.tokenize = tokenBase;
            break;
          }
          maybeEnd = ch2 == "*";
        }
        return ret("comment", "comment");
      }
      function tokenQuasi(stream, state) {
        var escaped = false, next;
        while ((next = stream.next()) != null) {
          if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
            state.tokenize = tokenBase;
            break;
          }
          escaped = !escaped && next == "\\";
        }
        return ret("quasi", "string-2", stream.current());
      }
      var brackets = "([{}])";
      function findFatArrow(stream, state) {
        if (state.fatArrowAt)
          state.fatArrowAt = null;
        var arrow = stream.string.indexOf("=>", stream.start);
        if (arrow < 0)
          return;
        if (isTS) {
          var m2 = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
          if (m2)
            arrow = m2.index;
        }
        var depth = 0, sawSomething = false;
        for (var pos = arrow - 1; pos >= 0; --pos) {
          var ch2 = stream.string.charAt(pos);
          var bracket = brackets.indexOf(ch2);
          if (bracket >= 0 && bracket < 3) {
            if (!depth) {
              ++pos;
              break;
            }
            if (--depth == 0) {
              if (ch2 == "(")
                sawSomething = true;
              break;
            }
          } else if (bracket >= 3 && bracket < 6) {
            ++depth;
          } else if (wordRE.test(ch2)) {
            sawSomething = true;
          } else if (/["'\/`]/.test(ch2)) {
            for (; ; --pos) {
              if (pos == 0)
                return;
              var next = stream.string.charAt(pos - 1);
              if (next == ch2 && stream.string.charAt(pos - 2) != "\\") {
                pos--;
                break;
              }
            }
          } else if (sawSomething && !depth) {
            ++pos;
            break;
          }
        }
        if (sawSomething && !depth)
          state.fatArrowAt = pos;
      }
      var atomicTypes = {
        "atom": true,
        "number": true,
        "variable": true,
        "string": true,
        "regexp": true,
        "this": true,
        "import": true,
        "jsonld-keyword": true
      };
      function JSLexical(indented, column, type3, align, prev, info2) {
        this.indented = indented;
        this.column = column;
        this.type = type3;
        this.prev = prev;
        this.info = info2;
        if (align != null)
          this.align = align;
      }
      function inScope(state, varname) {
        if (!trackScope)
          return false;
        for (var v2 = state.localVars; v2; v2 = v2.next)
          if (v2.name == varname)
            return true;
        for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
          for (var v2 = cx2.vars; v2; v2 = v2.next)
            if (v2.name == varname)
              return true;
        }
      }
      function parseJS(state, style, type3, content2, stream) {
        var cc2 = state.cc;
        cx.state = state;
        cx.stream = stream;
        cx.marked = null, cx.cc = cc2;
        cx.style = style;
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = true;
        while (true) {
          var combinator = cc2.length ? cc2.pop() : jsonMode ? expression : statement;
          if (combinator(type3, content2)) {
            while (cc2.length && cc2[cc2.length - 1].lex)
              cc2.pop()();
            if (cx.marked)
              return cx.marked;
            if (type3 == "variable" && inScope(state, content2))
              return "variable-2";
            return style;
          }
        }
      }
      var cx = { state: null, column: null, marked: null, cc: null };
      function pass() {
        for (var i = arguments.length - 1; i >= 0; i--)
          cx.cc.push(arguments[i]);
      }
      function cont() {
        pass.apply(null, arguments);
        return true;
      }
      function inList(name2, list3) {
        for (var v2 = list3; v2; v2 = v2.next)
          if (v2.name == name2)
            return true;
        return false;
      }
      function register(varname) {
        var state = cx.state;
        cx.marked = "def";
        if (!trackScope)
          return;
        if (state.context) {
          if (state.lexical.info == "var" && state.context && state.context.block) {
            var newContext = registerVarScoped(varname, state.context);
            if (newContext != null) {
              state.context = newContext;
              return;
            }
          } else if (!inList(varname, state.localVars)) {
            state.localVars = new Var(varname, state.localVars);
            return;
          }
        }
        if (parserConfig.globalVars && !inList(varname, state.globalVars))
          state.globalVars = new Var(varname, state.globalVars);
      }
      function registerVarScoped(varname, context) {
        if (!context) {
          return null;
        } else if (context.block) {
          var inner = registerVarScoped(varname, context.prev);
          if (!inner)
            return null;
          if (inner == context.prev)
            return context;
          return new Context(inner, context.vars, true);
        } else if (inList(varname, context.vars)) {
          return context;
        } else {
          return new Context(context.prev, new Var(varname, context.vars), false);
        }
      }
      function isModifier(name2) {
        return name2 == "public" || name2 == "private" || name2 == "protected" || name2 == "abstract" || name2 == "readonly";
      }
      function Context(prev, vars, block4) {
        this.prev = prev;
        this.vars = vars;
        this.block = block4;
      }
      function Var(name2, next) {
        this.name = name2;
        this.next = next;
      }
      var defaultVars = new Var("this", new Var("arguments", null));
      function pushcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
        cx.state.localVars = defaultVars;
      }
      function pushblockcontext() {
        cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
        cx.state.localVars = null;
      }
      pushcontext.lex = pushblockcontext.lex = true;
      function popcontext() {
        cx.state.localVars = cx.state.context.vars;
        cx.state.context = cx.state.context.prev;
      }
      popcontext.lex = true;
      function pushlex(type3, info2) {
        var result2 = function() {
          var state = cx.state, indent2 = state.indented;
          if (state.lexical.type == "stat")
            indent2 = state.lexical.indented;
          else
            for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
              indent2 = outer.indented;
          state.lexical = new JSLexical(indent2, cx.stream.column(), type3, null, state.lexical, info2);
        };
        result2.lex = true;
        return result2;
      }
      function poplex() {
        var state = cx.state;
        if (state.lexical.prev) {
          if (state.lexical.type == ")")
            state.indented = state.lexical.indented;
          state.lexical = state.lexical.prev;
        }
      }
      poplex.lex = true;
      function expect2(wanted) {
        function exp(type3) {
          if (type3 == wanted)
            return cont();
          else if (wanted == ";" || type3 == "}" || type3 == ")" || type3 == "]")
            return pass();
          else
            return cont(exp);
        }
        return exp;
      }
      function statement(type3, value) {
        if (type3 == "var")
          return cont(pushlex("vardef", value), vardef, expect2(";"), poplex);
        if (type3 == "keyword a")
          return cont(pushlex("form"), parenExpr, statement, poplex);
        if (type3 == "keyword b")
          return cont(pushlex("form"), statement, poplex);
        if (type3 == "keyword d")
          return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect2(";"), poplex);
        if (type3 == "debugger")
          return cont(expect2(";"));
        if (type3 == "{")
          return cont(pushlex("}"), pushblockcontext, block3, poplex, popcontext);
        if (type3 == ";")
          return cont();
        if (type3 == "if") {
          if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
            cx.state.cc.pop()();
          return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
        }
        if (type3 == "function")
          return cont(functiondef);
        if (type3 == "for")
          return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
        if (type3 == "class" || isTS && value == "interface") {
          cx.marked = "keyword";
          return cont(pushlex("form", type3 == "class" ? type3 : value), className, poplex);
        }
        if (type3 == "variable") {
          if (isTS && value == "declare") {
            cx.marked = "keyword";
            return cont(statement);
          } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
            cx.marked = "keyword";
            if (value == "enum")
              return cont(enumdef);
            else if (value == "type")
              return cont(typename, expect2("operator"), typeexpr, expect2(";"));
            else
              return cont(pushlex("form"), pattern, expect2("{"), pushlex("}"), block3, poplex, poplex);
          } else if (isTS && value == "namespace") {
            cx.marked = "keyword";
            return cont(pushlex("form"), expression, statement, poplex);
          } else if (isTS && value == "abstract") {
            cx.marked = "keyword";
            return cont(statement);
          } else {
            return cont(pushlex("stat"), maybelabel);
          }
        }
        if (type3 == "switch")
          return cont(pushlex("form"), parenExpr, expect2("{"), pushlex("}", "switch"), pushblockcontext, block3, poplex, poplex, popcontext);
        if (type3 == "case")
          return cont(expression, expect2(":"));
        if (type3 == "default")
          return cont(expect2(":"));
        if (type3 == "catch")
          return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
        if (type3 == "export")
          return cont(pushlex("stat"), afterExport, poplex);
        if (type3 == "import")
          return cont(pushlex("stat"), afterImport, poplex);
        if (type3 == "async")
          return cont(statement);
        if (value == "@")
          return cont(expression, statement);
        return pass(pushlex("stat"), expression, expect2(";"), poplex);
      }
      function maybeCatchBinding(type3) {
        if (type3 == "(")
          return cont(funarg, expect2(")"));
      }
      function expression(type3, value) {
        return expressionInner(type3, value, false);
      }
      function expressionNoComma(type3, value) {
        return expressionInner(type3, value, true);
      }
      function parenExpr(type3) {
        if (type3 != "(")
          return pass();
        return cont(pushlex(")"), maybeexpression, expect2(")"), poplex);
      }
      function expressionInner(type3, value, noComma) {
        if (cx.state.fatArrowAt == cx.stream.start) {
          var body = noComma ? arrowBodyNoComma : arrowBody;
          if (type3 == "(")
            return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect2("=>"), body, popcontext);
          else if (type3 == "variable")
            return pass(pushcontext, pattern, expect2("=>"), body, popcontext);
        }
        var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
        if (atomicTypes.hasOwnProperty(type3))
          return cont(maybeop);
        if (type3 == "function")
          return cont(functiondef, maybeop);
        if (type3 == "class" || isTS && value == "interface") {
          cx.marked = "keyword";
          return cont(pushlex("form"), classExpression, poplex);
        }
        if (type3 == "keyword c" || type3 == "async")
          return cont(noComma ? expressionNoComma : expression);
        if (type3 == "(")
          return cont(pushlex(")"), maybeexpression, expect2(")"), poplex, maybeop);
        if (type3 == "operator" || type3 == "spread")
          return cont(noComma ? expressionNoComma : expression);
        if (type3 == "[")
          return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
        if (type3 == "{")
          return contCommasep(objprop, "}", null, maybeop);
        if (type3 == "quasi")
          return pass(quasi, maybeop);
        if (type3 == "new")
          return cont(maybeTarget(noComma));
        return cont();
      }
      function maybeexpression(type3) {
        if (type3.match(/[;\}\)\],]/))
          return pass();
        return pass(expression);
      }
      function maybeoperatorComma(type3, value) {
        if (type3 == ",")
          return cont(maybeexpression);
        return maybeoperatorNoComma(type3, value, false);
      }
      function maybeoperatorNoComma(type3, value, noComma) {
        var me2 = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
        var expr = noComma == false ? expression : expressionNoComma;
        if (type3 == "=>")
          return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
        if (type3 == "operator") {
          if (/\+\+|--/.test(value) || isTS && value == "!")
            return cont(me2);
          if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me2);
          if (value == "?")
            return cont(expression, expect2(":"), expr);
          return cont(expr);
        }
        if (type3 == "quasi") {
          return pass(quasi, me2);
        }
        if (type3 == ";")
          return;
        if (type3 == "(")
          return contCommasep(expressionNoComma, ")", "call", me2);
        if (type3 == ".")
          return cont(property, me2);
        if (type3 == "[")
          return cont(pushlex("]"), maybeexpression, expect2("]"), poplex, me2);
        if (isTS && value == "as") {
          cx.marked = "keyword";
          return cont(typeexpr, me2);
        }
        if (type3 == "regexp") {
          cx.state.lastType = cx.marked = "operator";
          cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
          return cont(expr);
        }
      }
      function quasi(type3, value) {
        if (type3 != "quasi")
          return pass();
        if (value.slice(value.length - 2) != "${")
          return cont(quasi);
        return cont(maybeexpression, continueQuasi);
      }
      function continueQuasi(type3) {
        if (type3 == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasi);
        }
      }
      function arrowBody(type3) {
        findFatArrow(cx.stream, cx.state);
        return pass(type3 == "{" ? statement : expression);
      }
      function arrowBodyNoComma(type3) {
        findFatArrow(cx.stream, cx.state);
        return pass(type3 == "{" ? statement : expressionNoComma);
      }
      function maybeTarget(noComma) {
        return function(type3) {
          if (type3 == ".")
            return cont(noComma ? targetNoComma : target2);
          else if (type3 == "variable" && isTS)
            return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
          else
            return pass(noComma ? expressionNoComma : expression);
        };
      }
      function target2(_, value) {
        if (value == "target") {
          cx.marked = "keyword";
          return cont(maybeoperatorComma);
        }
      }
      function targetNoComma(_, value) {
        if (value == "target") {
          cx.marked = "keyword";
          return cont(maybeoperatorNoComma);
        }
      }
      function maybelabel(type3) {
        if (type3 == ":")
          return cont(poplex, statement);
        return pass(maybeoperatorComma, expect2(";"), poplex);
      }
      function property(type3) {
        if (type3 == "variable") {
          cx.marked = "property";
          return cont();
        }
      }
      function objprop(type3, value) {
        if (type3 == "async") {
          cx.marked = "property";
          return cont(objprop);
        } else if (type3 == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          if (value == "get" || value == "set")
            return cont(getterSetter);
          var m2;
          if (isTS && cx.state.fatArrowAt == cx.stream.start && (m2 = cx.stream.match(/^\s*:\s*/, false)))
            cx.state.fatArrowAt = cx.stream.pos + m2[0].length;
          return cont(afterprop);
        } else if (type3 == "number" || type3 == "string") {
          cx.marked = jsonldMode ? "property" : cx.style + " property";
          return cont(afterprop);
        } else if (type3 == "jsonld-keyword") {
          return cont(afterprop);
        } else if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(objprop);
        } else if (type3 == "[") {
          return cont(expression, maybetype, expect2("]"), afterprop);
        } else if (type3 == "spread") {
          return cont(expressionNoComma, afterprop);
        } else if (value == "*") {
          cx.marked = "keyword";
          return cont(objprop);
        } else if (type3 == ":") {
          return pass(afterprop);
        }
      }
      function getterSetter(type3) {
        if (type3 != "variable")
          return pass(afterprop);
        cx.marked = "property";
        return cont(functiondef);
      }
      function afterprop(type3) {
        if (type3 == ":")
          return cont(expressionNoComma);
        if (type3 == "(")
          return pass(functiondef);
      }
      function commasep(what, end2, sep) {
        function proceed(type3, value) {
          if (sep ? sep.indexOf(type3) > -1 : type3 == ",") {
            var lex2 = cx.state.lexical;
            if (lex2.info == "call")
              lex2.pos = (lex2.pos || 0) + 1;
            return cont(function(type4, value2) {
              if (type4 == end2 || value2 == end2)
                return pass();
              return pass(what);
            }, proceed);
          }
          if (type3 == end2 || value == end2)
            return cont();
          if (sep && sep.indexOf(";") > -1)
            return pass(what);
          return cont(expect2(end2));
        }
        return function(type3, value) {
          if (type3 == end2 || value == end2)
            return cont();
          return pass(what, proceed);
        };
      }
      function contCommasep(what, end2, info2) {
        for (var i = 3; i < arguments.length; i++)
          cx.cc.push(arguments[i]);
        return cont(pushlex(end2, info2), commasep(what, end2), poplex);
      }
      function block3(type3) {
        if (type3 == "}")
          return cont();
        return pass(statement, block3);
      }
      function maybetype(type3, value) {
        if (isTS) {
          if (type3 == ":")
            return cont(typeexpr);
          if (value == "?")
            return cont(maybetype);
        }
      }
      function maybetypeOrIn(type3, value) {
        if (isTS && (type3 == ":" || value == "in"))
          return cont(typeexpr);
      }
      function mayberettype(type3) {
        if (isTS && type3 == ":") {
          if (cx.stream.match(/^\s*\w+\s+is\b/, false))
            return cont(expression, isKW, typeexpr);
          else
            return cont(typeexpr);
        }
      }
      function isKW(_, value) {
        if (value == "is") {
          cx.marked = "keyword";
          return cont();
        }
      }
      function typeexpr(type3, value) {
        if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
          cx.marked = "keyword";
          return cont(value == "typeof" ? expressionNoComma : typeexpr);
        }
        if (type3 == "variable" || value == "void") {
          cx.marked = "type";
          return cont(afterType);
        }
        if (value == "|" || value == "&")
          return cont(typeexpr);
        if (type3 == "string" || type3 == "number" || type3 == "atom")
          return cont(afterType);
        if (type3 == "[")
          return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
        if (type3 == "{")
          return cont(pushlex("}"), typeprops, poplex, afterType);
        if (type3 == "(")
          return cont(commasep(typearg, ")"), maybeReturnType, afterType);
        if (type3 == "<")
          return cont(commasep(typeexpr, ">"), typeexpr);
        if (type3 == "quasi") {
          return pass(quasiType, afterType);
        }
      }
      function maybeReturnType(type3) {
        if (type3 == "=>")
          return cont(typeexpr);
      }
      function typeprops(type3) {
        if (type3.match(/[\}\)\]]/))
          return cont();
        if (type3 == "," || type3 == ";")
          return cont(typeprops);
        return pass(typeprop, typeprops);
      }
      function typeprop(type3, value) {
        if (type3 == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(typeprop);
        } else if (value == "?" || type3 == "number" || type3 == "string") {
          return cont(typeprop);
        } else if (type3 == ":") {
          return cont(typeexpr);
        } else if (type3 == "[") {
          return cont(expect2("variable"), maybetypeOrIn, expect2("]"), typeprop);
        } else if (type3 == "(") {
          return pass(functiondecl, typeprop);
        } else if (!type3.match(/[;\}\)\],]/)) {
          return cont();
        }
      }
      function quasiType(type3, value) {
        if (type3 != "quasi")
          return pass();
        if (value.slice(value.length - 2) != "${")
          return cont(quasiType);
        return cont(typeexpr, continueQuasiType);
      }
      function continueQuasiType(type3) {
        if (type3 == "}") {
          cx.marked = "string-2";
          cx.state.tokenize = tokenQuasi;
          return cont(quasiType);
        }
      }
      function typearg(type3, value) {
        if (type3 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?")
          return cont(typearg);
        if (type3 == ":")
          return cont(typeexpr);
        if (type3 == "spread")
          return cont(typearg);
        return pass(typeexpr);
      }
      function afterType(type3, value) {
        if (value == "<")
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
        if (value == "|" || type3 == "." || value == "&")
          return cont(typeexpr);
        if (type3 == "[")
          return cont(typeexpr, expect2("]"), afterType);
        if (value == "extends" || value == "implements") {
          cx.marked = "keyword";
          return cont(typeexpr);
        }
        if (value == "?")
          return cont(typeexpr, expect2(":"), typeexpr);
      }
      function maybeTypeArgs(_, value) {
        if (value == "<")
          return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
      }
      function typeparam() {
        return pass(typeexpr, maybeTypeDefault);
      }
      function maybeTypeDefault(_, value) {
        if (value == "=")
          return cont(typeexpr);
      }
      function vardef(_, value) {
        if (value == "enum") {
          cx.marked = "keyword";
          return cont(enumdef);
        }
        return pass(pattern, maybetype, maybeAssign, vardefCont);
      }
      function pattern(type3, value) {
        if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(pattern);
        }
        if (type3 == "variable") {
          register(value);
          return cont();
        }
        if (type3 == "spread")
          return cont(pattern);
        if (type3 == "[")
          return contCommasep(eltpattern, "]");
        if (type3 == "{")
          return contCommasep(proppattern, "}");
      }
      function proppattern(type3, value) {
        if (type3 == "variable" && !cx.stream.match(/^\s*:/, false)) {
          register(value);
          return cont(maybeAssign);
        }
        if (type3 == "variable")
          cx.marked = "property";
        if (type3 == "spread")
          return cont(pattern);
        if (type3 == "}")
          return pass();
        if (type3 == "[")
          return cont(expression, expect2("]"), expect2(":"), proppattern);
        return cont(expect2(":"), pattern, maybeAssign);
      }
      function eltpattern() {
        return pass(pattern, maybeAssign);
      }
      function maybeAssign(_type, value) {
        if (value == "=")
          return cont(expressionNoComma);
      }
      function vardefCont(type3) {
        if (type3 == ",")
          return cont(vardef);
      }
      function maybeelse(type3, value) {
        if (type3 == "keyword b" && value == "else")
          return cont(pushlex("form", "else"), statement, poplex);
      }
      function forspec(type3, value) {
        if (value == "await")
          return cont(forspec);
        if (type3 == "(")
          return cont(pushlex(")"), forspec1, poplex);
      }
      function forspec1(type3) {
        if (type3 == "var")
          return cont(vardef, forspec2);
        if (type3 == "variable")
          return cont(forspec2);
        return pass(forspec2);
      }
      function forspec2(type3, value) {
        if (type3 == ")")
          return cont();
        if (type3 == ";")
          return cont(forspec2);
        if (value == "in" || value == "of") {
          cx.marked = "keyword";
          return cont(expression, forspec2);
        }
        return pass(expression, forspec2);
      }
      function functiondef(type3, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(functiondef);
        }
        if (type3 == "variable") {
          register(value);
          return cont(functiondef);
        }
        if (type3 == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
        if (isTS && value == "<")
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
      }
      function functiondecl(type3, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(functiondecl);
        }
        if (type3 == "variable") {
          register(value);
          return cont(functiondecl);
        }
        if (type3 == "(")
          return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
        if (isTS && value == "<")
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
      }
      function typename(type3, value) {
        if (type3 == "keyword" || type3 == "variable") {
          cx.marked = "type";
          return cont(typename);
        } else if (value == "<") {
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
        }
      }
      function funarg(type3, value) {
        if (value == "@")
          cont(expression, funarg);
        if (type3 == "spread")
          return cont(funarg);
        if (isTS && isModifier(value)) {
          cx.marked = "keyword";
          return cont(funarg);
        }
        if (isTS && type3 == "this")
          return cont(maybetype, maybeAssign);
        return pass(pattern, maybetype, maybeAssign);
      }
      function classExpression(type3, value) {
        if (type3 == "variable")
          return className(type3, value);
        return classNameAfter(type3, value);
      }
      function className(type3, value) {
        if (type3 == "variable") {
          register(value);
          return cont(classNameAfter);
        }
      }
      function classNameAfter(type3, value) {
        if (value == "<")
          return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
        if (value == "extends" || value == "implements" || isTS && type3 == ",") {
          if (value == "implements")
            cx.marked = "keyword";
          return cont(isTS ? typeexpr : expression, classNameAfter);
        }
        if (type3 == "{")
          return cont(pushlex("}"), classBody, poplex);
      }
      function classBody(type3, value) {
        if (type3 == "async" || type3 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (type3 == "variable" || cx.style == "keyword") {
          cx.marked = "property";
          return cont(classfield, classBody);
        }
        if (type3 == "number" || type3 == "string")
          return cont(classfield, classBody);
        if (type3 == "[")
          return cont(expression, maybetype, expect2("]"), classfield, classBody);
        if (value == "*") {
          cx.marked = "keyword";
          return cont(classBody);
        }
        if (isTS && type3 == "(")
          return pass(functiondecl, classBody);
        if (type3 == ";" || type3 == ",")
          return cont(classBody);
        if (type3 == "}")
          return cont();
        if (value == "@")
          return cont(expression, classBody);
      }
      function classfield(type3, value) {
        if (value == "!")
          return cont(classfield);
        if (value == "?")
          return cont(classfield);
        if (type3 == ":")
          return cont(typeexpr, maybeAssign);
        if (value == "=")
          return cont(expressionNoComma);
        var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
        return pass(isInterface ? functiondecl : functiondef);
      }
      function afterExport(type3, value) {
        if (value == "*") {
          cx.marked = "keyword";
          return cont(maybeFrom, expect2(";"));
        }
        if (value == "default") {
          cx.marked = "keyword";
          return cont(expression, expect2(";"));
        }
        if (type3 == "{")
          return cont(commasep(exportField, "}"), maybeFrom, expect2(";"));
        return pass(statement);
      }
      function exportField(type3, value) {
        if (value == "as") {
          cx.marked = "keyword";
          return cont(expect2("variable"));
        }
        if (type3 == "variable")
          return pass(expressionNoComma, exportField);
      }
      function afterImport(type3) {
        if (type3 == "string")
          return cont();
        if (type3 == "(")
          return pass(expression);
        if (type3 == ".")
          return pass(maybeoperatorComma);
        return pass(importSpec, maybeMoreImports, maybeFrom);
      }
      function importSpec(type3, value) {
        if (type3 == "{")
          return contCommasep(importSpec, "}");
        if (type3 == "variable")
          register(value);
        if (value == "*")
          cx.marked = "keyword";
        return cont(maybeAs);
      }
      function maybeMoreImports(type3) {
        if (type3 == ",")
          return cont(importSpec, maybeMoreImports);
      }
      function maybeAs(_type, value) {
        if (value == "as") {
          cx.marked = "keyword";
          return cont(importSpec);
        }
      }
      function maybeFrom(_type, value) {
        if (value == "from") {
          cx.marked = "keyword";
          return cont(expression);
        }
      }
      function arrayLiteral(type3) {
        if (type3 == "]")
          return cont();
        return pass(commasep(expressionNoComma, "]"));
      }
      function enumdef() {
        return pass(pushlex("form"), pattern, expect2("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
      }
      function enummember() {
        return pass(pattern, maybeAssign);
      }
      function isContinuedStatement(state, textAfter) {
        return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
      }
      function expressionAllowed(stream, state, backUp) {
        return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
      }
      return {
        startState: function(basecolumn) {
          var state = {
            tokenize: tokenBase,
            lastType: "sof",
            cc: [],
            lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
            localVars: parserConfig.localVars,
            context: parserConfig.localVars && new Context(null, null, false),
            indented: basecolumn || 0
          };
          if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
            state.globalVars = parserConfig.globalVars;
          return state;
        },
        token: function(stream, state) {
          if (stream.sol()) {
            if (!state.lexical.hasOwnProperty("align"))
              state.lexical.align = false;
            state.indented = stream.indentation();
            findFatArrow(stream, state);
          }
          if (state.tokenize != tokenComment && stream.eatSpace())
            return null;
          var style = state.tokenize(stream, state);
          if (type2 == "comment")
            return style;
          state.lastType = type2 == "operator" && (content == "++" || content == "--") ? "incdec" : type2;
          return parseJS(state, style, type2, content, stream);
        },
        indent: function(state, textAfter) {
          if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
            return CodeMirror2.Pass;
          if (state.tokenize != tokenBase)
            return 0;
          var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top2;
          if (!/^\s*else\b/.test(textAfter))
            for (var i = state.cc.length - 1; i >= 0; --i) {
              var c = state.cc[i];
              if (c == poplex)
                lexical = lexical.prev;
              else if (c != maybeelse && c != popcontext)
                break;
            }
          while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top2 = state.cc[state.cc.length - 1]) && (top2 == maybeoperatorComma || top2 == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
            lexical = lexical.prev;
          if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
            lexical = lexical.prev;
          var type3 = lexical.type, closing = firstChar == type3;
          if (type3 == "vardef")
            return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
          else if (type3 == "form" && firstChar == "{")
            return lexical.indented;
          else if (type3 == "form")
            return lexical.indented + indentUnit;
          else if (type3 == "stat")
            return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
          else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
            return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
          else if (lexical.align)
            return lexical.column + (closing ? 0 : 1);
          else
            return lexical.indented + (closing ? 0 : indentUnit);
        },
        electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
        blockCommentStart: jsonMode ? null : "/*",
        blockCommentEnd: jsonMode ? null : "*/",
        blockCommentContinue: jsonMode ? null : " * ",
        lineComment: jsonMode ? null : "//",
        fold: "brace",
        closeBrackets: "()[]{}''\"\"``",
        helperType: jsonMode ? "json" : "javascript",
        jsonldMode,
        jsonMode,
        expressionAllowed,
        skipExpression: function(state) {
          parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
        }
      };
    });
    CodeMirror2.registerHelper("wordChars", "javascript", /[\w$]/);
    CodeMirror2.defineMIME("text/javascript", "javascript");
    CodeMirror2.defineMIME("text/ecmascript", "javascript");
    CodeMirror2.defineMIME("application/javascript", "javascript");
    CodeMirror2.defineMIME("application/x-javascript", "javascript");
    CodeMirror2.defineMIME("application/ecmascript", "javascript");
    CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
    CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
    CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
    CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
    CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
    CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
  });
})();
var __extends$9 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$7 = globalThis && globalThis.__assign || function() {
  __assign$7 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$7.apply(this, arguments);
};
var HeaderEditor = function(_super2) {
  __extends$9(HeaderEditor2, _super2);
  function HeaderEditor2(props) {
    var _this = _super2.call(this, props) || this;
    _this.editor = null;
    _this._node = null;
    _this.ignoreChangeEvent = false;
    _this._onKeyUp = function(_cm, event) {
      var code3 = event.keyCode;
      if (!_this.editor) {
        return;
      }
      if (code3 >= 65 && code3 <= 90 || !event.shiftKey && code3 >= 48 && code3 <= 57 || event.shiftKey && code3 === 189 || event.shiftKey && code3 === 222) {
        _this.editor.execCommand("autocomplete");
      }
    };
    _this._onEdit = function() {
      if (!_this.editor) {
        return;
      }
      if (!_this.ignoreChangeEvent) {
        _this.cachedValue = _this.editor.getValue();
        if (_this.props.onEdit) {
          _this.props.onEdit(_this.cachedValue);
        }
      }
    };
    _this._onHasCompletion = function(instance, changeObj) {
      onHasCompletion(instance, changeObj, _this.props.onHintInformationRender);
    };
    _this.cachedValue = props.value || "";
    return _this;
  }
  HeaderEditor2.prototype.componentDidMount = function() {
    var _this = this;
    var editor = this.editor = CodeMirror(this._node, {
      value: this.props.value || "",
      lineNumbers: true,
      tabSize: 2,
      mode: { name: "javascript", json: true },
      theme: this.props.editorTheme || "graphiql",
      keyMap: "sublime",
      autoCloseBrackets: true,
      matchBrackets: true,
      showCursorWhenSelecting: true,
      readOnly: this.props.readOnly ? "nocursor" : false,
      foldGutter: {
        minFoldSize: 4
      },
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: __assign$7({ "Cmd-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Ctrl-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Alt-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Shift-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Cmd-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Ctrl-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Shift-Ctrl-P": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-M": function() {
        if (_this.props.onMergeQuery) {
          _this.props.onMergeQuery();
        }
      } }, commonKeys)
    });
    editor.on("change", this._onEdit);
    editor.on("keyup", this._onKeyUp);
    editor.on("hasCompletion", this._onHasCompletion);
  };
  HeaderEditor2.prototype.componentDidUpdate = function(prevProps) {
    if (!this.editor) {
      return;
    }
    this.ignoreChangeEvent = true;
    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {
      var thisValue = this.props.value || "";
      this.cachedValue = thisValue;
      this.editor.setValue(thisValue);
    }
    this.ignoreChangeEvent = false;
  };
  HeaderEditor2.prototype.componentWillUnmount = function() {
    if (!this.editor) {
      return;
    }
    this.editor.off("change", this._onEdit);
    this.editor.off("keyup", this._onKeyUp);
    this.editor.off("hasCompletion", this._onHasCompletion);
    this.editor = null;
  };
  HeaderEditor2.prototype.render = function() {
    var _this = this;
    return React$1.createElement("div", { className: "codemirrorWrap", style: {
      position: this.props.active ? "relative" : "absolute",
      visibility: this.props.active ? "visible" : "hidden"
    }, ref: function(node) {
      _this._node = node;
    } });
  };
  HeaderEditor2.prototype.getCodeMirror = function() {
    return this.editor;
  };
  HeaderEditor2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  return HeaderEditor2;
}(React$1.Component);
var mode = {};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(mode, "__esModule", { value: true });
var codemirror_1 = __importDefault(codemirror.exports);
var graphql_language_service_1 = require$$1$2;
codemirror_1.default.defineMode("graphql-results", function(config2) {
  var parser = graphql_language_service_1.onlineParser({
    eatWhitespace: function(stream) {
      return stream.eatSpace();
    },
    lexRules: LexRules,
    parseRules: ParseRules,
    editorConfig: { tabSize: config2.tabSize }
  });
  return {
    config: config2,
    startState: parser.startState,
    token: parser.token,
    indent: indent$1,
    electricInput: /^\s*[}\]]/,
    fold: "brace",
    closeBrackets: {
      pairs: '[]{}""',
      explode: "[]{}"
    }
  };
});
function indent$1(state, textAfter) {
  var _a2, _b;
  var levels = state.levels;
  var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);
  return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);
}
var LexRules = {
  Punctuation: /^\[|]|\{|\}|:|,/,
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
  String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
  Keyword: /^true|false|null/
};
var ParseRules = {
  Document: [graphql_language_service_1.p("{"), graphql_language_service_1.list("Entry", graphql_language_service_1.p(",")), graphql_language_service_1.p("}")],
  Entry: [graphql_language_service_1.t("String", "def"), graphql_language_service_1.p(":"), "Value"],
  Value: function(token2) {
    switch (token2.kind) {
      case "Number":
        return "NumberValue";
      case "String":
        return "StringValue";
      case "Punctuation":
        switch (token2.value) {
          case "[":
            return "ListValue";
          case "{":
            return "ObjectValue";
        }
        return null;
      case "Keyword":
        switch (token2.value) {
          case "true":
          case "false":
            return "BooleanValue";
          case "null":
            return "NullValue";
        }
        return null;
    }
  },
  NumberValue: [graphql_language_service_1.t("Number", "number")],
  StringValue: [graphql_language_service_1.t("String", "string")],
  BooleanValue: [graphql_language_service_1.t("Keyword", "builtin")],
  NullValue: [graphql_language_service_1.t("Keyword", "keyword")],
  ListValue: [graphql_language_service_1.p("["), graphql_language_service_1.list("Value", graphql_language_service_1.p(",")), graphql_language_service_1.p("]")],
  ObjectValue: [graphql_language_service_1.p("{"), graphql_language_service_1.list("ObjectField", graphql_language_service_1.p(",")), graphql_language_service_1.p("}")],
  ObjectField: [graphql_language_service_1.t("String", "property"), graphql_language_service_1.p(":"), "Value"]
};
var __extends$8 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ResultViewer = function(_super2) {
  __extends$8(ResultViewer2, _super2);
  function ResultViewer2() {
    var _this = _super2 !== null && _super2.apply(this, arguments) || this;
    _this.viewer = null;
    _this._node = null;
    return _this;
  }
  ResultViewer2.prototype.componentDidMount = function() {
    var Tooltip = this.props.ResultsTooltip;
    var ImagePreview2 = this.props.ImagePreview;
    if (Tooltip || ImagePreview2) {
      var tooltipDiv_1 = document.createElement("div");
      CodeMirror.registerHelper("info", "graphql-results", function(token2, _options, _cm, pos) {
        var infoElements = [];
        if (Tooltip) {
          infoElements.push(React$1.createElement(Tooltip, { pos }));
        }
        if (ImagePreview2 && typeof ImagePreview2.shouldRender === "function" && ImagePreview2.shouldRender(token2)) {
          infoElements.push(React$1.createElement(ImagePreview2, { token: token2 }));
        }
        if (!infoElements.length) {
          ReactDOM.unmountComponentAtNode(tooltipDiv_1);
          return null;
        }
        ReactDOM.render(React$1.createElement("div", null, infoElements), tooltipDiv_1);
        return tooltipDiv_1;
      });
    }
    this.viewer = CodeMirror(this._node, {
      lineWrapping: true,
      value: this.props.value || "",
      readOnly: true,
      theme: this.props.editorTheme || "graphiql",
      mode: "graphql-results",
      keyMap: "sublime",
      foldGutter: {
        minFoldSize: 4
      },
      gutters: ["CodeMirror-foldgutter"],
      info: Boolean(this.props.ResultsTooltip || this.props.ImagePreview),
      extraKeys: commonKeys
    });
  };
  ResultViewer2.prototype.shouldComponentUpdate = function(nextProps) {
    return this.props.value !== nextProps.value;
  };
  ResultViewer2.prototype.componentDidUpdate = function() {
    if (this.viewer) {
      this.viewer.setValue(this.props.value || "");
    }
  };
  ResultViewer2.prototype.componentWillUnmount = function() {
    this.viewer = null;
  };
  ResultViewer2.prototype.render = function() {
    var _this = this;
    return React$1.createElement("section", { className: "result-window", "aria-label": "Result Window", "aria-live": "polite", "aria-atomic": "true", ref: function(node) {
      if (node) {
        _this.props.registerRef(node);
        _this._node = node;
      }
    } });
  };
  ResultViewer2.prototype.getCodeMirror = function() {
    return this.viewer;
  };
  ResultViewer2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  return ResultViewer2;
}(React$1.Component);
function TypeLink(props) {
  var onClick = props.onClick ? props.onClick : function() {
    return null;
  };
  return renderType(props.type, onClick);
}
function renderType(type2, onClick) {
  if (type2 instanceof GraphQLNonNull) {
    return React$1.createElement("span", null, renderType(type2.ofType, onClick), "!");
  }
  if (type2 instanceof GraphQLList) {
    return React$1.createElement("span", null, "[", renderType(type2.ofType, onClick), "]");
  }
  return React$1.createElement("a", { className: "type-name", onClick: function(event) {
    event.preventDefault();
    onClick(type2, event);
  }, href: "#" }, type2 === null || type2 === void 0 ? void 0 : type2.name);
}
var printDefault = function(ast2) {
  if (!ast2) {
    return "";
  }
  return print(ast2);
};
function DefaultValue(_a2) {
  var field = _a2.field;
  if ("defaultValue" in field && field.defaultValue !== void 0) {
    return React$1.createElement("span", null, " = ", React$1.createElement("span", { className: "arg-default-value" }, printDefault(astFromValue(field.defaultValue, field.type))));
  }
  return null;
}
function Argument(_a2) {
  var arg = _a2.arg, onClickType = _a2.onClickType, showDefaultValue = _a2.showDefaultValue;
  return React$1.createElement("span", { className: "arg" }, React$1.createElement("span", { className: "arg-name" }, arg.name), ": ", React$1.createElement(TypeLink, { type: arg.type, onClick: onClickType }), showDefaultValue !== false && React$1.createElement(DefaultValue, { field: arg }));
}
function Directive(_a2) {
  var directive = _a2.directive;
  return React$1.createElement("span", { className: "doc-category-item", id: directive.name.value }, "@", directive.name.value);
}
var md = new markdownIt({
  breaks: true,
  linkify: true
});
function MarkdownContent(_a2) {
  var markdown = _a2.markdown, className = _a2.className;
  if (!markdown) {
    return React$1.createElement("div", null);
  }
  return React$1.createElement("div", { className, dangerouslySetInnerHTML: { __html: md.render(markdown) } });
}
var __read$4 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
function FieldDoc(_a2) {
  var field = _a2.field, onClickType = _a2.onClickType;
  var _b = __read$4(React$1.useState(false), 2), showDeprecated = _b[0], handleShowDeprecated = _b[1];
  var argsDef;
  var deprecatedArgsDef;
  if (field && "args" in field && field.args.length > 0) {
    argsDef = React$1.createElement("div", { id: "doc-args", className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "arguments"), field.args.filter(function(arg) {
      return !arg.deprecationReason;
    }).map(function(arg) {
      return React$1.createElement("div", { key: arg.name, className: "doc-category-item" }, React$1.createElement("div", null, React$1.createElement(Argument, { arg, onClickType })), React$1.createElement(MarkdownContent, { className: "doc-value-description", markdown: arg.description }), arg && "deprecationReason" in arg && React$1.createElement(MarkdownContent, { className: "doc-deprecation", markdown: arg === null || arg === void 0 ? void 0 : arg.deprecationReason }));
    }));
    var deprecatedArgs = field.args.filter(function(arg) {
      return Boolean(arg.deprecationReason);
    });
    if (deprecatedArgs.length > 0) {
      deprecatedArgsDef = React$1.createElement("div", { id: "doc-deprecated-args", className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "deprecated arguments"), !showDeprecated ? React$1.createElement("button", { className: "show-btn", onClick: function() {
        return handleShowDeprecated(!showDeprecated);
      } }, "Show deprecated arguments...") : deprecatedArgs.map(function(arg, i) {
        return React$1.createElement("div", { key: i }, React$1.createElement("div", null, React$1.createElement(Argument, { arg, onClickType })), React$1.createElement(MarkdownContent, { className: "doc-value-description", markdown: arg.description }), arg && "deprecationReason" in arg && React$1.createElement(MarkdownContent, { className: "doc-deprecation", markdown: arg === null || arg === void 0 ? void 0 : arg.deprecationReason }));
      }));
    }
  }
  var directivesDef;
  if (field && field.astNode && field.astNode.directives && field.astNode.directives.length > 0) {
    directivesDef = React$1.createElement("div", { id: "doc-directives", className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "directives"), field.astNode.directives.map(function(directive) {
      return React$1.createElement("div", { key: directive.name.value, className: "doc-category-item" }, React$1.createElement("div", null, React$1.createElement(Directive, { directive })));
    }));
  }
  return React$1.createElement("div", null, React$1.createElement(MarkdownContent, { className: "doc-type-description", markdown: (field === null || field === void 0 ? void 0 : field.description) || "No Description" }), field && "deprecationReason" in field && React$1.createElement(MarkdownContent, { className: "doc-deprecation", markdown: field === null || field === void 0 ? void 0 : field.deprecationReason }), React$1.createElement("div", { className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "type"), React$1.createElement(TypeLink, { type: field === null || field === void 0 ? void 0 : field.type, onClick: onClickType })), argsDef, directivesDef, deprecatedArgsDef);
}
function SchemaDoc(_a2) {
  var schema = _a2.schema, onClickType = _a2.onClickType;
  var queryType = schema.getQueryType();
  var mutationType = schema.getMutationType && schema.getMutationType();
  var subscriptionType = schema.getSubscriptionType && schema.getSubscriptionType();
  return React$1.createElement("div", null, React$1.createElement(MarkdownContent, { className: "doc-type-description", markdown: schema.description || "A GraphQL schema provides a root type for each kind of operation." }), React$1.createElement("div", { className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "root types"), React$1.createElement("div", { className: "doc-category-item" }, React$1.createElement("span", { className: "keyword" }, "query"), ": ", React$1.createElement(TypeLink, { type: queryType, onClick: onClickType })), mutationType && React$1.createElement("div", { className: "doc-category-item" }, React$1.createElement("span", { className: "keyword" }, "mutation"), ": ", React$1.createElement(TypeLink, { type: mutationType, onClick: onClickType })), subscriptionType && React$1.createElement("div", { className: "doc-category-item" }, React$1.createElement("span", { className: "keyword" }, "subscription"), ": ", React$1.createElement(TypeLink, { type: subscriptionType, onClick: onClickType }))));
}
function debounce(duration, fn) {
  var timeout;
  return function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (timeout) {
      window.clearTimeout(timeout);
    }
    timeout = window.setTimeout(function() {
      timeout = null;
      fn.apply(_this, args);
    }, duration);
  };
}
var __extends$7 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SearchBox = function(_super2) {
  __extends$7(SearchBox2, _super2);
  function SearchBox2(props) {
    var _this = _super2.call(this, props) || this;
    _this.handleChange = function(event) {
      var value = event.currentTarget.value;
      _this.setState({ value });
      _this.debouncedOnSearch(value);
    };
    _this.handleClear = function() {
      _this.setState({ value: "" });
      _this.props.onSearch("");
    };
    _this.state = { value: props.value || "" };
    _this.debouncedOnSearch = debounce(200, _this.props.onSearch);
    return _this;
  }
  SearchBox2.prototype.render = function() {
    return React$1.createElement("label", { className: "search-box" }, React$1.createElement("div", { className: "search-box-icon", "aria-hidden": "true" }, "\u26B2"), React$1.createElement("input", { value: this.state.value, onChange: this.handleChange, type: "text", placeholder: this.props.placeholder, "aria-label": this.props.placeholder }), this.state.value && React$1.createElement("button", { className: "search-box-clear", onClick: this.handleClear, "aria-label": "Clear search input" }, "\u2715"));
  };
  return SearchBox2;
}(React$1.Component);
var __extends$6 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values$3 = globalThis && globalThis.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var SearchResults = function(_super2) {
  __extends$6(SearchResults2, _super2);
  function SearchResults2() {
    return _super2 !== null && _super2.apply(this, arguments) || this;
  }
  SearchResults2.prototype.shouldComponentUpdate = function(nextProps) {
    return this.props.schema !== nextProps.schema || this.props.searchValue !== nextProps.searchValue;
  };
  SearchResults2.prototype.render = function() {
    var e_1, _a2;
    var searchValue = this.props.searchValue;
    var withinType = this.props.withinType;
    var schema = this.props.schema;
    var onClickType = this.props.onClickType;
    var onClickField = this.props.onClickField;
    var matchedWithin = [];
    var matchedTypes = [];
    var matchedFields = [];
    var typeMap = schema.getTypeMap();
    var typeNames = Object.keys(typeMap);
    if (withinType) {
      typeNames = typeNames.filter(function(n2) {
        return n2 !== withinType.name;
      });
      typeNames.unshift(withinType.name);
    }
    var _loop_1 = function(typeName2) {
      if (matchedWithin.length + matchedTypes.length + matchedFields.length >= 100) {
        return "break";
      }
      var type2 = typeMap[typeName2];
      if (withinType !== type2 && isMatch(typeName2, searchValue)) {
        matchedTypes.push(React$1.createElement("div", { className: "doc-category-item", key: typeName2 }, React$1.createElement(TypeLink, { type: type2, onClick: onClickType })));
      }
      if (type2 && "getFields" in type2) {
        var fields_1 = type2.getFields();
        Object.keys(fields_1).forEach(function(fieldName) {
          var field = fields_1[fieldName];
          var matchingArgs;
          if (!isMatch(fieldName, searchValue)) {
            if ("args" in field && field.args.length) {
              matchingArgs = field.args.filter(function(arg) {
                return isMatch(arg.name, searchValue);
              });
              if (matchingArgs.length === 0) {
                return;
              }
            } else {
              return;
            }
          }
          var match2 = React$1.createElement("div", { className: "doc-category-item", key: typeName2 + "." + fieldName }, withinType !== type2 && [
            React$1.createElement(TypeLink, { key: "type", type: type2, onClick: onClickType }),
            "."
          ], React$1.createElement("a", { className: "field-name", onClick: function(event) {
            return onClickField(field, type2, event);
          } }, field.name), matchingArgs && [
            "(",
            React$1.createElement("span", { key: "args" }, matchingArgs.map(function(arg) {
              return React$1.createElement(Argument, { key: arg.name, arg, onClickType, showDefaultValue: false });
            })),
            ")"
          ]);
          if (withinType === type2) {
            matchedWithin.push(match2);
          } else {
            matchedFields.push(match2);
          }
        });
      }
    };
    try {
      for (var typeNames_1 = __values$3(typeNames), typeNames_1_1 = typeNames_1.next(); !typeNames_1_1.done; typeNames_1_1 = typeNames_1.next()) {
        var typeName = typeNames_1_1.value;
        var state_1 = _loop_1(typeName);
        if (state_1 === "break")
          break;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (typeNames_1_1 && !typeNames_1_1.done && (_a2 = typeNames_1.return))
          _a2.call(typeNames_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (matchedWithin.length + matchedTypes.length + matchedFields.length === 0) {
      return React$1.createElement("span", { className: "doc-alert-text" }, "No results found.");
    }
    if (withinType && matchedTypes.length + matchedFields.length > 0) {
      return React$1.createElement("div", null, matchedWithin, React$1.createElement("div", { className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "other results"), matchedTypes, matchedFields));
    }
    return React$1.createElement("div", { className: "doc-search-items" }, matchedWithin, matchedTypes, matchedFields);
  };
  return SearchResults2;
}(React$1.Component);
function isMatch(sourceText, searchValue) {
  try {
    var escaped = searchValue.replace(/[^_0-9A-Za-z]/g, function(ch2) {
      return "\\" + ch2;
    });
    return sourceText.search(new RegExp(escaped, "i")) !== -1;
  } catch (e) {
    return sourceText.toLowerCase().indexOf(searchValue.toLowerCase()) !== -1;
  }
}
var __extends$5 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TypeDoc = function(_super2) {
  __extends$5(TypeDoc2, _super2);
  function TypeDoc2(props) {
    var _this = _super2.call(this, props) || this;
    _this.handleShowDeprecated = function() {
      return _this.setState({ showDeprecated: true });
    };
    _this.state = { showDeprecated: false };
    return _this;
  }
  TypeDoc2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
    return this.props.type !== nextProps.type || this.props.schema !== nextProps.schema || this.state.showDeprecated !== nextState.showDeprecated;
  };
  TypeDoc2.prototype.render = function() {
    var schema = this.props.schema;
    var type2 = this.props.type;
    var onClickType = this.props.onClickType;
    var onClickField = this.props.onClickField;
    var typesTitle = null;
    var types = [];
    if (type2 instanceof GraphQLUnionType) {
      typesTitle = "possible types";
      types = schema.getPossibleTypes(type2);
    } else if (type2 instanceof GraphQLInterfaceType) {
      typesTitle = "implementations";
      types = schema.getPossibleTypes(type2);
    } else if (type2 instanceof GraphQLObjectType) {
      typesTitle = "implements";
      types = type2.getInterfaces();
    }
    var typesDef;
    if (types && types.length > 0) {
      typesDef = React$1.createElement("div", { id: "doc-types", className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, typesTitle), types.map(function(subtype) {
        return React$1.createElement("div", { key: subtype.name, className: "doc-category-item" }, React$1.createElement(TypeLink, { type: subtype, onClick: onClickType }));
      }));
    }
    var fieldsDef;
    var deprecatedFieldsDef;
    if (type2 && "getFields" in type2) {
      var fieldMap_1 = type2.getFields();
      var fields = Object.keys(fieldMap_1).map(function(name2) {
        return fieldMap_1[name2];
      });
      fieldsDef = React$1.createElement("div", { id: "doc-fields", className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "fields"), fields.filter(function(field) {
        return !field.deprecationReason;
      }).map(function(field) {
        return React$1.createElement(Field, { key: field.name, type: type2, field, onClickType, onClickField });
      }));
      var deprecatedFields = fields.filter(function(field) {
        return Boolean(field.deprecationReason);
      });
      if (deprecatedFields.length > 0) {
        deprecatedFieldsDef = React$1.createElement("div", { id: "doc-deprecated-fields", className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "deprecated fields"), !this.state.showDeprecated ? React$1.createElement("button", { className: "show-btn", onClick: this.handleShowDeprecated }, "Show deprecated fields...") : deprecatedFields.map(function(field) {
          return React$1.createElement(Field, { key: field.name, type: type2, field, onClickType, onClickField });
        }));
      }
    }
    var valuesDef;
    var deprecatedValuesDef;
    if (type2 instanceof GraphQLEnumType) {
      var values = type2.getValues();
      valuesDef = React$1.createElement("div", { className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "values"), values.filter(function(value) {
        return Boolean(!value.deprecationReason);
      }).map(function(value) {
        return React$1.createElement(EnumValue, { key: value.name, value });
      }));
      var deprecatedValues = values.filter(function(value) {
        return Boolean(value.deprecationReason);
      });
      if (deprecatedValues.length > 0) {
        deprecatedValuesDef = React$1.createElement("div", { className: "doc-category" }, React$1.createElement("div", { className: "doc-category-title" }, "deprecated values"), !this.state.showDeprecated ? React$1.createElement("button", { className: "show-btn", onClick: this.handleShowDeprecated }, "Show deprecated values...") : deprecatedValues.map(function(value) {
          return React$1.createElement(EnumValue, { key: value.name, value });
        }));
      }
    }
    return React$1.createElement("div", null, React$1.createElement(MarkdownContent, { className: "doc-type-description", markdown: "description" in type2 && type2.description || "No Description" }), type2 instanceof GraphQLObjectType && typesDef, fieldsDef, deprecatedFieldsDef, valuesDef, deprecatedValuesDef, !(type2 instanceof GraphQLObjectType) && typesDef);
  };
  return TypeDoc2;
}(React$1.Component);
function Field(_a2) {
  var type2 = _a2.type, field = _a2.field, onClickType = _a2.onClickType, onClickField = _a2.onClickField;
  return React$1.createElement("div", { className: "doc-category-item" }, React$1.createElement("a", { className: "field-name", onClick: function(event) {
    return onClickField(field, type2, event);
  } }, field.name), "args" in field && field.args && field.args.length > 0 && [
    "(",
    React$1.createElement("span", { key: "args" }, field.args.filter(function(arg) {
      return !arg.deprecationReason;
    }).map(function(arg) {
      return React$1.createElement(Argument, { key: arg.name, arg, onClickType });
    })),
    ")"
  ], ": ", React$1.createElement(TypeLink, { type: field.type, onClick: onClickType }), React$1.createElement(DefaultValue, { field }), field.description && React$1.createElement(MarkdownContent, { className: "field-short-description", markdown: field.description }), "deprecationReason" in field && field.deprecationReason && React$1.createElement(MarkdownContent, { className: "doc-deprecation", markdown: field.deprecationReason }));
}
function EnumValue(_a2) {
  var value = _a2.value;
  return React$1.createElement("div", { className: "doc-category-item" }, React$1.createElement("div", { className: "enum-value" }, value.name), React$1.createElement(MarkdownContent, { className: "doc-value-description", markdown: value.description }), value.deprecationReason && React$1.createElement(MarkdownContent, { className: "doc-deprecation", markdown: value.deprecationReason }));
}
var __extends$4 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$6 = globalThis && globalThis.__assign || function() {
  __assign$6 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$6.apply(this, arguments);
};
var initialNav = {
  name: "Schema",
  title: "Documentation Explorer"
};
var DocExplorer = function(_super2) {
  __extends$4(DocExplorer2, _super2);
  function DocExplorer2(props) {
    var _this = _super2.call(this, props) || this;
    _this.handleNavBackClick = function() {
      if (_this.state.navStack.length > 1) {
        _this.setState({ navStack: _this.state.navStack.slice(0, -1) });
      }
    };
    _this.handleClickType = function(type2) {
      _this.showDoc(type2);
    };
    _this.handleClickField = function(field) {
      _this.showDoc(field);
    };
    _this.handleSearch = function(value) {
      _this.showSearch(value);
    };
    _this.state = { navStack: [initialNav] };
    return _this;
  }
  DocExplorer2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
    return this.props.schema !== nextProps.schema || this.state.navStack !== nextState.navStack || this.props.schemaErrors !== nextProps.schemaErrors;
  };
  DocExplorer2.prototype.render = function() {
    var _a2 = this.props, schema = _a2.schema, schemaErrors = _a2.schemaErrors;
    var navStack = this.state.navStack;
    var navItem = navStack[navStack.length - 1];
    var content;
    if (schemaErrors) {
      content = React$1.createElement("div", { className: "error-container" }, "Error fetching schema");
    } else if (schema === void 0) {
      content = React$1.createElement("div", { className: "spinner-container" }, React$1.createElement("div", { className: "spinner" }));
    } else if (!schema) {
      content = React$1.createElement("div", { className: "error-container" }, "No Schema Available");
    } else if (navItem.search) {
      content = React$1.createElement(SearchResults, { searchValue: navItem.search, withinType: navItem.def, schema, onClickType: this.handleClickType, onClickField: this.handleClickField });
    } else if (navStack.length === 1) {
      content = React$1.createElement(SchemaDoc, { schema, onClickType: this.handleClickType });
    } else if (isType(navItem.def)) {
      content = React$1.createElement(TypeDoc, { schema, type: navItem.def, onClickType: this.handleClickType, onClickField: this.handleClickField });
    } else {
      content = React$1.createElement(FieldDoc, { field: navItem.def, onClickType: this.handleClickType });
    }
    var shouldSearchBoxAppear = navStack.length === 1 || isType(navItem.def) && "getFields" in navItem.def;
    var prevName;
    if (navStack.length > 1) {
      prevName = navStack[navStack.length - 2].name;
    }
    return React$1.createElement("section", { className: "doc-explorer", key: navItem.name, "aria-label": "Documentation Explorer" }, React$1.createElement("div", { className: "doc-explorer-title-bar" }, prevName && React$1.createElement("button", { className: "doc-explorer-back", onClick: this.handleNavBackClick, "aria-label": "Go back to " + prevName }, prevName), React$1.createElement("div", { className: "doc-explorer-title" }, navItem.title || navItem.name), React$1.createElement("div", { className: "doc-explorer-rhs" }, this.props.children)), React$1.createElement("div", { className: "doc-explorer-contents" }, shouldSearchBoxAppear && React$1.createElement(SearchBox, { value: navItem.search, placeholder: "Search " + navItem.name + "...", onSearch: this.handleSearch }), content));
  };
  DocExplorer2.prototype.showDoc = function(typeOrField) {
    var navStack = this.state.navStack;
    var topNav = navStack[navStack.length - 1];
    if (topNav.def !== typeOrField) {
      this.setState({
        navStack: navStack.concat([
          {
            name: typeOrField.name,
            def: typeOrField
          }
        ])
      });
    }
  };
  DocExplorer2.prototype.showDocForReference = function(reference3) {
    if (reference3 && reference3.kind === "Type") {
      this.showDoc(reference3.type);
    } else if (reference3.kind === "Field") {
      this.showDoc(reference3.field);
    } else if (reference3.kind === "Argument" && reference3.field) {
      this.showDoc(reference3.field);
    } else if (reference3.kind === "EnumValue" && reference3.type) {
      this.showDoc(reference3.type);
    }
  };
  DocExplorer2.prototype.showSearch = function(search) {
    var navStack = this.state.navStack.slice();
    var topNav = navStack[navStack.length - 1];
    navStack[navStack.length - 1] = __assign$6(__assign$6({}, topNav), { search });
    this.setState({ navStack });
  };
  DocExplorer2.prototype.reset = function() {
    this.setState({ navStack: [initialNav] });
  };
  return DocExplorer2;
}(React$1.Component);
var __extends$3 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HistoryQuery = function(_super2) {
  __extends$3(HistoryQuery2, _super2);
  function HistoryQuery2(props) {
    var _this = _super2.call(this, props) || this;
    _this.state = {
      editable: false
    };
    _this.editField = null;
    return _this;
  }
  HistoryQuery2.prototype.render = function() {
    var _this = this;
    var _a2;
    var displayName = this.props.label || this.props.operationName || ((_a2 = this.props.query) === null || _a2 === void 0 ? void 0 : _a2.split("\n").filter(function(line) {
      return line.indexOf("#") !== 0;
    }).join(""));
    var starIcon = this.props.favorite ? "\u2605" : "\u2606";
    return React$1.createElement("li", { className: this.state.editable ? "editable" : void 0 }, this.state.editable ? React$1.createElement("input", { type: "text", defaultValue: this.props.label, ref: function(c) {
      _this.editField = c;
    }, onBlur: this.handleFieldBlur.bind(this), onKeyDown: this.handleFieldKeyDown.bind(this), placeholder: "Type a label" }) : React$1.createElement("button", { className: "history-label", onClick: this.handleClick.bind(this) }, displayName), React$1.createElement("button", { onClick: this.handleEditClick.bind(this), "aria-label": "Edit label" }, "\u270E"), React$1.createElement("button", { className: this.props.favorite ? "favorited" : void 0, onClick: this.handleStarClick.bind(this), "aria-label": this.props.favorite ? "Remove favorite" : "Add favorite" }, starIcon));
  };
  HistoryQuery2.prototype.handleClick = function() {
    this.props.onSelect(this.props.query, this.props.variables, this.props.headers, this.props.operationName, this.props.label);
  };
  HistoryQuery2.prototype.handleStarClick = function(e) {
    e.stopPropagation();
    this.props.handleToggleFavorite(this.props.query, this.props.variables, this.props.headers, this.props.operationName, this.props.label, this.props.favorite);
  };
  HistoryQuery2.prototype.handleFieldBlur = function(e) {
    e.stopPropagation();
    this.setState({ editable: false });
    this.props.handleEditLabel(this.props.query, this.props.variables, this.props.headers, this.props.operationName, e.target.value, this.props.favorite);
  };
  HistoryQuery2.prototype.handleFieldKeyDown = function(e) {
    if (e.keyCode === 13) {
      e.stopPropagation();
      this.setState({ editable: false });
      this.props.handleEditLabel(this.props.query, this.props.variables, this.props.headers, this.props.operationName, e.currentTarget.value, this.props.favorite);
    }
  };
  HistoryQuery2.prototype.handleEditClick = function(e) {
    var _this = this;
    e.stopPropagation();
    this.setState({ editable: true }, function() {
      if (_this.editField) {
        _this.editField.focus();
      }
    });
  };
  return HistoryQuery2;
}(React$1.Component);
var __read$3 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread$3 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read$3(arguments[i]));
  return ar;
};
var QueryStore = function() {
  function QueryStore2(key, storage, maxSize) {
    if (maxSize === void 0) {
      maxSize = null;
    }
    this.key = key;
    this.storage = storage;
    this.maxSize = maxSize;
    this.items = this.fetchAll();
  }
  Object.defineProperty(QueryStore2.prototype, "length", {
    get: function() {
      return this.items.length;
    },
    enumerable: false,
    configurable: true
  });
  QueryStore2.prototype.contains = function(item) {
    return this.items.some(function(x2) {
      return x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName;
    });
  };
  QueryStore2.prototype.edit = function(item) {
    var itemIndex = this.items.findIndex(function(x2) {
      return x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName;
    });
    if (itemIndex !== -1) {
      this.items.splice(itemIndex, 1, item);
      this.save();
    }
  };
  QueryStore2.prototype.delete = function(item) {
    var itemIndex = this.items.findIndex(function(x2) {
      return x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName;
    });
    if (itemIndex !== -1) {
      this.items.splice(itemIndex, 1);
      this.save();
    }
  };
  QueryStore2.prototype.fetchRecent = function() {
    return this.items[this.items.length - 1];
  };
  QueryStore2.prototype.fetchAll = function() {
    var raw = this.storage.get(this.key);
    if (raw) {
      return JSON.parse(raw)[this.key];
    }
    return [];
  };
  QueryStore2.prototype.push = function(item) {
    var _a2;
    var items = __spread$3(this.items, [item]);
    if (this.maxSize && items.length > this.maxSize) {
      items.shift();
    }
    for (var attempts = 0; attempts < 5; attempts++) {
      var response = this.storage.set(this.key, JSON.stringify((_a2 = {}, _a2[this.key] = items, _a2)));
      if (!response || !response.error) {
        this.items = items;
      } else if (response.isQuotaError && this.maxSize) {
        items.shift();
      } else {
        return;
      }
    }
  };
  QueryStore2.prototype.save = function() {
    var _a2;
    this.storage.set(this.key, JSON.stringify((_a2 = {}, _a2[this.key] = this.items, _a2)));
  };
  return QueryStore2;
}();
var __assign$5 = globalThis && globalThis.__assign || function() {
  __assign$5 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$5.apply(this, arguments);
};
var __read$2 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread$2 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read$2(arguments[i]));
  return ar;
};
var MAX_QUERY_SIZE = 1e5;
var HistoryStore = function() {
  function HistoryStore2(storage, maxHistoryLength) {
    var _this = this;
    this.storage = storage;
    this.maxHistoryLength = maxHistoryLength;
    this.shouldSaveQuery = function(query, variables, headers, lastQuerySaved) {
      if (!query) {
        return false;
      }
      try {
        parse$1(query);
      } catch (e) {
        return false;
      }
      if (query.length > MAX_QUERY_SIZE) {
        return false;
      }
      if (!lastQuerySaved) {
        return true;
      }
      if (JSON.stringify(query) === JSON.stringify(lastQuerySaved.query)) {
        if (JSON.stringify(variables) === JSON.stringify(lastQuerySaved.variables)) {
          if (JSON.stringify(headers) === JSON.stringify(lastQuerySaved.headers)) {
            return false;
          }
          if (headers && !lastQuerySaved.headers) {
            return false;
          }
        }
        if (variables && !lastQuerySaved.variables) {
          return false;
        }
      }
      return true;
    };
    this.fetchAllQueries = function() {
      var historyQueries = _this.history.fetchAll();
      var favoriteQueries = _this.favorite.fetchAll();
      return historyQueries.concat(favoriteQueries);
    };
    this.updateHistory = function(query, variables, headers, operationName) {
      if (_this.shouldSaveQuery(query, variables, headers, _this.history.fetchRecent())) {
        _this.history.push({
          query,
          variables,
          headers,
          operationName
        });
        var historyQueries = _this.history.items;
        var favoriteQueries = _this.favorite.items;
        _this.queries = historyQueries.concat(favoriteQueries);
      }
    };
    this.toggleFavorite = function(query, variables, headers, operationName, label, favorite) {
      var item = {
        query,
        variables,
        headers,
        operationName,
        label
      };
      if (!_this.favorite.contains(item)) {
        item.favorite = true;
        _this.favorite.push(item);
      } else if (favorite) {
        item.favorite = false;
        _this.favorite.delete(item);
      }
      _this.queries = __spread$2(_this.history.items, _this.favorite.items);
    };
    this.editLabel = function(query, variables, headers, operationName, label, favorite) {
      var item = {
        query,
        variables,
        headers,
        operationName,
        label
      };
      if (favorite) {
        _this.favorite.edit(__assign$5(__assign$5({}, item), { favorite }));
      } else {
        _this.history.edit(item);
      }
      _this.queries = __spread$2(_this.history.items, _this.favorite.items);
    };
    this.history = new QueryStore("queries", this.storage, this.maxHistoryLength);
    this.favorite = new QueryStore("favorites", this.storage, null);
    this.queries = this.fetchAllQueries();
  }
  return HistoryStore2;
}();
var __extends$2 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$4 = globalThis && globalThis.__assign || function() {
  __assign$4 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$4.apply(this, arguments);
};
var QueryHistory = function(_super2) {
  __extends$2(QueryHistory2, _super2);
  function QueryHistory2(props) {
    var _this = _super2.call(this, props) || this;
    _this.onUpdateHistory = function(query, variables, headers, operationName) {
      _this.historyStore.updateHistory(query, variables, headers, operationName);
      _this.setState({ queries: _this.historyStore.queries });
    };
    _this.onHandleEditLabel = function(query, variables, headers, operationName, label, favorite) {
      _this.historyStore.editLabel(query, variables, headers, operationName, label, favorite);
      _this.setState({ queries: _this.historyStore.queries });
    };
    _this.onToggleFavorite = function(query, variables, headers, operationName, label, favorite) {
      _this.historyStore.toggleFavorite(query, variables, headers, operationName, label, favorite);
      _this.setState({ queries: _this.historyStore.queries });
    };
    _this.historyStore = new HistoryStore(_this.props.storage, _this.props.maxHistoryLength);
    var queries = _this.historyStore.queries;
    _this.state = { queries };
    return _this;
  }
  QueryHistory2.prototype.render = function() {
    var _this = this;
    var queries = this.state.queries.slice().reverse();
    var queryNodes = queries.map(function(query, i) {
      return React$1.createElement(HistoryQuery, __assign$4({ handleEditLabel: _this.onHandleEditLabel, handleToggleFavorite: _this.onToggleFavorite, key: i + ":" + (query.label || query.query), onSelect: _this.props.onSelectQuery }, query));
    });
    return React$1.createElement("section", { "aria-label": "History" }, React$1.createElement("div", { className: "history-title-bar" }, React$1.createElement("div", { className: "history-title" }, "History"), React$1.createElement("div", { className: "doc-explorer-rhs" }, this.props.children)), React$1.createElement("ul", { className: "history-contents" }, queryNodes));
  };
  return QueryHistory2;
}(React$1.Component);
var CodeMirrorSizer = function() {
  function CodeMirrorSizer2() {
    this.sizes = [];
  }
  CodeMirrorSizer2.prototype.updateSizes = function(components) {
    var _this = this;
    components.forEach(function(component, i) {
      if (component) {
        var size = component.getClientHeight();
        if (i <= _this.sizes.length && size !== _this.sizes[i]) {
          var editor = component.getCodeMirror();
          if (editor) {
            editor.setSize(null, null);
          }
        }
        _this.sizes[i] = size;
      }
    });
  };
  return CodeMirrorSizer2;
}();
function isQuotaError(storage, e) {
  return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage.length !== 0;
}
var StorageAPI = function() {
  function StorageAPI2(storage) {
    this.storage = storage || (typeof window !== "undefined" ? window.localStorage : null);
  }
  StorageAPI2.prototype.get = function(name2) {
    if (this.storage) {
      var value = this.storage.getItem("graphiql:" + name2);
      if (value === "null" || value === "undefined") {
        this.storage.removeItem("graphiql:" + name2);
        return null;
      }
      if (value) {
        return value;
      }
    }
    return null;
  };
  StorageAPI2.prototype.set = function(name2, value) {
    var quotaError = false;
    var error2 = null;
    if (this.storage) {
      var key = "graphiql:" + name2;
      if (value) {
        try {
          this.storage.setItem(key, value);
        } catch (e) {
          error2 = e;
          quotaError = isQuotaError(this.storage, e);
        }
      } else {
        this.storage.removeItem(key);
      }
    }
    return {
      isQuotaError: quotaError,
      error: error2
    };
  };
  return StorageAPI2;
}();
function getSelectedOperationName(prevOperations, prevSelectedOperationName, operations) {
  if (!operations || operations.length < 1) {
    return;
  }
  var names = operations.map(function(op) {
    return op.name && op.name.value;
  });
  if (prevSelectedOperationName && names.indexOf(prevSelectedOperationName) !== -1) {
    return prevSelectedOperationName;
  }
  if (prevSelectedOperationName && prevOperations) {
    var prevNames = prevOperations.map(function(op) {
      return op.name && op.name.value;
    });
    var prevIndex = prevNames.indexOf(prevSelectedOperationName);
    if (prevIndex !== -1 && prevIndex < names.length) {
      return names[prevIndex];
    }
  }
  return names[0];
}
function find(list3, predicate) {
  for (var i = 0; i < list3.length; i++) {
    if (predicate(list3[i])) {
      return list3[i];
    }
  }
}
function fillLeafs(schema, docString, getDefaultFieldNames) {
  var insertions = [];
  if (!schema || !docString) {
    return { insertions, result: docString };
  }
  var ast2;
  try {
    ast2 = parse$1(docString);
  } catch (error2) {
    return { insertions, result: docString };
  }
  var fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames$1;
  var typeInfo = new TypeInfo(schema);
  visit(ast2, {
    leave: function(node) {
      typeInfo.leave(node);
    },
    enter: function(node) {
      typeInfo.enter(node);
      if (node.kind === "Field" && !node.selectionSet) {
        var fieldType = typeInfo.getType();
        var selectionSet = buildSelectionSet(isFieldType(fieldType), fieldNameFn);
        if (selectionSet && node.loc) {
          var indent2 = getIndentation(docString, node.loc.start);
          insertions.push({
            index: node.loc.end,
            string: " " + print(selectionSet).replace(/\n/g, "\n" + indent2)
          });
        }
      }
    }
  });
  return {
    insertions,
    result: withInsertions(docString, insertions)
  };
}
function defaultGetDefaultFieldNames$1(type2) {
  if (!("getFields" in type2)) {
    return [];
  }
  var fields = type2.getFields();
  if (fields.id) {
    return ["id"];
  }
  if (fields.edges) {
    return ["edges"];
  }
  if (fields.node) {
    return ["node"];
  }
  var leafFieldNames = [];
  Object.keys(fields).forEach(function(fieldName) {
    if (isLeafType(fields[fieldName].type)) {
      leafFieldNames.push(fieldName);
    }
  });
  return leafFieldNames;
}
function buildSelectionSet(type2, getDefaultFieldNames) {
  var namedType = getNamedType(type2);
  if (!type2 || isLeafType(type2)) {
    return;
  }
  var fieldNames = getDefaultFieldNames(namedType);
  if (!Array.isArray(fieldNames) || fieldNames.length === 0 || !("getFields" in namedType)) {
    return;
  }
  return {
    kind: Kind.SELECTION_SET,
    selections: fieldNames.map(function(fieldName) {
      var fieldDef = namedType.getFields()[fieldName];
      var fieldType = fieldDef ? fieldDef.type : null;
      return {
        kind: Kind.FIELD,
        name: {
          kind: Kind.NAME,
          value: fieldName
        },
        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)
      };
    })
  };
}
function withInsertions(initial, insertions) {
  if (insertions.length === 0) {
    return initial;
  }
  var edited = "";
  var prevIndex = 0;
  insertions.forEach(function(_a2) {
    var index = _a2.index, string2 = _a2.string;
    edited += initial.slice(prevIndex, index) + string2;
    prevIndex = index;
  });
  edited += initial.slice(prevIndex);
  return edited;
}
function getIndentation(str, index) {
  var indentStart = index;
  var indentEnd = index;
  while (indentStart) {
    var c = str.charCodeAt(indentStart - 1);
    if (c === 10 || c === 13 || c === 8232 || c === 8233) {
      break;
    }
    indentStart--;
    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {
      indentEnd = indentStart;
    }
  }
  return str.substring(indentStart, indentEnd);
}
function isFieldType(fieldType) {
  if (fieldType) {
    return fieldType;
  }
}
function getLeft(initialElem) {
  var pt = 0;
  var elem = initialElem;
  while (elem.offsetParent) {
    pt += elem.offsetLeft;
    elem = elem.offsetParent;
  }
  return pt;
}
function getTop(initialElem) {
  var pt = 0;
  var elem = initialElem;
  while (elem.offsetParent) {
    pt += elem.offsetTop;
    elem = elem.offsetParent;
  }
  return pt;
}
var __assign$3 = globalThis && globalThis.__assign || function() {
  __assign$3 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$3.apply(this, arguments);
};
var __values$2 = globalThis && globalThis.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read$1 = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread$1 = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read$1(arguments[i]));
  return ar;
};
function uniqueBy(array, iteratee) {
  var e_1, _a2;
  var FilteredMap = /* @__PURE__ */ new Map();
  var result2 = [];
  try {
    for (var array_1 = __values$2(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
      var item = array_1_1.value;
      if (item.kind === "Field") {
        var uniqueValue = iteratee(item);
        var existing = FilteredMap.get(uniqueValue);
        if (item.directives && item.directives.length) {
          var itemClone = __assign$3({}, item);
          result2.push(itemClone);
        } else if (existing && existing.selectionSet && item.selectionSet) {
          existing.selectionSet.selections = __spread$1(existing.selectionSet.selections, item.selectionSet.selections);
        } else if (!existing) {
          var itemClone = __assign$3({}, item);
          FilteredMap.set(uniqueValue, itemClone);
          result2.push(itemClone);
        }
      } else {
        result2.push(item);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (array_1_1 && !array_1_1.done && (_a2 = array_1.return))
        _a2.call(array_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return result2;
}
function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {
  var e_2, _a2;
  var _b;
  var selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null;
  var outputSelections = [];
  var seenSpreads = [];
  try {
    for (var selections_1 = __values$2(selections), selections_1_1 = selections_1.next(); !selections_1_1.done; selections_1_1 = selections_1.next()) {
      var selection = selections_1_1.value;
      if (selection.kind === "FragmentSpread") {
        var fragmentName = selection.name.value;
        if (!selection.directives || selection.directives.length === 0) {
          if (seenSpreads.indexOf(fragmentName) >= 0) {
            continue;
          } else {
            seenSpreads.push(fragmentName);
          }
        }
        var fragmentDefinition = fragmentDefinitions[selection.name.value];
        if (fragmentDefinition) {
          var typeCondition = fragmentDefinition.typeCondition, directives = fragmentDefinition.directives, selectionSet = fragmentDefinition.selectionSet;
          selection = {
            kind: Kind.INLINE_FRAGMENT,
            typeCondition,
            directives,
            selectionSet
          };
        }
      }
      if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.directives || ((_b = selection.directives) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
        var fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;
        if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {
          outputSelections.push.apply(outputSelections, __spread$1(inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType)));
          continue;
        }
      }
      outputSelections.push(selection);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (selections_1_1 && !selections_1_1.done && (_a2 = selections_1.return))
        _a2.call(selections_1);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return outputSelections;
}
function mergeAST(documentAST, schema) {
  var e_3, _a2;
  var typeInfo = schema ? new TypeInfo(schema) : null;
  var fragmentDefinitions = /* @__PURE__ */ Object.create(null);
  try {
    for (var _b = __values$2(documentAST.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {
      var definition = _c.value;
      if (definition.kind === Kind.FRAGMENT_DEFINITION) {
        fragmentDefinitions[definition.name.value] = definition;
      }
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  var visitors = {
    SelectionSet: function(node) {
      var selectionSetType = typeInfo ? typeInfo.getParentType() : null;
      var selections = node.selections;
      selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);
      selections = uniqueBy(selections, function(selection) {
        return selection.alias ? selection.alias.value : selection.name.value;
      });
      return __assign$3(__assign$3({}, node), { selections });
    },
    FragmentDefinition: function() {
      return null;
    }
  };
  return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);
}
var staticName = "IntrospectionQuery";
var introspectionQueryName = staticName;
function merge(a, b, k) {
  if (typeof a === "object" && typeof b === "object") {
    if (Array.isArray(a) && Array.isArray(b)) {
      for (k = 0; k < b.length; k++) {
        a[k] = merge(a[k], b[k]);
      }
    } else {
      for (k in b) {
        a[k] = merge(a[k], b[k]);
      }
    }
    return a;
  }
  return b;
}
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l2 = keys.length, t2 = obj, x2, k;
  while (i < l2) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t2 = t2[k] = i === l2 ? merge(t2[k], val) : typeof (x2 = t2[k]) === typeof keys ? x2 : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}
var __extends$1 = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$2 = globalThis && globalThis.__assign || function() {
  __assign$2 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$2.apply(this, arguments);
};
var __awaiter$1 = globalThis && globalThis.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest = globalThis && globalThis.__rest || function(s, e) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var __asyncValues$1 = globalThis && globalThis.__asyncValues || function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values$1 === "function" ? __values$1(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
};
var __read = globalThis && globalThis.__read || function(o, n2) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2)
    return o;
  var i = m2.call(o), r2, ar = [], e;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread = globalThis && globalThis.__spread || function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
};
var __values$1 = globalThis && globalThis.__values || function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
  if (m2)
    return m2.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DEFAULT_DOC_EXPLORER_WIDTH = 350;
var majorVersion = parseInt(React$1.version.slice(0, 2), 10);
if (majorVersion < 16) {
  throw Error([
    "GraphiQL 0.18.0 and after is not compatible with React 15 or below.",
    "If you are using a CDN source (jsdelivr, unpkg, etc), follow this example:",
    "https://github.com/graphql/graphiql/blob/master/examples/graphiql-cdn/index.html#L49"
  ].join("\n"));
}
var stringify = function(obj) {
  return JSON.stringify(obj, null, 2);
};
var formatSingleError = function(error2) {
  return __assign$2(__assign$2({}, error2), { message: error2.message, stack: error2.stack });
};
var handleSingleError = function(error2) {
  if (error2 instanceof GraphQLError) {
    return error2.toString();
  }
  if (error2 instanceof Error) {
    return formatSingleError(error2);
  }
  return error2;
};
var GraphiQL = function(_super2) {
  __extends$1(GraphiQL2, _super2);
  function GraphiQL2(props) {
    var _a2, _b, _c, _d, _e, _f;
    var _this = _super2.call(this, props) || this;
    _this._editorQueryID = 0;
    _this.safeSetState = function(nextState, callback) {
      _this.componentIsMounted && _this.setState(nextState, callback);
    };
    _this.handleClickReference = function(reference3) {
      _this.setState({ docExplorerOpen: true }, function() {
        if (_this.docExplorerComponent) {
          _this.docExplorerComponent.showDocForReference(reference3);
        }
      });
      _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
    };
    _this.handleRunQuery = function(selectedOperationName) {
      return __awaiter$1(_this, void 0, void 0, function() {
        var queryID, editedQuery, variables2, headers2, shouldPersistHeaders2, operationName2, fullResponse_1, subscription, error_1;
        var _this2 = this;
        return __generator$1(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this._editorQueryID++;
              queryID = this._editorQueryID;
              editedQuery = this.autoCompleteLeafs() || this.state.query;
              variables2 = this.state.variables;
              headers2 = this.state.headers;
              shouldPersistHeaders2 = this.state.shouldPersistHeaders;
              operationName2 = this.state.operationName;
              if (selectedOperationName && selectedOperationName !== operationName2) {
                operationName2 = selectedOperationName;
                this.handleEditOperationName(operationName2);
              }
              _a3.label = 1;
            case 1:
              _a3.trys.push([1, 3, , 4]);
              this.setState({
                isWaitingForResponse: true,
                response: void 0,
                operationName: operationName2
              });
              this._storage.set("operationName", operationName2);
              if (this._queryHistory) {
                this._queryHistory.onUpdateHistory(editedQuery, variables2, headers2, operationName2);
              } else {
                if (this._historyStore) {
                  this._historyStore.updateHistory(editedQuery, variables2, headers2, operationName2);
                }
              }
              fullResponse_1 = { data: {} };
              return [4, this._fetchQuery(editedQuery, variables2, headers2, operationName2, shouldPersistHeaders2, function(result2) {
                var e_1, _a4;
                if (queryID === _this2._editorQueryID) {
                  var maybeMultipart = Array.isArray(result2) ? result2 : false;
                  if (!maybeMultipart && typeof result2 !== "string" && result2 !== null && "hasNext" in result2) {
                    maybeMultipart = [result2];
                  }
                  if (maybeMultipart) {
                    var payload = { data: fullResponse_1.data };
                    var maybeErrors = __spread((fullResponse_1 === null || fullResponse_1 === void 0 ? void 0 : fullResponse_1.errors) || [], maybeMultipart.map(function(i) {
                      return i.errors;
                    }).flat().filter(Boolean));
                    if (maybeErrors.length) {
                      payload.errors = maybeErrors;
                    }
                    try {
                      for (var maybeMultipart_1 = __values$1(maybeMultipart), maybeMultipart_1_1 = maybeMultipart_1.next(); !maybeMultipart_1_1.done; maybeMultipart_1_1 = maybeMultipart_1.next()) {
                        var part2 = maybeMultipart_1_1.value;
                        var path = part2.path, data = part2.data, _errors = part2.errors, rest = __rest(part2, ["path", "data", "errors"]);
                        if (path) {
                          if (!data) {
                            throw new Error("Expected part to contain a data property, but got " + part2);
                          }
                          dset(payload.data, path, data);
                        } else if (data) {
                          payload.data = part2.data;
                        }
                        fullResponse_1 = __assign$2(__assign$2({}, payload), rest);
                      }
                    } catch (e_1_1) {
                      e_1 = { error: e_1_1 };
                    } finally {
                      try {
                        if (maybeMultipart_1_1 && !maybeMultipart_1_1.done && (_a4 = maybeMultipart_1.return))
                          _a4.call(maybeMultipart_1);
                      } finally {
                        if (e_1)
                          throw e_1.error;
                      }
                    }
                    _this2.setState({
                      isWaitingForResponse: false,
                      response: GraphiQL2.formatResult(fullResponse_1)
                    });
                  } else {
                    _this2.setState({
                      isWaitingForResponse: false,
                      response: GraphiQL2.formatResult(result2)
                    });
                  }
                }
              })];
            case 2:
              subscription = _a3.sent();
              this.setState({ subscription });
              return [3, 4];
            case 3:
              error_1 = _a3.sent();
              this.setState({
                isWaitingForResponse: false,
                response: error_1.message
              });
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    };
    _this.handleStopQuery = function() {
      var subscription = _this.state.subscription;
      _this.setState({
        isWaitingForResponse: false,
        subscription: null
      });
      if (subscription) {
        subscription.unsubscribe();
      }
    };
    _this.handlePrettifyQuery = function() {
      var _a3, _b2, _c2;
      var editor = _this.getQueryEditor();
      var editorContent = (_a3 = editor === null || editor === void 0 ? void 0 : editor.getValue()) !== null && _a3 !== void 0 ? _a3 : "";
      var prettifiedEditorContent = print(parse$1(editorContent));
      if (prettifiedEditorContent !== editorContent) {
        editor === null || editor === void 0 ? void 0 : editor.setValue(prettifiedEditorContent);
      }
      var variableEditor = _this.getVariableEditor();
      var variableEditorContent = (_b2 = variableEditor === null || variableEditor === void 0 ? void 0 : variableEditor.getValue()) !== null && _b2 !== void 0 ? _b2 : "";
      try {
        var prettifiedVariableEditorContent = JSON.stringify(JSON.parse(variableEditorContent), null, 2);
        if (prettifiedVariableEditorContent !== variableEditorContent) {
          variableEditor === null || variableEditor === void 0 ? void 0 : variableEditor.setValue(prettifiedVariableEditorContent);
        }
      } catch (_d2) {
      }
      var headerEditor = _this.getHeaderEditor();
      var headerEditorContent = (_c2 = headerEditor === null || headerEditor === void 0 ? void 0 : headerEditor.getValue()) !== null && _c2 !== void 0 ? _c2 : "";
      try {
        var prettifiedHeaderEditorContent = JSON.stringify(JSON.parse(headerEditorContent), null, 2);
        if (prettifiedHeaderEditorContent !== headerEditorContent) {
          headerEditor === null || headerEditor === void 0 ? void 0 : headerEditor.setValue(prettifiedHeaderEditorContent);
        }
      } catch (_e2) {
      }
    };
    _this.handleMergeQuery = function() {
      var editor = _this.getQueryEditor();
      var query2 = editor.getValue();
      if (!query2) {
        return;
      }
      var ast2 = _this.state.documentAST;
      editor.setValue(print(mergeAST(ast2, _this.state.schema)));
    };
    _this.handleEditQuery = debounce(100, function(value) {
      var queryFacts2 = _this._updateQueryFacts(value, _this.state.operationName, _this.state.operations, _this.state.schema);
      _this.setState(__assign$2({ query: value }, queryFacts2));
      _this._storage.set("query", value);
      if (_this.props.onEditQuery) {
        return _this.props.onEditQuery(value, queryFacts2 === null || queryFacts2 === void 0 ? void 0 : queryFacts2.documentAST);
      }
    });
    _this.handleCopyQuery = function() {
      var editor = _this.getQueryEditor();
      var query2 = editor && editor.getValue();
      if (!query2) {
        return;
      }
      copyToClipboard(query2);
      if (_this.props.onCopyQuery) {
        return _this.props.onCopyQuery(query2);
      }
    };
    _this._updateQueryFacts = function(query2, operationName2, prevOperations, schema2) {
      var queryFacts2 = getOperationFacts(schema2, query2);
      if (queryFacts2) {
        var updatedOperationName = getSelectedOperationName(prevOperations, operationName2, queryFacts2.operations);
        var onEditOperationName = _this.props.onEditOperationName;
        if (onEditOperationName && updatedOperationName && operationName2 !== updatedOperationName) {
          onEditOperationName(updatedOperationName);
        }
        return __assign$2({ operationName: updatedOperationName }, queryFacts2);
      }
    };
    _this.handleEditVariables = function(value) {
      _this.setState({ variables: value });
      debounce(500, function() {
        return _this._storage.set("variables", value);
      })();
      if (_this.props.onEditVariables) {
        _this.props.onEditVariables(value);
      }
    };
    _this.handleEditHeaders = function(value) {
      _this.setState({ headers: value });
      _this.props.shouldPersistHeaders && debounce(500, function() {
        return _this._storage.set("headers", value);
      })();
      if (_this.props.onEditHeaders) {
        _this.props.onEditHeaders(value);
      }
    };
    _this.handleEditOperationName = function(operationName2) {
      var onEditOperationName = _this.props.onEditOperationName;
      if (onEditOperationName) {
        onEditOperationName(operationName2);
      }
    };
    _this.handleHintInformationRender = function(elem) {
      elem.addEventListener("click", _this._onClickHintInformation);
      var onRemoveFn;
      elem.addEventListener("DOMNodeRemoved", onRemoveFn = function() {
        elem.removeEventListener("DOMNodeRemoved", onRemoveFn);
        elem.removeEventListener("click", _this._onClickHintInformation);
      });
    };
    _this.handleEditorRunQuery = function() {
      _this._runQueryAtCursor();
    };
    _this._onClickHintInformation = function(event) {
      if ((event === null || event === void 0 ? void 0 : event.currentTarget) && "className" in event.currentTarget && event.currentTarget.className === "typeName") {
        var typeName = event.currentTarget.innerHTML;
        var schema2 = _this.state.schema;
        if (schema2) {
          var type_1 = schema2.getType(typeName);
          if (type_1) {
            _this.setState({ docExplorerOpen: true }, function() {
              if (_this.docExplorerComponent) {
                _this.docExplorerComponent.showDoc(type_1);
              }
            });
            debounce(500, function() {
              return _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
            })();
          }
        }
      }
    };
    _this.handleToggleDocs = function() {
      if (typeof _this.props.onToggleDocs === "function") {
        _this.props.onToggleDocs(!_this.state.docExplorerOpen);
      }
      _this._storage.set("docExplorerOpen", JSON.stringify(!_this.state.docExplorerOpen));
      _this.setState({ docExplorerOpen: !_this.state.docExplorerOpen });
    };
    _this.handleToggleHistory = function() {
      if (typeof _this.props.onToggleHistory === "function") {
        _this.props.onToggleHistory(!_this.state.historyPaneOpen);
      }
      _this._storage.set("historyPaneOpen", JSON.stringify(!_this.state.historyPaneOpen));
      _this.setState({ historyPaneOpen: !_this.state.historyPaneOpen });
    };
    _this.handleSelectHistoryQuery = function(query2, variables2, headers2, operationName2) {
      if (query2) {
        _this.handleEditQuery(query2);
      }
      if (variables2) {
        _this.handleEditVariables(variables2);
      }
      if (headers2) {
        _this.handleEditHeaders(headers2);
      }
      if (operationName2) {
        _this.handleEditOperationName(operationName2);
      }
    };
    _this.handleResizeStart = function(downEvent) {
      if (!_this._didClickDragBar(downEvent)) {
        return;
      }
      downEvent.preventDefault();
      var offset = downEvent.clientX - getLeft(downEvent.target);
      var onMouseMove = function(moveEvent) {
        if (moveEvent.buttons === 0) {
          return onMouseUp();
        }
        var editorBar = _this.editorBarComponent;
        var leftSize = moveEvent.clientX - getLeft(editorBar) - offset;
        var rightSize = editorBar.clientWidth - leftSize;
        _this.setState({ editorFlex: leftSize / rightSize });
        debounce(500, function() {
          return _this._storage.set("editorFlex", JSON.stringify(_this.state.editorFlex));
        })();
      };
      var onMouseUp = function() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        onMouseMove = null;
        onMouseUp = null;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    _this.handleResetResize = function() {
      _this.setState({ editorFlex: 1 });
      _this._storage.set("editorFlex", JSON.stringify(_this.state.editorFlex));
    };
    _this.handleDocsResizeStart = function(downEvent) {
      downEvent.preventDefault();
      var hadWidth = _this.state.docExplorerWidth;
      var offset = downEvent.clientX - getLeft(downEvent.target);
      var onMouseMove = function(moveEvent) {
        if (moveEvent.buttons === 0) {
          return onMouseUp();
        }
        var app = _this.graphiqlContainer;
        var cursorPos = moveEvent.clientX - getLeft(app) - offset;
        var docsSize = app.clientWidth - cursorPos;
        if (docsSize < 100) {
          if (typeof _this.props.onToggleDocs === "function") {
            _this.props.onToggleDocs(!_this.state.docExplorerOpen);
          }
          _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
          _this.setState({ docExplorerOpen: false });
        } else {
          _this.setState({
            docExplorerOpen: true,
            docExplorerWidth: Math.min(docsSize, 650)
          });
          debounce(500, function() {
            return _this._storage.set("docExplorerWidth", JSON.stringify(_this.state.docExplorerWidth));
          })();
        }
        _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
      };
      var onMouseUp = function() {
        if (!_this.state.docExplorerOpen) {
          _this.setState({ docExplorerWidth: hadWidth });
          debounce(500, function() {
            return _this._storage.set("docExplorerWidth", JSON.stringify(_this.state.docExplorerWidth));
          })();
        }
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        onMouseMove = null;
        onMouseUp = null;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    _this.handleDocsResetResize = function() {
      _this.setState({
        docExplorerWidth: DEFAULT_DOC_EXPLORER_WIDTH
      });
      debounce(500, function() {
        return _this._storage.set("docExplorerWidth", JSON.stringify(_this.state.docExplorerWidth));
      })();
    };
    _this.handleTabClickPropogation = function(downEvent) {
      downEvent.preventDefault();
      downEvent.stopPropagation();
    };
    _this.handleOpenHeaderEditorTab = function(_clickEvent) {
      _this.setState({
        headerEditorActive: true,
        variableEditorActive: false,
        secondaryEditorOpen: true
      });
    };
    _this.handleOpenVariableEditorTab = function(_clickEvent) {
      _this.setState({
        headerEditorActive: false,
        variableEditorActive: true,
        secondaryEditorOpen: true
      });
    };
    _this.handleSecondaryEditorResizeStart = function(downEvent) {
      downEvent.preventDefault();
      var didMove = false;
      var wasOpen = _this.state.secondaryEditorOpen;
      var hadHeight = _this.state.secondaryEditorHeight;
      var offset = downEvent.clientY - getTop(downEvent.target);
      var onMouseMove = function(moveEvent) {
        if (moveEvent.buttons === 0) {
          return onMouseUp();
        }
        didMove = true;
        var editorBar = _this.editorBarComponent;
        var topSize = moveEvent.clientY - getTop(editorBar) - offset;
        var bottomSize = editorBar.clientHeight - topSize;
        if (bottomSize < 60) {
          _this.setState({
            secondaryEditorOpen: false,
            secondaryEditorHeight: hadHeight
          });
        } else {
          _this.setState({
            secondaryEditorOpen: true,
            secondaryEditorHeight: bottomSize
          });
        }
        debounce(500, function() {
          return _this._storage.set("secondaryEditorHeight", JSON.stringify(_this.state.secondaryEditorHeight));
        })();
      };
      var onMouseUp = function() {
        if (!didMove) {
          _this.setState({ secondaryEditorOpen: !wasOpen });
        }
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        onMouseMove = null;
        onMouseUp = null;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    if (typeof props.fetcher !== "function") {
      throw new TypeError("GraphiQL requires a fetcher function.");
    }
    _this._storage = new StorageAPI(props.storage);
    var maxHistoryLength = (_a2 = props.maxHistoryLength) !== null && _a2 !== void 0 ? _a2 : 20;
    _this._historyStore = new HistoryStore(_this._storage, maxHistoryLength);
    _this.componentIsMounted = false;
    var query = props.query !== void 0 ? props.query : _this._storage.get("query") ? _this._storage.get("query") : props.defaultQuery !== void 0 ? props.defaultQuery : defaultQuery;
    var queryFacts = getOperationFacts(props.schema, query);
    var variables = props.variables !== void 0 ? props.variables : _this._storage.get("variables");
    var headers = props.headers !== void 0 ? props.headers : _this._storage.get("headers");
    var operationName = props.operationName !== void 0 ? props.operationName : getSelectedOperationName(void 0, _this._storage.get("operationName"), queryFacts && queryFacts.operations);
    var docExplorerOpen = props.docExplorerOpen || false;
    if (_this._storage.get("docExplorerOpen")) {
      docExplorerOpen = _this._storage.get("docExplorerOpen") === "true";
    }
    var secondaryEditorOpen;
    if (props.defaultVariableEditorOpen !== void 0) {
      secondaryEditorOpen = props.defaultVariableEditorOpen;
    } else if (props.defaultSecondaryEditorOpen !== void 0) {
      secondaryEditorOpen = props.defaultSecondaryEditorOpen;
    } else {
      secondaryEditorOpen = Boolean(variables || headers);
    }
    var headerEditorEnabled = (_b = props.headerEditorEnabled) !== null && _b !== void 0 ? _b : true;
    var shouldPersistHeaders = (_c = props.shouldPersistHeaders) !== null && _c !== void 0 ? _c : false;
    var schema = props.schema;
    var response = props.response;
    var schemaErrors = void 0;
    if (schema && !_this.props.dangerouslyAssumeSchemaIsValid) {
      var validationErrors = validateSchema(schema);
      if (validationErrors && validationErrors.length > 0) {
        response = GraphiQL2.formatError(validationErrors);
        schema = void 0;
        schemaErrors = validationErrors;
      }
    }
    _this._introspectionQuery = getIntrospectionQuery({
      schemaDescription: (_d = props.schemaDescription) !== null && _d !== void 0 ? _d : void 0,
      inputValueDeprecation: (_e = props.inputValueDeprecation) !== null && _e !== void 0 ? _e : void 0
    });
    _this._introspectionQueryName = (_f = props.introspectionQueryName) !== null && _f !== void 0 ? _f : introspectionQueryName;
    _this._introspectionQuerySansSubscriptions = _this._introspectionQuery.replace("subscriptionType { name }", "");
    _this.state = __assign$2({
      schema,
      query,
      variables,
      headers,
      operationName,
      docExplorerOpen,
      schemaErrors,
      response,
      editorFlex: Number(_this._storage.get("editorFlex")) || 1,
      secondaryEditorOpen,
      secondaryEditorHeight: Number(_this._storage.get("secondaryEditorHeight")) || 200,
      variableEditorActive: _this._storage.get("variableEditorActive") === "true" || props.headerEditorEnabled ? _this._storage.get("headerEditorActive") !== "true" : true,
      headerEditorActive: _this._storage.get("headerEditorActive") === "true",
      headerEditorEnabled,
      shouldPersistHeaders,
      historyPaneOpen: _this._storage.get("historyPaneOpen") === "true" || false,
      docExplorerWidth: Number(_this._storage.get("docExplorerWidth")) || DEFAULT_DOC_EXPLORER_WIDTH,
      isWaitingForResponse: false,
      subscription: null,
      maxHistoryLength
    }, queryFacts);
    return _this;
  }
  GraphiQL2.formatResult = function(result2) {
    return JSON.stringify(result2, null, 2);
  };
  GraphiQL2.prototype.componentDidMount = function() {
    this.componentIsMounted = true;
    if (this.state.schema === void 0) {
      this.fetchSchema();
    }
    this.codeMirrorSizer = new CodeMirrorSizer();
    if (typeof global !== void 0) {
      global.g = this;
    }
  };
  GraphiQL2.prototype.UNSAFE_componentWillMount = function() {
    this.componentIsMounted = false;
  };
  GraphiQL2.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
    var _this = this;
    var nextSchema = this.state.schema;
    var nextQuery = this.state.query;
    var nextVariables = this.state.variables;
    var nextHeaders = this.state.headers;
    var nextOperationName = this.state.operationName;
    var nextResponse = this.state.response;
    if (nextProps.schema !== void 0) {
      nextSchema = nextProps.schema;
    }
    if (nextProps.query !== void 0 && this.props.query !== nextProps.query) {
      nextQuery = nextProps.query;
    }
    if (nextProps.variables !== void 0 && this.props.variables !== nextProps.variables) {
      nextVariables = nextProps.variables;
    }
    if (nextProps.headers !== void 0 && this.props.headers !== nextProps.headers) {
      nextHeaders = nextProps.headers;
    }
    if (nextProps.operationName !== void 0) {
      nextOperationName = nextProps.operationName;
    }
    if (nextProps.response !== void 0) {
      nextResponse = nextProps.response;
    }
    if (nextQuery && nextSchema && (nextSchema !== this.state.schema || nextQuery !== this.state.query || nextOperationName !== this.state.operationName)) {
      if (!this.props.dangerouslyAssumeSchemaIsValid) {
        var validationErrors = validateSchema(nextSchema);
        if (validationErrors && validationErrors.length > 0) {
          this.handleSchemaErrors(validationErrors);
          nextSchema = void 0;
        }
      }
      var updatedQueryAttributes = this._updateQueryFacts(nextQuery, nextOperationName, this.state.operations, nextSchema);
      if (updatedQueryAttributes !== void 0) {
        nextOperationName = updatedQueryAttributes.operationName;
        this.setState(updatedQueryAttributes);
      }
    }
    if (nextProps.schema === void 0 && nextProps.fetcher !== this.props.fetcher) {
      nextSchema = void 0;
    }
    this._storage.set("operationName", nextOperationName);
    this.setState({
      schema: nextSchema,
      query: nextQuery,
      variables: nextVariables,
      headers: nextHeaders,
      operationName: nextOperationName,
      response: nextResponse
    }, function() {
      if (_this.state.schema === void 0) {
        if (_this.docExplorerComponent) {
          _this.docExplorerComponent.reset();
        }
        _this.fetchSchema();
      }
    });
  };
  GraphiQL2.prototype.componentDidUpdate = function() {
    this.codeMirrorSizer.updateSizes([
      this.queryEditorComponent,
      this.variableEditorComponent,
      this.headerEditorComponent,
      this.resultComponent
    ]);
  };
  GraphiQL2.prototype.render = function() {
    var _this = this;
    var _a2;
    var children = React$1.Children.toArray(this.props.children);
    var logo = find(children, function(child) {
      return isChildComponentType(child, GraphiQL2.Logo);
    }) || React$1.createElement(GraphiQL2.Logo, null);
    var toolbar = find(children, function(child) {
      return isChildComponentType(child, GraphiQL2.Toolbar);
    }) || React$1.createElement(GraphiQL2.Toolbar, null, React$1.createElement(ToolbarButton, { onClick: this.handlePrettifyQuery, title: "Prettify Query (Shift-Ctrl-P)", label: "Prettify" }), React$1.createElement(ToolbarButton, { onClick: this.handleMergeQuery, title: "Merge Query (Shift-Ctrl-M)", label: "Merge" }), React$1.createElement(ToolbarButton, { onClick: this.handleCopyQuery, title: "Copy Query (Shift-Ctrl-C)", label: "Copy" }), React$1.createElement(ToolbarButton, { onClick: this.handleToggleHistory, title: "Show History", label: "History" }), ((_a2 = this.props.toolbar) === null || _a2 === void 0 ? void 0 : _a2.additionalContent) ? this.props.toolbar.additionalContent : null);
    var footer = find(children, function(child) {
      return isChildComponentType(child, GraphiQL2.Footer);
    });
    var queryWrapStyle = {
      WebkitFlex: this.state.editorFlex,
      flex: this.state.editorFlex
    };
    var docWrapStyle = {
      display: "block",
      width: this.state.docExplorerWidth
    };
    var docExplorerWrapClasses = "docExplorerWrap" + (this.state.docExplorerWidth < 200 ? " doc-explorer-narrow" : "");
    var historyPaneStyle = {
      display: this.state.historyPaneOpen ? "block" : "none",
      width: "230px",
      zIndex: 7
    };
    var secondaryEditorOpen = this.state.secondaryEditorOpen;
    var secondaryEditorStyle = {
      height: secondaryEditorOpen ? this.state.secondaryEditorHeight : void 0
    };
    return React$1.createElement("div", { ref: function(n2) {
      _this.graphiqlContainer = n2;
    }, className: "graphiql-container" }, this.state.historyPaneOpen && React$1.createElement("div", { className: "historyPaneWrap", style: historyPaneStyle }, React$1.createElement(QueryHistory, { ref: function(node) {
      _this._queryHistory = node;
    }, operationName: this.state.operationName, query: this.state.query, variables: this.state.variables, onSelectQuery: this.handleSelectHistoryQuery, storage: this._storage, maxHistoryLength: this.state.maxHistoryLength, queryID: this._editorQueryID }, React$1.createElement("button", { className: "docExplorerHide", onClick: this.handleToggleHistory, "aria-label": "Close History" }, "\u2715"))), React$1.createElement("div", { className: "editorWrap" }, React$1.createElement("div", { className: "topBarWrap" }, this.props.beforeTopBarContent, React$1.createElement("div", { className: "topBar" }, logo, React$1.createElement(ExecuteButton, { isRunning: Boolean(this.state.subscription), onRun: this.handleRunQuery, onStop: this.handleStopQuery, operations: this.state.operations }), toolbar), !this.state.docExplorerOpen && React$1.createElement("button", { className: "docExplorerShow", onClick: this.handleToggleDocs, "aria-label": "Open Documentation Explorer" }, "Docs")), React$1.createElement("div", { ref: function(n2) {
      _this.editorBarComponent = n2;
    }, className: "editorBar", onDoubleClick: this.handleResetResize, onMouseDown: this.handleResizeStart }, React$1.createElement("div", { className: "queryWrap", style: queryWrapStyle }, React$1.createElement(QueryEditor, { ref: function(n2) {
      _this.queryEditorComponent = n2;
    }, schema: this.state.schema, validationRules: this.props.validationRules, value: this.state.query, onEdit: this.handleEditQuery, onHintInformationRender: this.handleHintInformationRender, onClickReference: this.handleClickReference, onCopyQuery: this.handleCopyQuery, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, externalFragments: this.props.externalFragments }), React$1.createElement("section", { className: "variable-editor secondary-editor", style: secondaryEditorStyle, "aria-label": this.state.variableEditorActive ? "Query Variables" : "Request Headers" }, React$1.createElement("div", { className: "secondary-editor-title variable-editor-title", id: "secondary-editor-title", style: {
      cursor: secondaryEditorOpen ? "row-resize" : "n-resize"
    }, onMouseDown: this.handleSecondaryEditorResizeStart }, React$1.createElement("div", { className: "variable-editor-title-text" + (this.state.variableEditorActive ? " active" : ""), onClick: this.handleOpenVariableEditorTab, onMouseDown: this.handleTabClickPropogation }, "Query Variables"), this.state.headerEditorEnabled && React$1.createElement("div", { style: {
      marginLeft: "20px"
    }, className: "variable-editor-title-text" + (this.state.headerEditorActive ? " active" : ""), onClick: this.handleOpenHeaderEditorTab, onMouseDown: this.handleTabClickPropogation }, "Request Headers")), React$1.createElement(VariableEditor, { ref: function(n2) {
      _this.variableEditorComponent = n2;
    }, value: this.state.variables, variableToType: this.state.variableToType, onEdit: this.handleEditVariables, onHintInformationRender: this.handleHintInformationRender, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, active: this.state.variableEditorActive }), this.state.headerEditorEnabled && React$1.createElement(HeaderEditor, { ref: function(n2) {
      _this.headerEditorComponent = n2;
    }, value: this.state.headers, onEdit: this.handleEditHeaders, onHintInformationRender: this.handleHintInformationRender, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, active: this.state.headerEditorActive }))), React$1.createElement("div", { className: "resultWrap" }, this.state.isWaitingForResponse && React$1.createElement("div", { className: "spinner-container" }, React$1.createElement("div", { className: "spinner" })), React$1.createElement(ResultViewer, { registerRef: function(n2) {
      _this.resultViewerElement = n2;
    }, ref: function(c) {
      _this.resultComponent = c;
    }, value: this.state.response, editorTheme: this.props.editorTheme, ResultsTooltip: this.props.ResultsTooltip, ImagePreview }), footer))), this.state.docExplorerOpen && React$1.createElement("div", { className: docExplorerWrapClasses, style: docWrapStyle }, React$1.createElement("div", { className: "docExplorerResizer", onDoubleClick: this.handleDocsResetResize, onMouseDown: this.handleDocsResizeStart }), React$1.createElement(DocExplorer, { ref: function(c) {
      _this.docExplorerComponent = c;
    }, schemaErrors: this.state.schemaErrors, schema: this.state.schema }, React$1.createElement("button", { className: "docExplorerHide", onClick: this.handleToggleDocs, "aria-label": "Close Documentation Explorer" }, "\u2715"))));
  };
  GraphiQL2.prototype.getQueryEditor = function() {
    if (this.queryEditorComponent) {
      return this.queryEditorComponent.getCodeMirror();
    }
  };
  GraphiQL2.prototype.getVariableEditor = function() {
    if (this.variableEditorComponent) {
      return this.variableEditorComponent.getCodeMirror();
    }
    return null;
  };
  GraphiQL2.prototype.getHeaderEditor = function() {
    if (this.headerEditorComponent) {
      return this.headerEditorComponent.getCodeMirror();
    }
    return null;
  };
  GraphiQL2.prototype.refresh = function() {
    if (this.queryEditorComponent) {
      this.queryEditorComponent.getCodeMirror().refresh();
    }
    if (this.variableEditorComponent) {
      this.variableEditorComponent.getCodeMirror().refresh();
    }
    if (this.headerEditorComponent) {
      this.headerEditorComponent.getCodeMirror().refresh();
    }
    if (this.resultComponent) {
      this.resultComponent.getCodeMirror().refresh();
    }
  };
  GraphiQL2.prototype.autoCompleteLeafs = function() {
    var _a2 = fillLeafs(this.state.schema, this.state.query, this.props.getDefaultFieldNames), insertions = _a2.insertions, result2 = _a2.result;
    if (insertions && insertions.length > 0) {
      var editor_1 = this.getQueryEditor();
      if (editor_1) {
        editor_1.operation(function() {
          var cursor = editor_1.getCursor();
          var cursorIndex = editor_1.indexFromPos(cursor);
          editor_1.setValue(result2 || "");
          var added = 0;
          var markers = insertions.map(function(_a3) {
            var index = _a3.index, string2 = _a3.string;
            return editor_1.markText(editor_1.posFromIndex(index + added), editor_1.posFromIndex(index + (added += string2.length)), {
              className: "autoInsertedLeaf",
              clearOnEnter: true,
              title: "Automatically added leaf fields"
            });
          });
          setTimeout(function() {
            return markers.forEach(function(marker2) {
              return marker2.clear();
            });
          }, 7e3);
          var newCursorIndex = cursorIndex;
          insertions.forEach(function(_a3) {
            var index = _a3.index, string2 = _a3.string;
            if (index < cursorIndex) {
              newCursorIndex += string2.length;
            }
          });
          editor_1.setCursor(editor_1.posFromIndex(newCursorIndex));
        });
      }
    }
    return result2;
  };
  GraphiQL2.prototype.fetchSchema = function() {
    var _this = this;
    var fetcher = this.props.fetcher;
    var fetcherOpts = {
      shouldPersistHeaders: Boolean(this.props.shouldPersistHeaders),
      documentAST: this.state.documentAST
    };
    if (this.state.headers && this.state.headers.trim().length > 2) {
      fetcherOpts.headers = JSON.parse(this.state.headers);
    } else if (this.props.headers) {
      fetcherOpts.headers = JSON.parse(this.props.headers);
    }
    var fetch2 = fetcherReturnToPromise(fetcher({
      query: this._introspectionQuery,
      operationName: this._introspectionQueryName
    }, fetcherOpts));
    if (!isPromise(fetch2)) {
      this.setState({
        response: "Fetcher did not return a Promise for introspection."
      });
      return;
    }
    fetch2.then(function(result2) {
      if (typeof result2 !== "string" && "data" in result2) {
        return result2;
      }
      var fetch22 = fetcherReturnToPromise(fetcher({
        query: _this._introspectionQuerySansSubscriptions,
        operationName: _this._introspectionQueryName
      }, fetcherOpts));
      if (!isPromise(fetch2)) {
        throw new Error("Fetcher did not return a Promise for introspection.");
      }
      return fetch22;
    }).then(function(result2) {
      var _a2, _b;
      if (_this.state.schema !== void 0) {
        return;
      }
      if (result2 && result2.data && "__schema" in (result2 === null || result2 === void 0 ? void 0 : result2.data)) {
        var schema = buildClientSchema(result2.data);
        if (!_this.props.dangerouslyAssumeSchemaIsValid) {
          var errors2 = validateSchema(schema);
          if (errors2 && errors2.length > 0) {
            schema = void 0;
            _this.handleSchemaErrors(errors2);
          }
        }
        if (schema) {
          var queryFacts = getOperationFacts(schema, _this.state.query);
          _this.safeSetState(__assign$2(__assign$2({ schema }, queryFacts), { schemaErrors: void 0 }));
          (_b = (_a2 = _this.props).onSchemaChange) === null || _b === void 0 ? void 0 : _b.call(_a2, schema);
        }
      } else {
        var responseString = typeof result2 === "string" ? result2 : GraphiQL2.formatResult(result2);
        _this.handleSchemaErrors([responseString]);
      }
    }).catch(function(error2) {
      _this.handleSchemaErrors([error2]);
    });
  };
  GraphiQL2.prototype.handleSchemaErrors = function(schemaErrors) {
    this.safeSetState({
      response: schemaErrors ? GraphiQL2.formatError(schemaErrors) : void 0,
      schema: void 0,
      schemaErrors
    });
  };
  GraphiQL2.prototype._fetchQuery = function(query, variables, headers, operationName, shouldPersistHeaders, cb2) {
    return __awaiter$1(this, void 0, void 0, function() {
      var fetcher, jsonVariables, jsonHeaders, externalFragments_1, fragmentDependencies, fetch2;
      var _this = this;
      return __generator$1(this, function(_a2) {
        fetcher = this.props.fetcher;
        jsonVariables = null;
        jsonHeaders = null;
        try {
          jsonVariables = variables && variables.trim() !== "" ? JSON.parse(variables) : null;
        } catch (error2) {
          throw new Error("Variables are invalid JSON: " + error2.message + ".");
        }
        if (typeof jsonVariables !== "object") {
          throw new Error("Variables are not a JSON object.");
        }
        try {
          jsonHeaders = headers && headers.trim() !== "" ? JSON.parse(headers) : null;
        } catch (error2) {
          throw new Error("Headers are invalid JSON: " + error2.message + ".");
        }
        if (typeof jsonHeaders !== "object") {
          throw new Error("Headers are not a JSON object.");
        }
        if (this.props.externalFragments) {
          externalFragments_1 = /* @__PURE__ */ new Map();
          if (Array.isArray(this.props.externalFragments)) {
            this.props.externalFragments.forEach(function(def) {
              externalFragments_1.set(def.name.value, def);
            });
          } else {
            visit(parse$1(this.props.externalFragments, {}), {
              FragmentDefinition: function(def) {
                externalFragments_1.set(def.name.value, def);
              }
            });
          }
          fragmentDependencies = getFragmentDependenciesForAST(this.state.documentAST, externalFragments_1);
          if (fragmentDependencies.length > 0) {
            query += "\n" + fragmentDependencies.map(function(node) {
              return print(node);
            }).join("\n");
          }
        }
        fetch2 = fetcher({
          query,
          variables: jsonVariables,
          operationName
        }, {
          headers: jsonHeaders,
          shouldPersistHeaders,
          documentAST: this.state.documentAST
        });
        return [2, Promise.resolve(fetch2).then(function(value) {
          if (isObservable(value)) {
            var subscription = value.subscribe({
              next: cb2,
              error: function(error2) {
                _this.safeSetState({
                  isWaitingForResponse: false,
                  response: error2 ? GraphiQL2.formatError(error2) : void 0,
                  subscription: null
                });
              },
              complete: function() {
                _this.safeSetState({
                  isWaitingForResponse: false,
                  subscription: null
                });
              }
            });
            return subscription;
          } else if (isAsyncIterable$1(value)) {
            (function() {
              return __awaiter$1(_this, void 0, void 0, function() {
                var value_1, value_1_1, result2, e_2_1, error_2;
                var e_2, _a3;
                return __generator$1(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, 13, , 14]);
                      _b.label = 1;
                    case 1:
                      _b.trys.push([1, 6, 7, 12]);
                      value_1 = __asyncValues$1(value);
                      _b.label = 2;
                    case 2:
                      return [4, value_1.next()];
                    case 3:
                      if (!(value_1_1 = _b.sent(), !value_1_1.done))
                        return [3, 5];
                      result2 = value_1_1.value;
                      cb2(result2);
                      _b.label = 4;
                    case 4:
                      return [3, 2];
                    case 5:
                      return [3, 12];
                    case 6:
                      e_2_1 = _b.sent();
                      e_2 = { error: e_2_1 };
                      return [3, 12];
                    case 7:
                      _b.trys.push([7, , 10, 11]);
                      if (!(value_1_1 && !value_1_1.done && (_a3 = value_1.return)))
                        return [3, 9];
                      return [4, _a3.call(value_1)];
                    case 8:
                      _b.sent();
                      _b.label = 9;
                    case 9:
                      return [3, 11];
                    case 10:
                      if (e_2)
                        throw e_2.error;
                      return [7];
                    case 11:
                      return [7];
                    case 12:
                      this.safeSetState({
                        isWaitingForResponse: false,
                        subscription: null
                      });
                      return [3, 14];
                    case 13:
                      error_2 = _b.sent();
                      this.safeSetState({
                        isWaitingForResponse: false,
                        response: error_2 ? GraphiQL2.formatError(error_2) : void 0,
                        subscription: null
                      });
                      return [3, 14];
                    case 14:
                      return [2];
                  }
                });
              });
            })();
            return {
              unsubscribe: function() {
                var _a3, _b;
                return (_b = (_a3 = value[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a3);
              }
            };
          } else {
            cb2(value);
            return null;
          }
        }).catch(function(error2) {
          _this.safeSetState({
            isWaitingForResponse: false,
            response: error2 ? GraphiQL2.formatError(error2) : void 0
          });
          return null;
        })];
      });
    });
  };
  GraphiQL2.prototype._runQueryAtCursor = function() {
    if (this.state.subscription) {
      this.handleStopQuery();
      return;
    }
    var operationName;
    var operations = this.state.operations;
    if (operations) {
      var editor = this.getQueryEditor();
      if (editor && editor.hasFocus()) {
        var cursor = editor.getCursor();
        var cursorIndex = editor.indexFromPos(cursor);
        for (var i = 0; i < operations.length; i++) {
          var operation = operations[i];
          if (operation.loc && operation.loc.start <= cursorIndex && operation.loc.end >= cursorIndex) {
            operationName = operation.name && operation.name.value;
            break;
          }
        }
      }
    }
    this.handleRunQuery(operationName);
  };
  GraphiQL2.prototype._didClickDragBar = function(event) {
    if (event.button !== 0 || event.ctrlKey) {
      return false;
    }
    var target2 = event.target;
    if (target2.className.indexOf("CodeMirror-gutter") !== 0) {
      return false;
    }
    var resultWindow = this.resultViewerElement;
    while (target2) {
      if (target2 === resultWindow) {
        return true;
      }
      target2 = target2.parentNode;
    }
    return false;
  };
  GraphiQL2.formatError = function(error2) {
    if (Array.isArray(error2)) {
      return stringify({
        errors: error2.map(function(e) {
          return handleSingleError(e);
        })
      });
    }
    return stringify({ errors: handleSingleError(error2) });
  };
  GraphiQL2.Logo = GraphiQLLogo;
  GraphiQL2.Toolbar = GraphiQLToolbar;
  GraphiQL2.Footer = GraphiQLFooter;
  GraphiQL2.QueryEditor = QueryEditor;
  GraphiQL2.VariableEditor = VariableEditor;
  GraphiQL2.HeaderEditor = HeaderEditor;
  GraphiQL2.ResultViewer = ResultViewer;
  GraphiQL2.Button = ToolbarButton;
  GraphiQL2.ToolbarButton = ToolbarButton;
  GraphiQL2.Group = ToolbarGroup;
  GraphiQL2.Menu = ToolbarMenu;
  GraphiQL2.MenuItem = ToolbarMenuItem;
  return GraphiQL2;
}(React$1.Component);
function GraphiQLLogo(props) {
  return React$1.createElement("div", { className: "title" }, props.children || React$1.createElement("span", null, "Graph", React$1.createElement("em", null, "i"), "QL"));
}
GraphiQLLogo.displayName = "GraphiQLLogo";
function GraphiQLToolbar(props) {
  return React$1.createElement("div", { className: "toolbar", role: "toolbar", "aria-label": "Editor Commands" }, props.children);
}
GraphiQLToolbar.displayName = "GraphiQLToolbar";
function GraphiQLFooter(props) {
  return React$1.createElement("div", { className: "footer" }, props.children);
}
GraphiQLFooter.displayName = "GraphiQLFooter";
var defaultQuery = '# Welcome to GraphiQL\n#\n# GraphiQL is an in-browser tool for writing, validating, and\n# testing GraphQL queries.\n#\n# Type queries into this side of the screen, and you will see intelligent\n# typeaheads aware of the current GraphQL type schema and live syntax and\n# validation errors highlighted within the text.\n#\n# GraphQL queries typically start with a "{" character. Lines that start\n# with a # are ignored.\n#\n# An example GraphQL query might look like:\n#\n#     {\n#       field(arg: "value") {\n#         subField\n#       }\n#     }\n#\n# Keyboard shortcuts:\n#\n#  Prettify Query:  Shift-Ctrl-P (or press the prettify button above)\n#\n#     Merge Query:  Shift-Ctrl-M (or press the merge button above)\n#\n#       Run Query:  Ctrl-Enter (or press the play button above)\n#\n#   Auto Complete:  Ctrl-Space (or just start typing)\n#\n\n';
function isPromise(value) {
  return typeof value === "object" && typeof value.then === "function";
}
function observableToPromise(observable) {
  return new Promise(function(resolve, reject) {
    var subscription = observable.subscribe({
      next: function(v2) {
        resolve(v2);
        subscription.unsubscribe();
      },
      error: reject,
      complete: function() {
        reject(new Error("no value resolved"));
      }
    });
  });
}
function isObservable(value) {
  return typeof value === "object" && "subscribe" in value && typeof value.subscribe === "function";
}
function isAsyncIterable$1(input) {
  return typeof input === "object" && input !== null && (input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator in input);
}
function asyncIterableToPromise(input) {
  return new Promise(function(resolve, reject) {
    var _a2;
    var iteratorReturn = (_a2 = ("return" in input ? input : input[Symbol.asyncIterator]()).return) === null || _a2 === void 0 ? void 0 : _a2.bind(input);
    var iteratorNext = ("next" in input ? input : input[Symbol.asyncIterator]()).next.bind(input);
    iteratorNext().then(function(result2) {
      resolve(result2.value);
      iteratorReturn === null || iteratorReturn === void 0 ? void 0 : iteratorReturn();
    }).catch(function(err) {
      reject(err);
    });
  });
}
function fetcherReturnToPromise(fetcherResult) {
  return Promise.resolve(fetcherResult).then(function(fetcherResult2) {
    if (isAsyncIterable$1(fetcherResult2)) {
      return asyncIterableToPromise(fetcherResult2);
    } else if (isObservable(fetcherResult2)) {
      return observableToPromise(fetcherResult2);
    }
    return fetcherResult2;
  });
}
function isChildComponentType(child, component) {
  var _a2;
  if (((_a2 = child === null || child === void 0 ? void 0 : child.type) === null || _a2 === void 0 ? void 0 : _a2.displayName) && child.type.displayName === component.displayName) {
    return true;
  }
  return child.type === component;
}
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign$1.apply(this, arguments);
};
function hasProps(child) {
  if (!child || typeof child !== "object" || !("props" in child)) {
    return false;
  }
  return true;
}
(function(_super2) {
  __extends(ToolbarSelect, _super2);
  function ToolbarSelect(props) {
    var _this = _super2.call(this, props) || this;
    _this._node = null;
    _this._listener = null;
    _this.handleOpen = function(e) {
      preventDefault(e);
      _this.setState({ visible: true });
      _this._subscribe();
    };
    _this.state = { visible: false };
    return _this;
  }
  ToolbarSelect.prototype.componentWillUnmount = function() {
    this._release();
  };
  ToolbarSelect.prototype.render = function() {
    var _this = this;
    var selectedChild;
    var visible = this.state.visible;
    var optionChildren = React$1.Children.map(this.props.children, function(child, i) {
      if (!hasProps(child)) {
        return null;
      }
      if (!selectedChild || child.props.selected) {
        selectedChild = child;
      }
      var onChildSelect = child.props.onSelect || _this.props.onSelect && _this.props.onSelect.bind(null, child.props.value, i);
      return React$1.createElement(ToolbarSelectOption, __assign$1({}, child.props, { onSelect: onChildSelect }));
    });
    return React$1.createElement("a", { className: "toolbar-select toolbar-button", onClick: this.handleOpen.bind(this), onMouseDown: preventDefault, ref: function(node) {
      _this._node = node;
    }, title: this.props.title }, selectedChild === null || selectedChild === void 0 ? void 0 : selectedChild.props.label, React$1.createElement("svg", { width: "13", height: "10" }, React$1.createElement("path", { fill: "#666", d: "M 5 5 L 13 5 L 9 1 z" }), React$1.createElement("path", { fill: "#666", d: "M 5 6 L 13 6 L 9 10 z" })), React$1.createElement("ul", { className: "toolbar-select-options" + (visible ? " open" : "") }, optionChildren));
  };
  ToolbarSelect.prototype._subscribe = function() {
    if (!this._listener) {
      this._listener = this.handleClick.bind(this);
      document.addEventListener("click", this._listener);
    }
  };
  ToolbarSelect.prototype._release = function() {
    if (this._listener) {
      document.removeEventListener("click", this._listener);
      this._listener = null;
    }
  };
  ToolbarSelect.prototype.handleClick = function(e) {
    if (this._node !== e.target) {
      preventDefault(e);
      this.setState({ visible: false });
      this._release();
    }
  };
  return ToolbarSelect;
})(React$1.Component);
function ToolbarSelectOption(_a2) {
  var onSelect = _a2.onSelect, label = _a2.label, selected = _a2.selected;
  return React$1.createElement("li", { onMouseOver: function(e) {
    e.currentTarget.className = "hover";
  }, onMouseOut: function(e) {
    e.currentTarget.className = "";
  }, onMouseDown: preventDefault, onMouseUp: onSelect }, label, selected && React$1.createElement("svg", { width: "13", height: "13" }, React$1.createElement("polygon", { points: "4.851,10.462 0,5.611 2.314,3.297 4.851,5.835\n    10.686,0 13,2.314 4.851,10.462" })));
}
function preventDefault(e) {
  e.preventDefault();
}
let AggregateErrorImpl;
if (typeof AggregateError === "undefined") {
  class AggregateErrorClass extends Error {
    constructor(errors2, message = "") {
      super(message);
      this.errors = errors2;
      this.name = "AggregateError";
      Error.captureStackTrace(this, AggregateErrorClass);
    }
  }
  AggregateErrorImpl = function(errors2, message) {
    return new AggregateErrorClass(errors2, message);
  };
} else {
  AggregateErrorImpl = AggregateError;
}
function isAggregateError(error2) {
  return "errors" in error2 && Array.isArray(error2["errors"]);
}
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatError(value) {
  if (value instanceof GraphQLError) {
    return value.toString();
  }
  return `${value.name}: ${value.message};
 ${value.stack}`;
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (value instanceof Error) {
    if (isAggregateError(value)) {
      return formatError(value) + "\n" + formatArray(value.errors, previouslySeenValues);
    }
    return formatError(value);
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value]) => key + ": " + formatValue(value, seenValues));
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
function astFromType(type2) {
  if (isNonNullType(type2)) {
    const innerType = astFromType(type2.ofType);
    if (innerType.kind === Kind.NON_NULL_TYPE) {
      throw new Error(`Invalid type node ${inspect(type2)}. Inner type of non-null type cannot be a non-null type.`);
    }
    return {
      kind: Kind.NON_NULL_TYPE,
      type: innerType
    };
  } else if (isListType(type2)) {
    return {
      kind: Kind.LIST_TYPE,
      type: astFromType(type2.ofType)
    };
  }
  return {
    kind: Kind.NAMED_TYPE,
    name: {
      kind: Kind.NAME,
      value: type2.name
    }
  };
}
function memoize1(fn) {
  const memoize1cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1) {
    const cachedValue = memoize1cache.get(a1);
    if (cachedValue === void 0) {
      const newValue = fn(a1);
      memoize1cache.set(a1, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function memoize2(fn) {
  const memoize2cache = /* @__PURE__ */ new WeakMap();
  return function memoized(a1, a2) {
    let cache2 = memoize2cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize2cache.set(a1, cache2);
      const newValue = fn(a1, a2);
      cache2.set(a2, newValue);
      return newValue;
    }
    const cachedValue = cache2.get(a2);
    if (cachedValue === void 0) {
      const newValue = fn(a1, a2);
      cache2.set(a2, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
const memoize2of4cache = /* @__PURE__ */ new WeakMap();
function memoize2of4(fn) {
  return function memoized(a1, a2, a3, a4) {
    let cache2 = memoize2of4cache.get(a1);
    if (!cache2) {
      cache2 = /* @__PURE__ */ new WeakMap();
      memoize2of4cache.set(a1, cache2);
      const newValue = fn(a1, a2, a3, a4);
      cache2.set(a2, newValue);
      return newValue;
    }
    const cachedValue = cache2.get(a2);
    if (cachedValue === void 0) {
      const newValue = fn(a1, a2, a3, a4);
      cache2.set(a2, newValue);
      return newValue;
    }
    return cachedValue;
  };
}
function getDefinedRootType(schema, operation) {
  const rootTypeMap = getRootTypeMap(schema);
  const rootType = rootTypeMap.get(operation);
  if (rootType == null) {
    throw new Error(`Root type for operation "${operation}" not defined by the given schema.`);
  }
  return rootType;
}
const getRootTypeNames = memoize1(function getRootTypeNames2(schema) {
  const rootTypes = getRootTypes(schema);
  return new Set([...rootTypes].map((type2) => type2.name));
});
const getRootTypes = memoize1(function getRootTypes2(schema) {
  const rootTypeMap = getRootTypeMap(schema);
  return new Set(rootTypeMap.values());
});
const getRootTypeMap = memoize1(function getRootTypeMap2(schema) {
  const rootTypeMap = /* @__PURE__ */ new Map();
  const queryType = schema.getQueryType();
  if (queryType) {
    rootTypeMap.set("query", queryType);
  }
  const mutationType = schema.getMutationType();
  if (mutationType) {
    rootTypeMap.set("mutation", mutationType);
  }
  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    rootTypeMap.set("subscription", subscriptionType);
  }
  return rootTypeMap;
});
const MAX_LINE_LENGTH = 80;
let commentsRegistry = {};
function printComment(comment2) {
  return "\n# " + comment2.replace(/\n/g, "\n# ");
}
function join(maybeArray, separator2) {
  return maybeArray ? maybeArray.filter((x2) => x2).join(separator2 || "") : "";
}
function hasMultilineItems(maybeArray) {
  var _a2;
  return (_a2 = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _a2 !== void 0 ? _a2 : false;
}
function addDescription(cb2) {
  return (node, _key, _parent, path, ancestors) => {
    var _a2;
    const keys = [];
    const parent = path.reduce((prev, key2) => {
      if (["fields", "arguments", "values"].includes(key2) && prev.name) {
        keys.push(prev.name.value);
      }
      return prev[key2];
    }, ancestors[0]);
    const key = [...keys, (_a2 = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a2 === void 0 ? void 0 : _a2.value].filter(Boolean).join(".");
    const items = [];
    if (node.kind.includes("Definition") && commentsRegistry[key]) {
      items.push(...commentsRegistry[key]);
    }
    return join([...items.map(printComment), node.description, cb2(node, _key, _parent, path, ancestors)], "\n");
  };
}
function indent(maybeString) {
  return maybeString && `  ${maybeString.replace(/\n/g, "\n  ")}`;
}
function block2(array) {
  return array && array.length !== 0 ? `{
${indent(join(array, "\n"))}
}` : "";
}
function wrap(start2, maybeString, end2) {
  return maybeString ? start2 + maybeString + (end2 || "") : "";
}
function printBlockString(value, isDescription = false) {
  const escaped = value.replace(/"""/g, '\\"""');
  return (value[0] === " " || value[0] === "	") && value.indexOf("\n") === -1 ? `"""${escaped.replace(/"$/, '"\n')}"""` : `"""
${isDescription ? escaped : indent(escaped)}
"""`;
}
const printDocASTReducer = {
  Name: { leave: (node) => node.value },
  Variable: { leave: (node) => "$" + node.name },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave: (node) => {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([node.operation, join([node.name, varDefs]), join(node.directives, " ")], " ");
      return prefix + " " + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue: defaultValue2, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue2) + wrap(" ", join(directives, " "))
  },
  SelectionSet: { leave: ({ selections }) => block2(selections) },
  Field: {
    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: { leave: ({ name: name2, value }) => name2 + ": " + value },
  FragmentSpread: {
    leave: ({ name: name2, directives }) => "..." + name2 + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ")
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name2}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: { leave: ({ value }) => value },
  FloatValue: { leave: ({ value }) => value },
  StringValue: {
    leave: ({ value, block: isBlockString }) => {
      if (isBlockString) {
        return printBlockString(value);
      }
      return JSON.stringify(value);
    }
  },
  BooleanValue: { leave: ({ value }) => value ? "true" : "false" },
  NullValue: { leave: () => "null" },
  EnumValue: { leave: ({ value }) => value },
  ListValue: { leave: ({ values }) => "[" + join(values, ", ") + "]" },
  ObjectValue: { leave: ({ fields }) => "{" + join(fields, ", ") + "}" },
  ObjectField: { leave: ({ name: name2, value }) => name2 + ": " + value },
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  NamedType: { leave: ({ name: name2 }) => name2 },
  ListType: { leave: ({ type: type2 }) => "[" + type2 + "]" },
  NonNullType: { leave: ({ type: type2 }) => type2 + "!" },
  SchemaDefinition: {
    leave: ({ directives, operationTypes }) => join(["schema", join(directives, " "), block2(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ name: name2, directives }) => join(["scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(["type", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block2(fields)], " ")
  },
  FieldDefinition: {
    leave: ({ name: name2, arguments: args, type: type2, directives }) => name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ name: name2, type: type2, defaultValue: defaultValue2, directives }) => join([name2 + ": " + type2, wrap("= ", defaultValue2), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(["interface", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block2(fields)], " ")
  },
  UnionTypeDefinition: {
    leave: ({ name: name2, directives, types }) => join(["union", name2, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ name: name2, directives, values }) => join(["enum", name2, join(directives, " "), block2(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ name: name2, directives }) => join([name2, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ name: name2, directives, fields }) => join(["input", name2, join(directives, " "), block2(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ name: name2, arguments: args, repeatable, locations }) => "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block2(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives }) => join(["extend scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(["extend type", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block2(fields)], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join(["extend interface", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block2(fields)], " ")
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives, types }) => join(["extend union", name2, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives, values }) => join(["extend enum", name2, join(directives, " "), block2(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives, fields }) => join(["extend input", name2, join(directives, " "), block2(fields)], " ")
  }
};
Object.keys(printDocASTReducer).reduce((prev, key) => __spreadProps(__spreadValues({}, prev), {
  [key]: {
    leave: addDescription(printDocASTReducer[key].leave)
  }
}), {});
function getLeadingCommentBlock(node) {
  const loc = node.loc;
  if (!loc) {
    return;
  }
  const comments = [];
  let token2 = loc.startToken.prev;
  while (token2 != null && token2.kind === TokenKind.COMMENT && token2.next != null && token2.prev != null && token2.line + 1 === token2.next.line && token2.line !== token2.prev.line) {
    const value = String(token2.value);
    comments.push(value);
    token2 = token2.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
function dedentBlockStringValue(rawString) {
  const lines = rawString.split(/\r\n|[\n\r]/g);
  const commonIndent = getBlockStringIndentation(lines);
  if (commonIndent !== 0) {
    for (let i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  while (lines.length > 0 && isBlank(lines[0])) {
    lines.shift();
  }
  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {
    lines.pop();
  }
  return lines.join("\n");
}
function getBlockStringIndentation(lines) {
  let commonIndent = null;
  for (let i = 1; i < lines.length; i++) {
    const line = lines[i];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    if (commonIndent === null || indent2 < commonIndent) {
      commonIndent = indent2;
      if (commonIndent === 0) {
        break;
      }
    }
  }
  return commonIndent === null ? 0 : commonIndent;
}
function leadingWhitespace(str) {
  let i = 0;
  while (i < str.length && (str[i] === " " || str[i] === "	")) {
    i++;
  }
  return i;
}
function isBlank(str) {
  return leadingWhitespace(str) === str.length;
}
function parseGraphQLSDL(location, rawSDL, options = {}) {
  let document2;
  try {
    if (options.commentDescriptions && rawSDL.includes("#")) {
      document2 = transformCommentsToDescriptions(rawSDL, options);
      if (options.noLocation) {
        document2 = parse$1(print(document2), options);
      }
    } else {
      document2 = parse$1(new Source(rawSDL, location), options);
    }
  } catch (e) {
    if (e.message.includes("EOF") && rawSDL.replace(/(\#[^*]*)/g, "").trim() === "") {
      document2 = {
        kind: Kind.DOCUMENT,
        definitions: []
      };
    } else {
      throw e;
    }
  }
  return {
    location,
    document: document2
  };
}
function transformCommentsToDescriptions(sourceSdl, options = {}) {
  const parsedDoc = parse$1(sourceSdl, __spreadProps(__spreadValues({}, options), {
    noLocation: false
  }));
  const modifiedDoc = visit(parsedDoc, {
    leave: (node) => {
      if (isDescribable(node)) {
        const rawValue = getLeadingCommentBlock(node);
        if (rawValue !== void 0) {
          const commentsBlock = dedentBlockStringValue("\n" + rawValue);
          const isBlock = commentsBlock.includes("\n");
          if (!node.description) {
            return __spreadProps(__spreadValues({}, node), {
              description: {
                kind: Kind.STRING,
                value: commentsBlock,
                block: isBlock
              }
            });
          } else {
            return __spreadProps(__spreadValues({}, node), {
              description: __spreadProps(__spreadValues({}, node.description), {
                value: node.description.value + "\n" + commentsBlock,
                block: true
              })
            });
          }
        }
      }
    }
  });
  return modifiedDoc;
}
function isDescribable(node) {
  return isTypeSystemDefinitionNode(node) || node.kind === Kind.FIELD_DEFINITION || node.kind === Kind.INPUT_VALUE_DEFINITION || node.kind === Kind.ENUM_VALUE_DEFINITION;
}
var MapperKind;
(function(MapperKind2) {
  MapperKind2["TYPE"] = "MapperKind.TYPE";
  MapperKind2["SCALAR_TYPE"] = "MapperKind.SCALAR_TYPE";
  MapperKind2["ENUM_TYPE"] = "MapperKind.ENUM_TYPE";
  MapperKind2["COMPOSITE_TYPE"] = "MapperKind.COMPOSITE_TYPE";
  MapperKind2["OBJECT_TYPE"] = "MapperKind.OBJECT_TYPE";
  MapperKind2["INPUT_OBJECT_TYPE"] = "MapperKind.INPUT_OBJECT_TYPE";
  MapperKind2["ABSTRACT_TYPE"] = "MapperKind.ABSTRACT_TYPE";
  MapperKind2["UNION_TYPE"] = "MapperKind.UNION_TYPE";
  MapperKind2["INTERFACE_TYPE"] = "MapperKind.INTERFACE_TYPE";
  MapperKind2["ROOT_OBJECT"] = "MapperKind.ROOT_OBJECT";
  MapperKind2["QUERY"] = "MapperKind.QUERY";
  MapperKind2["MUTATION"] = "MapperKind.MUTATION";
  MapperKind2["SUBSCRIPTION"] = "MapperKind.SUBSCRIPTION";
  MapperKind2["DIRECTIVE"] = "MapperKind.DIRECTIVE";
  MapperKind2["FIELD"] = "MapperKind.FIELD";
  MapperKind2["COMPOSITE_FIELD"] = "MapperKind.COMPOSITE_FIELD";
  MapperKind2["OBJECT_FIELD"] = "MapperKind.OBJECT_FIELD";
  MapperKind2["ROOT_FIELD"] = "MapperKind.ROOT_FIELD";
  MapperKind2["QUERY_ROOT_FIELD"] = "MapperKind.QUERY_ROOT_FIELD";
  MapperKind2["MUTATION_ROOT_FIELD"] = "MapperKind.MUTATION_ROOT_FIELD";
  MapperKind2["SUBSCRIPTION_ROOT_FIELD"] = "MapperKind.SUBSCRIPTION_ROOT_FIELD";
  MapperKind2["INTERFACE_FIELD"] = "MapperKind.INTERFACE_FIELD";
  MapperKind2["INPUT_OBJECT_FIELD"] = "MapperKind.INPUT_OBJECT_FIELD";
  MapperKind2["ARGUMENT"] = "MapperKind.ARGUMENT";
  MapperKind2["ENUM_VALUE"] = "MapperKind.ENUM_VALUE";
})(MapperKind || (MapperKind = {}));
function getObjectTypeFromTypeMap(typeMap, type2) {
  if (type2) {
    const maybeObjectType = typeMap[type2.name];
    if (isObjectType(maybeObjectType)) {
      return maybeObjectType;
    }
  }
}
function isNamedStub(type2) {
  if ("getFields" in type2) {
    const fields = type2.getFields();
    for (const fieldName in fields) {
      const field = fields[fieldName];
      return field.name === "_fake";
    }
  }
  return false;
}
function getBuiltInForStub(type2) {
  switch (type2.name) {
    case GraphQLInt.name:
      return GraphQLInt;
    case GraphQLFloat.name:
      return GraphQLFloat;
    case GraphQLString.name:
      return GraphQLString;
    case GraphQLBoolean.name:
      return GraphQLBoolean;
    case GraphQLID.name:
      return GraphQLID;
    default:
      return type2;
  }
}
function rewireTypes(originalTypeMap, directives) {
  const referenceTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in originalTypeMap) {
    referenceTypeMap[typeName] = originalTypeMap[typeName];
  }
  const newTypeMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in referenceTypeMap) {
    const namedType = referenceTypeMap[typeName];
    if (namedType == null || typeName.startsWith("__")) {
      continue;
    }
    const newName = namedType.name;
    if (newName.startsWith("__")) {
      continue;
    }
    if (newTypeMap[newName] != null) {
      throw new Error(`Duplicate schema type name ${newName}`);
    }
    newTypeMap[newName] = namedType;
  }
  for (const typeName in newTypeMap) {
    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);
  }
  const newDirectives = directives.map((directive) => rewireDirective(directive));
  return {
    typeMap: newTypeMap,
    directives: newDirectives
  };
  function rewireDirective(directive) {
    if (isSpecifiedDirective(directive)) {
      return directive;
    }
    const directiveConfig = directive.toConfig();
    directiveConfig.args = rewireArgs(directiveConfig.args);
    return new GraphQLDirective(directiveConfig);
  }
  function rewireArgs(args) {
    const rewiredArgs = {};
    for (const argName in args) {
      const arg = args[argName];
      const rewiredArgType = rewireType(arg.type);
      if (rewiredArgType != null) {
        arg.type = rewiredArgType;
        rewiredArgs[argName] = arg;
      }
    }
    return rewiredArgs;
  }
  function rewireNamedType(type2) {
    if (isObjectType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps(__spreadValues({}, config2), {
        fields: () => rewireFields(config2.fields),
        interfaces: () => rewireNamedTypes(config2.interfaces)
      });
      return new GraphQLObjectType(newConfig);
    } else if (isInterfaceType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps(__spreadValues({}, config2), {
        fields: () => rewireFields(config2.fields)
      });
      if ("interfaces" in newConfig) {
        newConfig.interfaces = () => rewireNamedTypes(config2.interfaces);
      }
      return new GraphQLInterfaceType(newConfig);
    } else if (isUnionType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps(__spreadValues({}, config2), {
        types: () => rewireNamedTypes(config2.types)
      });
      return new GraphQLUnionType(newConfig);
    } else if (isInputObjectType(type2)) {
      const config2 = type2.toConfig();
      const newConfig = __spreadProps(__spreadValues({}, config2), {
        fields: () => rewireInputFields(config2.fields)
      });
      return new GraphQLInputObjectType(newConfig);
    } else if (isEnumType(type2)) {
      const enumConfig = type2.toConfig();
      return new GraphQLEnumType(enumConfig);
    } else if (isScalarType(type2)) {
      if (isSpecifiedScalarType(type2)) {
        return type2;
      }
      const scalarConfig = type2.toConfig();
      return new GraphQLScalarType(scalarConfig);
    }
    throw new Error(`Unexpected schema type: ${type2}`);
  }
  function rewireFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null && field.args) {
        field.type = rewiredFieldType;
        field.args = rewireArgs(field.args);
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireInputFields(fields) {
    const rewiredFields = {};
    for (const fieldName in fields) {
      const field = fields[fieldName];
      const rewiredFieldType = rewireType(field.type);
      if (rewiredFieldType != null) {
        field.type = rewiredFieldType;
        rewiredFields[fieldName] = field;
      }
    }
    return rewiredFields;
  }
  function rewireNamedTypes(namedTypes) {
    const rewiredTypes = [];
    for (const namedType of namedTypes) {
      const rewiredType = rewireType(namedType);
      if (rewiredType != null) {
        rewiredTypes.push(rewiredType);
      }
    }
    return rewiredTypes;
  }
  function rewireType(type2) {
    if (isListType(type2)) {
      const rewiredType = rewireType(type2.ofType);
      return rewiredType != null ? new GraphQLList(rewiredType) : null;
    } else if (isNonNullType(type2)) {
      const rewiredType = rewireType(type2.ofType);
      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;
    } else if (isNamedType(type2)) {
      let rewiredType = referenceTypeMap[type2.name];
      if (rewiredType === void 0) {
        rewiredType = isNamedStub(type2) ? getBuiltInForStub(type2) : rewireNamedType(type2);
        newTypeMap[rewiredType.name] = referenceTypeMap[type2.name] = rewiredType;
      }
      return rewiredType != null ? newTypeMap[rewiredType.name] : null;
    }
    return null;
  }
}
function transformInputValue(type2, value, inputLeafValueTransformer = null, inputObjectValueTransformer = null) {
  if (value == null) {
    return value;
  }
  const nullableType = getNullableType(type2);
  if (isLeafType(nullableType)) {
    return inputLeafValueTransformer != null ? inputLeafValueTransformer(nullableType, value) : value;
  } else if (isListType(nullableType)) {
    return value.map((listMember) => transformInputValue(nullableType.ofType, listMember, inputLeafValueTransformer, inputObjectValueTransformer));
  } else if (isInputObjectType(nullableType)) {
    const fields = nullableType.getFields();
    const newValue = {};
    for (const key in value) {
      const field = fields[key];
      if (field != null) {
        newValue[key] = transformInputValue(field.type, value[key], inputLeafValueTransformer, inputObjectValueTransformer);
      }
    }
    return inputObjectValueTransformer != null ? inputObjectValueTransformer(nullableType, newValue) : newValue;
  }
}
function serializeInputValue(type2, value) {
  return transformInputValue(type2, value, (t2, v2) => t2.serialize(v2));
}
function parseInputValue(type2, value) {
  return transformInputValue(type2, value, (t2, v2) => t2.parseValue(v2));
}
function mapSchema(schema, schemaMapper = {}) {
  const newTypeMap = mapArguments(mapFields(mapTypes(mapDefaultValues(mapEnumValues(mapTypes(mapDefaultValues(schema.getTypeMap(), schema, serializeInputValue), schema, schemaMapper, (type2) => isLeafType(type2)), schema, schemaMapper), schema, parseInputValue), schema, schemaMapper, (type2) => !isLeafType(type2)), schema, schemaMapper), schema, schemaMapper);
  const originalDirectives = schema.getDirectives();
  const newDirectives = mapDirectives(originalDirectives, schema, schemaMapper);
  const { typeMap, directives } = rewireTypes(newTypeMap, newDirectives);
  return new GraphQLSchema(__spreadProps(__spreadValues({}, schema.toConfig()), {
    query: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getQueryType())),
    mutation: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getMutationType())),
    subscription: getObjectTypeFromTypeMap(typeMap, getObjectTypeFromTypeMap(newTypeMap, schema.getSubscriptionType())),
    types: Object.values(typeMap),
    directives
  }));
}
function mapTypes(originalTypeMap, schema, schemaMapper, testFn = () => true) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (originalType == null || !testFn(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const typeMapper = getTypeMapper(schema, schemaMapper, typeName);
      if (typeMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const maybeNewType = typeMapper(originalType, schema);
      if (maybeNewType === void 0) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      newTypeMap[typeName] = maybeNewType;
    }
  }
  return newTypeMap;
}
function mapEnumValues(originalTypeMap, schema, schemaMapper) {
  const enumValueMapper = getEnumValueMapper(schemaMapper);
  if (!enumValueMapper) {
    return originalTypeMap;
  }
  return mapTypes(originalTypeMap, schema, {
    [MapperKind.ENUM_TYPE]: (type2) => {
      const config2 = type2.toConfig();
      const originalEnumValueConfigMap = config2.values;
      const newEnumValueConfigMap = {};
      for (const externalValue in originalEnumValueConfigMap) {
        const originalEnumValueConfig = originalEnumValueConfigMap[externalValue];
        const mappedEnumValue = enumValueMapper(originalEnumValueConfig, type2.name, schema, externalValue);
        if (mappedEnumValue === void 0) {
          newEnumValueConfigMap[externalValue] = originalEnumValueConfig;
        } else if (Array.isArray(mappedEnumValue)) {
          const [newExternalValue, newEnumValueConfig] = mappedEnumValue;
          newEnumValueConfigMap[newExternalValue] = newEnumValueConfig === void 0 ? originalEnumValueConfig : newEnumValueConfig;
        } else if (mappedEnumValue !== null) {
          newEnumValueConfigMap[externalValue] = mappedEnumValue;
        }
      }
      return correctASTNodes(new GraphQLEnumType(__spreadProps(__spreadValues({}, config2), {
        values: newEnumValueConfigMap
      })));
    }
  }, (type2) => isEnumType(type2));
}
function mapDefaultValues(originalTypeMap, schema, fn) {
  const newTypeMap = mapArguments(originalTypeMap, schema, {
    [MapperKind.ARGUMENT]: (argumentConfig) => {
      if (argumentConfig.defaultValue === void 0) {
        return argumentConfig;
      }
      const maybeNewType = getNewType(originalTypeMap, argumentConfig.type);
      if (maybeNewType != null) {
        return __spreadProps(__spreadValues({}, argumentConfig), {
          defaultValue: fn(maybeNewType, argumentConfig.defaultValue)
        });
      }
    }
  });
  return mapFields(newTypeMap, schema, {
    [MapperKind.INPUT_OBJECT_FIELD]: (inputFieldConfig) => {
      if (inputFieldConfig.defaultValue === void 0) {
        return inputFieldConfig;
      }
      const maybeNewType = getNewType(newTypeMap, inputFieldConfig.type);
      if (maybeNewType != null) {
        return __spreadProps(__spreadValues({}, inputFieldConfig), {
          defaultValue: fn(maybeNewType, inputFieldConfig.defaultValue)
        });
      }
    }
  });
}
function getNewType(newTypeMap, type2) {
  if (isListType(type2)) {
    const newType = getNewType(newTypeMap, type2.ofType);
    return newType != null ? new GraphQLList(newType) : null;
  } else if (isNonNullType(type2)) {
    const newType = getNewType(newTypeMap, type2.ofType);
    return newType != null ? new GraphQLNonNull(newType) : null;
  } else if (isNamedType(type2)) {
    const newType = newTypeMap[type2.name];
    return newType != null ? newType : null;
  }
  return null;
}
function mapFields(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType(originalType) && !isInterfaceType(originalType) && !isInputObjectType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const fieldMapper = getFieldMapper(schema, schemaMapper, typeName);
      if (fieldMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const mappedField = fieldMapper(originalFieldConfig, fieldName, typeName, schema);
        if (mappedField === void 0) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
        } else if (Array.isArray(mappedField)) {
          const [newFieldName, newFieldConfig] = mappedField;
          if (newFieldConfig.astNode != null) {
            newFieldConfig.astNode = __spreadProps(__spreadValues({}, newFieldConfig.astNode), {
              name: __spreadProps(__spreadValues({}, newFieldConfig.astNode.name), {
                value: newFieldName
              })
            });
          }
          newFieldConfigMap[newFieldName] = newFieldConfig === void 0 ? originalFieldConfig : newFieldConfig;
        } else if (mappedField !== null) {
          newFieldConfigMap[fieldName] = mappedField;
        }
      }
      if (isObjectType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
          fields: newFieldConfigMap
        })));
      } else if (isInterfaceType(originalType)) {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
          fields: newFieldConfigMap
        })));
      } else {
        newTypeMap[typeName] = correctASTNodes(new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
          fields: newFieldConfigMap
        })));
      }
    }
  }
  return newTypeMap;
}
function mapArguments(originalTypeMap, schema, schemaMapper) {
  const newTypeMap = {};
  for (const typeName in originalTypeMap) {
    if (!typeName.startsWith("__")) {
      const originalType = originalTypeMap[typeName];
      if (!isObjectType(originalType) && !isInterfaceType(originalType)) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const argumentMapper = getArgumentMapper(schemaMapper);
      if (argumentMapper == null) {
        newTypeMap[typeName] = originalType;
        continue;
      }
      const config2 = originalType.toConfig();
      const originalFieldConfigMap = config2.fields;
      const newFieldConfigMap = {};
      for (const fieldName in originalFieldConfigMap) {
        const originalFieldConfig = originalFieldConfigMap[fieldName];
        const originalArgumentConfigMap = originalFieldConfig.args;
        if (originalArgumentConfigMap == null) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const argumentNames = Object.keys(originalArgumentConfigMap);
        if (!argumentNames.length) {
          newFieldConfigMap[fieldName] = originalFieldConfig;
          continue;
        }
        const newArgumentConfigMap = {};
        for (const argumentName of argumentNames) {
          const originalArgumentConfig = originalArgumentConfigMap[argumentName];
          const mappedArgument = argumentMapper(originalArgumentConfig, fieldName, typeName, schema);
          if (mappedArgument === void 0) {
            newArgumentConfigMap[argumentName] = originalArgumentConfig;
          } else if (Array.isArray(mappedArgument)) {
            const [newArgumentName, newArgumentConfig] = mappedArgument;
            newArgumentConfigMap[newArgumentName] = newArgumentConfig;
          } else if (mappedArgument !== null) {
            newArgumentConfigMap[argumentName] = mappedArgument;
          }
        }
        newFieldConfigMap[fieldName] = __spreadProps(__spreadValues({}, originalFieldConfig), {
          args: newArgumentConfigMap
        });
      }
      if (isObjectType(originalType)) {
        newTypeMap[typeName] = new GraphQLObjectType(__spreadProps(__spreadValues({}, config2), {
          fields: newFieldConfigMap
        }));
      } else if (isInterfaceType(originalType)) {
        newTypeMap[typeName] = new GraphQLInterfaceType(__spreadProps(__spreadValues({}, config2), {
          fields: newFieldConfigMap
        }));
      } else {
        newTypeMap[typeName] = new GraphQLInputObjectType(__spreadProps(__spreadValues({}, config2), {
          fields: newFieldConfigMap
        }));
      }
    }
  }
  return newTypeMap;
}
function mapDirectives(originalDirectives, schema, schemaMapper) {
  const directiveMapper = getDirectiveMapper(schemaMapper);
  if (directiveMapper == null) {
    return originalDirectives.slice();
  }
  const newDirectives = [];
  for (const directive of originalDirectives) {
    const mappedDirective = directiveMapper(directive, schema);
    if (mappedDirective === void 0) {
      newDirectives.push(directive);
    } else if (mappedDirective !== null) {
      newDirectives.push(mappedDirective);
    }
  }
  return newDirectives;
}
function getTypeSpecifiers(schema, typeName) {
  var _a2, _b, _c;
  const type2 = schema.getType(typeName);
  const specifiers = [MapperKind.TYPE];
  if (isObjectType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);
    if (typeName === ((_a2 = schema.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);
    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);
    }
  } else if (isInputObjectType(type2)) {
    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);
  } else if (isInterfaceType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);
  } else if (isUnionType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);
  } else if (isEnumType(type2)) {
    specifiers.push(MapperKind.ENUM_TYPE);
  } else if (isScalarType(type2)) {
    specifiers.push(MapperKind.SCALAR_TYPE);
  }
  return specifiers;
}
function getTypeMapper(schema, schemaMapper, typeName) {
  const specifiers = getTypeSpecifiers(schema, typeName);
  let typeMapper;
  const stack = [...specifiers];
  while (!typeMapper && stack.length > 0) {
    const next = stack.pop();
    typeMapper = schemaMapper[next];
  }
  return typeMapper != null ? typeMapper : null;
}
function getFieldSpecifiers(schema, typeName) {
  var _a2, _b, _c;
  const type2 = schema.getType(typeName);
  const specifiers = [MapperKind.FIELD];
  if (isObjectType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.OBJECT_FIELD);
    if (typeName === ((_a2 = schema.getQueryType()) === null || _a2 === void 0 ? void 0 : _a2.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.QUERY_ROOT_FIELD);
    } else if (typeName === ((_b = schema.getMutationType()) === null || _b === void 0 ? void 0 : _b.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.MUTATION_ROOT_FIELD);
    } else if (typeName === ((_c = schema.getSubscriptionType()) === null || _c === void 0 ? void 0 : _c.name)) {
      specifiers.push(MapperKind.ROOT_FIELD, MapperKind.SUBSCRIPTION_ROOT_FIELD);
    }
  } else if (isInterfaceType(type2)) {
    specifiers.push(MapperKind.COMPOSITE_FIELD, MapperKind.INTERFACE_FIELD);
  } else if (isInputObjectType(type2)) {
    specifiers.push(MapperKind.INPUT_OBJECT_FIELD);
  }
  return specifiers;
}
function getFieldMapper(schema, schemaMapper, typeName) {
  const specifiers = getFieldSpecifiers(schema, typeName);
  let fieldMapper;
  const stack = [...specifiers];
  while (!fieldMapper && stack.length > 0) {
    const next = stack.pop();
    fieldMapper = schemaMapper[next];
  }
  return fieldMapper !== null && fieldMapper !== void 0 ? fieldMapper : null;
}
function getArgumentMapper(schemaMapper) {
  const argumentMapper = schemaMapper[MapperKind.ARGUMENT];
  return argumentMapper != null ? argumentMapper : null;
}
function getDirectiveMapper(schemaMapper) {
  const directiveMapper = schemaMapper[MapperKind.DIRECTIVE];
  return directiveMapper != null ? directiveMapper : null;
}
function getEnumValueMapper(schemaMapper) {
  const enumValueMapper = schemaMapper[MapperKind.ENUM_VALUE];
  return enumValueMapper != null ? enumValueMapper : null;
}
function correctASTNodes(type2) {
  if (isObjectType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        fields
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLObjectType(config2);
  } else if (isInterfaceType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        fields
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLInterfaceType(config2);
  } else if (isInputObjectType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const fields = [];
      for (const fieldName in config2.fields) {
        const fieldConfig = config2.fields[fieldName];
        if (fieldConfig.astNode != null) {
          fields.push(fieldConfig.astNode);
        }
      }
      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        fields
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        fields: void 0
      }));
    }
    return new GraphQLInputObjectType(config2);
  } else if (isEnumType(type2)) {
    const config2 = type2.toConfig();
    if (config2.astNode != null) {
      const values = [];
      for (const enumKey in config2.values) {
        const enumValueConfig = config2.values[enumKey];
        if (enumValueConfig.astNode != null) {
          values.push(enumValueConfig.astNode);
        }
      }
      config2.astNode = __spreadProps(__spreadValues({}, config2.astNode), {
        values
      });
    }
    if (config2.extensionASTNodes != null) {
      config2.extensionASTNodes = config2.extensionASTNodes.map((node) => __spreadProps(__spreadValues({}, node), {
        values: void 0
      }));
    }
    return new GraphQLEnumType(config2);
  } else {
    return type2;
  }
}
function getResponseKeyFromInfo(info2) {
  return info2.fieldNodes[0].alias != null ? info2.fieldNodes[0].alias.value : info2.fieldName;
}
function mapAsyncIterator(iterator, callback, rejectCallback) {
  let $return;
  let abruptClose;
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = (error2) => {
      const rethrow = () => Promise.reject(error2);
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result2) {
    return result2.done ? result2 : asyncMapValue(result2.value, callback).then(iteratorResult, abruptClose);
  }
  let mapReject;
  if (rejectCallback) {
    const reject = rejectCallback;
    mapReject = (error2) => asyncMapValue(error2, reject).then(iteratorResult, abruptClose);
  }
  return {
    next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({ value: void 0, done: true });
    },
    throw(error2) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error2).then(mapResult, mapReject);
      }
      return Promise.reject(error2).catch(abruptClose);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function asyncMapValue(value, callback) {
  return new Promise((resolve) => resolve(callback(value)));
}
function iteratorResult(value) {
  return { value, done: false };
}
function updateArgument(argumentNodes, variableDefinitionsMap, variableValues, argName, varName, type2, value) {
  argumentNodes[argName] = {
    kind: Kind.ARGUMENT,
    name: {
      kind: Kind.NAME,
      value: argName
    },
    value: {
      kind: Kind.VARIABLE,
      name: {
        kind: Kind.NAME,
        value: varName
      }
    }
  };
  variableDefinitionsMap[varName] = {
    kind: Kind.VARIABLE_DEFINITION,
    variable: {
      kind: Kind.VARIABLE,
      name: {
        kind: Kind.NAME,
        value: varName
      }
    },
    type: astFromType(type2)
  };
  if (value !== void 0) {
    variableValues[varName] = value;
    return;
  }
  if (varName in variableValues) {
    delete variableValues[varName];
  }
}
function createVariableNameGenerator(variableDefinitionMap) {
  let varCounter = 0;
  return (argName) => {
    let varName;
    do {
      varName = `_v${(varCounter++).toString()}_${argName}`;
    } while (varName in variableDefinitionMap);
    return varName;
  };
}
function implementsAbstractType(schema, typeA, typeB) {
  if (typeB == null || typeA == null) {
    return false;
  } else if (typeA === typeB) {
    return true;
  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {
    return doTypesOverlap(schema, typeA, typeB);
  }
  return false;
}
function relocatedError(originalError, path) {
  return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path === null ? void 0 : path === void 0 ? originalError.path : path, originalError.originalError, originalError.extensions);
}
function observableToAsyncIterable(observable) {
  const pullQueue = [];
  const pushQueue = [];
  let listening = true;
  const pushValue = (value) => {
    if (pullQueue.length !== 0) {
      pullQueue.shift()({ value, done: false });
    } else {
      pushQueue.push({ value, done: false });
    }
  };
  const pushError = (error2) => {
    if (pullQueue.length !== 0) {
      pullQueue.shift()({ value: { errors: [error2] }, done: false });
    } else {
      pushQueue.push({ value: { errors: [error2] }, done: false });
    }
  };
  const pushDone = () => {
    if (pullQueue.length !== 0) {
      pullQueue.shift()({ done: true });
    } else {
      pushQueue.push({ done: true });
    }
  };
  const pullValue = () => new Promise((resolve) => {
    if (pushQueue.length !== 0) {
      const element = pushQueue.shift();
      resolve(element);
    } else {
      pullQueue.push(resolve);
    }
  });
  const subscription = observable.subscribe({
    next(value) {
      pushValue(value);
    },
    error(err) {
      pushError(err);
    },
    complete() {
      pushDone();
    }
  });
  const emptyQueue = () => {
    if (listening) {
      listening = false;
      subscription.unsubscribe();
      for (const resolve of pullQueue) {
        resolve({ value: void 0, done: true });
      }
      pullQueue.length = 0;
      pushQueue.length = 0;
    }
  };
  return {
    next() {
      return listening ? pullValue() : this.return();
    },
    return() {
      emptyQueue();
      return Promise.resolve({ value: void 0, done: true });
    },
    throw(error2) {
      emptyQueue();
      return Promise.reject(error2);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
function getOperationASTFromDocument(documentNode, operationName) {
  const doc = getOperationAST(documentNode, operationName);
  if (!doc) {
    throw new Error(`Cannot infer operation ${operationName || ""}`);
  }
  return doc;
}
const getOperationASTFromRequest = memoize1(function getOperationASTFromRequest2(request) {
  return getOperationASTFromDocument(request.document, request.operationName);
});
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name2 = getFieldEntryKey(selection);
        const fieldList = fields.get(name2);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name2, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFields(schema, fragments, variableValues, runtimeType, selection.selectionSet, fields, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFields(schema, fragments, variableValues, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);
        break;
      }
    }
  }
  return fields;
}
function shouldIncludeNode(variableValues, node) {
  const skip2 = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip2 === null || skip2 === void 0 ? void 0 : skip2["if"]) === true) {
    return false;
  }
  const include = getDirectiveValues(GraphQLIncludeDirective, node, variableValues);
  if ((include === null || include === void 0 ? void 0 : include["if"]) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type2) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    const possibleTypes = schema.getPossibleTypes(conditionalType);
    return possibleTypes.includes(type2);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function isAsyncIterable(value) {
  return typeof value === "object" && value != null && Symbol.asyncIterator in value && typeof value[Symbol.asyncIterator] === "function";
}
async function defaultAsyncIteratorReturn(value) {
  return { value, done: true };
}
const proxyMethodFactory = memoize2(function proxyMethodFactory2(target2, targetMethod) {
  return function proxyMethod(...args) {
    return Reflect.apply(targetMethod, target2, args);
  };
});
function getAsyncIteratorWithCancel(asyncIterator, onCancel) {
  return new Proxy(asyncIterator, {
    has(asyncIterator2, prop2) {
      if (prop2 === "return") {
        return true;
      }
      return Reflect.has(asyncIterator2, prop2);
    },
    get(asyncIterator2, prop2, receiver) {
      const existingPropValue = Reflect.get(asyncIterator2, prop2, receiver);
      if (prop2 === "return") {
        const existingReturn = existingPropValue || defaultAsyncIteratorReturn;
        return async function returnWithCancel(value) {
          const returnValue = await onCancel(value);
          return Reflect.apply(existingReturn, asyncIterator2, [returnValue]);
        };
      } else if (typeof existingPropValue === "function") {
        return proxyMethodFactory(asyncIterator2, existingPropValue);
      }
      return existingPropValue;
    }
  });
}
function getAsyncIterableWithCancel(asyncIterable, onCancel) {
  return new Proxy(asyncIterable, {
    get(asyncIterable2, prop2, receiver) {
      const existingPropValue = Reflect.get(asyncIterable2, prop2, receiver);
      if (Symbol.asyncIterator === prop2) {
        return function asyncIteratorFactory() {
          const asyncIterator = Reflect.apply(existingPropValue, asyncIterable2, []);
          return getAsyncIteratorWithCancel(asyncIterator, onCancel);
        };
      } else if (typeof existingPropValue === "function") {
        return proxyMethodFactory(asyncIterable2, existingPropValue);
      }
      return existingPropValue;
    }
  });
}
var validUrl = { exports: {} };
(function(module2) {
  (function(module3) {
    module3.exports.is_uri = is_iri;
    module3.exports.is_http_uri = is_http_iri;
    module3.exports.is_https_uri = is_https_iri;
    module3.exports.is_web_uri = is_web_iri;
    module3.exports.isUri = is_iri;
    module3.exports.isHttpUri = is_http_iri;
    module3.exports.isHttpsUri = is_https_iri;
    module3.exports.isWebUri = is_web_iri;
    var splitUri = function(uri) {
      var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
      return splitted;
    };
    function is_iri(value) {
      if (!value) {
        return;
      }
      if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value))
        return;
      if (/%[^0-9a-f]/i.test(value))
        return;
      if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
        return;
      var splitted = [];
      var scheme = "";
      var authority = "";
      var path = "";
      var query = "";
      var fragment = "";
      var out = "";
      splitted = splitUri(value);
      scheme = splitted[1];
      authority = splitted[2];
      path = splitted[3];
      query = splitted[4];
      fragment = splitted[5];
      if (!(scheme && scheme.length && path.length >= 0))
        return;
      if (authority && authority.length) {
        if (!(path.length === 0 || /^\//.test(path)))
          return;
      } else {
        if (/^\/\//.test(path))
          return;
      }
      if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
        return;
      out += scheme + ":";
      if (authority && authority.length) {
        out += "//" + authority;
      }
      out += path;
      if (query && query.length) {
        out += "?" + query;
      }
      if (fragment && fragment.length) {
        out += "#" + fragment;
      }
      return out;
    }
    function is_http_iri(value, allowHttps) {
      if (!is_iri(value)) {
        return;
      }
      var splitted = [];
      var scheme = "";
      var authority = "";
      var path = "";
      var port = "";
      var query = "";
      var fragment = "";
      var out = "";
      splitted = splitUri(value);
      scheme = splitted[1];
      authority = splitted[2];
      path = splitted[3];
      query = splitted[4];
      fragment = splitted[5];
      if (!scheme)
        return;
      if (allowHttps) {
        if (scheme.toLowerCase() != "https")
          return;
      } else {
        if (scheme.toLowerCase() != "http")
          return;
      }
      if (!authority) {
        return;
      }
      if (/:(\d+)$/.test(authority)) {
        port = authority.match(/:(\d+)$/)[0];
        authority = authority.replace(/:\d+$/, "");
      }
      out += scheme + ":";
      out += "//" + authority;
      if (port) {
        out += port;
      }
      out += path;
      if (query && query.length) {
        out += "?" + query;
      }
      if (fragment && fragment.length) {
        out += "#" + fragment;
      }
      return out;
    }
    function is_https_iri(value) {
      return is_http_iri(value, true);
    }
    function is_web_iri(value) {
      return is_http_iri(value) || is_https_iri(value);
    }
  })(module2);
})(validUrl);
function isPromiseLike$1(object) {
  return object != null && typeof object.then === "function";
}
const defaultOnRejectedFn = (reason) => {
  throw reason;
};
class ValueOrPromise {
  constructor(executor) {
    let value;
    try {
      value = executor();
    } catch (reason) {
      this.state = { status: "rejected", value: reason };
      return;
    }
    if (isPromiseLike$1(value)) {
      this.state = { status: "pending", value };
      return;
    }
    this.state = { status: "fulfilled", value };
  }
  then(onFulfilled, onRejected) {
    const state = this.state;
    if (state.status === "pending") {
      return new ValueOrPromise(() => state.value.then(onFulfilled, onRejected));
    }
    const onRejectedFn = typeof onRejected === "function" ? onRejected : defaultOnRejectedFn;
    if (state.status === "rejected") {
      return new ValueOrPromise(() => onRejectedFn(state.value));
    }
    try {
      const onFulfilledFn = typeof onFulfilled === "function" ? onFulfilled : void 0;
      return onFulfilledFn === void 0 ? new ValueOrPromise(() => state.value) : new ValueOrPromise(() => onFulfilledFn(state.value));
    } catch (e) {
      return new ValueOrPromise(() => onRejectedFn(e));
    }
  }
  catch(onRejected) {
    return this.then(void 0, onRejected);
  }
  resolve() {
    const state = this.state;
    if (state.status === "pending") {
      return Promise.resolve(state.value);
    }
    if (state.status === "rejected") {
      throw state.value;
    }
    return state.value;
  }
  static all(valueOrPromises) {
    let containsPromise = false;
    const values = [];
    for (const valueOrPromise of valueOrPromises) {
      const state = valueOrPromise.state;
      if (state.status === "rejected") {
        return new ValueOrPromise(() => {
          throw state.value;
        });
      }
      if (state.status === "pending") {
        containsPromise = true;
      }
      values.push(state.value);
    }
    if (containsPromise) {
      return new ValueOrPromise(() => Promise.all(values));
    }
    return new ValueOrPromise(() => values);
  }
}
var DataLoader = /* @__PURE__ */ function() {
  function DataLoader2(batchLoadFn, options) {
    if (typeof batchLoadFn !== "function") {
      throw new TypeError("DataLoader must be constructed with a function which accepts " + ("Array<key> and returns Promise<Array<value>>, but got: " + batchLoadFn + "."));
    }
    this._batchLoadFn = batchLoadFn;
    this._maxBatchSize = getValidMaxBatchSize(options);
    this._batchScheduleFn = getValidBatchScheduleFn(options);
    this._cacheKeyFn = getValidCacheKeyFn(options);
    this._cacheMap = getValidCacheMap(options);
    this._batch = null;
  }
  var _proto = DataLoader2.prototype;
  _proto.load = function load(key) {
    if (key === null || key === void 0) {
      throw new TypeError("The loader.load() function must be called with a value," + ("but got: " + String(key) + "."));
    }
    var batch = getCurrentBatch(this);
    var cacheMap = this._cacheMap;
    var cacheKey = this._cacheKeyFn(key);
    if (cacheMap) {
      var cachedPromise = cacheMap.get(cacheKey);
      if (cachedPromise) {
        var cacheHits = batch.cacheHits || (batch.cacheHits = []);
        return new Promise(function(resolve) {
          cacheHits.push(function() {
            return resolve(cachedPromise);
          });
        });
      }
    }
    batch.keys.push(key);
    var promise = new Promise(function(resolve, reject) {
      batch.callbacks.push({
        resolve,
        reject
      });
    });
    if (cacheMap) {
      cacheMap.set(cacheKey, promise);
    }
    return promise;
  };
  _proto.loadMany = function loadMany(keys) {
    if (!isArrayLike(keys)) {
      throw new TypeError("The loader.loadMany() function must be called with Array<key> " + ("but got: " + keys + "."));
    }
    var loadPromises = [];
    for (var i = 0; i < keys.length; i++) {
      loadPromises.push(this.load(keys[i])["catch"](function(error2) {
        return error2;
      }));
    }
    return Promise.all(loadPromises);
  };
  _proto.clear = function clear(key) {
    var cacheMap = this._cacheMap;
    if (cacheMap) {
      var cacheKey = this._cacheKeyFn(key);
      cacheMap["delete"](cacheKey);
    }
    return this;
  };
  _proto.clearAll = function clearAll() {
    var cacheMap = this._cacheMap;
    if (cacheMap) {
      cacheMap.clear();
    }
    return this;
  };
  _proto.prime = function prime2(key, value) {
    var cacheMap = this._cacheMap;
    if (cacheMap) {
      var cacheKey = this._cacheKeyFn(key);
      if (cacheMap.get(cacheKey) === void 0) {
        var promise;
        if (value instanceof Error) {
          promise = Promise.reject(value);
          promise["catch"](function() {
          });
        } else {
          promise = Promise.resolve(value);
        }
        cacheMap.set(cacheKey, promise);
      }
    }
    return this;
  };
  return DataLoader2;
}();
var enqueuePostPromiseJob = typeof process === "object" && typeof process.nextTick === "function" ? function(fn) {
  if (!resolvedPromise) {
    resolvedPromise = Promise.resolve();
  }
  resolvedPromise.then(function() {
    return process.nextTick(fn);
  });
} : setImmediate || setTimeout;
var resolvedPromise;
function getCurrentBatch(loader) {
  var existingBatch = loader._batch;
  if (existingBatch !== null && !existingBatch.hasDispatched && existingBatch.keys.length < loader._maxBatchSize && (!existingBatch.cacheHits || existingBatch.cacheHits.length < loader._maxBatchSize)) {
    return existingBatch;
  }
  var newBatch = {
    hasDispatched: false,
    keys: [],
    callbacks: []
  };
  loader._batch = newBatch;
  loader._batchScheduleFn(function() {
    return dispatchBatch(loader, newBatch);
  });
  return newBatch;
}
function dispatchBatch(loader, batch) {
  batch.hasDispatched = true;
  if (batch.keys.length === 0) {
    resolveCacheHits(batch);
    return;
  }
  var batchPromise = loader._batchLoadFn(batch.keys);
  if (!batchPromise || typeof batchPromise.then !== "function") {
    return failedDispatch(loader, batch, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise: " + String(batchPromise) + ".")));
  }
  batchPromise.then(function(values) {
    if (!isArrayLike(values)) {
      throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did " + ("not return a Promise of an Array: " + String(values) + "."));
    }
    if (values.length !== batch.keys.length) {
      throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys." + ("\n\nKeys:\n" + String(batch.keys)) + ("\n\nValues:\n" + String(values)));
    }
    resolveCacheHits(batch);
    for (var i = 0; i < batch.callbacks.length; i++) {
      var value = values[i];
      if (value instanceof Error) {
        batch.callbacks[i].reject(value);
      } else {
        batch.callbacks[i].resolve(value);
      }
    }
  })["catch"](function(error2) {
    return failedDispatch(loader, batch, error2);
  });
}
function failedDispatch(loader, batch, error2) {
  resolveCacheHits(batch);
  for (var i = 0; i < batch.keys.length; i++) {
    loader.clear(batch.keys[i]);
    batch.callbacks[i].reject(error2);
  }
}
function resolveCacheHits(batch) {
  if (batch.cacheHits) {
    for (var i = 0; i < batch.cacheHits.length; i++) {
      batch.cacheHits[i]();
    }
  }
}
function getValidMaxBatchSize(options) {
  var shouldBatch = !options || options.batch !== false;
  if (!shouldBatch) {
    return 1;
  }
  var maxBatchSize = options && options.maxBatchSize;
  if (maxBatchSize === void 0) {
    return Infinity;
  }
  if (typeof maxBatchSize !== "number" || maxBatchSize < 1) {
    throw new TypeError("maxBatchSize must be a positive number: " + maxBatchSize);
  }
  return maxBatchSize;
}
function getValidBatchScheduleFn(options) {
  var batchScheduleFn = options && options.batchScheduleFn;
  if (batchScheduleFn === void 0) {
    return enqueuePostPromiseJob;
  }
  if (typeof batchScheduleFn !== "function") {
    throw new TypeError("batchScheduleFn must be a function: " + batchScheduleFn);
  }
  return batchScheduleFn;
}
function getValidCacheKeyFn(options) {
  var cacheKeyFn = options && options.cacheKeyFn;
  if (cacheKeyFn === void 0) {
    return function(key) {
      return key;
    };
  }
  if (typeof cacheKeyFn !== "function") {
    throw new TypeError("cacheKeyFn must be a function: " + cacheKeyFn);
  }
  return cacheKeyFn;
}
function getValidCacheMap(options) {
  var shouldCache = !options || options.cache !== false;
  if (!shouldCache) {
    return null;
  }
  var cacheMap = options && options.cacheMap;
  if (cacheMap === void 0) {
    return /* @__PURE__ */ new Map();
  }
  if (cacheMap !== null) {
    var cacheFunctions = ["get", "set", "delete", "clear"];
    var missingFunctions = cacheFunctions.filter(function(fnName) {
      return cacheMap && typeof cacheMap[fnName] !== "function";
    });
    if (missingFunctions.length !== 0) {
      throw new TypeError("Custom cacheMap missing methods: " + missingFunctions.join(", "));
    }
  }
  return cacheMap;
}
function isArrayLike(x2) {
  return typeof x2 === "object" && x2 !== null && typeof x2.length === "number" && (x2.length === 0 || x2.length > 0 && Object.prototype.hasOwnProperty.call(x2, x2.length - 1));
}
var dataloader = DataLoader;
function createPrefix(index) {
  return `_${index}_`;
}
function parseKey(prefixedKey) {
  const match2 = /^_([\d]+)_(.*)$/.exec(prefixedKey);
  if (match2 && match2.length === 3 && !isNaN(Number(match2[1])) && match2[2]) {
    return { index: Number(match2[1]), originalKey: match2[2] };
  }
  throw new Error(`Key ${prefixedKey} is not correctly prefixed`);
}
function mergeRequests(requests, extensionsReducer) {
  var _a2;
  const mergedVariables = /* @__PURE__ */ Object.create(null);
  const mergedVariableDefinitions = [];
  const mergedSelections = [];
  const mergedFragmentDefinitions = [];
  let mergedExtensions = /* @__PURE__ */ Object.create(null);
  for (const index in requests) {
    const request = requests[index];
    const prefixedRequests = prefixRequest(createPrefix(index), request);
    for (const def of prefixedRequests.document.definitions) {
      if (isOperationDefinition(def)) {
        mergedSelections.push(...def.selectionSet.selections);
        if (def.variableDefinitions) {
          mergedVariableDefinitions.push(...def.variableDefinitions);
        }
      }
      if (isFragmentDefinition(def)) {
        mergedFragmentDefinitions.push(def);
      }
    }
    Object.assign(mergedVariables, prefixedRequests.variables);
    mergedExtensions = extensionsReducer(mergedExtensions, request);
  }
  const firstRequest = requests[0];
  const operationType = (_a2 = firstRequest.operationType) !== null && _a2 !== void 0 ? _a2 : getOperationASTFromRequest(firstRequest).operation;
  const mergedOperationDefinition = {
    kind: Kind.OPERATION_DEFINITION,
    operation: operationType,
    variableDefinitions: mergedVariableDefinitions,
    selectionSet: {
      kind: Kind.SELECTION_SET,
      selections: mergedSelections
    }
  };
  return {
    document: {
      kind: Kind.DOCUMENT,
      definitions: [mergedOperationDefinition, ...mergedFragmentDefinitions]
    },
    variables: mergedVariables,
    extensions: mergedExtensions,
    context: requests[0].context,
    info: requests[0].info,
    operationType
  };
}
function prefixRequest(prefix, request) {
  var _a2;
  const executionVariables = (_a2 = request.variables) !== null && _a2 !== void 0 ? _a2 : {};
  function prefixNode(node) {
    return prefixNodeName(node, prefix);
  }
  let prefixedDocument = aliasTopLevelFields(prefix, request.document);
  const executionVariableNames = Object.keys(executionVariables);
  const hasFragmentDefinitions = request.document.definitions.some((def) => isFragmentDefinition(def));
  const fragmentSpreadImpl = {};
  if (executionVariableNames.length > 0 || hasFragmentDefinitions) {
    prefixedDocument = visit(prefixedDocument, {
      [Kind.VARIABLE]: prefixNode,
      [Kind.FRAGMENT_DEFINITION]: prefixNode,
      [Kind.FRAGMENT_SPREAD]: (node) => {
        node = prefixNodeName(node, prefix);
        fragmentSpreadImpl[node.name.value] = true;
        return node;
      }
    });
  }
  const prefixedVariables = {};
  for (const variableName of executionVariableNames) {
    prefixedVariables[prefix + variableName] = executionVariables[variableName];
  }
  if (hasFragmentDefinitions) {
    prefixedDocument = __spreadProps(__spreadValues({}, prefixedDocument), {
      definitions: prefixedDocument.definitions.filter((def) => {
        return !isFragmentDefinition(def) || fragmentSpreadImpl[def.name.value];
      })
    });
  }
  return {
    document: prefixedDocument,
    variables: prefixedVariables
  };
}
function aliasTopLevelFields(prefix, document2) {
  const transformer = {
    [Kind.OPERATION_DEFINITION]: (def) => {
      const { selections } = def.selectionSet;
      return __spreadProps(__spreadValues({}, def), {
        selectionSet: __spreadProps(__spreadValues({}, def.selectionSet), {
          selections: aliasFieldsInSelection(prefix, selections, document2)
        })
      });
    }
  };
  return visit(document2, transformer, {
    [Kind.DOCUMENT]: [`definitions`]
  });
}
function aliasFieldsInSelection(prefix, selections, document2) {
  return selections.map((selection) => {
    switch (selection.kind) {
      case Kind.INLINE_FRAGMENT:
        return aliasFieldsInInlineFragment(prefix, selection, document2);
      case Kind.FRAGMENT_SPREAD: {
        const inlineFragment = inlineFragmentSpread(selection, document2);
        return aliasFieldsInInlineFragment(prefix, inlineFragment, document2);
      }
      case Kind.FIELD:
      default:
        return aliasField(selection, prefix);
    }
  });
}
function aliasFieldsInInlineFragment(prefix, fragment, document2) {
  const { selections } = fragment.selectionSet;
  return __spreadProps(__spreadValues({}, fragment), {
    selectionSet: __spreadProps(__spreadValues({}, fragment.selectionSet), {
      selections: aliasFieldsInSelection(prefix, selections, document2)
    })
  });
}
function inlineFragmentSpread(spread, document2) {
  const fragment = document2.definitions.find((def) => isFragmentDefinition(def) && def.name.value === spread.name.value);
  if (!fragment) {
    throw new Error(`Fragment ${spread.name.value} does not exist`);
  }
  const { typeCondition, selectionSet } = fragment;
  return {
    kind: Kind.INLINE_FRAGMENT,
    typeCondition,
    selectionSet,
    directives: spread.directives
  };
}
function prefixNodeName(namedNode, prefix) {
  return __spreadProps(__spreadValues({}, namedNode), {
    name: __spreadProps(__spreadValues({}, namedNode.name), {
      value: prefix + namedNode.name.value
    })
  });
}
function aliasField(field, aliasPrefix) {
  const aliasNode = field.alias ? field.alias : field.name;
  return __spreadProps(__spreadValues({}, field), {
    alias: __spreadProps(__spreadValues({}, aliasNode), {
      value: aliasPrefix + aliasNode.value
    })
  });
}
function isOperationDefinition(def) {
  return def.kind === Kind.OPERATION_DEFINITION;
}
function isFragmentDefinition(def) {
  return def.kind === Kind.FRAGMENT_DEFINITION;
}
function splitResult({ data, errors: errors2 }, numResults) {
  const splitResults = [];
  for (let i = 0; i < numResults; i++) {
    splitResults.push({});
  }
  if (data) {
    for (const prefixedKey in data) {
      const { index, originalKey } = parseKey(prefixedKey);
      const result2 = splitResults[index];
      if (result2 == null) {
        continue;
      }
      if (result2.data == null) {
        result2.data = { [originalKey]: data[prefixedKey] };
      } else {
        result2.data[originalKey] = data[prefixedKey];
      }
    }
  }
  if (errors2) {
    for (const error2 of errors2) {
      if (error2.path) {
        const parsedKey = parseKey(error2.path[0]);
        const { index, originalKey } = parsedKey;
        const newError = relocatedError(error2, [originalKey, ...error2.path.slice(1)]);
        const resultErrors = splitResults[index].errors = splitResults[index].errors || [];
        resultErrors.push(newError);
      } else {
        splitResults.forEach((result2) => {
          const resultErrors = result2.errors = result2.errors || [];
          resultErrors.push(new GraphQLError(error2.message));
        });
      }
    }
  }
  return splitResults;
}
function createBatchingExecutor(executor, dataLoaderOptions, extensionsReducer = defaultExtensionsReducer) {
  const loadFn = createLoadFn(executor, extensionsReducer);
  const loader = new dataloader(loadFn, dataLoaderOptions);
  return function batchingExecutor(request) {
    const operationAst = getOperationASTFromRequest(request);
    return operationAst.operation === "subscription" ? executor(request) : loader.load(request);
  };
}
function createLoadFn(executor, extensionsReducer) {
  return async function batchExecuteLoadFn(requests) {
    const execBatches = [];
    let index = 0;
    const request = requests[index];
    let currentBatch = [request];
    execBatches.push(currentBatch);
    const operationAst = getOperationASTFromRequest(request);
    const operationType = operationAst.operation;
    if (operationType == null) {
      throw new Error("could not identify operation type of document");
    }
    while (++index < requests.length) {
      const currentRequest = requests[index];
      const currentOperationAST = getOperationASTFromRequest(currentRequest);
      const currentOperationType = currentOperationAST.operation;
      if (operationType === currentOperationType) {
        currentBatch.push(currentRequest);
      } else {
        currentBatch = [currentRequest];
        execBatches.push(currentBatch);
      }
    }
    const results = await Promise.all(execBatches.map(async (execBatch) => {
      const mergedRequests = mergeRequests(execBatch, extensionsReducer);
      const resultBatches = await executor(mergedRequests);
      return splitResult(resultBatches, execBatch.length);
    }));
    return results.flat();
  };
}
function defaultExtensionsReducer(mergedExtensions, request) {
  const newExtensions = request.extensions;
  if (newExtensions != null) {
    Object.assign(mergedExtensions, newExtensions);
  }
  return mergedExtensions;
}
const getBatchingExecutor = memoize2of4(function getBatchingExecutor2(_context, executor, dataLoaderOptions, extensionsReducer) {
  return createBatchingExecutor(executor, dataLoaderOptions, extensionsReducer);
});
function applySchemaTransforms(originalWrappingSchema, subschemaConfig, transformedSchema) {
  const schemaTransforms = subschemaConfig.transforms;
  if (schemaTransforms == null) {
    return originalWrappingSchema;
  }
  return schemaTransforms.reduce((schema, transform) => transform.transformSchema != null ? transform.transformSchema(schema, subschemaConfig, transformedSchema) : schema, originalWrappingSchema);
}
class Subschema {
  constructor(config2) {
    var _a2;
    this.schema = config2.schema;
    this.executor = config2.executor;
    this.batch = config2.batch;
    this.batchingOptions = config2.batchingOptions;
    this.createProxyingResolver = config2.createProxyingResolver;
    this.transforms = (_a2 = config2.transforms) !== null && _a2 !== void 0 ? _a2 : [];
    this.transformedSchema = applySchemaTransforms(this.schema, config2);
    this.merge = config2.merge;
  }
}
function getDocumentMetadata(document2) {
  const operations = [];
  const fragments = [];
  const fragmentNames = /* @__PURE__ */ new Set();
  for (let i = 0; i < document2.definitions.length; i++) {
    const def = document2.definitions[i];
    if (def.kind === Kind.FRAGMENT_DEFINITION) {
      fragments.push(def);
      fragmentNames.add(def.name.value);
    } else if (def.kind === Kind.OPERATION_DEFINITION) {
      operations.push(def);
    }
  }
  return {
    operations,
    fragments,
    fragmentNames
  };
}
function prepareGatewayDocument(originalDocument, transformedSchema, returnType, infoSchema) {
  const wrappedConcreteTypesDocument = wrapConcreteTypes(returnType, transformedSchema, originalDocument);
  if (infoSchema == null) {
    return wrappedConcreteTypesDocument;
  }
  const { possibleTypesMap, reversePossibleTypesMap: reversePossibleTypesMap2, interfaceExtensionsMap, fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField } = getSchemaMetaData(infoSchema, transformedSchema);
  const { operations, fragments, fragmentNames } = getDocumentMetadata(wrappedConcreteTypesDocument);
  const { expandedFragments, fragmentReplacements } = getExpandedFragments(fragments, fragmentNames, possibleTypesMap);
  const typeInfo = new TypeInfo(transformedSchema);
  const expandedDocument = {
    kind: Kind.DOCUMENT,
    definitions: [...operations, ...fragments, ...expandedFragments]
  };
  const visitorKeyMap = {
    Document: ["definitions"],
    OperationDefinition: ["selectionSet"],
    SelectionSet: ["selections"],
    Field: ["selectionSet"],
    InlineFragment: ["selectionSet"],
    FragmentDefinition: ["selectionSet"]
  };
  return visit(expandedDocument, visitWithTypeInfo(typeInfo, {
    [Kind.SELECTION_SET]: (node) => visitSelectionSet(node, fragmentReplacements, transformedSchema, typeInfo, possibleTypesMap, reversePossibleTypesMap2, interfaceExtensionsMap, fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField)
  }), visitorKeyMap);
}
function visitSelectionSet(node, fragmentReplacements, schema, typeInfo, possibleTypesMap, reversePossibleTypesMap2, interfaceExtensionsMap, fieldNodesByType, fieldNodesByField, dynamicSelectionSetsByField) {
  var _a2, _b;
  const newSelections = /* @__PURE__ */ new Set();
  const maybeType = typeInfo.getParentType();
  if (maybeType != null) {
    const parentType = getNamedType(maybeType);
    const parentTypeName = parentType.name;
    const fieldNodes = fieldNodesByType[parentTypeName];
    if (fieldNodes) {
      for (const fieldNode of fieldNodes) {
        newSelections.add(fieldNode);
      }
    }
    const interfaceExtensions = interfaceExtensionsMap[parentType.name];
    const interfaceExtensionFields = [];
    for (const selection of node.selections) {
      if (selection.kind === Kind.INLINE_FRAGMENT) {
        if (selection.typeCondition != null) {
          const possibleTypes = possibleTypesMap[selection.typeCondition.name.value];
          if (possibleTypes == null) {
            newSelections.add(selection);
            continue;
          }
          for (const possibleTypeName of possibleTypes) {
            const maybePossibleType = schema.getType(possibleTypeName);
            if (maybePossibleType != null && implementsAbstractType(schema, parentType, maybePossibleType)) {
              newSelections.add(generateInlineFragment(possibleTypeName, selection.selectionSet));
            }
          }
        }
      } else if (selection.kind === Kind.FRAGMENT_SPREAD) {
        const fragmentName = selection.name.value;
        if (!fragmentReplacements[fragmentName]) {
          newSelections.add(selection);
          continue;
        }
        for (const replacement of fragmentReplacements[fragmentName]) {
          const typeName = replacement.typeName;
          const maybeReplacementType = schema.getType(typeName);
          if (maybeReplacementType != null && implementsAbstractType(schema, parentType, maybeType)) {
            newSelections.add({
              kind: Kind.FRAGMENT_SPREAD,
              name: {
                kind: Kind.NAME,
                value: replacement.fragmentName
              }
            });
          }
        }
      } else {
        const fieldName = selection.name.value;
        const fieldNodes2 = (_a2 = fieldNodesByField[parentTypeName]) === null || _a2 === void 0 ? void 0 : _a2[fieldName];
        if (fieldNodes2 != null) {
          for (const fieldNode of fieldNodes2) {
            newSelections.add(fieldNode);
          }
        }
        const dynamicSelectionSets = (_b = dynamicSelectionSetsByField[parentTypeName]) === null || _b === void 0 ? void 0 : _b[fieldName];
        if (dynamicSelectionSets != null) {
          for (const selectionSetFn of dynamicSelectionSets) {
            const selectionSet = selectionSetFn(selection);
            if (selectionSet != null) {
              for (const selection2 of selectionSet.selections) {
                newSelections.add(selection2);
              }
            }
          }
        }
        if (interfaceExtensions === null || interfaceExtensions === void 0 ? void 0 : interfaceExtensions[fieldName]) {
          interfaceExtensionFields.push(selection);
        } else {
          newSelections.add(selection);
        }
      }
    }
    if (reversePossibleTypesMap2[parentType.name]) {
      newSelections.add({
        kind: Kind.FIELD,
        name: {
          kind: Kind.NAME,
          value: "__typename"
        }
      });
    }
    if (interfaceExtensionFields.length) {
      const possibleTypes = possibleTypesMap[parentType.name];
      if (possibleTypes != null) {
        for (const possibleType of possibleTypes) {
          newSelections.add(generateInlineFragment(possibleType, {
            kind: Kind.SELECTION_SET,
            selections: interfaceExtensionFields
          }));
        }
      }
    }
    return __spreadProps(__spreadValues({}, node), {
      selections: Array.from(newSelections)
    });
  }
  return node;
}
function generateInlineFragment(typeName, selectionSet) {
  return {
    kind: Kind.INLINE_FRAGMENT,
    typeCondition: {
      kind: Kind.NAMED_TYPE,
      name: {
        kind: Kind.NAME,
        value: typeName
      }
    },
    selectionSet
  };
}
const getSchemaMetaData = memoize2((sourceSchema, targetSchema) => {
  var _a2, _b, _c, _d;
  const typeMap = sourceSchema.getTypeMap();
  const targetTypeMap = targetSchema.getTypeMap();
  const possibleTypesMap = /* @__PURE__ */ Object.create(null);
  const interfaceExtensionsMap = /* @__PURE__ */ Object.create(null);
  for (const typeName in typeMap) {
    const type2 = typeMap[typeName];
    if (isAbstractType(type2)) {
      const targetType = targetTypeMap[typeName];
      if (isInterfaceType(type2) && isInterfaceType(targetType)) {
        const targetTypeFields = targetType.getFields();
        const sourceTypeFields = type2.getFields();
        const extensionFields = /* @__PURE__ */ Object.create(null);
        let isExtensionFieldsEmpty = true;
        for (const fieldName in sourceTypeFields) {
          if (!targetTypeFields[fieldName]) {
            extensionFields[fieldName] = true;
            isExtensionFieldsEmpty = false;
          }
        }
        if (!isExtensionFieldsEmpty) {
          interfaceExtensionsMap[typeName] = extensionFields;
        }
      }
      if (interfaceExtensionsMap[typeName] || !isAbstractType(targetType)) {
        const implementations = sourceSchema.getPossibleTypes(type2);
        possibleTypesMap[typeName] = [];
        for (const impl of implementations) {
          if (targetTypeMap[impl.name]) {
            possibleTypesMap[typeName].push(impl.name);
          }
        }
      }
    }
  }
  const stitchingInfo = (_a2 = sourceSchema.extensions) === null || _a2 === void 0 ? void 0 : _a2["stitchingInfo"];
  return {
    possibleTypesMap,
    reversePossibleTypesMap: reversePossibleTypesMap(possibleTypesMap),
    interfaceExtensionsMap,
    fieldNodesByType: (_b = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.fieldNodesByType) !== null && _b !== void 0 ? _b : {},
    fieldNodesByField: (_c = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.fieldNodesByField) !== null && _c !== void 0 ? _c : {},
    dynamicSelectionSetsByField: (_d = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.dynamicSelectionSetsByField) !== null && _d !== void 0 ? _d : {}
  };
});
function reversePossibleTypesMap(possibleTypesMap) {
  const result2 = /* @__PURE__ */ Object.create(null);
  for (const typeName in possibleTypesMap) {
    const toTypeNames = possibleTypesMap[typeName];
    for (const toTypeName of toTypeNames) {
      if (!result2[toTypeName]) {
        result2[toTypeName] = [];
      }
      result2[toTypeName].push(typeName);
    }
  }
  return result2;
}
function getExpandedFragments(fragments, fragmentNames, possibleTypesMap) {
  let fragmentCounter = 0;
  function generateFragmentName(typeName) {
    let fragmentName;
    do {
      fragmentName = `_${typeName}_Fragment${fragmentCounter.toString()}`;
      fragmentCounter++;
    } while (fragmentNames.has(fragmentName));
    return fragmentName;
  }
  const expandedFragments = [];
  const fragmentReplacements = /* @__PURE__ */ Object.create(null);
  for (const fragment of fragments) {
    const possibleTypes = possibleTypesMap[fragment.typeCondition.name.value];
    if (possibleTypes != null) {
      const fragmentName = fragment.name.value;
      fragmentReplacements[fragmentName] = [];
      for (const possibleTypeName of possibleTypes) {
        const name2 = generateFragmentName(possibleTypeName);
        fragmentNames.add(name2);
        expandedFragments.push({
          kind: Kind.FRAGMENT_DEFINITION,
          name: {
            kind: Kind.NAME,
            value: name2
          },
          typeCondition: {
            kind: Kind.NAMED_TYPE,
            name: {
              kind: Kind.NAME,
              value: possibleTypeName
            }
          },
          selectionSet: fragment.selectionSet
        });
        fragmentReplacements[fragmentName].push({
          fragmentName: name2,
          typeName: possibleTypeName
        });
      }
    }
  }
  return {
    expandedFragments,
    fragmentReplacements
  };
}
function wrapConcreteTypes(returnType, targetSchema, document2) {
  const namedType = getNamedType(returnType);
  if (!isObjectType(namedType)) {
    return document2;
  }
  const rootTypeNames = getRootTypeNames(targetSchema);
  const typeInfo = new TypeInfo(targetSchema);
  const visitorKeys = {
    Document: ["definitions"],
    OperationDefinition: ["selectionSet"],
    SelectionSet: ["selections"],
    InlineFragment: ["selectionSet"],
    FragmentDefinition: ["selectionSet"]
  };
  return visit(document2, visitWithTypeInfo(typeInfo, {
    [Kind.FRAGMENT_DEFINITION]: (node) => {
      const typeName = node.typeCondition.name.value;
      if (!rootTypeNames.has(typeName)) {
        return false;
      }
    },
    [Kind.FIELD]: (node) => {
      const type2 = typeInfo.getType();
      if (type2 != null && isAbstractType(getNamedType(type2))) {
        return __spreadProps(__spreadValues({}, node), {
          selectionSet: {
            kind: Kind.SELECTION_SET,
            selections: [
              {
                kind: Kind.INLINE_FRAGMENT,
                typeCondition: {
                  kind: Kind.NAMED_TYPE,
                  name: {
                    kind: Kind.NAME,
                    value: namedType.name
                  }
                },
                selectionSet: node.selectionSet
              }
            ]
          }
        });
      }
    }
  }), visitorKeys);
}
function finalizeGatewayDocument(targetSchema, fragments, operations) {
  var _a2;
  let usedVariables = [];
  let usedFragments = [];
  const newOperations = [];
  let newFragments = [];
  const validFragments = [];
  const validFragmentsWithType = /* @__PURE__ */ Object.create(null);
  for (const fragment of fragments) {
    const typeName = fragment.typeCondition.name.value;
    const type2 = targetSchema.getType(typeName);
    if (type2 != null) {
      validFragments.push(fragment);
      validFragmentsWithType[fragment.name.value] = type2;
    }
  }
  let fragmentSet = /* @__PURE__ */ Object.create(null);
  for (const operation of operations) {
    const type2 = getDefinedRootType(targetSchema, operation.operation);
    const { selectionSet, usedFragments: operationUsedFragments, usedVariables: operationUsedVariables } = finalizeSelectionSet(targetSchema, type2, validFragmentsWithType, operation.selectionSet);
    usedFragments = union(usedFragments, operationUsedFragments);
    const { usedVariables: collectedUsedVariables, newFragments: collectedNewFragments, fragmentSet: collectedFragmentSet } = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments);
    const operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);
    usedVariables = union(usedVariables, operationOrFragmentVariables);
    newFragments = collectedNewFragments;
    fragmentSet = collectedFragmentSet;
    const variableDefinitions = ((_a2 = operation.variableDefinitions) !== null && _a2 !== void 0 ? _a2 : []).filter((variable) => operationOrFragmentVariables.indexOf(variable.variable.name.value) !== -1);
    newOperations.push({
      kind: Kind.OPERATION_DEFINITION,
      operation: operation.operation,
      name: operation.name,
      directives: operation.directives,
      variableDefinitions,
      selectionSet
    });
  }
  const newDocument = {
    kind: Kind.DOCUMENT,
    definitions: [...newOperations, ...newFragments]
  };
  return {
    usedVariables,
    newDocument
  };
}
function finalizeGatewayRequest(originalRequest, delegationContext) {
  let { document: document2, variables } = originalRequest;
  let { operations, fragments } = getDocumentMetadata(document2);
  const { targetSchema, args } = delegationContext;
  if (args) {
    const requestWithNewVariables = addVariablesToRootFields(targetSchema, operations, args);
    operations = requestWithNewVariables.newOperations;
    variables = Object.assign({}, variables !== null && variables !== void 0 ? variables : {}, requestWithNewVariables.newVariables);
  }
  const { usedVariables, newDocument } = finalizeGatewayDocument(targetSchema, fragments, operations);
  const newVariables = {};
  if (variables != null) {
    for (const variableName of usedVariables) {
      const variableValue = variables[variableName];
      if (variableValue !== void 0) {
        newVariables[variableName] = variableValue;
      }
    }
  }
  return __spreadProps(__spreadValues({}, originalRequest), {
    document: newDocument,
    variables: newVariables
  });
}
function addVariablesToRootFields(targetSchema, operations, args) {
  const newVariables = /* @__PURE__ */ Object.create(null);
  const newOperations = operations.map((operation) => {
    var _a2, _b;
    const variableDefinitionMap = ((_a2 = operation.variableDefinitions) !== null && _a2 !== void 0 ? _a2 : []).reduce((prev, def) => __spreadProps(__spreadValues({}, prev), {
      [def.variable.name.value]: def
    }), {});
    const type2 = getDefinedRootType(targetSchema, operation.operation);
    const newSelections = [];
    for (const selection of operation.selectionSet.selections) {
      if (selection.kind === Kind.FIELD) {
        const argumentNodes = (_b = selection.arguments) !== null && _b !== void 0 ? _b : [];
        const argumentNodeMap = argumentNodes.reduce((prev, argument) => __spreadProps(__spreadValues({}, prev), {
          [argument.name.value]: argument
        }), {});
        const targetField = type2.getFields()[selection.name.value];
        if (targetField != null) {
          updateArguments(targetField, argumentNodeMap, variableDefinitionMap, newVariables, args);
        }
        newSelections.push(__spreadProps(__spreadValues({}, selection), {
          arguments: Object.values(argumentNodeMap)
        }));
      } else {
        newSelections.push(selection);
      }
    }
    const newSelectionSet = {
      kind: Kind.SELECTION_SET,
      selections: newSelections
    };
    return __spreadProps(__spreadValues({}, operation), {
      variableDefinitions: Object.values(variableDefinitionMap),
      selectionSet: newSelectionSet
    });
  });
  return {
    newOperations,
    newVariables
  };
}
function updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {
  const generateVariableName = createVariableNameGenerator(variableDefinitionMap);
  for (const argument of targetField.args) {
    const argName = argument.name;
    const argType = argument.type;
    if (argName in newArgs) {
      updateArgument(argumentNodeMap, variableDefinitionMap, variableValues, argName, generateVariableName(argName), argType, serializeInputValue(argType, newArgs[argName]));
    }
  }
}
function collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {
  let remainingFragments = usedFragments.slice();
  let usedVariables = [];
  const newFragments = [];
  while (remainingFragments.length !== 0) {
    const nextFragmentName = remainingFragments.pop();
    const fragment = validFragments.find((fr) => fr.name.value === nextFragmentName);
    if (fragment != null) {
      const name2 = nextFragmentName;
      const typeName = fragment.typeCondition.name.value;
      const type2 = targetSchema.getType(typeName);
      if (type2 == null) {
        throw new Error(`Fragment reference type "${typeName}", but the type is not contained within the target schema.`);
      }
      const { selectionSet, usedFragments: fragmentUsedFragments, usedVariables: fragmentUsedVariables } = finalizeSelectionSet(targetSchema, type2, validFragmentsWithType, fragment.selectionSet);
      remainingFragments = union(remainingFragments, fragmentUsedFragments);
      usedVariables = union(usedVariables, fragmentUsedVariables);
      if (name2 && !(name2 in fragmentSet)) {
        fragmentSet[name2] = true;
        newFragments.push({
          kind: Kind.FRAGMENT_DEFINITION,
          name: {
            kind: Kind.NAME,
            value: name2
          },
          typeCondition: fragment.typeCondition,
          selectionSet
        });
      }
    }
  }
  return {
    usedVariables,
    newFragments,
    fragmentSet
  };
}
const filteredSelectionSetVisitorKeys = {
  SelectionSet: ["selections"],
  Field: ["selectionSet"],
  InlineFragment: ["selectionSet"],
  FragmentDefinition: ["selectionSet"]
};
const variablesVisitorKeys = {
  SelectionSet: ["selections"],
  Field: ["arguments", "directives", "selectionSet"],
  Argument: ["value"],
  InlineFragment: ["directives", "selectionSet"],
  FragmentSpread: ["directives"],
  FragmentDefinition: ["selectionSet"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["arguments"],
  ListValue: ["values"]
};
function finalizeSelectionSet(schema, type2, validFragments, selectionSet) {
  const usedFragments = [];
  const usedVariables = [];
  const typeInfo = versionInfo.major < 16 ? new TypeInfo(schema, void 0, type2) : new TypeInfo(schema, type2);
  const filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, {
    [Kind.FIELD]: {
      enter: (node) => {
        const parentType = typeInfo.getParentType();
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          const fields = parentType.getFields();
          const field = node.name.value === "__typename" ? TypeNameMetaFieldDef : fields[node.name.value];
          if (!field) {
            return null;
          }
          const args = field.args != null ? field.args : [];
          const argsMap = /* @__PURE__ */ Object.create(null);
          for (const arg of args) {
            argsMap[arg.name] = arg;
          }
          if (node.arguments != null) {
            const newArgs = [];
            for (const arg of node.arguments) {
              if (arg.name.value in argsMap) {
                newArgs.push(arg);
              }
            }
            if (newArgs.length !== node.arguments.length) {
              return __spreadProps(__spreadValues({}, node), {
                arguments: newArgs
              });
            }
          }
        }
      },
      leave: (node) => {
        const type3 = typeInfo.getType();
        if (type3 == null) {
          throw new Error(`No type was found for field node ${inspect(node)}.`);
        }
        const namedType = getNamedType(type3);
        if (!schema.getType(namedType.name) == null) {
          return null;
        }
        if (isObjectType(namedType) || isInterfaceType(namedType)) {
          const selections = node.selectionSet != null ? node.selectionSet.selections : null;
          if (selections == null || selections.length === 0) {
            return null;
          }
        }
      }
    },
    [Kind.FRAGMENT_SPREAD]: {
      enter: (node) => {
        if (!(node.name.value in validFragments)) {
          return null;
        }
        const parentType = typeInfo.getParentType();
        const innerType = validFragments[node.name.value];
        if (!implementsAbstractType(schema, parentType, innerType)) {
          return null;
        }
        usedFragments.push(node.name.value);
      }
    },
    [Kind.INLINE_FRAGMENT]: {
      enter: (node) => {
        if (node.typeCondition != null) {
          const parentType = typeInfo.getParentType();
          const innerType = schema.getType(node.typeCondition.name.value);
          if (!implementsAbstractType(schema, parentType, innerType)) {
            return null;
          }
        }
      }
    },
    [Kind.SELECTION_SET]: {
      leave: (node) => {
        const parentType = typeInfo.getParentType();
        if (parentType != null && isAbstractType(parentType)) {
          const selections = node.selections.concat([
            {
              kind: Kind.FIELD,
              name: {
                kind: Kind.NAME,
                value: "__typename"
              }
            }
          ]);
          return __spreadProps(__spreadValues({}, node), {
            selections
          });
        }
      }
    }
  }), filteredSelectionSetVisitorKeys);
  visit(filteredSelectionSet, {
    [Kind.VARIABLE]: (variableNode) => {
      usedVariables.push(variableNode.name.value);
    }
  }, variablesVisitorKeys);
  return {
    selectionSet: filteredSelectionSet,
    usedFragments,
    usedVariables
  };
}
function union(...arrays) {
  const cache = /* @__PURE__ */ Object.create(null);
  const result2 = [];
  for (const array of arrays) {
    for (const item of array) {
      if (!(item in cache)) {
        cache[item] = true;
        result2.push(item);
      }
    }
  }
  return result2;
}
const UNPATHED_ERRORS_SYMBOL = Symbol("subschemaErrors");
const OBJECT_SUBSCHEMA_SYMBOL = Symbol("initialSubschema");
const FIELD_SUBSCHEMA_MAP_SYMBOL = Symbol("subschemaMap");
function isExternalObject(data) {
  return data[UNPATHED_ERRORS_SYMBOL] !== void 0;
}
function annotateExternalObject(object, errors2, subschema, subschemaMap) {
  Object.defineProperties(object, {
    [OBJECT_SUBSCHEMA_SYMBOL]: { value: subschema },
    [FIELD_SUBSCHEMA_MAP_SYMBOL]: { value: subschemaMap },
    [UNPATHED_ERRORS_SYMBOL]: { value: errors2 }
  });
  return object;
}
function getSubschema(object, responseKey) {
  var _a2;
  return (_a2 = object[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey]) !== null && _a2 !== void 0 ? _a2 : object[OBJECT_SUBSCHEMA_SYMBOL];
}
function getUnpathedErrors(object) {
  return object[UNPATHED_ERRORS_SYMBOL];
}
const EMPTY_ARRAY = [];
const EMPTY_OBJECT = /* @__PURE__ */ Object.create(null);
async function mergeFields(mergedTypeInfo, object, sourceSubschema, context, info2) {
  var _a2;
  const delegationMaps = mergedTypeInfo.delegationPlanBuilder(info2.schema, sourceSubschema, info2.variableValues != null && Object.keys(info2.variableValues).length > 0 ? info2.variableValues : EMPTY_OBJECT, info2.fragments != null && Object.keys(info2.fragments).length > 0 ? info2.fragments : EMPTY_OBJECT, ((_a2 = info2.fieldNodes) === null || _a2 === void 0 ? void 0 : _a2.length) ? info2.fieldNodes : EMPTY_ARRAY);
  for (const delegationMap of delegationMaps) {
    await executeDelegationStage(mergedTypeInfo, delegationMap, object, context, info2);
  }
  return object;
}
async function executeDelegationStage(mergedTypeInfo, delegationMap, object, context, info2) {
  const combinedErrors = object[UNPATHED_ERRORS_SYMBOL];
  const path = pathToArray(info2.path);
  const combinedFieldSubschemaMap = object[FIELD_SUBSCHEMA_MAP_SYMBOL];
  const type2 = info2.schema.getType(object.__typename);
  await Promise.all([...delegationMap.entries()].map(async ([s, selectionSet]) => {
    var _a2;
    const resolver = mergedTypeInfo.resolvers.get(s);
    if (resolver) {
      let source;
      try {
        source = await resolver(object, context, info2, s, selectionSet);
      } catch (error2) {
        source = error2;
      }
      if (source instanceof Error || source == null) {
        const fieldNodeResponseKeyMap = collectFields(info2.schema, {}, {}, type2, selectionSet, /* @__PURE__ */ new Map(), /* @__PURE__ */ new Set());
        const nullResult = {};
        for (const [responseKey, fieldNodes] of fieldNodeResponseKeyMap) {
          const combinedPath = [...path, responseKey];
          if (source instanceof GraphQLError) {
            nullResult[responseKey] = relocatedError(source, combinedPath);
          } else if (source instanceof Error) {
            nullResult[responseKey] = locatedError(source, fieldNodes, combinedPath);
          } else {
            nullResult[responseKey] = null;
          }
        }
        source = nullResult;
      } else {
        if (source[UNPATHED_ERRORS_SYMBOL]) {
          combinedErrors.push(...source[UNPATHED_ERRORS_SYMBOL]);
        }
      }
      const objectSubschema = source[OBJECT_SUBSCHEMA_SYMBOL];
      const fieldSubschemaMap = source[FIELD_SUBSCHEMA_MAP_SYMBOL];
      for (const responseKey in source) {
        object[responseKey] = source[responseKey];
        combinedFieldSubschemaMap[responseKey] = (_a2 = fieldSubschemaMap === null || fieldSubschemaMap === void 0 ? void 0 : fieldSubschemaMap[responseKey]) !== null && _a2 !== void 0 ? _a2 : objectSubschema;
      }
    }
  }));
}
function resolveExternalValue(result2, unpathedErrors, subschema, context, info2, returnType = getReturnType(info2), skipTypeMerging) {
  const type2 = getNullableType(returnType);
  if (result2 instanceof Error) {
    return result2;
  }
  if (result2 == null) {
    return reportUnpathedErrorsViaNull(unpathedErrors);
  }
  if ("parseValue" in type2) {
    return type2.parseValue(result2);
  } else if (isCompositeType(type2)) {
    return resolveExternalObject(type2, result2, unpathedErrors, subschema, context, info2, skipTypeMerging);
  } else if (isListType(type2)) {
    return resolveExternalList(type2, result2, unpathedErrors, subschema, context, info2, skipTypeMerging);
  }
}
function resolveExternalObject(type2, object, unpathedErrors, subschema, context, info2, skipTypeMerging) {
  var _a2;
  if (!isExternalObject(object)) {
    annotateExternalObject(object, unpathedErrors, subschema, /* @__PURE__ */ Object.create(null));
  }
  if (skipTypeMerging || info2 == null) {
    return object;
  }
  const stitchingInfo = (_a2 = info2.schema.extensions) === null || _a2 === void 0 ? void 0 : _a2["stitchingInfo"];
  if (stitchingInfo == null) {
    return object;
  }
  let typeName;
  if (isAbstractType(type2)) {
    const resolvedType = info2.schema.getType(object.__typename);
    if (resolvedType == null) {
      throw new Error(`Unable to resolve type '${object.__typename}'. Did you forget to include a transform that renames types? Did you delegate to the original subschema rather that the subschema config object containing the transform?`);
    }
    typeName = resolvedType.name;
  } else {
    typeName = type2.name;
  }
  const mergedTypeInfo = stitchingInfo.mergedTypes[typeName];
  let targetSubschemas;
  if (mergedTypeInfo != null) {
    targetSubschemas = mergedTypeInfo.targetSubschemas.get(subschema);
  }
  if (!targetSubschemas || !targetSubschemas.length) {
    return object;
  }
  return mergeFields(mergedTypeInfo, object, subschema, context, info2);
}
function resolveExternalList(type2, list3, unpathedErrors, subschema, context, info2, skipTypeMerging) {
  return list3.map((listMember) => resolveExternalListMember(getNullableType(type2.ofType), listMember, unpathedErrors, subschema, context, info2, skipTypeMerging));
}
function resolveExternalListMember(type2, listMember, unpathedErrors, subschema, context, info2, skipTypeMerging) {
  if (listMember instanceof Error) {
    return listMember;
  }
  if (listMember == null) {
    return reportUnpathedErrorsViaNull(unpathedErrors);
  }
  if ("parseValue" in type2) {
    return type2.parseValue(listMember);
  } else if (isCompositeType(type2)) {
    return resolveExternalObject(type2, listMember, unpathedErrors, subschema, context, info2, skipTypeMerging);
  } else if (isListType(type2)) {
    return resolveExternalList(type2, listMember, unpathedErrors, subschema, context, info2, skipTypeMerging);
  }
}
const reportedErrors = /* @__PURE__ */ new WeakMap();
function reportUnpathedErrorsViaNull(unpathedErrors) {
  if (unpathedErrors.length) {
    const unreportedErrors = [];
    for (const error2 of unpathedErrors) {
      if (!reportedErrors.has(error2)) {
        unreportedErrors.push(error2);
        reportedErrors.set(error2, true);
      }
    }
    if (unreportedErrors.length) {
      if (unreportedErrors.length === 1) {
        return unreportedErrors[0];
      }
      const combinedError = new AggregateErrorImpl(unreportedErrors, unreportedErrors.map((error2) => error2.message).join(", \n"));
      return locatedError(combinedError, void 0, unreportedErrors[0].path);
    }
  }
  return null;
}
function getReturnType(info2) {
  if (info2 == null) {
    throw new Error(`Return type cannot be inferred without a source schema.`);
  }
  return info2.returnType;
}
function checkResultAndHandleErrors(result2, delegationContext) {
  const { context, info: info2, fieldName: responseKey = getResponseKey(info2), subschema, returnType = getReturnType$1(info2), skipTypeMerging, onLocatedError } = delegationContext;
  const { data, unpathedErrors } = mergeDataAndErrors(result2.data == null ? void 0 : result2.data[responseKey], result2.errors == null ? [] : result2.errors, info2 != null && info2.path ? pathToArray(info2.path) : void 0, onLocatedError);
  return resolveExternalValue(data, unpathedErrors, subschema, context, info2, returnType, skipTypeMerging);
}
function mergeDataAndErrors(data, errors2, path, onLocatedError, index = 1) {
  var _a2;
  if (data == null) {
    if (!errors2.length) {
      return { data: null, unpathedErrors: [] };
    }
    if (errors2.length === 1) {
      const error2 = onLocatedError ? onLocatedError(errors2[0]) : errors2[0];
      const newPath = path === void 0 ? error2.path : error2.path === void 0 ? path : path.concat(error2.path.slice(1));
      return { data: relocatedError(errors2[0], newPath), unpathedErrors: [] };
    }
    const combinedError = new AggregateErrorImpl(errors2, errors2.map((error2) => error2.message).join(", \n"));
    const newError = locatedError(combinedError, void 0, path);
    return { data: newError, unpathedErrors: [] };
  }
  if (!errors2.length) {
    return { data, unpathedErrors: [] };
  }
  const unpathedErrors = [];
  const errorMap = /* @__PURE__ */ new Map();
  for (const error2 of errors2) {
    const pathSegment = (_a2 = error2.path) === null || _a2 === void 0 ? void 0 : _a2[index];
    if (pathSegment != null) {
      let pathSegmentErrors = errorMap.get(pathSegment);
      if (pathSegmentErrors === void 0) {
        pathSegmentErrors = [error2];
        errorMap.set(pathSegment, pathSegmentErrors);
      } else {
        pathSegmentErrors.push(error2);
      }
    } else {
      unpathedErrors.push(error2);
    }
  }
  for (const [pathSegment, pathSegmentErrors] of errorMap) {
    if (data[pathSegment] !== void 0) {
      const { data: newData, unpathedErrors: newErrors } = mergeDataAndErrors(data[pathSegment], pathSegmentErrors, path, onLocatedError, index + 1);
      data[pathSegment] = newData;
      unpathedErrors.push(...newErrors);
    } else {
      unpathedErrors.push(...pathSegmentErrors);
    }
  }
  return { data, unpathedErrors };
}
function getResponseKey(info2) {
  if (info2 == null) {
    throw new Error(`Data cannot be extracted from result without an explicit key or source schema.`);
  }
  return getResponseKeyFromInfo(info2);
}
function getReturnType$1(info2) {
  if (info2 == null) {
    throw new Error(`Return type cannot be inferred without a source schema.`);
  }
  return info2.returnType;
}
class Transformer {
  constructor(context) {
    this.transformations = [];
    this.delegationContext = context;
    const transforms = context.transforms;
    const delegationTransforms = transforms.slice().reverse();
    for (const transform of delegationTransforms) {
      this.addTransform(transform, {});
    }
  }
  addTransform(transform, context = {}) {
    this.transformations.push({ transform, context });
  }
  transformRequest(originalRequest) {
    var _a2;
    let request = __spreadProps(__spreadValues({}, originalRequest), {
      document: prepareGatewayDocument(originalRequest.document, this.delegationContext.transformedSchema, this.delegationContext.returnType, (_a2 = this.delegationContext.info) === null || _a2 === void 0 ? void 0 : _a2.schema)
    });
    for (const transformation of this.transformations) {
      if (transformation.transform.transformRequest) {
        request = transformation.transform.transformRequest(request, this.delegationContext, transformation.context);
      }
    }
    return finalizeGatewayRequest(request, this.delegationContext);
  }
  transformResult(originalResult) {
    let result2 = originalResult;
    for (let i = this.transformations.length - 1; i >= 0; i--) {
      const transformation = this.transformations[i];
      if (transformation.transform.transformResult) {
        result2 = transformation.transform.transformResult(result2, this.delegationContext, transformation.context);
      }
    }
    return checkResultAndHandleErrors(result2, this.delegationContext);
  }
}
function getDelegatingOperation(parentType, schema) {
  if (parentType === schema.getMutationType()) {
    return "mutation";
  } else if (parentType === schema.getSubscriptionType()) {
    return "subscription";
  }
  return "query";
}
function createRequestFromInfo({ info: info2, rootValue, operationName, operation = getDelegatingOperation(info2.parentType, info2.schema), fieldName = info2.fieldName, selectionSet, fieldNodes = info2.fieldNodes, context }) {
  return createRequest({
    sourceSchema: info2.schema,
    sourceParentType: info2.parentType,
    sourceFieldName: info2.fieldName,
    fragments: info2.fragments,
    variableDefinitions: info2.operation.variableDefinitions,
    variableValues: info2.variableValues,
    targetRootValue: rootValue,
    targetOperationName: operationName,
    targetOperation: operation,
    targetFieldName: fieldName,
    selectionSet,
    fieldNodes,
    context,
    info: info2
  });
}
function createRequest({ sourceSchema, sourceParentType, sourceFieldName, fragments, variableDefinitions, variableValues, targetRootValue, targetOperationName, targetOperation, targetFieldName, selectionSet, fieldNodes, context, info: info2 }) {
  var _a2, _b;
  let newSelectionSet;
  const argumentNodeMap = /* @__PURE__ */ Object.create(null);
  if (selectionSet != null) {
    newSelectionSet = selectionSet;
  } else {
    const selections = [];
    for (const fieldNode of fieldNodes || []) {
      if (fieldNode.selectionSet) {
        for (const selection of fieldNode.selectionSet.selections) {
          selections.push(selection);
        }
      }
    }
    newSelectionSet = selections.length ? {
      kind: Kind.SELECTION_SET,
      selections
    } : void 0;
    const args = (_a2 = fieldNodes === null || fieldNodes === void 0 ? void 0 : fieldNodes[0]) === null || _a2 === void 0 ? void 0 : _a2.arguments;
    if (args) {
      for (const argNode of args) {
        argumentNodeMap[argNode.name.value] = argNode;
      }
    }
  }
  const newVariables = /* @__PURE__ */ Object.create(null);
  const variableDefinitionMap = /* @__PURE__ */ Object.create(null);
  if (sourceSchema != null && variableDefinitions != null) {
    for (const def of variableDefinitions) {
      const varName = def.variable.name.value;
      variableDefinitionMap[varName] = def;
      const varType = typeFromAST(sourceSchema, def.type);
      const serializedValue = serializeInputValue(varType, variableValues === null || variableValues === void 0 ? void 0 : variableValues[varName]);
      if (serializedValue !== void 0) {
        newVariables[varName] = serializedValue;
      }
    }
  }
  if (sourceParentType != null && sourceFieldName != null) {
    updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);
  }
  const rootFieldName = targetFieldName !== null && targetFieldName !== void 0 ? targetFieldName : (_b = fieldNodes === null || fieldNodes === void 0 ? void 0 : fieldNodes[0]) === null || _b === void 0 ? void 0 : _b.name.value;
  if (rootFieldName === void 0) {
    throw new Error(`Either "targetFieldName" or a non empty "fieldNodes" array must be provided.`);
  }
  const rootfieldNode = {
    kind: Kind.FIELD,
    arguments: Object.values(argumentNodeMap),
    name: {
      kind: Kind.NAME,
      value: rootFieldName
    },
    selectionSet: newSelectionSet
  };
  const operationName = targetOperationName ? {
    kind: Kind.NAME,
    value: targetOperationName
  } : void 0;
  const operationDefinition = {
    kind: Kind.OPERATION_DEFINITION,
    name: operationName,
    operation: targetOperation,
    variableDefinitions: Object.values(variableDefinitionMap),
    selectionSet: {
      kind: Kind.SELECTION_SET,
      selections: [rootfieldNode]
    }
  };
  const definitions = [operationDefinition];
  if (fragments != null) {
    for (const fragmentName in fragments) {
      const fragment = fragments[fragmentName];
      definitions.push(fragment);
    }
  }
  const document2 = {
    kind: Kind.DOCUMENT,
    definitions
  };
  return {
    document: document2,
    variables: newVariables,
    rootValue: targetRootValue,
    operationName: targetOperationName,
    context,
    info: info2,
    operationType: targetOperation
  };
}
function updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {
  const generateVariableName = createVariableNameGenerator(variableDefinitionMap);
  const sourceField = sourceParentType.getFields()[sourceFieldName];
  for (const argument of sourceField.args) {
    const argName = argument.name;
    const sourceArgType = argument.type;
    if (argumentNodeMap[argName] === void 0) {
      const defaultValue2 = argument.defaultValue;
      if (defaultValue2 !== void 0) {
        updateArgument(argumentNodeMap, variableDefinitionMap, variableValues, argName, generateVariableName(argName), sourceArgType, serializeInputValue(sourceArgType, defaultValue2));
      }
    }
  }
}
function defaultMergedResolver(parent, args, context, info2) {
  if (!parent) {
    return null;
  }
  const responseKey = getResponseKeyFromInfo(info2);
  if (!isExternalObject(parent)) {
    return defaultFieldResolver(parent, args, context, info2);
  }
  const data = parent[responseKey];
  const unpathedErrors = getUnpathedErrors(parent);
  const subschema = getSubschema(parent, responseKey);
  return resolveExternalValue(data, unpathedErrors, subschema, context, info2);
}
function isSubschemaConfig(value) {
  return Boolean(value === null || value === void 0 ? void 0 : value.schema);
}
function delegateToSchema(options) {
  const { info: info2, schema, rootValue, operationName, operation = getDelegatingOperation(info2.parentType, info2.schema), fieldName = info2.fieldName, selectionSet, fieldNodes, context } = options;
  const request = createRequestFromInfo({
    info: info2,
    operation,
    fieldName,
    selectionSet,
    fieldNodes,
    rootValue: rootValue !== null && rootValue !== void 0 ? rootValue : schema.rootValue,
    operationName,
    context
  });
  return delegateRequest(__spreadProps(__spreadValues({}, options), {
    request
  }));
}
function getDelegationReturnType(targetSchema, operation, fieldName) {
  const rootType = getDefinedRootType(targetSchema, operation);
  return rootType.getFields()[fieldName].type;
}
function delegateRequest(options) {
  const delegationContext = getDelegationContext(options);
  const transformer = new Transformer(delegationContext);
  const processedRequest = transformer.transformRequest(options.request);
  if (options.validateRequest) {
    validateRequest(delegationContext, processedRequest.document);
  }
  const executor = getExecutor(delegationContext);
  return new ValueOrPromise(() => executor(processedRequest)).then((originalResult) => {
    if (isAsyncIterable(originalResult)) {
      const iterator = originalResult[Symbol.asyncIterator]();
      return mapAsyncIterator(iterator, (result2) => transformer.transformResult(result2));
    }
    return transformer.transformResult(originalResult);
  }).resolve();
}
function getDelegationContext({ request, schema, fieldName, returnType, args, info: info2, transforms = [], transformedSchema, skipTypeMerging = false }) {
  var _a2, _b, _c, _d;
  const operationDefinition = getOperationASTFromRequest(request);
  let targetFieldName;
  if (fieldName == null) {
    targetFieldName = operationDefinition.selectionSet.selections[0].name.value;
  } else {
    targetFieldName = fieldName;
  }
  const stitchingInfo = (_a2 = info2 === null || info2 === void 0 ? void 0 : info2.schema.extensions) === null || _a2 === void 0 ? void 0 : _a2["stitchingInfo"];
  const subschemaOrSubschemaConfig = (_b = stitchingInfo === null || stitchingInfo === void 0 ? void 0 : stitchingInfo.subschemaMap.get(schema)) !== null && _b !== void 0 ? _b : schema;
  const operation = operationDefinition.operation;
  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {
    const targetSchema = subschemaOrSubschemaConfig.schema;
    return {
      subschema: schema,
      subschemaConfig: subschemaOrSubschemaConfig,
      targetSchema,
      operation,
      fieldName: targetFieldName,
      args,
      context: request.context,
      info: info2,
      returnType: (_c = returnType !== null && returnType !== void 0 ? returnType : info2 === null || info2 === void 0 ? void 0 : info2.returnType) !== null && _c !== void 0 ? _c : getDelegationReturnType(targetSchema, operation, targetFieldName),
      transforms: subschemaOrSubschemaConfig.transforms != null ? subschemaOrSubschemaConfig.transforms.concat(transforms) : transforms,
      transformedSchema: transformedSchema !== null && transformedSchema !== void 0 ? transformedSchema : subschemaOrSubschemaConfig instanceof Subschema ? subschemaOrSubschemaConfig.transformedSchema : targetSchema,
      skipTypeMerging
    };
  }
  return {
    subschema: schema,
    subschemaConfig: void 0,
    targetSchema: subschemaOrSubschemaConfig,
    operation,
    fieldName: targetFieldName,
    args,
    context: request.context,
    info: info2,
    returnType: (_d = returnType !== null && returnType !== void 0 ? returnType : info2 === null || info2 === void 0 ? void 0 : info2.returnType) !== null && _d !== void 0 ? _d : getDelegationReturnType(subschemaOrSubschemaConfig, operation, targetFieldName),
    transforms,
    transformedSchema: transformedSchema !== null && transformedSchema !== void 0 ? transformedSchema : subschemaOrSubschemaConfig,
    skipTypeMerging
  };
}
function validateRequest(delegationContext, document2) {
  const errors2 = validate(delegationContext.targetSchema, document2);
  if (errors2.length > 0) {
    if (errors2.length > 1) {
      const combinedError = new AggregateErrorImpl(errors2, errors2.map((error3) => error3.message).join(", \n"));
      throw combinedError;
    }
    const error2 = errors2[0];
    throw error2.originalError || error2;
  }
}
const GLOBAL_CONTEXT = {};
function getExecutor(delegationContext) {
  const { subschemaConfig, targetSchema, context } = delegationContext;
  let executor = (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.executor) || createDefaultExecutor(targetSchema);
  if (subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.batch) {
    const batchingOptions = subschemaConfig === null || subschemaConfig === void 0 ? void 0 : subschemaConfig.batchingOptions;
    executor = getBatchingExecutor(context !== null && context !== void 0 ? context : GLOBAL_CONTEXT, executor, batchingOptions === null || batchingOptions === void 0 ? void 0 : batchingOptions.dataLoaderOptions, batchingOptions === null || batchingOptions === void 0 ? void 0 : batchingOptions.extensionsReducer);
  }
  return executor;
}
const createDefaultExecutor = memoize1(function createDefaultExecutor2(schema) {
  return function defaultExecutor(request) {
    const operationAst = getOperationASTFromRequest(request);
    const executionArgs = {
      schema,
      document: request.document,
      contextValue: request.context,
      variableValues: request.variables,
      rootValue: request.rootValue,
      operationName: request.operationName
    };
    if (operationAst.operation === "subscription") {
      return subscribe(executionArgs);
    }
    return execute(executionArgs);
  };
});
function generateProxyingResolvers(subschemaConfig) {
  var _a2;
  const targetSchema = subschemaConfig.schema;
  const createProxyingResolver = (_a2 = subschemaConfig.createProxyingResolver) !== null && _a2 !== void 0 ? _a2 : defaultCreateProxyingResolver;
  const transformedSchema = applySchemaTransforms(targetSchema, subschemaConfig);
  const rootTypeMap = getRootTypeMap(targetSchema);
  const resolvers = {};
  for (const [operation, rootType] of rootTypeMap.entries()) {
    const typeName = rootType.name;
    const fields = rootType.getFields();
    resolvers[typeName] = {};
    for (const fieldName in fields) {
      const proxyingResolver = createProxyingResolver({
        subschemaConfig,
        transformedSchema,
        operation,
        fieldName
      });
      const finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);
      if (operation === "subscription") {
        resolvers[typeName][fieldName] = {
          subscribe: finalResolver,
          resolve: identical
        };
      } else {
        resolvers[typeName][fieldName] = {
          resolve: finalResolver
        };
      }
    }
  }
  return resolvers;
}
function identical(value) {
  return value;
}
function createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {
  return function possiblyNestedProxyingResolver(parent, args, context, info2) {
    if (parent != null) {
      const responseKey = getResponseKeyFromInfo(info2);
      if (isExternalObject(parent)) {
        const unpathedErrors = getUnpathedErrors(parent);
        const subschema = getSubschema(parent, responseKey);
        if (subschemaConfig === subschema && parent[responseKey] !== void 0) {
          return resolveExternalValue(parent[responseKey], unpathedErrors, subschema, context, info2);
        }
      }
    }
    return proxyingResolver(parent, args, context, info2);
  };
}
function defaultCreateProxyingResolver({ subschemaConfig, operation, transformedSchema }) {
  return function proxyingResolver(_parent, _args, context, info2) {
    return delegateToSchema({
      schema: subschemaConfig,
      operation,
      context,
      info: info2,
      transformedSchema
    });
  };
}
function wrapSchema(subschemaConfig) {
  const targetSchema = subschemaConfig.schema;
  const proxyingResolvers = generateProxyingResolvers(subschemaConfig);
  const schema = createWrappingSchema(targetSchema, proxyingResolvers);
  const transformedSchema = applySchemaTransforms(schema, subschemaConfig);
  return applySchemaTransforms(schema, subschemaConfig, transformedSchema);
}
function createWrappingSchema(schema, proxyingResolvers) {
  return mapSchema(schema, {
    [MapperKind.ROOT_OBJECT]: (type2) => {
      var _a2;
      const config2 = type2.toConfig();
      const fieldConfigMap = config2.fields;
      for (const fieldName in fieldConfigMap) {
        const field = fieldConfigMap[fieldName];
        if (field == null) {
          continue;
        }
        fieldConfigMap[fieldName] = __spreadValues(__spreadValues({}, field), (_a2 = proxyingResolvers[type2.name]) === null || _a2 === void 0 ? void 0 : _a2[fieldName]);
      }
      return new GraphQLObjectType(config2);
    },
    [MapperKind.OBJECT_TYPE]: (type2) => {
      const config2 = type2.toConfig();
      config2.isTypeOf = void 0;
      for (const fieldName in config2.fields) {
        const field = config2.fields[fieldName];
        if (field == null) {
          continue;
        }
        field.resolve = defaultMergedResolver;
        field.subscribe = void 0;
      }
      return new GraphQLObjectType(config2);
    },
    [MapperKind.INTERFACE_TYPE]: (type2) => {
      const config2 = type2.toConfig();
      delete config2.resolveType;
      return new GraphQLInterfaceType(config2);
    },
    [MapperKind.UNION_TYPE]: (type2) => {
      const config2 = type2.toConfig();
      delete config2.resolveType;
      return new GraphQLUnionType(config2);
    }
  });
}
function getSchemaFromIntrospection(introspectionResult, options) {
  var _a2, _b;
  if ((_a2 = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.data) === null || _a2 === void 0 ? void 0 : _a2.__schema) {
    return buildClientSchema(introspectionResult.data, options);
  } else if ((_b = introspectionResult === null || introspectionResult === void 0 ? void 0 : introspectionResult.errors) === null || _b === void 0 ? void 0 : _b.length) {
    if (introspectionResult.errors.length > 1) {
      const combinedError = new AggregateErrorImpl(introspectionResult.errors, "Could not obtain introspection result");
      throw combinedError;
    }
    const error2 = introspectionResult.errors[0];
    throw error2.originalError || error2;
  } else {
    throw new Error("Could not obtain introspection result, received: " + JSON.stringify(introspectionResult));
  }
}
function introspectSchema(executor, context, options) {
  const parsedIntrospectionQuery = parse$1(getIntrospectionQuery(options), options);
  return new ValueOrPromise(() => executor({
    document: parsedIntrospectionQuery,
    context,
    operationType: "query"
  })).then((introspection2) => {
    if (isAsyncIterable(introspection2)) {
      const iterator = introspection2[Symbol.asyncIterator]();
      return iterator.next().then(({ value }) => value);
    }
    return introspection2;
  }).then((introspection2) => getSchemaFromIntrospection(introspection2, options)).resolve();
}
const baseHasOwnProperty = Object.prototype.hasOwnProperty;
function isObject$3(val) {
  return typeof val === "object" && val !== null;
}
function areGraphQLErrors(obj) {
  return Array.isArray(obj) && obj.length > 0 && obj.every((ob2) => "message" in ob2);
}
function hasOwnProperty(obj, prop2) {
  return baseHasOwnProperty.call(obj, prop2);
}
function hasOwnObjectProperty(obj, prop2) {
  return baseHasOwnProperty.call(obj, prop2) && isObject$3(obj[prop2]);
}
function hasOwnStringProperty(obj, prop2) {
  return baseHasOwnProperty.call(obj, prop2) && typeof obj[prop2] === "string";
}
function limitCloseReason(reason, whenTooLong) {
  return reason.length < 124 ? reason : whenTooLong;
}
const GRAPHQL_TRANSPORT_WS_PROTOCOL = "graphql-transport-ws";
var CloseCode;
(function(CloseCode2) {
  CloseCode2[CloseCode2["InternalServerError"] = 4500] = "InternalServerError";
  CloseCode2[CloseCode2["InternalClientError"] = 4005] = "InternalClientError";
  CloseCode2[CloseCode2["BadRequest"] = 4400] = "BadRequest";
  CloseCode2[CloseCode2["BadResponse"] = 4004] = "BadResponse";
  CloseCode2[CloseCode2["Unauthorized"] = 4401] = "Unauthorized";
  CloseCode2[CloseCode2["Forbidden"] = 4403] = "Forbidden";
  CloseCode2[CloseCode2["SubprotocolNotAcceptable"] = 4406] = "SubprotocolNotAcceptable";
  CloseCode2[CloseCode2["ConnectionInitialisationTimeout"] = 4408] = "ConnectionInitialisationTimeout";
  CloseCode2[CloseCode2["ConnectionAcknowledgementTimeout"] = 4504] = "ConnectionAcknowledgementTimeout";
  CloseCode2[CloseCode2["SubscriberAlreadyExists"] = 4409] = "SubscriberAlreadyExists";
  CloseCode2[CloseCode2["TooManyInitialisationRequests"] = 4429] = "TooManyInitialisationRequests";
})(CloseCode || (CloseCode = {}));
var MessageType;
(function(MessageType2) {
  MessageType2["ConnectionInit"] = "connection_init";
  MessageType2["ConnectionAck"] = "connection_ack";
  MessageType2["Ping"] = "ping";
  MessageType2["Pong"] = "pong";
  MessageType2["Subscribe"] = "subscribe";
  MessageType2["Next"] = "next";
  MessageType2["Error"] = "error";
  MessageType2["Complete"] = "complete";
})(MessageType || (MessageType = {}));
function isMessage(val) {
  if (isObject$3(val)) {
    if (!hasOwnStringProperty(val, "type")) {
      return false;
    }
    switch (val.type) {
      case MessageType.ConnectionInit:
        return !hasOwnProperty(val, "payload") || val.payload === void 0 || isObject$3(val.payload);
      case MessageType.ConnectionAck:
      case MessageType.Ping:
      case MessageType.Pong:
        return !hasOwnProperty(val, "payload") || val.payload === void 0 || isObject$3(val.payload);
      case MessageType.Subscribe:
        return hasOwnStringProperty(val, "id") && hasOwnObjectProperty(val, "payload") && (!hasOwnProperty(val.payload, "operationName") || val.payload.operationName === void 0 || val.payload.operationName === null || typeof val.payload.operationName === "string") && hasOwnStringProperty(val.payload, "query") && (!hasOwnProperty(val.payload, "variables") || val.payload.variables === void 0 || val.payload.variables === null || hasOwnObjectProperty(val.payload, "variables")) && (!hasOwnProperty(val.payload, "extensions") || val.payload.extensions === void 0 || val.payload.extensions === null || hasOwnObjectProperty(val.payload, "extensions"));
      case MessageType.Next:
        return hasOwnStringProperty(val, "id") && hasOwnObjectProperty(val, "payload");
      case MessageType.Error:
        return hasOwnStringProperty(val, "id") && areGraphQLErrors(val.payload);
      case MessageType.Complete:
        return hasOwnStringProperty(val, "id");
      default:
        return false;
    }
  }
  return false;
}
function parseMessage(data, reviver) {
  if (isMessage(data)) {
    return data;
  }
  if (typeof data !== "string") {
    throw new Error("Message not parsable");
  }
  const message = JSON.parse(data, reviver);
  if (!isMessage(message)) {
    throw new Error("Invalid message");
  }
  return message;
}
function stringifyMessage(msg, replacer) {
  if (!isMessage(msg)) {
    throw new Error("Cannot stringify invalid message");
  }
  return JSON.stringify(msg, replacer);
}
function createClient$1(options) {
  const {
    url,
    connectionParams,
    lazy = true,
    onNonLazyError = console.error,
    lazyCloseTimeout = 0,
    keepAlive = 0,
    disablePong,
    connectionAckWaitTimeout = 0,
    retryAttempts = 5,
    retryWait = async function randomisedExponentialBackoff(retries2) {
      let retryDelay = 1e3;
      for (let i = 0; i < retries2; i++) {
        retryDelay *= 2;
      }
      await new Promise((resolve) => setTimeout(resolve, retryDelay + Math.floor(Math.random() * (3e3 - 300) + 300)));
    },
    isFatalConnectionProblem = (errOrCloseEvent) => !isLikeCloseEvent(errOrCloseEvent),
    on,
    webSocketImpl,
    generateID = function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r2 = Math.random() * 16 | 0, v2 = c == "x" ? r2 : r2 & 3 | 8;
        return v2.toString(16);
      });
    },
    jsonMessageReplacer: replacer,
    jsonMessageReviver: reviver
  } = options;
  let ws2;
  if (webSocketImpl) {
    if (!isWebSocket(webSocketImpl)) {
      throw new Error("Invalid WebSocket implementation provided");
    }
    ws2 = webSocketImpl;
  } else if (typeof WebSocket !== "undefined") {
    ws2 = WebSocket;
  } else if (typeof global !== "undefined") {
    ws2 = global.WebSocket || global.MozWebSocket;
  } else if (typeof window !== "undefined") {
    ws2 = window.WebSocket || window.MozWebSocket;
  }
  if (!ws2)
    throw new Error("WebSocket implementation missing");
  const WebSocketImpl = ws2;
  const emitter = (() => {
    const message = (() => {
      const listeners2 = {};
      return {
        on(id2, listener) {
          listeners2[id2] = listener;
          return () => {
            delete listeners2[id2];
          };
        },
        emit(message2) {
          var _a2;
          if ("id" in message2)
            (_a2 = listeners2[message2.id]) === null || _a2 === void 0 ? void 0 : _a2.call(listeners2, message2);
        }
      };
    })();
    const listeners = {
      connecting: (on === null || on === void 0 ? void 0 : on.connecting) ? [on.connecting] : [],
      opened: (on === null || on === void 0 ? void 0 : on.opened) ? [on.opened] : [],
      connected: (on === null || on === void 0 ? void 0 : on.connected) ? [on.connected] : [],
      ping: (on === null || on === void 0 ? void 0 : on.ping) ? [on.ping] : [],
      pong: (on === null || on === void 0 ? void 0 : on.pong) ? [on.pong] : [],
      message: (on === null || on === void 0 ? void 0 : on.message) ? [message.emit, on.message] : [message.emit],
      closed: (on === null || on === void 0 ? void 0 : on.closed) ? [on.closed] : [],
      error: (on === null || on === void 0 ? void 0 : on.error) ? [on.error] : []
    };
    return {
      onMessage: message.on,
      on(event, listener) {
        const l2 = listeners[event];
        l2.push(listener);
        return () => {
          l2.splice(l2.indexOf(listener), 1);
        };
      },
      emit(event, ...args) {
        for (const listener of [...listeners[event]]) {
          listener(...args);
        }
      }
    };
  })();
  function errorOrClosed(cb2) {
    const listening = [
      emitter.on("error", (err) => {
        listening.forEach((unlisten) => unlisten());
        cb2(err);
      }),
      emitter.on("closed", (event) => {
        listening.forEach((unlisten) => unlisten());
        cb2(event);
      })
    ];
  }
  let connecting, locks = 0, retrying = false, retries = 0, disposed = false;
  async function connect2() {
    const [socket, throwOnClose] = await (connecting !== null && connecting !== void 0 ? connecting : connecting = new Promise((connected, denied) => (async () => {
      if (retrying) {
        await retryWait(retries);
        if (!locks) {
          connecting = void 0;
          return denied({ code: 1e3, reason: "All Subscriptions Gone" });
        }
        retries++;
      }
      emitter.emit("connecting");
      const socket2 = new WebSocketImpl(typeof url === "function" ? await url() : url, GRAPHQL_TRANSPORT_WS_PROTOCOL);
      let connectionAckTimeout, queuedPing;
      function enqueuePing() {
        if (isFinite(keepAlive) && keepAlive > 0) {
          clearTimeout(queuedPing);
          queuedPing = setTimeout(() => {
            if (socket2.readyState === WebSocketImpl.OPEN) {
              socket2.send(stringifyMessage({ type: MessageType.Ping }));
              emitter.emit("ping", false, void 0);
            }
          }, keepAlive);
        }
      }
      errorOrClosed((errOrEvent) => {
        connecting = void 0;
        clearTimeout(connectionAckTimeout);
        clearTimeout(queuedPing);
        denied(errOrEvent);
      });
      socket2.onerror = (err) => emitter.emit("error", err);
      socket2.onclose = (event) => emitter.emit("closed", event);
      socket2.onopen = async () => {
        try {
          emitter.emit("opened", socket2);
          const payload = typeof connectionParams === "function" ? await connectionParams() : connectionParams;
          socket2.send(stringifyMessage(payload ? {
            type: MessageType.ConnectionInit,
            payload
          } : {
            type: MessageType.ConnectionInit
          }, replacer));
          if (isFinite(connectionAckWaitTimeout) && connectionAckWaitTimeout > 0) {
            connectionAckTimeout = setTimeout(() => {
              socket2.close(CloseCode.ConnectionAcknowledgementTimeout, "Connection acknowledgement timeout");
            }, connectionAckWaitTimeout);
          }
          enqueuePing();
        } catch (err) {
          emitter.emit("error", err);
          socket2.close(CloseCode.InternalClientError, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, "Internal client error"));
        }
      };
      let acknowledged = false;
      socket2.onmessage = ({ data }) => {
        try {
          const message = parseMessage(data, reviver);
          emitter.emit("message", message);
          if (message.type === "ping" || message.type === "pong") {
            emitter.emit(message.type, true, message.payload);
            if (message.type === "pong") {
              enqueuePing();
            } else if (!disablePong) {
              socket2.send(stringifyMessage(message.payload ? {
                type: MessageType.Pong,
                payload: message.payload
              } : {
                type: MessageType.Pong
              }));
              emitter.emit("pong", false, message.payload);
            }
            return;
          }
          if (acknowledged)
            return;
          if (message.type !== MessageType.ConnectionAck)
            throw new Error(`First message cannot be of type ${message.type}`);
          clearTimeout(connectionAckTimeout);
          acknowledged = true;
          emitter.emit("connected", socket2, message.payload);
          retrying = false;
          retries = 0;
          connected([
            socket2,
            new Promise((_, reject) => errorOrClosed(reject))
          ]);
        } catch (err) {
          socket2.onmessage = null;
          emitter.emit("error", err);
          socket2.close(CloseCode.BadResponse, limitCloseReason(err instanceof Error ? err.message : new Error(err).message, "Bad response"));
        }
      };
    })()));
    if (socket.readyState === WebSocketImpl.CLOSING)
      await throwOnClose;
    let release = () => {
    };
    const released = new Promise((resolve) => release = resolve);
    return [
      socket,
      release,
      Promise.race([
        released.then(() => {
          if (!locks) {
            const complete = () => socket.close(1e3, "Normal Closure");
            if (isFinite(lazyCloseTimeout) && lazyCloseTimeout > 0) {
              setTimeout(() => {
                if (!locks && socket.readyState === WebSocketImpl.OPEN)
                  complete();
              }, lazyCloseTimeout);
            } else {
              complete();
            }
          }
        }),
        throwOnClose
      ])
    ];
  }
  function shouldRetryConnectOrThrow(errOrCloseEvent) {
    if (isLikeCloseEvent(errOrCloseEvent) && (isFatalInternalCloseCode(errOrCloseEvent.code) || [
      CloseCode.InternalServerError,
      CloseCode.InternalClientError,
      CloseCode.BadRequest,
      CloseCode.BadResponse,
      CloseCode.Unauthorized,
      CloseCode.SubprotocolNotAcceptable,
      CloseCode.SubscriberAlreadyExists,
      CloseCode.TooManyInitialisationRequests
    ].includes(errOrCloseEvent.code)))
      throw errOrCloseEvent;
    if (disposed)
      return false;
    if (isLikeCloseEvent(errOrCloseEvent) && errOrCloseEvent.code === 1e3)
      return locks > 0;
    if (!retryAttempts || retries >= retryAttempts)
      throw errOrCloseEvent;
    if (isFatalConnectionProblem(errOrCloseEvent))
      throw errOrCloseEvent;
    return retrying = true;
  }
  if (!lazy) {
    (async () => {
      locks++;
      for (; ; ) {
        try {
          const [, , throwOnClose] = await connect2();
          await throwOnClose;
        } catch (errOrCloseEvent) {
          try {
            if (!shouldRetryConnectOrThrow(errOrCloseEvent))
              return;
          } catch (errOrCloseEvent2) {
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(errOrCloseEvent2);
          }
        }
      }
    })();
  }
  return {
    on: emitter.on,
    subscribe(payload, sink) {
      const id2 = generateID();
      let done = false, errored = false, releaser = () => {
        locks--;
        done = true;
      };
      (async () => {
        locks++;
        for (; ; ) {
          try {
            const [socket, release, waitForReleaseOrThrowOnClose] = await connect2();
            if (done)
              return release();
            const unlisten = emitter.onMessage(id2, (message) => {
              switch (message.type) {
                case MessageType.Next: {
                  sink.next(message.payload);
                  return;
                }
                case MessageType.Error: {
                  errored = true, done = true;
                  sink.error(message.payload);
                  releaser();
                  return;
                }
                case MessageType.Complete: {
                  done = true;
                  releaser();
                  return;
                }
              }
            });
            socket.send(stringifyMessage({
              id: id2,
              type: MessageType.Subscribe,
              payload
            }, replacer));
            releaser = () => {
              if (!done && socket.readyState === WebSocketImpl.OPEN)
                socket.send(stringifyMessage({
                  id: id2,
                  type: MessageType.Complete
                }, replacer));
              locks--;
              done = true;
              release();
            };
            await waitForReleaseOrThrowOnClose.finally(unlisten);
            return;
          } catch (errOrCloseEvent) {
            if (!shouldRetryConnectOrThrow(errOrCloseEvent))
              return;
          }
        }
      })().then(() => {
        if (!errored)
          sink.complete();
      }).catch((err) => {
        sink.error(err);
      });
      return () => {
        if (!done)
          releaser();
      };
    },
    async dispose() {
      disposed = true;
      if (connecting) {
        const [socket] = await connecting;
        socket.close(1e3, "Normal Closure");
      }
    }
  };
}
function isLikeCloseEvent(val) {
  return isObject$3(val) && "code" in val && "reason" in val;
}
function isFatalInternalCloseCode(code3) {
  if ([
    1e3,
    1001,
    1006,
    1005,
    1012,
    1013,
    1013
  ].includes(code3))
    return false;
  return code3 >= 1e3 && code3 <= 1999;
}
function isWebSocket(val) {
  return typeof val === "function" && "constructor" in val && "CLOSED" in val && "CLOSING" in val && "CONNECTING" in val && "OPEN" in val;
}
const TOKEN_HEADER_KEY = "x-graphql-event-stream-token";
function validateStreamEvent(e) {
  e = e;
  if (e !== "next" && e !== "complete")
    throw new Error(`Invalid stream event "${e}"`);
  return e;
}
function parseStreamData(e, data) {
  if (data) {
    try {
      data = JSON.parse(data);
    } catch (_a2) {
      throw new Error("Invalid stream data");
    }
  }
  if (e === "next" && !data)
    throw new Error('Stream data must be an object for "next" events');
  return data || null;
}
function isObject$2(val) {
  return typeof val === "object" && val !== null;
}
var ControlChars;
(function(ControlChars2) {
  ControlChars2[ControlChars2["NewLine"] = 10] = "NewLine";
  ControlChars2[ControlChars2["CchunkiageReturn"] = 13] = "CchunkiageReturn";
  ControlChars2[ControlChars2["Space"] = 32] = "Space";
  ControlChars2[ControlChars2["Colon"] = 58] = "Colon";
})(ControlChars || (ControlChars = {}));
function createParser() {
  let buffer2;
  let position;
  let fieldLength;
  let discardTrailingNewline = false;
  let message = { event: "", data: "" };
  let pending = [];
  const decoder2 = new TextDecoder();
  return function parse2(chunk) {
    if (buffer2 === void 0) {
      buffer2 = chunk;
      position = 0;
      fieldLength = -1;
    } else {
      const concat2 = new Uint8Array(buffer2.length + chunk.length);
      concat2.set(buffer2);
      concat2.set(chunk, buffer2.length);
      buffer2 = concat2;
    }
    const bufLength = buffer2.length;
    let lineStart = 0;
    while (position < bufLength) {
      if (discardTrailingNewline) {
        if (buffer2[position] === ControlChars.NewLine) {
          lineStart = ++position;
        }
        discardTrailingNewline = false;
      }
      let lineEnd = -1;
      for (; position < bufLength && lineEnd === -1; ++position) {
        switch (buffer2[position]) {
          case ControlChars.Colon:
            if (fieldLength === -1) {
              fieldLength = position - lineStart;
            }
            break;
          case ControlChars.CchunkiageReturn:
            discardTrailingNewline = true;
          case ControlChars.NewLine:
            lineEnd = position;
            break;
        }
      }
      if (lineEnd === -1) {
        break;
      } else if (lineStart === lineEnd) {
        if (message.event || message.data) {
          if (!message.event)
            throw new Error("Missing message event");
          const event = validateStreamEvent(message.event);
          const data = parseStreamData(event, message.data);
          pending.push({
            event,
            data
          });
          message = { event: "", data: "" };
        }
      } else if (fieldLength > 0) {
        const line = buffer2.subarray(lineStart, lineEnd);
        const field = decoder2.decode(line.subarray(0, fieldLength));
        const valueOffset = fieldLength + (line[fieldLength + 1] === ControlChars.Space ? 2 : 1);
        const value = decoder2.decode(line.subarray(valueOffset));
        switch (field) {
          case "event":
            message.event = value;
            break;
          case "data":
            message.data = message.data ? message.data + "\n" + value : value;
            break;
        }
      }
      lineStart = position;
      fieldLength = -1;
    }
    if (lineStart === bufLength) {
      buffer2 = void 0;
      const messages = [...pending];
      pending = [];
      return messages;
    } else if (lineStart !== 0) {
      buffer2 = buffer2.subarray(lineStart);
      position -= lineStart;
    }
  };
}
var __asyncValues = globalThis && globalThis.__asyncValues || function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d });
    }, reject);
  }
};
var __await = globalThis && globalThis.__await || function(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
};
var __asyncGenerator = globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g[n2])
      i[n2] = function(v2) {
        return new Promise(function(a, b) {
          q2.push([n2, v2, a, b]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step(g[n2](v2));
    } catch (e) {
      settle(q2[0][3], e);
    }
  }
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v2) {
    if (f(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
};
function createClient(options) {
  const {
    singleConnection = false,
    lazy = true,
    onNonLazyError = console.error,
    generateID = function generateUUID() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r2 = Math.random() * 16 | 0, v2 = c == "x" ? r2 : r2 & 3 | 8;
        return v2.toString(16);
      });
    },
    retryAttempts = 5,
    retry = async function randomisedExponentialBackoff(retries2) {
      let retryDelay = 1e3;
      for (let i = 0; i < retries2; i++) {
        retryDelay *= 2;
      }
      await new Promise((resolve) => setTimeout(resolve, retryDelay + Math.floor(Math.random() * (3e3 - 300) + 300)));
    }
  } = options;
  const fetchFn = options.fetchFn || fetch;
  const AbortControllerImpl = options.abortControllerImpl || AbortController;
  const client2 = (() => {
    let disposed = false;
    const listeners = [];
    return {
      get disposed() {
        return disposed;
      },
      onDispose(cb2) {
        if (disposed) {
          setTimeout(() => cb2(), 0);
          return () => {
          };
        }
        listeners.push(cb2);
        return () => {
          listeners.splice(listeners.indexOf(cb2), 1);
        };
      },
      dispose() {
        if (disposed)
          return;
        disposed = true;
        for (const listener of [...listeners]) {
          listener();
        }
      }
    };
  })();
  let connCtrl, conn, locks = 0, retryingErr = null, retries = 0;
  async function getOrConnect() {
    try {
      if (client2.disposed)
        throw new Error("Client has been disposed");
      return await (conn !== null && conn !== void 0 ? conn : conn = (async () => {
        var _a2;
        if (retryingErr) {
          await retry(retries);
          if (connCtrl.signal.aborted)
            throw new Error("Connection aborted by the client");
          retries++;
        }
        connCtrl = new AbortControllerImpl();
        const unlistenDispose = client2.onDispose(() => connCtrl.abort());
        connCtrl.signal.addEventListener("abort", () => {
          unlistenDispose();
          conn = void 0;
        });
        const url = typeof options.url === "function" ? await options.url() : options.url;
        if (connCtrl.signal.aborted)
          throw new Error("Connection aborted by the client");
        const headers = typeof options.headers === "function" ? await options.headers() : (_a2 = options.headers) !== null && _a2 !== void 0 ? _a2 : {};
        if (connCtrl.signal.aborted)
          throw new Error("Connection aborted by the client");
        let res;
        try {
          res = await fetchFn(url, {
            signal: connCtrl.signal,
            method: "PUT",
            headers
          });
        } catch (err) {
          throw new NetworkError(err);
        }
        if (res.status !== 201)
          throw new NetworkError(res);
        const token2 = await res.text();
        headers[TOKEN_HEADER_KEY] = token2;
        const connected = await connect({
          signal: connCtrl.signal,
          headers,
          url,
          fetchFn
        });
        retryingErr = null;
        retries = 0;
        connected.waitForThrow().catch(() => conn = void 0);
        return connected;
      })());
    } catch (err) {
      conn = void 0;
      throw err;
    }
  }
  if (singleConnection && !lazy) {
    (async () => {
      locks++;
      for (; ; ) {
        try {
          const { waitForThrow } = await getOrConnect();
          await waitForThrow();
        } catch (err) {
          if (client2.disposed)
            return;
          if (!(err instanceof NetworkError))
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);
          if (!retryAttempts || retries >= retryAttempts)
            return onNonLazyError === null || onNonLazyError === void 0 ? void 0 : onNonLazyError(err);
          retryingErr = err;
        }
      }
    })();
  }
  return {
    subscribe(request, sink) {
      if (!singleConnection) {
        const control2 = new AbortControllerImpl();
        const unlisten2 = client2.onDispose(() => {
          unlisten2();
          control2.abort();
        });
        (async () => {
          var e_1, _a2;
          var _b;
          let retryingErr2 = null, retries2 = 0;
          for (; ; ) {
            try {
              if (retryingErr2) {
                await retry(retries2);
                if (control2.signal.aborted)
                  throw new Error("Connection aborted by the client");
                retries2++;
              }
              const url = typeof options.url === "function" ? await options.url() : options.url;
              if (control2.signal.aborted)
                throw new Error("Connection aborted by the client");
              const headers = typeof options.headers === "function" ? await options.headers() : (_b = options.headers) !== null && _b !== void 0 ? _b : {};
              if (control2.signal.aborted)
                throw new Error("Connection aborted by the client");
              const { getResults } = await connect({
                signal: control2.signal,
                headers,
                url,
                body: JSON.stringify(request),
                fetchFn
              });
              retryingErr2 = null;
              retries2 = 0;
              try {
                for (var _c = (e_1 = void 0, __asyncValues(getResults())), _d; _d = await _c.next(), !_d.done; ) {
                  const result2 = _d.value;
                  sink.next(result2);
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (_d && !_d.done && (_a2 = _c.return))
                    await _a2.call(_c);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              return control2.abort();
            } catch (err) {
              if (control2.signal.aborted)
                return;
              if (!(err instanceof NetworkError))
                throw err;
              if (!retryAttempts || retries2 >= retryAttempts)
                throw err;
              retryingErr2 = err;
            }
          }
        })().then(() => sink.complete()).catch((err) => sink.error(err));
        return () => control2.abort();
      }
      locks++;
      const control = new AbortControllerImpl();
      const unlisten = client2.onDispose(() => {
        unlisten();
        control.abort();
      });
      (async () => {
        var e_2, _a2;
        const operationId = generateID();
        request = Object.assign(Object.assign({}, request), { extensions: Object.assign(Object.assign({}, request.extensions), { operationId }) });
        let complete = null;
        for (; ; ) {
          complete = null;
          try {
            const { url, headers, getResults } = await getOrConnect();
            let res;
            try {
              res = await fetchFn(url, {
                signal: control.signal,
                method: "POST",
                headers,
                body: JSON.stringify(request)
              });
            } catch (err) {
              throw new NetworkError(err);
            }
            if (res.status !== 202)
              throw new NetworkError(res);
            complete = async () => {
              let res2;
              try {
                const control2 = new AbortControllerImpl();
                const unlisten2 = client2.onDispose(() => {
                  unlisten2();
                  control2.abort();
                });
                res2 = await fetchFn(url + "?operationId=" + operationId, {
                  signal: control2.signal,
                  method: "DELETE",
                  headers
                });
              } catch (err) {
                throw new NetworkError(err);
              }
              if (res2.status !== 200)
                throw new NetworkError(res2);
            };
            try {
              for (var _b = (e_2 = void 0, __asyncValues(getResults({
                signal: control.signal,
                operationId
              }))), _c; _c = await _b.next(), !_c.done; ) {
                const result2 = _c.value;
                sink.next(result2);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (_c && !_c.done && (_a2 = _b.return))
                  await _a2.call(_b);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            complete = null;
            return control.abort();
          } catch (err) {
            if (control.signal.aborted)
              return await (complete === null || complete === void 0 ? void 0 : complete());
            if (!(err instanceof NetworkError))
              throw err;
            if (!retryAttempts || retries >= retryAttempts)
              throw err;
            retryingErr = err;
          } finally {
            if (control.signal.aborted && --locks === 0)
              connCtrl.abort();
          }
        }
      })().then(() => sink.complete()).catch((err) => sink.error(err));
      return () => control.abort();
    },
    dispose() {
      client2.dispose();
    }
  };
}
class NetworkError extends Error {
  constructor(msgOrErrOrResponse) {
    let message, response;
    if (isResponseLike(msgOrErrOrResponse)) {
      response = msgOrErrOrResponse;
      message = "Server responded with " + msgOrErrOrResponse.status + ": " + msgOrErrOrResponse.statusText;
    } else if (msgOrErrOrResponse instanceof Error)
      message = msgOrErrOrResponse.message;
    else
      message = String(msgOrErrOrResponse);
    super(message);
    this.name = this.constructor.name;
    this.response = response;
  }
}
function isResponseLike(val) {
  return isObject$2(val) && typeof val["ok"] === "boolean" && typeof val["status"] === "number" && typeof val["statusText"] === "string";
}
async function connect(options) {
  const { signal, url, headers, body, fetchFn } = options;
  const waiting = {};
  const queue = {};
  let res;
  try {
    res = await fetchFn(url, {
      signal,
      method: body ? "POST" : "GET",
      headers: Object.assign(Object.assign({}, headers), { accept: "text/event-stream" }),
      body
    });
  } catch (err) {
    throw new NetworkError(err);
  }
  if (!res.ok)
    throw new NetworkError(res);
  if (!res.body)
    throw new Error("Missing response body");
  let error2 = null;
  let waitingForThrow = null;
  (async () => {
    var e_3, _a2;
    var _b;
    try {
      const parse2 = createParser();
      try {
        for (var _c = __asyncValues(toAsyncIterator(res.body)), _d; _d = await _c.next(), !_d.done; ) {
          const chunk = _d.value;
          if (typeof chunk === "string")
            throw new Error(`Unexpected string chunk "${chunk}"`);
          const msgs = parse2(chunk);
          if (!msgs)
            continue;
          for (const msg of msgs) {
            const operationId = msg.data && "id" in msg.data ? msg.data.id : "";
            if (!(operationId in queue))
              queue[operationId] = [];
            switch (msg.event) {
              case "next":
                if (operationId)
                  queue[operationId].push(msg.data.payload);
                else
                  queue[operationId].push(msg.data);
                break;
              case "complete":
                queue[operationId].push("complete");
                break;
              default:
                throw new Error(`Unexpected message event "${msg.event}"`);
            }
            (_b = waiting[operationId]) === null || _b === void 0 ? void 0 : _b.proceed();
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a2 = _c.return))
            await _a2.call(_c);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    } catch (err) {
      error2 = err;
      if (waitingForThrow)
        waitingForThrow(err);
    } finally {
      Object.values(waiting).forEach(({ proceed }) => proceed());
    }
  })();
  return {
    url,
    headers,
    waitForThrow: () => new Promise((_, reject) => {
      if (error2)
        return reject(error2);
      waitingForThrow = reject;
    }),
    getResults(options2) {
      var _a2;
      return __asyncGenerator(this, arguments, function* getResults_1() {
        const { signal: signal2, operationId = "" } = options2 !== null && options2 !== void 0 ? options2 : {};
        try {
          for (; ; ) {
            while ((_a2 = queue[operationId]) === null || _a2 === void 0 ? void 0 : _a2.length) {
              const result2 = queue[operationId].shift();
              if (result2 === "complete")
                return yield __await(void 0);
              yield yield __await(result2);
            }
            if (error2)
              throw error2;
            if (signal2 === null || signal2 === void 0 ? void 0 : signal2.aborted)
              throw new Error("Getting results aborted by the client");
            yield __await(new Promise((resolve) => {
              const proceed = () => {
                signal2 === null || signal2 === void 0 ? void 0 : signal2.removeEventListener("abort", proceed);
                delete waiting[operationId];
                resolve();
              };
              signal2 === null || signal2 === void 0 ? void 0 : signal2.addEventListener("abort", proceed);
              waiting[operationId] = { proceed };
            }));
          }
        } finally {
          delete queue[operationId];
        }
      });
    }
  };
}
function toAsyncIterator(val) {
  if (typeof Object(val)[Symbol.asyncIterator] === "function") {
    val = val;
    return val[Symbol.asyncIterator]();
  }
  return function() {
    return __asyncGenerator(this, arguments, function* () {
      val = val;
      const reader = val.getReader();
      for (; ; ) {
        const { value, done } = yield __await(reader.read());
        if (done)
          return yield __await(value);
        yield yield __await(value);
      }
    });
  }();
}
var ws = null;
if (typeof WebSocket !== "undefined") {
  ws = WebSocket;
} else if (typeof MozWebSocket !== "undefined") {
  ws = MozWebSocket;
} else if (typeof commonjsGlobal !== "undefined") {
  ws = commonjsGlobal.WebSocket || commonjsGlobal.MozWebSocket;
} else if (typeof window !== "undefined") {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== "undefined") {
  ws = self.WebSocket || self.MozWebSocket;
}
var browser$1 = ws;
var ReactNativeFile_1 = class ReactNativeFile {
  constructor({ uri, name: name2, type: type2 }) {
    this.uri = uri;
    this.name = name2;
    this.type = type2;
  }
};
const ReactNativeFile2 = ReactNativeFile_1;
var isExtractableFile = function isExtractableFile2(value) {
  return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile2;
};
var isExtractableFile$1 = isExtractableFile;
const defaultIsExtractableFile = isExtractableFile;
var extractFiles = function extractFiles2(value, path = "", isExtractableFile3 = defaultIsExtractableFile) {
  const files = /* @__PURE__ */ new Map();
  const clones = /* @__PURE__ */ new Map();
  function recurse(value2, path2, recursed) {
    let clone = value2;
    if (isExtractableFile3(value2)) {
      clone = null;
      const filePaths = files.get(value2);
      filePaths ? filePaths.push(path2) : files.set(value2, [path2]);
    } else {
      const isList2 = Array.isArray(value2) || typeof FileList !== "undefined" && value2 instanceof FileList;
      const isObject2 = value2 && value2.constructor === Object;
      if (isList2 || isObject2) {
        const hasClone = clones.has(value2);
        if (hasClone)
          clone = clones.get(value2);
        else {
          clone = isList2 ? [] : {};
          clones.set(value2, clone);
        }
        if (!recursed.has(value2)) {
          const pathPrefix = path2 ? `${path2}.` : "";
          const recursedDeeper = new Set(recursed).add(value2);
          if (isList2) {
            let index = 0;
            for (const item of value2) {
              const itemClone = recurse(item, pathPrefix + index++, recursedDeeper);
              if (!hasClone)
                clone.push(itemClone);
            }
          } else
            for (const key in value2) {
              const propertyClone = recurse(value2[key], pathPrefix + key, recursedDeeper);
              if (!hasClone)
                clone[key] = propertyClone;
            }
        }
      }
    }
    return clone;
  }
  return {
    clone: recurse(value, path, /* @__PURE__ */ new Set()),
    files
  };
};
var extractFiles$1 = extractFiles;
var client = {};
var backo2 = Backoff$1;
function Backoff$1(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
Backoff$1.prototype.duration = function() {
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand = Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};
Backoff$1.prototype.reset = function() {
  this.attempts = 0;
};
Backoff$1.prototype.setMin = function(min) {
  this.ms = min;
};
Backoff$1.prototype.setMax = function(max) {
  this.max = max;
};
Backoff$1.prototype.setJitter = function(jitter) {
  this.jitter = jitter;
};
var eventemitter3 = { exports: {} };
(function(module2) {
  var has2 = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name2;
    if (this._eventsCount === 0)
      return names;
    for (name2 in events = this._events) {
      if (has2.call(events, name2))
        names.push(prefix ? name2.slice(1) : name2);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee2 = new Array(l2); i < l2; i++) {
      ee2[i] = handlers[i].fn;
    }
    return ee2;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  {
    module2.exports = EventEmitter;
  }
})(eventemitter3);
var isString$1 = {};
Object.defineProperty(isString$1, "__esModule", { value: true });
function isString(value) {
  return typeof value === "string";
}
isString$1.default = isString;
var isObject$1 = {};
Object.defineProperty(isObject$1, "__esModule", { value: true });
function isObject(value) {
  return value !== null && typeof value === "object";
}
isObject$1.default = isObject;
var require$$4 = /* @__PURE__ */ getAugmentedNamespace(printer);
var require$$5 = /* @__PURE__ */ getAugmentedNamespace(getOperationAST$1);
function symbolObservablePonyfill(root2) {
  var result2;
  var Symbol2 = root2.Symbol;
  if (typeof Symbol2 === "function") {
    if (Symbol2.observable) {
      result2 = Symbol2.observable;
    } else {
      result2 = Symbol2("observable");
      Symbol2.observable = result2;
    }
  } else {
    result2 = "@@observable";
  }
  return result2;
}
var root;
if (typeof self !== "undefined") {
  root = self;
} else if (typeof window !== "undefined") {
  root = window;
} else if (typeof global !== "undefined") {
  root = global;
} else if (typeof module !== "undefined") {
  root = module;
} else {
  root = Function("return this")();
}
var result = symbolObservablePonyfill(root);
var es = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: "Module",
  "default": result
});
var require$$6 = /* @__PURE__ */ getAugmentedNamespace(es);
var protocol = {};
Object.defineProperty(protocol, "__esModule", { value: true });
protocol.GRAPHQL_SUBSCRIPTIONS = protocol.GRAPHQL_WS = void 0;
var GRAPHQL_WS = "graphql-ws";
protocol.GRAPHQL_WS = GRAPHQL_WS;
var GRAPHQL_SUBSCRIPTIONS = "graphql-subscriptions";
protocol.GRAPHQL_SUBSCRIPTIONS = GRAPHQL_SUBSCRIPTIONS;
var defaults = {};
Object.defineProperty(defaults, "__esModule", { value: true });
defaults.WS_TIMEOUT = defaults.MIN_WS_TIMEOUT = void 0;
var MIN_WS_TIMEOUT = 1e3;
defaults.MIN_WS_TIMEOUT = MIN_WS_TIMEOUT;
var WS_TIMEOUT = 3e4;
defaults.WS_TIMEOUT = WS_TIMEOUT;
var messageTypes = {};
Object.defineProperty(messageTypes, "__esModule", { value: true });
var MessageTypes = function() {
  function MessageTypes2() {
    throw new Error("Static Class");
  }
  MessageTypes2.GQL_CONNECTION_INIT = "connection_init";
  MessageTypes2.GQL_CONNECTION_ACK = "connection_ack";
  MessageTypes2.GQL_CONNECTION_ERROR = "connection_error";
  MessageTypes2.GQL_CONNECTION_KEEP_ALIVE = "ka";
  MessageTypes2.GQL_CONNECTION_TERMINATE = "connection_terminate";
  MessageTypes2.GQL_START = "start";
  MessageTypes2.GQL_DATA = "data";
  MessageTypes2.GQL_ERROR = "error";
  MessageTypes2.GQL_COMPLETE = "complete";
  MessageTypes2.GQL_STOP = "stop";
  MessageTypes2.SUBSCRIPTION_START = "subscription_start";
  MessageTypes2.SUBSCRIPTION_DATA = "subscription_data";
  MessageTypes2.SUBSCRIPTION_SUCCESS = "subscription_success";
  MessageTypes2.SUBSCRIPTION_FAIL = "subscription_fail";
  MessageTypes2.SUBSCRIPTION_END = "subscription_end";
  MessageTypes2.INIT = "init";
  MessageTypes2.INIT_SUCCESS = "init_success";
  MessageTypes2.INIT_FAIL = "init_fail";
  MessageTypes2.KEEP_ALIVE = "keepalive";
  return MessageTypes2;
}();
messageTypes.default = MessageTypes;
var __assign = commonjsGlobal && commonjsGlobal.__assign || function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = commonjsGlobal && commonjsGlobal.__generator || function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y2, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y2 = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray = commonjsGlobal && commonjsGlobal.__spreadArray || function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(client, "__esModule", { value: true });
var SubscriptionClient_1 = client.SubscriptionClient = void 0;
var _global = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : {};
var NativeWebSocket = _global.WebSocket || _global.MozWebSocket;
var Backoff = backo2;
var eventemitter3_1 = eventemitter3.exports;
var is_string_1 = isString$1;
var is_object_1 = isObject$1;
var printer_1 = require$$4;
var getOperationAST_1 = require$$5;
var symbol_observable_1 = require$$6;
var protocol_1 = protocol;
var defaults_1 = defaults;
var message_types_1 = messageTypes;
var SubscriptionClient = function() {
  function SubscriptionClient2(url, options, webSocketImpl, webSocketProtocols) {
    var _a2 = options || {}, _b = _a2.connectionCallback, connectionCallback = _b === void 0 ? void 0 : _b, _c = _a2.connectionParams, connectionParams = _c === void 0 ? {} : _c, _d = _a2.minTimeout, minTimeout = _d === void 0 ? defaults_1.MIN_WS_TIMEOUT : _d, _e = _a2.timeout, timeout = _e === void 0 ? defaults_1.WS_TIMEOUT : _e, _f = _a2.reconnect, reconnect = _f === void 0 ? false : _f, _g = _a2.reconnectionAttempts, reconnectionAttempts = _g === void 0 ? Infinity : _g, _h = _a2.lazy, lazy = _h === void 0 ? false : _h, _j = _a2.inactivityTimeout, inactivityTimeout = _j === void 0 ? 0 : _j, _k = _a2.wsOptionArguments, wsOptionArguments = _k === void 0 ? [] : _k;
    this.wsImpl = webSocketImpl || NativeWebSocket;
    if (!this.wsImpl) {
      throw new Error("Unable to find native implementation, or alternative implementation for WebSocket!");
    }
    this.wsProtocols = webSocketProtocols || protocol_1.GRAPHQL_WS;
    this.connectionCallback = connectionCallback;
    this.url = url;
    this.operations = {};
    this.nextOperationId = 0;
    this.minWsTimeout = minTimeout;
    this.wsTimeout = timeout;
    this.unsentMessagesQueue = [];
    this.reconnect = reconnect;
    this.reconnecting = false;
    this.reconnectionAttempts = reconnectionAttempts;
    this.lazy = !!lazy;
    this.inactivityTimeout = inactivityTimeout;
    this.closedByUser = false;
    this.backoff = new Backoff({ jitter: 0.5 });
    this.eventEmitter = new eventemitter3_1.EventEmitter();
    this.middlewares = [];
    this.client = null;
    this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
    this.connectionParams = this.getConnectionParams(connectionParams);
    this.wsOptionArguments = wsOptionArguments;
    if (!this.lazy) {
      this.connect();
    }
  }
  Object.defineProperty(SubscriptionClient2.prototype, "status", {
    get: function() {
      if (this.client === null) {
        return this.wsImpl.CLOSED;
      }
      return this.client.readyState;
    },
    enumerable: false,
    configurable: true
  });
  SubscriptionClient2.prototype.close = function(isForced, closedByUser) {
    if (isForced === void 0) {
      isForced = true;
    }
    if (closedByUser === void 0) {
      closedByUser = true;
    }
    this.clearInactivityTimeout();
    if (this.client !== null) {
      this.closedByUser = closedByUser;
      if (isForced) {
        this.clearCheckConnectionInterval();
        this.clearMaxConnectTimeout();
        this.clearTryReconnectTimeout();
        this.unsubscribeAll();
        this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_TERMINATE, null);
      }
      this.client.close();
      this.client.onopen = null;
      this.client.onclose = null;
      this.client.onerror = null;
      this.client.onmessage = null;
      this.client = null;
      this.eventEmitter.emit("disconnected");
      if (!isForced) {
        this.tryReconnect();
      }
    }
  };
  SubscriptionClient2.prototype.request = function(request) {
    var _a2;
    var getObserver = this.getObserver.bind(this);
    var executeOperation2 = this.executeOperation.bind(this);
    var unsubscribe = this.unsubscribe.bind(this);
    var opId;
    this.clearInactivityTimeout();
    return _a2 = {}, _a2[symbol_observable_1.default] = function() {
      return this;
    }, _a2.subscribe = function(observerOrNext, onError, onComplete) {
      var observer = getObserver(observerOrNext, onError, onComplete);
      opId = executeOperation2(request, function(error2, result2) {
        if (error2 === null && result2 === null) {
          if (observer.complete) {
            observer.complete();
          }
        } else if (error2) {
          if (observer.error) {
            observer.error(error2[0]);
          }
        } else {
          if (observer.next) {
            observer.next(result2);
          }
        }
      });
      return {
        unsubscribe: function() {
          if (opId) {
            unsubscribe(opId);
            opId = null;
          }
        }
      };
    }, _a2;
  };
  SubscriptionClient2.prototype.on = function(eventName, callback, context) {
    var handler = this.eventEmitter.on(eventName, callback, context);
    return function() {
      handler.off(eventName, callback, context);
    };
  };
  SubscriptionClient2.prototype.onConnected = function(callback, context) {
    return this.on("connected", callback, context);
  };
  SubscriptionClient2.prototype.onConnecting = function(callback, context) {
    return this.on("connecting", callback, context);
  };
  SubscriptionClient2.prototype.onDisconnected = function(callback, context) {
    return this.on("disconnected", callback, context);
  };
  SubscriptionClient2.prototype.onReconnected = function(callback, context) {
    return this.on("reconnected", callback, context);
  };
  SubscriptionClient2.prototype.onReconnecting = function(callback, context) {
    return this.on("reconnecting", callback, context);
  };
  SubscriptionClient2.prototype.onError = function(callback, context) {
    return this.on("error", callback, context);
  };
  SubscriptionClient2.prototype.unsubscribeAll = function() {
    var _this = this;
    Object.keys(this.operations).forEach(function(subId) {
      _this.unsubscribe(subId);
    });
  };
  SubscriptionClient2.prototype.applyMiddlewares = function(options) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      var queue = function(funcs, scope) {
        var next = function(error2) {
          if (error2) {
            reject(error2);
          } else {
            if (funcs.length > 0) {
              var f = funcs.shift();
              if (f) {
                f.applyMiddleware.apply(scope, [options, next]);
              }
            } else {
              resolve(options);
            }
          }
        };
        next();
      };
      queue(__spreadArray([], _this.middlewares, true), _this);
    });
  };
  SubscriptionClient2.prototype.use = function(middlewares) {
    var _this = this;
    middlewares.map(function(middleware) {
      if (typeof middleware.applyMiddleware === "function") {
        _this.middlewares.push(middleware);
      } else {
        throw new Error("Middleware must implement the applyMiddleware function.");
      }
    });
    return this;
  };
  SubscriptionClient2.prototype.getConnectionParams = function(connectionParams) {
    return function() {
      return new Promise(function(resolve, reject) {
        if (typeof connectionParams === "function") {
          try {
            return resolve(connectionParams.call(null));
          } catch (error2) {
            return reject(error2);
          }
        }
        resolve(connectionParams);
      });
    };
  };
  SubscriptionClient2.prototype.executeOperation = function(options, handler) {
    var _this = this;
    if (this.client === null) {
      this.connect();
    }
    var opId = this.generateOperationId();
    this.operations[opId] = { options, handler };
    this.applyMiddlewares(options).then(function(processedOptions) {
      _this.checkOperationOptions(processedOptions, handler);
      if (_this.operations[opId]) {
        _this.operations[opId] = { options: processedOptions, handler };
        _this.sendMessage(opId, message_types_1.default.GQL_START, processedOptions);
      }
    }).catch(function(error2) {
      _this.unsubscribe(opId);
      handler(_this.formatErrors(error2));
    });
    return opId;
  };
  SubscriptionClient2.prototype.getObserver = function(observerOrNext, error2, complete) {
    if (typeof observerOrNext === "function") {
      return {
        next: function(v2) {
          return observerOrNext(v2);
        },
        error: function(e) {
          return error2 && error2(e);
        },
        complete: function() {
          return complete && complete();
        }
      };
    }
    return observerOrNext;
  };
  SubscriptionClient2.prototype.createMaxConnectTimeGenerator = function() {
    var minValue = this.minWsTimeout;
    var maxValue = this.wsTimeout;
    return new Backoff({
      min: minValue,
      max: maxValue,
      factor: 1.2
    });
  };
  SubscriptionClient2.prototype.clearCheckConnectionInterval = function() {
    if (this.checkConnectionIntervalId) {
      clearInterval(this.checkConnectionIntervalId);
      this.checkConnectionIntervalId = null;
    }
  };
  SubscriptionClient2.prototype.clearMaxConnectTimeout = function() {
    if (this.maxConnectTimeoutId) {
      clearTimeout(this.maxConnectTimeoutId);
      this.maxConnectTimeoutId = null;
    }
  };
  SubscriptionClient2.prototype.clearTryReconnectTimeout = function() {
    if (this.tryReconnectTimeoutId) {
      clearTimeout(this.tryReconnectTimeoutId);
      this.tryReconnectTimeoutId = null;
    }
  };
  SubscriptionClient2.prototype.clearInactivityTimeout = function() {
    if (this.inactivityTimeoutId) {
      clearTimeout(this.inactivityTimeoutId);
      this.inactivityTimeoutId = null;
    }
  };
  SubscriptionClient2.prototype.setInactivityTimeout = function() {
    var _this = this;
    if (this.inactivityTimeout > 0 && Object.keys(this.operations).length === 0) {
      this.inactivityTimeoutId = setTimeout(function() {
        if (Object.keys(_this.operations).length === 0) {
          _this.close();
        }
      }, this.inactivityTimeout);
    }
  };
  SubscriptionClient2.prototype.checkOperationOptions = function(options, handler) {
    var query = options.query, variables = options.variables, operationName = options.operationName;
    if (!query) {
      throw new Error("Must provide a query.");
    }
    if (!handler) {
      throw new Error("Must provide an handler.");
    }
    if (!(0, is_string_1.default)(query) && !(0, getOperationAST_1.getOperationAST)(query, operationName) || operationName && !(0, is_string_1.default)(operationName) || variables && !(0, is_object_1.default)(variables)) {
      throw new Error("Incorrect option types. query must be a string or a document,`operationName` must be a string, and `variables` must be an object.");
    }
  };
  SubscriptionClient2.prototype.buildMessage = function(id2, type2, payload) {
    var payloadToReturn = payload && payload.query ? __assign(__assign({}, payload), { query: typeof payload.query === "string" ? payload.query : (0, printer_1.print)(payload.query) }) : payload;
    return {
      id: id2,
      type: type2,
      payload: payloadToReturn
    };
  };
  SubscriptionClient2.prototype.formatErrors = function(errors2) {
    if (Array.isArray(errors2)) {
      return errors2;
    }
    if (errors2 && errors2.errors) {
      return this.formatErrors(errors2.errors);
    }
    if (errors2 && errors2.message) {
      return [errors2];
    }
    return [{
      name: "FormatedError",
      message: "Unknown error",
      originalError: errors2
    }];
  };
  SubscriptionClient2.prototype.sendMessage = function(id2, type2, payload) {
    this.sendMessageRaw(this.buildMessage(id2, type2, payload));
  };
  SubscriptionClient2.prototype.sendMessageRaw = function(message) {
    switch (this.status) {
      case this.wsImpl.OPEN:
        var serializedMessage = JSON.stringify(message);
        try {
          JSON.parse(serializedMessage);
        } catch (e) {
          this.eventEmitter.emit("error", new Error("Message must be JSON-serializable. Got: " + message));
        }
        this.client.send(serializedMessage);
        break;
      case this.wsImpl.CONNECTING:
        this.unsentMessagesQueue.push(message);
        break;
      default:
        if (!this.reconnecting) {
          this.eventEmitter.emit("error", new Error("A message was not sent because socket is not connected, is closing or is already closed. Message was: " + JSON.stringify(message)));
        }
    }
  };
  SubscriptionClient2.prototype.generateOperationId = function() {
    return String(++this.nextOperationId);
  };
  SubscriptionClient2.prototype.tryReconnect = function() {
    var _this = this;
    if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
      return;
    }
    if (!this.reconnecting) {
      Object.keys(this.operations).forEach(function(key) {
        _this.unsentMessagesQueue.push(_this.buildMessage(key, message_types_1.default.GQL_START, _this.operations[key].options));
      });
      this.reconnecting = true;
    }
    this.clearTryReconnectTimeout();
    var delay = this.backoff.duration();
    this.tryReconnectTimeoutId = setTimeout(function() {
      _this.connect();
    }, delay);
  };
  SubscriptionClient2.prototype.flushUnsentMessagesQueue = function() {
    var _this = this;
    this.unsentMessagesQueue.forEach(function(message) {
      _this.sendMessageRaw(message);
    });
    this.unsentMessagesQueue = [];
  };
  SubscriptionClient2.prototype.checkConnection = function() {
    if (this.wasKeepAliveReceived) {
      this.wasKeepAliveReceived = false;
      return;
    }
    if (!this.reconnecting) {
      this.close(false, true);
    }
  };
  SubscriptionClient2.prototype.checkMaxConnectTimeout = function() {
    var _this = this;
    this.clearMaxConnectTimeout();
    this.maxConnectTimeoutId = setTimeout(function() {
      if (_this.status !== _this.wsImpl.OPEN) {
        _this.reconnecting = true;
        _this.close(false, true);
      }
    }, this.maxConnectTimeGenerator.duration());
  };
  SubscriptionClient2.prototype.connect = function() {
    var _a2;
    var _this = this;
    this.client = new ((_a2 = this.wsImpl).bind.apply(_a2, __spreadArray([void 0, this.url, this.wsProtocols], this.wsOptionArguments, false)))();
    this.checkMaxConnectTimeout();
    this.client.onopen = function() {
      return __awaiter(_this, void 0, void 0, function() {
        var connectionParams, error_1;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              if (!(this.status === this.wsImpl.OPEN))
                return [3, 4];
              this.clearMaxConnectTimeout();
              this.closedByUser = false;
              this.eventEmitter.emit(this.reconnecting ? "reconnecting" : "connecting");
              _a3.label = 1;
            case 1:
              _a3.trys.push([1, 3, , 4]);
              return [4, this.connectionParams()];
            case 2:
              connectionParams = _a3.sent();
              this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_INIT, connectionParams);
              this.flushUnsentMessagesQueue();
              return [3, 4];
            case 3:
              error_1 = _a3.sent();
              this.sendMessage(void 0, message_types_1.default.GQL_CONNECTION_ERROR, error_1);
              this.flushUnsentMessagesQueue();
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    };
    this.client.onclose = function() {
      if (!_this.closedByUser) {
        _this.close(false, false);
      }
    };
    this.client.onerror = function(err) {
      _this.eventEmitter.emit("error", err);
    };
    this.client.onmessage = function(_a3) {
      var data = _a3.data;
      _this.processReceivedData(data);
    };
  };
  SubscriptionClient2.prototype.processReceivedData = function(receivedData) {
    var parsedMessage;
    var opId;
    try {
      parsedMessage = JSON.parse(receivedData);
      opId = parsedMessage.id;
    } catch (e) {
      throw new Error("Message must be JSON-parseable. Got: " + receivedData);
    }
    if ([
      message_types_1.default.GQL_DATA,
      message_types_1.default.GQL_COMPLETE,
      message_types_1.default.GQL_ERROR
    ].indexOf(parsedMessage.type) !== -1 && !this.operations[opId]) {
      this.unsubscribe(opId);
      return;
    }
    switch (parsedMessage.type) {
      case message_types_1.default.GQL_CONNECTION_ERROR:
        if (this.connectionCallback) {
          this.connectionCallback(parsedMessage.payload);
        }
        break;
      case message_types_1.default.GQL_CONNECTION_ACK:
        this.eventEmitter.emit(this.reconnecting ? "reconnected" : "connected", parsedMessage.payload);
        this.reconnecting = false;
        this.backoff.reset();
        this.maxConnectTimeGenerator.reset();
        if (this.connectionCallback) {
          this.connectionCallback();
        }
        break;
      case message_types_1.default.GQL_COMPLETE:
        var handler = this.operations[opId].handler;
        delete this.operations[opId];
        handler.call(this, null, null);
        break;
      case message_types_1.default.GQL_ERROR:
        this.operations[opId].handler(this.formatErrors(parsedMessage.payload), null);
        delete this.operations[opId];
        break;
      case message_types_1.default.GQL_DATA:
        var parsedPayload = !parsedMessage.payload.errors ? parsedMessage.payload : __assign(__assign({}, parsedMessage.payload), { errors: this.formatErrors(parsedMessage.payload.errors) });
        this.operations[opId].handler(null, parsedPayload);
        break;
      case message_types_1.default.GQL_CONNECTION_KEEP_ALIVE:
        var firstKA = typeof this.wasKeepAliveReceived === "undefined";
        this.wasKeepAliveReceived = true;
        if (firstKA) {
          this.checkConnection();
        }
        if (this.checkConnectionIntervalId) {
          clearInterval(this.checkConnectionIntervalId);
          this.checkConnection();
        }
        this.checkConnectionIntervalId = setInterval(this.checkConnection.bind(this), this.wsTimeout);
        break;
      default:
        throw new Error("Invalid message type!");
    }
  };
  SubscriptionClient2.prototype.unsubscribe = function(opId) {
    if (this.operations[opId]) {
      delete this.operations[opId];
      this.setInactivityTimeout();
      this.sendMessage(opId, message_types_1.default.GQL_STOP, void 0);
    }
  };
  return SubscriptionClient2;
}();
SubscriptionClient_1 = client.SubscriptionClient = SubscriptionClient;
const GraphQLLiveDirective = new GraphQLDirective({
  name: "live",
  description: "Instruction for establishing a live connection that is updated once the underlying data changes.",
  locations: [DirectiveLocation.QUERY],
  args: {
    if: {
      type: GraphQLBoolean,
      defaultValue: true,
      description: "Whether the query should be live or not."
    },
    throttle: {
      type: GraphQLInt,
      description: 'Propose a desired throttle interval ot the server in order to receive updates to at most once per "throttle" milliseconds. The server must not accept this value.'
    }
  }
});
const isNone = (input) => input == null;
const getLiveDirectiveNode = (input) => {
  var _a2;
  if (input.kind !== "OperationDefinition" || input.operation !== "query") {
    return null;
  }
  const liveDirective = (_a2 = input.directives) === null || _a2 === void 0 ? void 0 : _a2.find((d) => d.name.value === "live");
  if (isNone(liveDirective)) {
    return null;
  }
  return liveDirective;
};
const getLiveDirectiveArgumentValues = (node, variableValues) => {
  var _a2;
  const values = getDirectiveValues(GraphQLLiveDirective, { directives: [node] }, variableValues);
  return {
    isLive: (values === null || values === void 0 ? void 0 : values["if"]) === true,
    throttleValue: (_a2 = values === null || values === void 0 ? void 0 : values["throttle"]) !== null && _a2 !== void 0 ? _a2 : null
  };
};
const isLiveQueryOperationDefinitionNode = (input, variables) => {
  const liveDirectiveNode = getLiveDirectiveNode(input);
  if (isNone(liveDirectiveNode)) {
    return false;
  }
  return getLiveDirectiveArgumentValues(liveDirectiveNode, variables).isLive;
};
var fetch$1 = globalThis.fetch;
var FormData = globalThis.FormData;
var AbortController$1 = globalThis.AbortController;
var File$1 = globalThis.File;
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code2.length; i < len; ++i) {
  lookup[i] = code2[i];
  revLookup[code2.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num2) {
  return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
}
function encodeChunk(uint8, start2, end2) {
  var tmp;
  var output = [];
  for (var i = start2; i < end2; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string2, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength2(string2, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string2, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy2 = new Uint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b)
      return 0;
    var x2 = a.length;
    var y2 = b.length;
    for (var i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b[i]) {
        x2 = a[i];
        y2 = b[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat2(list3, length) {
    if (!Array.isArray(list3)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list3.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list3.length; ++i) {
        length += list3[i].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list3.length; ++i) {
      var buf = list3[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          Buffer2.from(buf).copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string2, encoding) {
    if (Buffer2.isBuffer(string2)) {
      return string2.length;
    }
    if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
      return string2.byteLength;
    }
    if (typeof string2 !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
    }
    var len = string2.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string2).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string2).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start2, end2) {
    var loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start2 >>>= 0;
    if (end2 <= start2) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end2);
        case "ascii":
          return asciiSlice(this, start2, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end2);
        case "base64":
          return base64Slice(this, start2, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end2);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n2, m2) {
    var i = b[n2];
    b[n2] = b[m2];
    b[m2] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals2(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect2() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target2, start2, end2, thisStart, thisEnd) {
    if (isInstance(target2, Uint8Array)) {
      target2 = Buffer2.from(target2, target2.offset, target2.byteLength);
    }
    if (!Buffer2.isBuffer(target2)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target2);
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = target2 ? target2.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end2 > target2.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end2) {
      return 1;
    }
    start2 >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target2)
      return 0;
    var x2 = thisEnd - thisStart;
    var y2 = end2 - start2;
    var len = Math.min(x2, y2);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target2.slice(start2, end2);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2)
      return -1;
    if (y2 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string2, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen2 = string2.length;
    if (length > strLen2 / 2) {
      length = strLen2 / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string2.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string2, offset, length) {
    return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string2, offset, length) {
    return blitBuffer(asciiToBytes(string2), buf, offset, length);
  }
  function base64Write(buf, string2, offset, length) {
    return blitBuffer(base64ToBytes(string2), buf, offset, length);
  }
  function ucs2Write(buf, string2, offset, length) {
    return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string2, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string2, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string2, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string2, offset, length);
        case "base64":
          return base64Write(this, string2, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string2, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end2) {
    if (start2 === 0 && end2 === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end2));
    }
  }
  function utf8Slice(buf, start2, end2) {
    end2 = Math.min(buf.length, end2);
    var res = [];
    var i = start2;
    while (i < end2) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end2) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start2, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var i = start2; i < end2; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end2) {
    var ret = "";
    end2 = Math.min(buf.length, end2);
    for (var i = start2; i < end2; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end2) {
    var len = buf.length;
    if (!start2 || start2 < 0)
      start2 = 0;
    if (!end2 || end2 < 0 || end2 > len)
      end2 = len;
    var out = "";
    for (var i = start2; i < end2; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end2) {
    var bytes = buf.slice(start2, end2);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start2, end2) {
    var len = this.length;
    start2 = ~~start2;
    end2 = end2 === void 0 ? len : ~~end2;
    if (start2 < 0) {
      start2 += len;
      if (start2 < 0)
        start2 = 0;
    } else if (start2 > len) {
      start2 = len;
    }
    if (end2 < 0) {
      end2 += len;
      if (end2 < 0)
        end2 = 0;
    } else if (end2 > len) {
      end2 = len;
    }
    if (end2 < start2)
      end2 = start2;
    var newBuf = this.subarray(start2, end2);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i = byteLength3;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub2 = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i - 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i = byteLength3 - 1;
    var mul = 1;
    var sub2 = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i + 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy2(target2, targetStart, start2, end2) {
    if (!Buffer2.isBuffer(target2))
      throw new TypeError("argument should be a Buffer");
    if (!start2)
      start2 = 0;
    if (!end2 && end2 !== 0)
      end2 = this.length;
    if (targetStart >= target2.length)
      targetStart = target2.length;
    if (!targetStart)
      targetStart = 0;
    if (end2 > 0 && end2 < start2)
      end2 = start2;
    if (end2 === start2)
      return 0;
    if (target2.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length)
      throw new RangeError("Index out of range");
    if (end2 < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length)
      end2 = this.length;
    if (target2.length - targetStart < end2 - start2) {
      end2 = target2.length - targetStart + start2;
    }
    var len = end2 - start2;
    if (this === target2 && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end2);
    } else {
      Uint8Array.prototype.set.call(target2, this.subarray(start2, end2), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start2, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code3 = val.charCodeAt(0);
        if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
          val = code3;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start2; i < end2; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end2 - start2; ++i) {
        this[i + start2] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string2, units) {
    units = units || Infinity;
    var codePoint;
    var length = string2.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string2.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi2, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi2 = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi2);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table3 = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table3[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table3;
  }();
})(buffer);
const { Buffer: Buffer$1 } = buffer;
function syncFetch(...args) {
  const [url, opts] = parseArgs(...args);
  const xhr = new XMLHttpRequest();
  xhr.withCredentials = opts.credentials === "include";
  xhr.timeout = opts.timeout;
  xhr.open(opts.method || "GET", url, false);
  try {
    xhr.responseType = "arraybuffer";
  } catch (e) {
  }
  for (const header of opts.headers) {
    xhr.setRequestHeader(...header);
  }
  xhr.send(opts.body || null);
  let headers = xhr.getAllResponseHeaders();
  headers = headers && headers.split("\r\n").filter(Boolean).map((header) => header.split(": ", 2));
  return new syncFetch.Response(xhr.response, {
    url: xhr.responseURL,
    status: xhr.status,
    statusText: xhr.statusText,
    headers,
    redirected: xhr.responseURL !== url
  });
}
function parseArgs(resource, init) {
  const request = [];
  if (resource instanceof syncFetch.Request) {
    request.push(resource.url);
    request.push({
      method: resource.method,
      headers: resource.headers,
      body: resource.body
    });
  } else {
    request.push(resource, {});
  }
  Object.assign(request[1], init);
  request[1].headers = new syncFetch.Headers(request[1].headers || {});
  return request;
}
const INTERNALS = Symbol("SyncFetch Internals");
class SyncRequest extends Request {
  constructor(resource, init = {}, body = init.body) {
    super(resource, init);
    this[INTERNALS] = {
      body: body ? Buffer$1.from(body) : null
    };
  }
  clone() {
    checkBody(this);
    return new SyncRequest(this.url, this);
  }
}
class SyncResponse extends Response {
  constructor(body, init = {}) {
    body = body ? Buffer$1.from(body) : null;
    super(createStream(body), init);
    this[INTERNALS] = {
      url: init.url,
      redirected: init.redirected,
      body
    };
  }
  get url() {
    return this[INTERNALS].url;
  }
  get redirected() {
    return this[INTERNALS].redirected;
  }
  clone() {
    checkBody(this);
    return new SyncResponse(this[INTERNALS].body, {
      url: this.url,
      headers: this.headers,
      status: this.status,
      statusText: this.statusText,
      redirected: this.redirected
    });
  }
}
class Body {
  constructor(body) {
    this[INTERNALS] = {
      body: Buffer$1.from(body)
    };
  }
  static mixin(prototype) {
    for (const name2 of Object.getOwnPropertyNames(Body.prototype)) {
      if (name2 === "constructor") {
        continue;
      }
      const desc = Object.getOwnPropertyDescriptor(Body.prototype, name2);
      Object.defineProperty(prototype, name2, __spreadProps(__spreadValues({}, desc), { enumerable: true }));
    }
  }
  arrayBuffer() {
    checkBody(this);
    const buffer2 = consumeBody(this);
    return buffer2.buffer.slice(buffer2.byteOffset, buffer2.byteOffset + buffer2.byteLength);
  }
  blob() {
    checkBody(this);
    const type2 = this.headers && this.headers.get("content-type");
    return new Blob([consumeBody(this)], type2 && { type: type2 });
  }
  text() {
    checkBody(this);
    return consumeBody(this).toString();
  }
  json() {
    checkBody(this);
    try {
      return JSON.parse(consumeBody(this).toString());
    } catch (err) {
      throw new TypeError(`invalid json response body at ${this.url} reason: ${err.message}`, "invalid-json");
    }
  }
  buffer() {
    checkBody(this);
    return consumeBody(this).clone();
  }
}
function checkBody(body) {
  if (body.bodyUsed) {
    throw new TypeError(`body used already for: ${body.url}`);
  }
}
function consumeBody(body) {
  _super(body, "arrayBuffer")();
  return body[INTERNALS].body || Buffer$1.alloc(0);
}
function _super(self2, method) {
  return Object.getPrototypeOf(Object.getPrototypeOf(self2))[method].bind(self2);
}
function createStream(body) {
  return new ReadableStream({
    start(controller) {
      controller.enqueue(body);
      controller.close();
    }
  });
}
Body.mixin(SyncRequest.prototype);
Body.mixin(SyncResponse.prototype);
syncFetch.Headers = self.Headers;
syncFetch.Request = SyncRequest;
syncFetch.Response = SyncResponse;
var browser = syncFetch;
const separator$1 = "\r\n\r\n";
async function* generate$1(stream, boundary, options) {
  const len_boundary = Buffer.byteLength(boundary), is_eager = !options || !options.multiple;
  let buffer2 = Buffer.alloc(0), is_preamble = true, payloads = [];
  outer:
    for await (const chunk of stream) {
      let idx_boundary = buffer2.byteLength;
      buffer2 = Buffer.concat([buffer2, chunk]);
      const idx_chunk = chunk.indexOf(boundary);
      if (!!~idx_chunk) {
        idx_boundary += idx_chunk;
      } else {
        idx_boundary = buffer2.indexOf(boundary);
      }
      payloads = [];
      while (!!~idx_boundary) {
        const current = buffer2.slice(0, idx_boundary);
        const next = buffer2.slice(idx_boundary + len_boundary);
        if (is_preamble) {
          is_preamble = false;
        } else {
          const headers = {};
          const idx_headers = current.indexOf(separator$1);
          const arr_headers = buffer2.slice(0, idx_headers).toString().trim().split(/\r\n/);
          let tmp;
          while (tmp = arr_headers.shift()) {
            tmp = tmp.split(": ");
            headers[tmp.shift().toLowerCase()] = tmp.join(": ");
          }
          let body = current.slice(idx_headers + separator$1.length, current.lastIndexOf("\r\n"));
          let is_json = false;
          tmp = headers["content-type"];
          if (tmp && !!~tmp.indexOf("application/json")) {
            try {
              body = JSON.parse(body.toString());
              is_json = true;
            } catch (_) {
            }
          }
          tmp = { headers, body, json: is_json };
          is_eager ? yield tmp : payloads.push(tmp);
          if (next.slice(0, 2).toString() === "--")
            break outer;
        }
        buffer2 = next;
        idx_boundary = buffer2.indexOf(boundary);
      }
      if (payloads.length)
        yield payloads;
    }
  if (payloads.length)
    yield payloads;
}
async function meros$1(response, options) {
  const ctype = response.headers["content-type"];
  if (!ctype || !~ctype.indexOf("multipart/mixed"))
    return response;
  const idx_boundary = ctype.indexOf("boundary=");
  return generate$1(response, `--${!!~idx_boundary ? ctype.substring(idx_boundary + 9).trim().replace(/['"]/g, "") : "-"}`, options);
}
const separator = "\r\n\r\n";
const decoder = new TextDecoder();
async function* generate(stream, boundary, options) {
  const reader = stream.getReader(), is_eager = !options || !options.multiple;
  let buffer2 = "", is_preamble = true, payloads = [];
  try {
    let result2;
    outer:
      while (!(result2 = await reader.read()).done) {
        const chunk = decoder.decode(result2.value);
        const idx_chunk = chunk.indexOf(boundary);
        let idx_boundary = buffer2.length;
        buffer2 += chunk;
        if (!!~idx_chunk) {
          idx_boundary += idx_chunk;
        } else {
          idx_boundary = buffer2.indexOf(boundary);
        }
        payloads = [];
        while (!!~idx_boundary) {
          const current = buffer2.substring(0, idx_boundary);
          const next = buffer2.substring(idx_boundary + boundary.length);
          if (is_preamble) {
            is_preamble = false;
          } else {
            const headers = {};
            const idx_headers = current.indexOf(separator);
            const arr_headers = buffer2.slice(0, idx_headers).toString().trim().split(/\r\n/);
            let tmp;
            while (tmp = arr_headers.shift()) {
              tmp = tmp.split(": ");
              headers[tmp.shift().toLowerCase()] = tmp.join(": ");
            }
            let body = current.substring(idx_headers + separator.length, current.lastIndexOf("\r\n"));
            let is_json = false;
            tmp = headers["content-type"];
            if (tmp && !!~tmp.indexOf("application/json")) {
              try {
                body = JSON.parse(body);
                is_json = true;
              } catch (_) {
              }
            }
            tmp = { headers, body, json: is_json };
            is_eager ? yield tmp : payloads.push(tmp);
            if (next.substring(0, 2) === "--")
              break outer;
          }
          buffer2 = next;
          idx_boundary = buffer2.indexOf(boundary);
        }
        if (payloads.length)
          yield payloads;
      }
  } finally {
    if (payloads.length)
      yield payloads;
    reader.releaseLock();
  }
}
async function meros(response, options) {
  if (!response.ok || !response.body || response.bodyUsed)
    return response;
  const ctype = response.headers.get("content-type");
  if (!ctype || !~ctype.indexOf("multipart/mixed"))
    return response;
  const idx_boundary = ctype.indexOf("boundary=");
  return generate(response.body, `--${!!~idx_boundary ? ctype.substring(idx_boundary + 9).trim().replace(/['"]/g, "") : "-"}`, options);
}
const defaultAsyncFetch = async (input, init) => {
  return fetch$1(input, init);
};
const defaultSyncFetch = (input, init) => {
  if (typeof input === "string") {
    init === null || init === void 0 ? true : delete init.signal;
  } else {
    delete input.signal;
  }
  return browser(input, init);
};
function isIncomingMessage(body) {
  return body != null && typeof body === "object" && "pipe" in body;
}
async function handleMultipartMixedResponse(response) {
  const body = await response.body;
  const contentType = response.headers.get("content-type") || "";
  let asyncIterator;
  if (isIncomingMessage(body)) {
    body.headers = {
      "content-type": contentType
    };
    asyncIterator = await meros$1(body);
  } else {
    asyncIterator = await meros(response);
  }
  const executionResult = {};
  return mapAsyncIterator(asyncIterator, (part2) => {
    if (part2.json) {
      const chunk = part2.body;
      if (chunk.path) {
        if (chunk.data) {
          const path = ["data"];
          dset(executionResult, path.concat(chunk.path), chunk.data);
        }
        if (chunk.errors) {
          executionResult.errors = (executionResult.errors || []).concat(chunk.errors);
        }
      } else {
        if (chunk.data) {
          executionResult.data = chunk.data;
        }
        if (chunk.errors) {
          executionResult.errors = chunk.errors;
        }
      }
      return executionResult;
    }
  });
}
async function* handleReadable(readable) {
  const decoder2 = new TextDecoder();
  outer:
    for await (const chunk of readable) {
      const chunkStr = typeof chunk === "string" ? chunk : decoder2.decode(chunk);
      for (const part2 of chunkStr.split("\n\n")) {
        if (part2) {
          const eventStr = part2.split("event: ")[1];
          const dataStr = part2.split("data: ")[1];
          if (eventStr === "complete") {
            break outer;
          }
          if (dataStr) {
            const data = JSON.parse(dataStr);
            yield data.payload || data;
          }
        }
      }
    }
}
async function* handleReadableStream(stream) {
  const decoder2 = new TextDecoder();
  const reader = stream.getReader();
  let buffer2;
  let position = 0;
  let fieldLength = -1;
  let discardTrailingNewline = false;
  try {
    let result2;
    let message = {
      data: "",
      event: "",
      id: "",
      retry: void 0
    };
    while (!(result2 = await reader.read()).done) {
      const arr = result2.value;
      if (buffer2 === void 0) {
        buffer2 = arr;
        position = 0;
        fieldLength = -1;
      } else {
        buffer2 = concat(buffer2, arr);
      }
      const bufLength = buffer2.length;
      let lineStart = 0;
      while (position < bufLength) {
        if (discardTrailingNewline) {
          if (buffer2[position] === 10) {
            lineStart = ++position;
          }
          discardTrailingNewline = false;
        }
        let lineEnd = -1;
        for (; position < bufLength && lineEnd === -1; ++position) {
          switch (buffer2[position]) {
            case 58: {
              if (fieldLength === -1) {
                fieldLength = position - lineStart;
              }
              break;
            }
            case 13: {
              discardTrailingNewline = true;
              break;
            }
            case 10: {
              lineEnd = position;
              break;
            }
          }
        }
        if (lineEnd === -1) {
          break;
        }
        const line = buffer2.subarray(lineStart, lineEnd);
        if (line.length === 0) {
          if (message.event || message.data) {
            yield JSON.parse(message.data);
            message = {
              data: "",
              event: "",
              id: "",
              retry: void 0
            };
          }
        } else if (fieldLength > 0) {
          const field = decoder2.decode(line.subarray(0, fieldLength));
          const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
          const value = decoder2.decode(line.subarray(valueOffset));
          switch (field) {
            case "data":
              message.data = message.data ? message.data + "\n" + value : value;
              break;
            case "event":
              message.event = value;
              break;
            case "id":
              message.id = value;
              break;
            case "retry": {
              const retry = parseInt(value, 10);
              message.retry = retry;
              break;
            }
          }
        }
        lineStart = position;
        fieldLength = -1;
      }
      if (lineStart === bufLength) {
        buffer2 = void 0;
      } else if (lineStart !== 0) {
        buffer2 = buffer2.subarray(lineStart);
        position -= lineStart;
      }
    }
  } finally {
    reader.releaseLock();
  }
}
function concat(a, b) {
  const res = new Uint8Array(a.length + b.length);
  res.set(a);
  res.set(b, a.length);
  return res;
}
async function handleEventStreamResponse(response) {
  const body = await response.body;
  if (body) {
    if (isAsyncIterable(body)) {
      return handleReadable(body);
    }
    return handleReadableStream(body);
  }
  throw new Error("Response body is expected to be a readable stream but got; " + inspect(body));
}
function addCancelToResponseStream(resultStream, controller) {
  return getAsyncIterableWithCancel(resultStream, () => {
    if (!controller.signal.aborted) {
      controller.abort();
    }
  });
}
function isBlob(obj) {
  return typeof obj.arrayBuffer === "function";
}
function isGraphQLUpload(upload) {
  return typeof upload.createReadStream === "function";
}
function isPromiseLike(obj) {
  return typeof obj.then === "function";
}
const asyncImport = (moduleName) => import(moduleName);
const syncImport = (moduleName) => require(moduleName);
var SubscriptionProtocol;
(function(SubscriptionProtocol2) {
  SubscriptionProtocol2["WS"] = "WS";
  SubscriptionProtocol2["LEGACY_WS"] = "LEGACY_WS";
  SubscriptionProtocol2["SSE"] = "SSE";
  SubscriptionProtocol2["GRAPHQL_SSE"] = "GRAPHQL_SSE";
})(SubscriptionProtocol || (SubscriptionProtocol = {}));
const isCompatibleUri = (uri) => {
  if (validUrl.exports.isWebUri(uri)) {
    return true;
  }
  const wsUri = uri.replace("wss://", "http://").replace("ws://", "http://");
  return !!validUrl.exports.isWebUri(wsUri);
};
class UrlLoader {
  async canLoad(pointer, options) {
    return this.canLoadSync(pointer, options);
  }
  canLoadSync(pointer, _options) {
    return isCompatibleUri(pointer);
  }
  createFormDataFromVariables({ query, variables, operationName, extensions }) {
    const vars = Object.assign({}, variables);
    const { clone, files } = extractFiles$1(vars, "variables", (v2) => isExtractableFile$1(v2) || (v2 === null || v2 === void 0 ? void 0 : v2.promise) || isAsyncIterable(v2) || (v2 === null || v2 === void 0 ? void 0 : v2.then) || typeof (v2 === null || v2 === void 0 ? void 0 : v2.arrayBuffer) === "function");
    const map2 = {};
    const uploads = [];
    let currIndex = 0;
    for (const [file, curr] of files) {
      map2[currIndex] = curr;
      uploads[currIndex] = file;
      currIndex++;
    }
    const form = new FormData();
    form.append("operations", JSON.stringify({
      query,
      variables: clone,
      operationName,
      extensions
    }));
    form.append("map", JSON.stringify(map2));
    function handleUpload(upload, i) {
      const indexStr = i.toString();
      if (upload != null) {
        const filename = upload.filename || upload.name || upload.path || `blob-${indexStr}`;
        if (isPromiseLike(upload)) {
          return upload.then((resolvedUpload) => handleUpload(resolvedUpload, i));
        } else if (isBlob(upload)) {
          return upload.arrayBuffer().then((arrayBuffer) => {
            form.append(indexStr, new File$1([arrayBuffer], filename, { type: upload.type }), filename);
          });
        } else if (isGraphQLUpload(upload)) {
          const stream = upload.createReadStream();
          const chunks = [];
          return Promise.resolve().then(async () => {
            for await (const chunk of stream) {
              if (chunk) {
                chunks.push(...chunk);
              }
            }
            const blobPart = new Uint8Array(chunks);
            form.append(indexStr, new File$1([blobPart], filename, { type: upload.mimetype }), filename);
          });
        } else {
          form.append(indexStr, new File$1([upload], filename), filename);
        }
      }
    }
    return ValueOrPromise.all(uploads.map((upload, i) => new ValueOrPromise(() => handleUpload(upload, i)))).then(() => form).resolve();
  }
  prepareGETUrl({ baseUrl, query, variables, operationName, extensions }) {
    const HTTP_URL = switchProtocols(baseUrl, {
      wss: "https",
      ws: "http"
    });
    const dummyHostname = "https://dummyhostname.com";
    const validUrl2 = HTTP_URL.startsWith("http") ? HTTP_URL : HTTP_URL.startsWith("/") ? `${dummyHostname}${HTTP_URL}` : `${dummyHostname}/${HTTP_URL}`;
    const urlObj = new URL(validUrl2);
    urlObj.searchParams.set("query", query);
    if (variables && Object.keys(variables).length > 0) {
      urlObj.searchParams.set("variables", JSON.stringify(variables));
    }
    if (operationName) {
      urlObj.searchParams.set("operationName", operationName);
    }
    if (extensions) {
      urlObj.searchParams.set("extensions", JSON.stringify(extensions));
    }
    const finalUrl = urlObj.toString().replace(dummyHostname, "");
    return finalUrl;
  }
  buildHTTPExecutor(endpoint, fetch2, options) {
    const defaultMethod = this.getDefaultMethodFromOptions(options === null || options === void 0 ? void 0 : options.method, "POST");
    const HTTP_URL = switchProtocols(endpoint, {
      wss: "https",
      ws: "http"
    });
    const executor = (request) => {
      var _a2;
      const controller = new AbortController$1();
      let method = defaultMethod;
      if (options === null || options === void 0 ? void 0 : options.useGETForQueries) {
        const operationAst = getOperationASTFromRequest(request);
        const operationType = operationAst.operation;
        if (operationType === "query") {
          method = "GET";
        }
      }
      const headers = Object.assign({}, options === null || options === void 0 ? void 0 : options.headers, ((_a2 = request.extensions) === null || _a2 === void 0 ? void 0 : _a2.headers) || {});
      const acceptedProtocols = [`application/json`];
      if (method === "GET" && (options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.SSE) {
        acceptedProtocols.push("text/event-stream");
      } else {
        acceptedProtocols.push("multipart/mixed");
      }
      const accept = acceptedProtocols.join(", ");
      const query = print(request.document);
      const requestBody = {
        query,
        variables: request.variables,
        operationName: request.operationName,
        extensions: request.extensions
      };
      return new ValueOrPromise(() => {
        switch (method) {
          case "GET":
            const finalUrl = this.prepareGETUrl(__spreadValues({
              baseUrl: endpoint
            }, requestBody));
            return fetch2(finalUrl, {
              method: "GET",
              credentials: "include",
              headers: __spreadValues({
                accept
              }, headers),
              signal: controller.signal
            });
          case "POST":
            if (options === null || options === void 0 ? void 0 : options.multipart) {
              return new ValueOrPromise(() => this.createFormDataFromVariables(requestBody)).then((form) => fetch2(HTTP_URL, {
                method: "POST",
                credentials: "include",
                body: form,
                headers: __spreadValues({
                  accept
                }, headers),
                signal: controller.signal
              })).resolve();
            } else {
              return fetch2(HTTP_URL, {
                method: "POST",
                credentials: "include",
                body: JSON.stringify(requestBody),
                headers: __spreadValues({
                  accept,
                  "content-type": "application/json"
                }, headers),
                signal: controller.signal
              });
            }
        }
      }).then((fetchResult) => {
        const contentType = fetchResult.headers.get("content-type");
        if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("text/event-stream")) {
          return handleEventStreamResponse(fetchResult).then((resultStream) => addCancelToResponseStream(resultStream, controller));
        } else if (contentType === null || contentType === void 0 ? void 0 : contentType.includes("multipart/mixed")) {
          return handleMultipartMixedResponse(fetchResult).then((resultStream) => addCancelToResponseStream(resultStream, controller));
        }
        return fetchResult.json();
      }).resolve();
    };
    return executor;
  }
  buildWSExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams) {
    const WS_URL = switchProtocols(subscriptionsEndpoint, {
      https: "wss",
      http: "ws"
    });
    const subscriptionClient = createClient$1({
      url: WS_URL,
      webSocketImpl,
      connectionParams,
      lazy: true
    });
    return async ({ document: document2, variables, operationName, extensions }) => {
      const query = print(document2);
      return observableToAsyncIterable({
        subscribe: (observer) => {
          const unsubscribe = subscriptionClient.subscribe({
            query,
            variables,
            operationName,
            extensions
          }, observer);
          return {
            unsubscribe
          };
        }
      });
    };
  }
  buildWSLegacyExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams) {
    const WS_URL = switchProtocols(subscriptionsEndpoint, {
      https: "wss",
      http: "ws"
    });
    const subscriptionClient = new SubscriptionClient_1(WS_URL, {
      connectionParams,
      lazy: true
    }, webSocketImpl);
    return async ({ document: document2, variables, operationName }) => {
      return observableToAsyncIterable(subscriptionClient.request({
        query: document2,
        variables,
        operationName
      }));
    };
  }
  buildGraphQLSSEExecutor(endpoint, fetch2, options = {}) {
    const { headers } = options;
    const client2 = createClient(__spreadProps(__spreadValues({}, options.graphqlSseOptions), {
      url: endpoint,
      fetchFn: fetch2,
      abortControllerImpl: AbortController$1,
      headers
    }));
    return async ({ document: document2, variables, operationName, extensions }) => {
      return observableToAsyncIterable({
        subscribe: (observer) => {
          const unsubscribe = client2.subscribe({
            query: document2,
            variables,
            operationName,
            extensions
          }, observer);
          return {
            unsubscribe
          };
        }
      });
    };
  }
  getFetch(customFetch, importFn) {
    if (customFetch) {
      if (typeof customFetch === "string") {
        const [moduleName, fetchFnName] = customFetch.split("#");
        return new ValueOrPromise(() => importFn(moduleName)).then((module2) => fetchFnName ? module2[fetchFnName] : module2).resolve();
      } else if (typeof customFetch === "function") {
        return customFetch;
      }
    }
    if (importFn === asyncImport) {
      return defaultAsyncFetch;
    } else {
      return defaultSyncFetch;
    }
  }
  getDefaultMethodFromOptions(method, defaultMethod) {
    if (method) {
      defaultMethod = method;
    }
    return defaultMethod;
  }
  getWebSocketImpl(importFn, options) {
    if (typeof (options === null || options === void 0 ? void 0 : options.webSocketImpl) === "string") {
      const [moduleName, webSocketImplName] = options.webSocketImpl.split("#");
      return new ValueOrPromise(() => importFn(moduleName)).then((importedModule) => webSocketImplName ? importedModule[webSocketImplName] : importedModule).resolve();
    } else {
      const websocketImpl = (options === null || options === void 0 ? void 0 : options.webSocketImpl) || browser$1;
      return websocketImpl;
    }
  }
  async buildSubscriptionExecutor(subscriptionsEndpoint, fetch2, options) {
    if ((options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.SSE) {
      return this.buildHTTPExecutor(subscriptionsEndpoint, fetch2, __spreadProps(__spreadValues({}, options), {
        method: "GET"
      }));
    } else if ((options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.GRAPHQL_SSE) {
      if (!(options === null || options === void 0 ? void 0 : options.subscriptionsEndpoint)) {
        subscriptionsEndpoint += "/stream";
      }
      return this.buildGraphQLSSEExecutor(subscriptionsEndpoint, fetch2, options);
    } else {
      const webSocketImpl = await this.getWebSocketImpl(asyncImport, options);
      const connectionParams = () => ({ headers: options === null || options === void 0 ? void 0 : options.headers });
      if ((options === null || options === void 0 ? void 0 : options.subscriptionsProtocol) === SubscriptionProtocol.LEGACY_WS) {
        return this.buildWSLegacyExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams);
      } else {
        return this.buildWSExecutor(subscriptionsEndpoint, webSocketImpl, connectionParams);
      }
    }
  }
  async getExecutorAsync(endpoint, options) {
    const fetch2 = await this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, asyncImport);
    const httpExecutor = this.buildHTTPExecutor(endpoint, fetch2, options);
    const subscriptionsEndpoint = (options === null || options === void 0 ? void 0 : options.subscriptionsEndpoint) || endpoint;
    const subscriptionExecutor = await this.buildSubscriptionExecutor(subscriptionsEndpoint, fetch2, options);
    return (request) => {
      const operationAst = getOperationASTFromRequest(request);
      if (operationAst.operation === "subscription" || isLiveQueryOperationDefinitionNode(operationAst, request.variables)) {
        return subscriptionExecutor(request);
      }
      return httpExecutor(request);
    };
  }
  getExecutorSync(endpoint, options) {
    const fetch2 = this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, syncImport);
    const executor = this.buildHTTPExecutor(endpoint, fetch2, options);
    return executor;
  }
  handleSDL(pointer, fetch2, options) {
    const defaultMethod = this.getDefaultMethodFromOptions(options === null || options === void 0 ? void 0 : options.method, "GET");
    return new ValueOrPromise(() => fetch2(pointer, {
      method: defaultMethod,
      headers: options.headers
    })).then((response) => response.text()).then((schemaString) => parseGraphQLSDL(pointer, schemaString, options)).resolve();
  }
  async load(pointer, options) {
    if (!await this.canLoad(pointer, options)) {
      return [];
    }
    let source = {
      location: pointer
    };
    const fetch2 = await this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, asyncImport);
    let executor = await this.getExecutorAsync(pointer, options);
    if ((options === null || options === void 0 ? void 0 : options.handleAsSDL) || pointer.endsWith(".graphql") || pointer.endsWith(".graphqls")) {
      source = await this.handleSDL(pointer, fetch2, options);
      if (!source.schema && !source.document && !source.rawSDL) {
        throw new Error(`Invalid SDL response`);
      }
      source.schema = source.schema || (source.document ? buildASTSchema(source.document, options) : source.rawSDL ? buildSchema(source.rawSDL, options) : void 0);
    } else {
      source.schema = await introspectSchema(executor, {}, options);
    }
    if (!source.schema) {
      throw new Error(`Invalid introspected schema`);
    }
    if (options === null || options === void 0 ? void 0 : options.endpoint) {
      executor = await this.getExecutorAsync(options.endpoint, options);
    }
    source.schema = wrapSchema({
      schema: source.schema,
      executor
    });
    return [source];
  }
  loadSync(pointer, options) {
    if (!this.canLoadSync(pointer, options)) {
      return [];
    }
    let source = {
      location: pointer
    };
    const fetch2 = this.getFetch(options === null || options === void 0 ? void 0 : options.customFetch, syncImport);
    let executor = this.getExecutorSync(pointer, options);
    if ((options === null || options === void 0 ? void 0 : options.handleAsSDL) || pointer.endsWith(".graphql") || pointer.endsWith(".graphqls")) {
      source = this.handleSDL(pointer, fetch2, options);
      if (!source.schema && !source.document && !source.rawSDL) {
        throw new Error(`Invalid SDL response`);
      }
      source.schema = source.schema || (source.document ? buildASTSchema(source.document, options) : source.rawSDL ? buildSchema(source.rawSDL, options) : void 0);
    } else {
      source.schema = introspectSchema(executor, {}, options);
    }
    if (!source.schema) {
      throw new Error(`Invalid introspected schema`);
    }
    if (options === null || options === void 0 ? void 0 : options.endpoint) {
      executor = this.getExecutorSync(options.endpoint, options);
    }
    source.schema = wrapSchema({
      schema: source.schema,
      executor
    });
    return [source];
  }
}
function switchProtocols(pointer, protocolMap) {
  return Object.entries(protocolMap).reduce((prev, [source, target2]) => prev.replace(`${source}://`, `${target2}://`).replace(`${source}:\\`, `${target2}:\\`), pointer);
}
var dist = {};
var Explorer$1 = {};
Object.defineProperty(Explorer$1, "__esModule", {
  value: true
});
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
  return typeof obj;
} : function(obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var _slicedToArray = function() {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"])
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  return function(arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
var _extends = Object.assign || function(target2) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target2[key] = source[key];
      }
    }
  }
  return target2;
};
var _createClass = function() {
  function defineProperties(target2, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target2, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
Explorer$1.defaultValue = defaultValue;
var _react = react.exports;
var React = _interopRequireWildcard(_react);
var _graphql = require$$1$1;
function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
      }
    }
    newObj.default = obj;
    return newObj;
  }
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toConsumableArray(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  } else {
    return Array.from(arr);
  }
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var defaultColors = {
  keyword: "#B11A04",
  def: "#D2054E",
  property: "#1F61A0",
  qualifier: "#1C92A9",
  attribute: "#8B2BB9",
  number: "#2882F9",
  string: "#D64292",
  builtin: "#D47509",
  string2: "#0B7FC7",
  variable: "#397D13",
  atom: "#CA9800"
};
var defaultArrowOpen = React.createElement("svg", { width: "12", height: "9" }, React.createElement("path", { fill: "#666", d: "M 0 2 L 9 2 L 4.5 7.5 z" }));
var defaultArrowClosed = React.createElement("svg", { width: "12", height: "9" }, React.createElement("path", { fill: "#666", d: "M 0 0 L 0 9 L 5.5 4.5 z" }));
var defaultCheckboxChecked = React.createElement("svg", {
  style: { marginRight: "3px", marginLeft: "-3px" },
  width: "12",
  height: "12",
  viewBox: "0 0 18 18",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, React.createElement("path", {
  d: "M16 0H2C0.9 0 0 0.9 0 2V16C0 17.1 0.9 18 2 18H16C17.1 18 18 17.1 18 16V2C18 0.9 17.1 0 16 0ZM16 16H2V2H16V16ZM14.99 6L13.58 4.58L6.99 11.17L4.41 8.6L2.99 10.01L6.99 14L14.99 6Z",
  fill: "#666"
}));
var defaultCheckboxUnchecked = React.createElement("svg", {
  style: { marginRight: "3px", marginLeft: "-3px" },
  width: "12",
  height: "12",
  viewBox: "0 0 18 18",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, React.createElement("path", {
  d: "M16 2V16H2V2H16ZM16 0H2C0.9 0 0 0.9 0 2V16C0 17.1 0.9 18 2 18H16C17.1 18 18 17.1 18 16V2C18 0.9 17.1 0 16 0Z",
  fill: "#CCC"
}));
function Checkbox(props) {
  return props.checked ? props.styleConfig.checkboxChecked : props.styleConfig.checkboxUnchecked;
}
function defaultGetDefaultFieldNames(type2) {
  var fields = type2.getFields();
  if (fields["id"]) {
    var res = ["id"];
    if (fields["email"]) {
      res.push("email");
    } else if (fields["name"]) {
      res.push("name");
    }
    return res;
  }
  if (fields["edges"]) {
    return ["edges"];
  }
  if (fields["node"]) {
    return ["node"];
  }
  if (fields["nodes"]) {
    return ["nodes"];
  }
  var leafFieldNames = [];
  Object.keys(fields).forEach(function(fieldName) {
    if ((0, _graphql.isLeafType)(fields[fieldName].type)) {
      leafFieldNames.push(fieldName);
    }
  });
  if (!leafFieldNames.length) {
    return ["__typename"];
  }
  return leafFieldNames.slice(0, 2);
}
function isRequiredArgument(arg) {
  return (0, _graphql.isNonNullType)(arg.type) && arg.defaultValue === void 0;
}
function unwrapOutputType(outputType) {
  var unwrappedType = outputType;
  while ((0, _graphql.isWrappingType)(unwrappedType)) {
    unwrappedType = unwrappedType.ofType;
  }
  return unwrappedType;
}
function unwrapInputType(inputType) {
  var unwrappedType = inputType;
  while ((0, _graphql.isWrappingType)(unwrappedType)) {
    unwrappedType = unwrappedType.ofType;
  }
  return unwrappedType;
}
function coerceArgValue(argType, value) {
  if (typeof value !== "string" && value.kind === "VariableDefinition") {
    return value.variable;
  } else if ((0, _graphql.isScalarType)(argType)) {
    try {
      switch (argType.name) {
        case "String":
          return {
            kind: "StringValue",
            value: String(argType.parseValue(value))
          };
        case "Float":
          return {
            kind: "FloatValue",
            value: String(argType.parseValue(parseFloat(value)))
          };
        case "Int":
          return {
            kind: "IntValue",
            value: String(argType.parseValue(parseInt(value, 10)))
          };
        case "Boolean":
          try {
            var parsed = JSON.parse(value);
            if (typeof parsed === "boolean") {
              return { kind: "BooleanValue", value: parsed };
            } else {
              return { kind: "BooleanValue", value: false };
            }
          } catch (e) {
            return {
              kind: "BooleanValue",
              value: false
            };
          }
        default:
          return {
            kind: "StringValue",
            value: String(argType.parseValue(value))
          };
      }
    } catch (e) {
      console.error("error coercing arg value", e, value);
      return { kind: "StringValue", value };
    }
  } else {
    try {
      var parsedValue = argType.parseValue(value);
      if (parsedValue) {
        return { kind: "EnumValue", value: String(parsedValue) };
      } else {
        return { kind: "EnumValue", value: argType.getValues()[0].name };
      }
    } catch (e) {
      return { kind: "EnumValue", value: argType.getValues()[0].name };
    }
  }
}
var InputArgView = function(_React$PureComponent) {
  _inherits(InputArgView2, _React$PureComponent);
  function InputArgView2() {
    var _ref;
    var _temp, _this, _ret;
    _classCallCheck(this, InputArgView2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = InputArgView2.__proto__ || Object.getPrototypeOf(InputArgView2)).call.apply(_ref, [this].concat(args))), _this), _this._getArgSelection = function() {
      return _this.props.selection.fields.find(function(field) {
        return field.name.value === _this.props.arg.name;
      });
    }, _this._removeArg = function() {
      var selection = _this.props.selection;
      var argSelection = _this._getArgSelection();
      _this._previousArgSelection = argSelection;
      _this.props.modifyFields(selection.fields.filter(function(field) {
        return field !== argSelection;
      }), true);
    }, _this._addArg = function() {
      var _this$props = _this.props, selection = _this$props.selection, arg = _this$props.arg, getDefaultScalarArgValue = _this$props.getDefaultScalarArgValue, parentField = _this$props.parentField, makeDefaultArg = _this$props.makeDefaultArg;
      var argType = unwrapInputType(arg.type);
      var argSelection = null;
      if (_this._previousArgSelection) {
        argSelection = _this._previousArgSelection;
      } else if ((0, _graphql.isInputObjectType)(argType)) {
        var _fields = argType.getFields();
        argSelection = {
          kind: "ObjectField",
          name: { kind: "Name", value: arg.name },
          value: {
            kind: "ObjectValue",
            fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, Object.keys(_fields).map(function(k) {
              return _fields[k];
            }))
          }
        };
      } else if ((0, _graphql.isLeafType)(argType)) {
        argSelection = {
          kind: "ObjectField",
          name: { kind: "Name", value: arg.name },
          value: getDefaultScalarArgValue(parentField, arg, argType)
        };
      }
      if (!argSelection) {
        console.error("Unable to add arg for argType", argType);
      } else {
        return _this.props.modifyFields([].concat(_toConsumableArray(selection.fields || []), [argSelection]), true);
      }
    }, _this._setArgValue = function(event, options) {
      var settingToNull = false;
      var settingToVariable = false;
      var settingToLiteralValue = false;
      try {
        if (event.kind === "VariableDefinition") {
          settingToVariable = true;
        } else if (event === null || typeof event === "undefined") {
          settingToNull = true;
        } else if (typeof event.kind === "string") {
          settingToLiteralValue = true;
        }
      } catch (e) {
      }
      var selection = _this.props.selection;
      var argSelection = _this._getArgSelection();
      if (!argSelection) {
        console.error("missing arg selection when setting arg value");
        return;
      }
      var argType = unwrapInputType(_this.props.arg.type);
      var handleable = (0, _graphql.isLeafType)(argType) || settingToVariable || settingToNull || settingToLiteralValue;
      if (!handleable) {
        console.warn("Unable to handle non leaf types in InputArgView.setArgValue", event);
        return;
      }
      var targetValue = void 0;
      var value = void 0;
      if (event === null || typeof event === "undefined") {
        value = null;
      } else if (!event.target && !!event.kind && event.kind === "VariableDefinition") {
        targetValue = event;
        value = targetValue.variable;
      } else if (typeof event.kind === "string") {
        value = event;
      } else if (event.target && typeof event.target.value === "string") {
        targetValue = event.target.value;
        value = coerceArgValue(argType, targetValue);
      }
      var newDoc = _this.props.modifyFields((selection.fields || []).map(function(field) {
        var isTarget = field === argSelection;
        var newField = isTarget ? _extends({}, field, {
          value
        }) : field;
        return newField;
      }), options);
      return newDoc;
    }, _this._modifyChildFields = function(fields) {
      return _this.props.modifyFields(_this.props.selection.fields.map(function(field) {
        return field.name.value === _this.props.arg.name ? _extends({}, field, {
          value: {
            kind: "ObjectValue",
            fields
          }
        }) : field;
      }), true);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  _createClass(InputArgView2, [{
    key: "render",
    value: function render() {
      var _props = this.props, arg = _props.arg, parentField = _props.parentField;
      var argSelection = this._getArgSelection();
      return React.createElement(AbstractArgView, {
        argValue: argSelection ? argSelection.value : null,
        arg,
        parentField,
        addArg: this._addArg,
        removeArg: this._removeArg,
        setArgFields: this._modifyChildFields,
        setArgValue: this._setArgValue,
        getDefaultScalarArgValue: this.props.getDefaultScalarArgValue,
        makeDefaultArg: this.props.makeDefaultArg,
        onRunOperation: this.props.onRunOperation,
        styleConfig: this.props.styleConfig,
        onCommit: this.props.onCommit,
        definition: this.props.definition
      });
    }
  }]);
  return InputArgView2;
}(React.PureComponent);
function defaultValue(argType) {
  if ((0, _graphql.isEnumType)(argType)) {
    return { kind: "EnumValue", value: argType.getValues()[0].name };
  } else {
    switch (argType.name) {
      case "String":
        return { kind: "StringValue", value: "" };
      case "Float":
        return { kind: "FloatValue", value: "1.5" };
      case "Int":
        return { kind: "IntValue", value: "10" };
      case "Boolean":
        return { kind: "BooleanValue", value: false };
      default:
        return { kind: "StringValue", value: "" };
    }
  }
}
function defaultGetDefaultScalarArgValue(parentField, arg, argType) {
  return defaultValue(argType);
}
var ArgView = function(_React$PureComponent2) {
  _inherits(ArgView2, _React$PureComponent2);
  function ArgView2() {
    var _ref2;
    var _temp2, _this2, _ret2;
    _classCallCheck(this, ArgView2);
    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return _ret2 = (_temp2 = (_this2 = _possibleConstructorReturn(this, (_ref2 = ArgView2.__proto__ || Object.getPrototypeOf(ArgView2)).call.apply(_ref2, [this].concat(args))), _this2), _this2._getArgSelection = function() {
      var selection = _this2.props.selection;
      return (selection.arguments || []).find(function(arg) {
        return arg.name.value === _this2.props.arg.name;
      });
    }, _this2._removeArg = function(commit) {
      var selection = _this2.props.selection;
      var argSelection = _this2._getArgSelection();
      _this2._previousArgSelection = argSelection;
      return _this2.props.modifyArguments((selection.arguments || []).filter(function(arg) {
        return arg !== argSelection;
      }), commit);
    }, _this2._addArg = function(commit) {
      var _this2$props = _this2.props, selection = _this2$props.selection, getDefaultScalarArgValue = _this2$props.getDefaultScalarArgValue, makeDefaultArg = _this2$props.makeDefaultArg, parentField = _this2$props.parentField, arg = _this2$props.arg;
      var argType = unwrapInputType(arg.type);
      var argSelection = null;
      if (_this2._previousArgSelection) {
        argSelection = _this2._previousArgSelection;
      } else if ((0, _graphql.isInputObjectType)(argType)) {
        var _fields2 = argType.getFields();
        argSelection = {
          kind: "Argument",
          name: { kind: "Name", value: arg.name },
          value: {
            kind: "ObjectValue",
            fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, Object.keys(_fields2).map(function(k) {
              return _fields2[k];
            }))
          }
        };
      } else if ((0, _graphql.isLeafType)(argType)) {
        argSelection = {
          kind: "Argument",
          name: { kind: "Name", value: arg.name },
          value: getDefaultScalarArgValue(parentField, arg, argType)
        };
      }
      if (!argSelection) {
        console.error("Unable to add arg for argType", argType);
        return null;
      } else {
        return _this2.props.modifyArguments([].concat(_toConsumableArray(selection.arguments || []), [argSelection]), commit);
      }
    }, _this2._setArgValue = function(event, options) {
      var settingToNull = false;
      var settingToVariable = false;
      var settingToLiteralValue = false;
      try {
        if (event.kind === "VariableDefinition") {
          settingToVariable = true;
        } else if (event === null || typeof event === "undefined") {
          settingToNull = true;
        } else if (typeof event.kind === "string") {
          settingToLiteralValue = true;
        }
      } catch (e) {
      }
      var selection = _this2.props.selection;
      var argSelection = _this2._getArgSelection();
      if (!argSelection && !settingToVariable) {
        console.error("missing arg selection when setting arg value");
        return;
      }
      var argType = unwrapInputType(_this2.props.arg.type);
      var handleable = (0, _graphql.isLeafType)(argType) || settingToVariable || settingToNull || settingToLiteralValue;
      if (!handleable) {
        console.warn("Unable to handle non leaf types in ArgView._setArgValue");
        return;
      }
      var targetValue = void 0;
      var value = void 0;
      if (event === null || typeof event === "undefined") {
        value = null;
      } else if (event.target && typeof event.target.value === "string") {
        targetValue = event.target.value;
        value = coerceArgValue(argType, targetValue);
      } else if (!event.target && event.kind === "VariableDefinition") {
        targetValue = event;
        value = targetValue.variable;
      } else if (typeof event.kind === "string") {
        value = event;
      }
      return _this2.props.modifyArguments((selection.arguments || []).map(function(a) {
        return a === argSelection ? _extends({}, a, {
          value
        }) : a;
      }), options);
    }, _this2._setArgFields = function(fields, commit) {
      var selection = _this2.props.selection;
      var argSelection = _this2._getArgSelection();
      if (!argSelection) {
        console.error("missing arg selection when setting arg value");
        return;
      }
      return _this2.props.modifyArguments((selection.arguments || []).map(function(a) {
        return a === argSelection ? _extends({}, a, {
          value: {
            kind: "ObjectValue",
            fields
          }
        }) : a;
      }), commit);
    }, _temp2), _possibleConstructorReturn(_this2, _ret2);
  }
  _createClass(ArgView2, [{
    key: "render",
    value: function render() {
      var _props2 = this.props, arg = _props2.arg, parentField = _props2.parentField;
      var argSelection = this._getArgSelection();
      return React.createElement(AbstractArgView, {
        argValue: argSelection ? argSelection.value : null,
        arg,
        parentField,
        addArg: this._addArg,
        removeArg: this._removeArg,
        setArgFields: this._setArgFields,
        setArgValue: this._setArgValue,
        getDefaultScalarArgValue: this.props.getDefaultScalarArgValue,
        makeDefaultArg: this.props.makeDefaultArg,
        onRunOperation: this.props.onRunOperation,
        styleConfig: this.props.styleConfig,
        onCommit: this.props.onCommit,
        definition: this.props.definition
      });
    }
  }]);
  return ArgView2;
}(React.PureComponent);
function isRunShortcut(event) {
  return event.ctrlKey && event.key === "Enter";
}
function canRunOperation(operationName) {
  return operationName !== "FragmentDefinition";
}
var ScalarInput = function(_React$PureComponent3) {
  _inherits(ScalarInput2, _React$PureComponent3);
  function ScalarInput2() {
    var _ref3;
    var _temp3, _this3, _ret3;
    _classCallCheck(this, ScalarInput2);
    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return _ret3 = (_temp3 = (_this3 = _possibleConstructorReturn(this, (_ref3 = ScalarInput2.__proto__ || Object.getPrototypeOf(ScalarInput2)).call.apply(_ref3, [this].concat(args))), _this3), _this3._handleChange = function(event) {
      _this3.props.setArgValue(event, true);
    }, _temp3), _possibleConstructorReturn(_this3, _ret3);
  }
  _createClass(ScalarInput2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var input = this._ref;
      var activeElement = document.activeElement;
      if (input && activeElement && !(activeElement instanceof HTMLTextAreaElement)) {
        input.focus();
        input.setSelectionRange(0, input.value.length);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this4 = this;
      var _props3 = this.props, arg = _props3.arg, argValue = _props3.argValue, styleConfig = _props3.styleConfig;
      var argType = unwrapInputType(arg.type);
      var value = typeof argValue.value === "string" ? argValue.value : "";
      var color = this.props.argValue.kind === "StringValue" ? styleConfig.colors.string : styleConfig.colors.number;
      return React.createElement("span", { style: { color } }, argType.name === "String" ? '"' : "", React.createElement("input", {
        style: {
          border: "none",
          borderBottom: "1px solid #888",
          outline: "none",
          width: Math.max(1, Math.min(15, value.length)) + "ch",
          color
        },
        ref: function ref(_ref4) {
          _this4._ref = _ref4;
        },
        type: "text",
        onChange: this._handleChange,
        value
      }), argType.name === "String" ? '"' : "");
    }
  }]);
  return ScalarInput2;
}(React.PureComponent);
var AbstractArgView = function(_React$PureComponent4) {
  _inherits(AbstractArgView2, _React$PureComponent4);
  function AbstractArgView2() {
    var _ref5;
    var _temp4, _this5, _ret4;
    _classCallCheck(this, AbstractArgView2);
    for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return _ret4 = (_temp4 = (_this5 = _possibleConstructorReturn(this, (_ref5 = AbstractArgView2.__proto__ || Object.getPrototypeOf(AbstractArgView2)).call.apply(_ref5, [this].concat(args))), _this5), _this5.state = { displayArgActions: false }, _temp4), _possibleConstructorReturn(_this5, _ret4);
  }
  _createClass(AbstractArgView2, [{
    key: "render",
    value: function render() {
      var _this6 = this;
      var _props4 = this.props, argValue = _props4.argValue, arg = _props4.arg, styleConfig = _props4.styleConfig;
      var argType = unwrapInputType(arg.type);
      var input = null;
      if (argValue) {
        if (argValue.kind === "Variable") {
          input = React.createElement("span", { style: { color: styleConfig.colors.variable } }, "$", argValue.name.value);
        } else if ((0, _graphql.isScalarType)(argType)) {
          if (argType.name === "Boolean") {
            input = React.createElement("select", {
              style: {
                color: styleConfig.colors.builtin
              },
              onChange: this.props.setArgValue,
              value: argValue.kind === "BooleanValue" ? argValue.value : void 0
            }, React.createElement("option", { key: "true", value: "true" }, "true"), React.createElement("option", { key: "false", value: "false" }, "false"));
          } else {
            input = React.createElement(ScalarInput, {
              setArgValue: this.props.setArgValue,
              arg,
              argValue,
              onRunOperation: this.props.onRunOperation,
              styleConfig: this.props.styleConfig
            });
          }
        } else if ((0, _graphql.isEnumType)(argType)) {
          if (argValue.kind === "EnumValue") {
            input = React.createElement("select", {
              style: {
                backgroundColor: "white",
                color: styleConfig.colors.string2
              },
              onChange: this.props.setArgValue,
              value: argValue.value
            }, argType.getValues().map(function(value) {
              return React.createElement("option", { key: value.name, value: value.name }, value.name);
            }));
          } else {
            console.error("arg mismatch between arg and selection", argType, argValue);
          }
        } else if ((0, _graphql.isInputObjectType)(argType)) {
          if (argValue.kind === "ObjectValue") {
            var _fields3 = argType.getFields();
            input = React.createElement("div", { style: { marginLeft: 16 } }, Object.keys(_fields3).sort().map(function(fieldName) {
              return React.createElement(InputArgView, {
                key: fieldName,
                arg: _fields3[fieldName],
                parentField: _this6.props.parentField,
                selection: argValue,
                modifyFields: _this6.props.setArgFields,
                getDefaultScalarArgValue: _this6.props.getDefaultScalarArgValue,
                makeDefaultArg: _this6.props.makeDefaultArg,
                onRunOperation: _this6.props.onRunOperation,
                styleConfig: _this6.props.styleConfig,
                onCommit: _this6.props.onCommit,
                definition: _this6.props.definition
              });
            }));
          } else {
            console.error("arg mismatch between arg and selection", argType, argValue);
          }
        }
      }
      var variablize = function variablize2() {
        var baseVariableName = arg.name;
        var conflictingNameCount = (_this6.props.definition.variableDefinitions || []).filter(function(varDef) {
          return varDef.variable.name.value.startsWith(baseVariableName);
        }).length;
        var variableName = void 0;
        if (conflictingNameCount > 0) {
          variableName = "" + baseVariableName + conflictingNameCount;
        } else {
          variableName = baseVariableName;
        }
        var argPrintedType = arg.type.toString();
        var argType2 = (0, _graphql.parseType)(argPrintedType);
        var base2 = {
          kind: "VariableDefinition",
          variable: {
            kind: "Variable",
            name: {
              kind: "Name",
              value: variableName
            }
          },
          type: argType2,
          directives: []
        };
        var variableDefinitionByName = function variableDefinitionByName2(name2) {
          return (_this6.props.definition.variableDefinitions || []).find(function(varDef) {
            return varDef.variable.name.value === name2;
          });
        };
        var variable = void 0;
        var subVariableUsageCountByName = {};
        if (typeof argValue !== "undefined" && argValue !== null) {
          var cleanedDefaultValue = (0, _graphql.visit)(argValue, {
            Variable: function Variable(node) {
              var varName = node.name.value;
              var varDef = variableDefinitionByName(varName);
              subVariableUsageCountByName[varName] = subVariableUsageCountByName[varName] + 1 || 1;
              if (!varDef) {
                return;
              }
              return varDef.defaultValue;
            }
          });
          var isNonNullable = base2.type.kind === "NonNullType";
          var unwrappedBase = isNonNullable ? _extends({}, base2, { type: base2.type.type }) : base2;
          variable = _extends({}, unwrappedBase, { defaultValue: cleanedDefaultValue });
        } else {
          variable = base2;
        }
        var newlyUnusedVariables = Object.entries(subVariableUsageCountByName).filter(function(_ref6) {
          var _ref7 = _slicedToArray(_ref6, 2);
          _ref7[0];
          var usageCount = _ref7[1];
          return usageCount < 2;
        }).map(function(_ref8) {
          var _ref9 = _slicedToArray(_ref8, 2), varName = _ref9[0];
          _ref9[1];
          return varName;
        });
        if (variable) {
          var _newDoc = _this6.props.setArgValue(variable, false);
          if (_newDoc) {
            var targetOperation = _newDoc.definitions.find(function(definition) {
              if (!!definition.operation && !!definition.name && !!definition.name.value && !!_this6.props.definition.name && !!_this6.props.definition.name.value) {
                return definition.name.value === _this6.props.definition.name.value;
              } else {
                return false;
              }
            });
            var newVariableDefinitions = [].concat(_toConsumableArray(targetOperation.variableDefinitions || []), [variable]).filter(function(varDef) {
              return newlyUnusedVariables.indexOf(varDef.variable.name.value) === -1;
            });
            var newOperation = _extends({}, targetOperation, {
              variableDefinitions: newVariableDefinitions
            });
            var existingDefs = _newDoc.definitions;
            var newDefinitions = existingDefs.map(function(existingOperation) {
              if (targetOperation === existingOperation) {
                return newOperation;
              } else {
                return existingOperation;
              }
            });
            var finalDoc = _extends({}, _newDoc, {
              definitions: newDefinitions
            });
            _this6.props.onCommit(finalDoc);
          }
        }
      };
      var devariablize = function devariablize2() {
        if (!argValue || !argValue.name || !argValue.name.value) {
          return;
        }
        var variableName = argValue.name.value;
        var variableDefinition = (_this6.props.definition.variableDefinitions || []).find(function(varDef) {
          return varDef.variable.name.value === variableName;
        });
        if (!variableDefinition) {
          return;
        }
        var defaultValue2 = variableDefinition.defaultValue;
        var newDoc = _this6.props.setArgValue(defaultValue2, {
          commit: false
        });
        if (newDoc) {
          var targetOperation = newDoc.definitions.find(function(definition) {
            return definition.name.value === _this6.props.definition.name.value;
          });
          if (!targetOperation) {
            return;
          }
          var variableUseCount = 0;
          (0, _graphql.visit)(targetOperation, {
            Variable: function Variable(node) {
              if (node.name.value === variableName) {
                variableUseCount = variableUseCount + 1;
              }
            }
          });
          var newVariableDefinitions = targetOperation.variableDefinitions || [];
          if (variableUseCount < 2) {
            newVariableDefinitions = newVariableDefinitions.filter(function(varDef) {
              return varDef.variable.name.value !== variableName;
            });
          }
          var newOperation = _extends({}, targetOperation, {
            variableDefinitions: newVariableDefinitions
          });
          var existingDefs = newDoc.definitions;
          var newDefinitions = existingDefs.map(function(existingOperation) {
            if (targetOperation === existingOperation) {
              return newOperation;
            } else {
              return existingOperation;
            }
          });
          var finalDoc = _extends({}, newDoc, {
            definitions: newDefinitions
          });
          _this6.props.onCommit(finalDoc);
        }
      };
      var isArgValueVariable = argValue && argValue.kind === "Variable";
      var variablizeActionButton = !this.state.displayArgActions ? null : React.createElement("button", {
        type: "submit",
        className: "toolbar-button",
        title: isArgValueVariable ? "Remove the variable" : "Extract the current value into a GraphQL variable",
        onClick: function onClick(event) {
          event.preventDefault();
          event.stopPropagation();
          if (isArgValueVariable) {
            devariablize();
          } else {
            variablize();
          }
        },
        style: styleConfig.styles.actionButtonStyle
      }, React.createElement("span", { style: { color: styleConfig.colors.variable } }, "$"));
      return React.createElement("div", {
        style: {
          cursor: "pointer",
          minHeight: "16px",
          WebkitUserSelect: "none",
          userSelect: "none"
        },
        "data-arg-name": arg.name,
        "data-arg-type": argType.name,
        className: "graphiql-explorer-" + arg.name
      }, React.createElement("span", {
        style: { cursor: "pointer" },
        onClick: function onClick(event) {
          var shouldAdd = !argValue;
          if (shouldAdd) {
            _this6.props.addArg(true);
          } else {
            _this6.props.removeArg(true);
          }
          _this6.setState({ displayArgActions: shouldAdd });
        }
      }, (0, _graphql.isInputObjectType)(argType) ? React.createElement("span", null, !!argValue ? this.props.styleConfig.arrowOpen : this.props.styleConfig.arrowClosed) : React.createElement(Checkbox, {
        checked: !!argValue,
        styleConfig: this.props.styleConfig
      }), React.createElement("span", {
        style: { color: styleConfig.colors.attribute },
        title: arg.description,
        onMouseEnter: function onMouseEnter() {
          if (argValue !== null && typeof argValue !== "undefined") {
            _this6.setState({ displayArgActions: true });
          }
        },
        onMouseLeave: function onMouseLeave() {
          return _this6.setState({ displayArgActions: false });
        }
      }, arg.name, isRequiredArgument(arg) ? "*" : "", ": ", variablizeActionButton, " "), " "), input || React.createElement("span", null), " ");
    }
  }]);
  return AbstractArgView2;
}(React.PureComponent);
var AbstractView = function(_React$PureComponent5) {
  _inherits(AbstractView2, _React$PureComponent5);
  function AbstractView2() {
    var _ref10;
    var _temp5, _this7, _ret5;
    _classCallCheck(this, AbstractView2);
    for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return _ret5 = (_temp5 = (_this7 = _possibleConstructorReturn(this, (_ref10 = AbstractView2.__proto__ || Object.getPrototypeOf(AbstractView2)).call.apply(_ref10, [this].concat(args))), _this7), _this7._addFragment = function() {
      _this7.props.modifySelections([].concat(_toConsumableArray(_this7.props.selections), [_this7._previousSelection || {
        kind: "InlineFragment",
        typeCondition: {
          kind: "NamedType",
          name: { kind: "Name", value: _this7.props.implementingType.name }
        },
        selectionSet: {
          kind: "SelectionSet",
          selections: _this7.props.getDefaultFieldNames(_this7.props.implementingType).map(function(fieldName) {
            return {
              kind: "Field",
              name: { kind: "Name", value: fieldName }
            };
          })
        }
      }]));
    }, _this7._removeFragment = function() {
      var thisSelection = _this7._getSelection();
      _this7._previousSelection = thisSelection;
      _this7.props.modifySelections(_this7.props.selections.filter(function(s) {
        return s !== thisSelection;
      }));
    }, _this7._getSelection = function() {
      var selection = _this7.props.selections.find(function(selection2) {
        return selection2.kind === "InlineFragment" && selection2.typeCondition && _this7.props.implementingType.name === selection2.typeCondition.name.value;
      });
      if (!selection) {
        return null;
      }
      if (selection.kind === "InlineFragment") {
        return selection;
      }
    }, _this7._modifyChildSelections = function(selections, options) {
      var thisSelection = _this7._getSelection();
      return _this7.props.modifySelections(_this7.props.selections.map(function(selection) {
        if (selection === thisSelection) {
          return {
            directives: selection.directives,
            kind: "InlineFragment",
            typeCondition: {
              kind: "NamedType",
              name: { kind: "Name", value: _this7.props.implementingType.name }
            },
            selectionSet: {
              kind: "SelectionSet",
              selections
            }
          };
        }
        return selection;
      }), options);
    }, _temp5), _possibleConstructorReturn(_this7, _ret5);
  }
  _createClass(AbstractView2, [{
    key: "render",
    value: function render() {
      var _this8 = this;
      var _props5 = this.props, implementingType = _props5.implementingType, schema = _props5.schema, getDefaultFieldNames = _props5.getDefaultFieldNames, styleConfig = _props5.styleConfig;
      var selection = this._getSelection();
      var fields = implementingType.getFields();
      var childSelections = selection ? selection.selectionSet ? selection.selectionSet.selections : [] : [];
      return React.createElement("div", { className: "graphiql-explorer-" + implementingType.name }, React.createElement("span", {
        style: { cursor: "pointer" },
        onClick: selection ? this._removeFragment : this._addFragment
      }, React.createElement(Checkbox, {
        checked: !!selection,
        styleConfig: this.props.styleConfig
      }), React.createElement("span", { style: { color: styleConfig.colors.atom } }, this.props.implementingType.name)), selection ? React.createElement("div", { style: { marginLeft: 16 } }, Object.keys(fields).sort().map(function(fieldName) {
        return React.createElement(FieldView, {
          key: fieldName,
          field: fields[fieldName],
          selections: childSelections,
          modifySelections: _this8._modifyChildSelections,
          schema,
          getDefaultFieldNames,
          getDefaultScalarArgValue: _this8.props.getDefaultScalarArgValue,
          makeDefaultArg: _this8.props.makeDefaultArg,
          onRunOperation: _this8.props.onRunOperation,
          onCommit: _this8.props.onCommit,
          styleConfig: _this8.props.styleConfig,
          definition: _this8.props.definition,
          availableFragments: _this8.props.availableFragments
        });
      })) : null);
    }
  }]);
  return AbstractView2;
}(React.PureComponent);
var FragmentView = function(_React$PureComponent6) {
  _inherits(FragmentView2, _React$PureComponent6);
  function FragmentView2() {
    var _ref11;
    var _temp6, _this9, _ret6;
    _classCallCheck(this, FragmentView2);
    for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return _ret6 = (_temp6 = (_this9 = _possibleConstructorReturn(this, (_ref11 = FragmentView2.__proto__ || Object.getPrototypeOf(FragmentView2)).call.apply(_ref11, [this].concat(args))), _this9), _this9._addFragment = function() {
      _this9.props.modifySelections([].concat(_toConsumableArray(_this9.props.selections), [_this9._previousSelection || {
        kind: "FragmentSpread",
        name: _this9.props.fragment.name
      }]));
    }, _this9._removeFragment = function() {
      var thisSelection = _this9._getSelection();
      _this9._previousSelection = thisSelection;
      _this9.props.modifySelections(_this9.props.selections.filter(function(s) {
        var isTargetSelection = s.kind === "FragmentSpread" && s.name.value === _this9.props.fragment.name.value;
        return !isTargetSelection;
      }));
    }, _this9._getSelection = function() {
      var selection = _this9.props.selections.find(function(selection2) {
        return selection2.kind === "FragmentSpread" && selection2.name.value === _this9.props.fragment.name.value;
      });
      return selection;
    }, _temp6), _possibleConstructorReturn(_this9, _ret6);
  }
  _createClass(FragmentView2, [{
    key: "render",
    value: function render() {
      var styleConfig = this.props.styleConfig;
      var selection = this._getSelection();
      return React.createElement("div", { className: "graphiql-explorer-" + this.props.fragment.name.value }, React.createElement("span", {
        style: { cursor: "pointer" },
        onClick: selection ? this._removeFragment : this._addFragment
      }, React.createElement(Checkbox, {
        checked: !!selection,
        styleConfig: this.props.styleConfig
      }), React.createElement("span", {
        style: { color: styleConfig.colors.def },
        className: "graphiql-explorer-" + this.props.fragment.name.value
      }, this.props.fragment.name.value)));
    }
  }]);
  return FragmentView2;
}(React.PureComponent);
function defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, fields) {
  var nodes = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = void 0;
  try {
    for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _field = _step.value;
      if ((0, _graphql.isRequiredInputField)(_field) || makeDefaultArg && makeDefaultArg(parentField, _field)) {
        var fieldType = unwrapInputType(_field.type);
        if ((0, _graphql.isInputObjectType)(fieldType)) {
          (function() {
            var fields2 = fieldType.getFields();
            nodes.push({
              kind: "ObjectField",
              name: { kind: "Name", value: _field.name },
              value: {
                kind: "ObjectValue",
                fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, parentField, Object.keys(fields2).map(function(k) {
                  return fields2[k];
                }))
              }
            });
          })();
        } else if ((0, _graphql.isLeafType)(fieldType)) {
          nodes.push({
            kind: "ObjectField",
            name: { kind: "Name", value: _field.name },
            value: getDefaultScalarArgValue(parentField, _field, fieldType)
          });
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
  return nodes;
}
function defaultArgs(getDefaultScalarArgValue, makeDefaultArg, field) {
  var args = [];
  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = void 0;
  try {
    for (var _iterator2 = field.args[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var _arg = _step2.value;
      if (isRequiredArgument(_arg) || makeDefaultArg && makeDefaultArg(field, _arg)) {
        var argType = unwrapInputType(_arg.type);
        if ((0, _graphql.isInputObjectType)(argType)) {
          (function() {
            var fields = argType.getFields();
            args.push({
              kind: "Argument",
              name: { kind: "Name", value: _arg.name },
              value: {
                kind: "ObjectValue",
                fields: defaultInputObjectFields(getDefaultScalarArgValue, makeDefaultArg, field, Object.keys(fields).map(function(k) {
                  return fields[k];
                }))
              }
            });
          })();
        } else if ((0, _graphql.isLeafType)(argType)) {
          args.push({
            kind: "Argument",
            name: { kind: "Name", value: _arg.name },
            value: getDefaultScalarArgValue(field, _arg, argType)
          });
        }
      }
    }
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2.return) {
        _iterator2.return();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }
  return args;
}
var FieldView = function(_React$PureComponent7) {
  _inherits(FieldView2, _React$PureComponent7);
  function FieldView2() {
    var _ref12;
    var _temp7, _this10, _ret9;
    _classCallCheck(this, FieldView2);
    for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return _ret9 = (_temp7 = (_this10 = _possibleConstructorReturn(this, (_ref12 = FieldView2.__proto__ || Object.getPrototypeOf(FieldView2)).call.apply(_ref12, [this].concat(args))), _this10), _this10.state = { displayFieldActions: false }, _this10._addAllFieldsToSelections = function(rawSubfields) {
      var subFields = !!rawSubfields ? Object.keys(rawSubfields).map(function(fieldName) {
        return {
          kind: "Field",
          name: { kind: "Name", value: fieldName },
          arguments: []
        };
      }) : [];
      var subSelectionSet = {
        kind: "SelectionSet",
        selections: subFields
      };
      var nextSelections = [].concat(_toConsumableArray(_this10.props.selections.filter(function(selection) {
        if (selection.kind === "InlineFragment") {
          return true;
        } else {
          return selection.name.value !== _this10.props.field.name;
        }
      })), [{
        kind: "Field",
        name: { kind: "Name", value: _this10.props.field.name },
        arguments: defaultArgs(_this10.props.getDefaultScalarArgValue, _this10.props.makeDefaultArg, _this10.props.field),
        selectionSet: subSelectionSet
      }]);
      _this10.props.modifySelections(nextSelections);
    }, _this10._addFieldToSelections = function(rawSubfields) {
      var nextSelections = [].concat(_toConsumableArray(_this10.props.selections), [_this10._previousSelection || {
        kind: "Field",
        name: { kind: "Name", value: _this10.props.field.name },
        arguments: defaultArgs(_this10.props.getDefaultScalarArgValue, _this10.props.makeDefaultArg, _this10.props.field)
      }]);
      _this10.props.modifySelections(nextSelections);
    }, _this10._handleUpdateSelections = function(event) {
      var selection = _this10._getSelection();
      if (selection && !event.altKey) {
        _this10._removeFieldFromSelections();
      } else {
        var fieldType = (0, _graphql.getNamedType)(_this10.props.field.type);
        var rawSubfields = (0, _graphql.isObjectType)(fieldType) && fieldType.getFields();
        var shouldSelectAllSubfields = !!rawSubfields && event.altKey;
        shouldSelectAllSubfields ? _this10._addAllFieldsToSelections(rawSubfields) : _this10._addFieldToSelections(rawSubfields);
      }
    }, _this10._removeFieldFromSelections = function() {
      var previousSelection = _this10._getSelection();
      _this10._previousSelection = previousSelection;
      _this10.props.modifySelections(_this10.props.selections.filter(function(selection) {
        return selection !== previousSelection;
      }));
    }, _this10._getSelection = function() {
      var selection = _this10.props.selections.find(function(selection2) {
        return selection2.kind === "Field" && _this10.props.field.name === selection2.name.value;
      });
      if (!selection) {
        return null;
      }
      if (selection.kind === "Field") {
        return selection;
      }
    }, _this10._setArguments = function(argumentNodes, options) {
      var selection = _this10._getSelection();
      if (!selection) {
        console.error("Missing selection when setting arguments", argumentNodes);
        return;
      }
      return _this10.props.modifySelections(_this10.props.selections.map(function(s) {
        return s === selection ? {
          alias: selection.alias,
          arguments: argumentNodes,
          directives: selection.directives,
          kind: "Field",
          name: selection.name,
          selectionSet: selection.selectionSet
        } : s;
      }), options);
    }, _this10._modifyChildSelections = function(selections, options) {
      return _this10.props.modifySelections(_this10.props.selections.map(function(selection) {
        if (selection.kind === "Field" && _this10.props.field.name === selection.name.value) {
          if (selection.kind !== "Field") {
            throw new Error("invalid selection");
          }
          return {
            alias: selection.alias,
            arguments: selection.arguments,
            directives: selection.directives,
            kind: "Field",
            name: selection.name,
            selectionSet: {
              kind: "SelectionSet",
              selections
            }
          };
        }
        return selection;
      }), options);
    }, _temp7), _possibleConstructorReturn(_this10, _ret9);
  }
  _createClass(FieldView2, [{
    key: "render",
    value: function render() {
      var _this11 = this;
      var _props6 = this.props, field = _props6.field, schema = _props6.schema, getDefaultFieldNames = _props6.getDefaultFieldNames, styleConfig = _props6.styleConfig;
      var selection = this._getSelection();
      var type2 = unwrapOutputType(field.type);
      var args = field.args.sort(function(a, b) {
        return a.name.localeCompare(b.name);
      });
      var className = "graphiql-explorer-node graphiql-explorer-" + field.name;
      if (field.isDeprecated) {
        className += " graphiql-explorer-deprecated";
      }
      var applicableFragments = (0, _graphql.isObjectType)(type2) || (0, _graphql.isInterfaceType)(type2) || (0, _graphql.isUnionType)(type2) ? this.props.availableFragments && this.props.availableFragments[type2.name] : null;
      var node = React.createElement("div", { className }, React.createElement("span", {
        title: field.description,
        style: {
          cursor: "pointer",
          display: "inline-flex",
          alignItems: "center",
          minHeight: "16px",
          WebkitUserSelect: "none",
          userSelect: "none"
        },
        "data-field-name": field.name,
        "data-field-type": type2.name,
        onClick: this._handleUpdateSelections,
        onMouseEnter: function onMouseEnter() {
          var containsMeaningfulSubselection = (0, _graphql.isObjectType)(type2) && selection && selection.selectionSet && selection.selectionSet.selections.filter(function(selection2) {
            return selection2.kind !== "FragmentSpread";
          }).length > 0;
          if (containsMeaningfulSubselection) {
            _this11.setState({ displayFieldActions: true });
          }
        },
        onMouseLeave: function onMouseLeave() {
          return _this11.setState({ displayFieldActions: false });
        }
      }, (0, _graphql.isObjectType)(type2) ? React.createElement("span", null, !!selection ? this.props.styleConfig.arrowOpen : this.props.styleConfig.arrowClosed) : null, (0, _graphql.isObjectType)(type2) ? null : React.createElement(Checkbox, {
        checked: !!selection,
        styleConfig: this.props.styleConfig
      }), React.createElement("span", {
        style: { color: styleConfig.colors.property },
        className: "graphiql-explorer-field-view"
      }, field.name), !this.state.displayFieldActions ? null : React.createElement("button", {
        type: "submit",
        className: "toolbar-button",
        title: "Extract selections into a new reusable fragment",
        onClick: function onClick(event) {
          event.preventDefault();
          event.stopPropagation();
          var typeName = type2.name;
          var newFragmentName = typeName + "Fragment";
          var conflictingNameCount = (applicableFragments || []).filter(function(fragment) {
            return fragment.name.value.startsWith(newFragmentName);
          }).length;
          if (conflictingNameCount > 0) {
            newFragmentName = "" + newFragmentName + conflictingNameCount;
          }
          var childSelections2 = selection ? selection.selectionSet ? selection.selectionSet.selections : [] : [];
          var nextSelections = [{
            kind: "FragmentSpread",
            name: {
              kind: "Name",
              value: newFragmentName
            },
            directives: []
          }];
          var newFragmentDefinition = {
            kind: "FragmentDefinition",
            name: {
              kind: "Name",
              value: newFragmentName
            },
            typeCondition: {
              kind: "NamedType",
              name: {
                kind: "Name",
                value: type2.name
              }
            },
            directives: [],
            selectionSet: {
              kind: "SelectionSet",
              selections: childSelections2
            }
          };
          var newDoc = _this11._modifyChildSelections(nextSelections, false);
          if (newDoc) {
            var newDocWithFragment = _extends({}, newDoc, {
              definitions: [].concat(_toConsumableArray(newDoc.definitions), [newFragmentDefinition])
            });
            _this11.props.onCommit(newDocWithFragment);
          } else {
            console.warn("Unable to complete extractFragment operation");
          }
        },
        style: _extends({}, styleConfig.styles.actionButtonStyle)
      }, React.createElement("span", null, "\u2026"))), selection && args.length ? React.createElement("div", {
        style: { marginLeft: 16 },
        className: "graphiql-explorer-graphql-arguments"
      }, args.map(function(arg) {
        return React.createElement(ArgView, {
          key: arg.name,
          parentField: field,
          arg,
          selection,
          modifyArguments: _this11._setArguments,
          getDefaultScalarArgValue: _this11.props.getDefaultScalarArgValue,
          makeDefaultArg: _this11.props.makeDefaultArg,
          onRunOperation: _this11.props.onRunOperation,
          styleConfig: _this11.props.styleConfig,
          onCommit: _this11.props.onCommit,
          definition: _this11.props.definition
        });
      })) : null);
      if (selection && ((0, _graphql.isObjectType)(type2) || (0, _graphql.isInterfaceType)(type2) || (0, _graphql.isUnionType)(type2))) {
        var _fields4 = (0, _graphql.isUnionType)(type2) ? {} : type2.getFields();
        var childSelections = selection ? selection.selectionSet ? selection.selectionSet.selections : [] : [];
        return React.createElement("div", { className: "graphiql-explorer-" + field.name }, node, React.createElement("div", { style: { marginLeft: 16 } }, !!applicableFragments ? applicableFragments.map(function(fragment) {
          var type3 = schema.getType(fragment.typeCondition.name.value);
          var fragmentName = fragment.name.value;
          return !type3 ? null : React.createElement(FragmentView, {
            key: fragmentName,
            fragment,
            selections: childSelections,
            modifySelections: _this11._modifyChildSelections,
            schema,
            styleConfig: _this11.props.styleConfig,
            onCommit: _this11.props.onCommit
          });
        }) : null, Object.keys(_fields4).sort().map(function(fieldName) {
          return React.createElement(FieldView2, {
            key: fieldName,
            field: _fields4[fieldName],
            selections: childSelections,
            modifySelections: _this11._modifyChildSelections,
            schema,
            getDefaultFieldNames,
            getDefaultScalarArgValue: _this11.props.getDefaultScalarArgValue,
            makeDefaultArg: _this11.props.makeDefaultArg,
            onRunOperation: _this11.props.onRunOperation,
            styleConfig: _this11.props.styleConfig,
            onCommit: _this11.props.onCommit,
            definition: _this11.props.definition,
            availableFragments: _this11.props.availableFragments
          });
        }), (0, _graphql.isInterfaceType)(type2) || (0, _graphql.isUnionType)(type2) ? schema.getPossibleTypes(type2).map(function(type3) {
          return React.createElement(AbstractView, {
            key: type3.name,
            implementingType: type3,
            selections: childSelections,
            modifySelections: _this11._modifyChildSelections,
            schema,
            getDefaultFieldNames,
            getDefaultScalarArgValue: _this11.props.getDefaultScalarArgValue,
            makeDefaultArg: _this11.props.makeDefaultArg,
            onRunOperation: _this11.props.onRunOperation,
            styleConfig: _this11.props.styleConfig,
            onCommit: _this11.props.onCommit,
            definition: _this11.props.definition
          });
        }) : null));
      }
      return node;
    }
  }]);
  return FieldView2;
}(React.PureComponent);
function parseQuery(text3) {
  try {
    if (!text3.trim()) {
      return null;
    }
    return (0, _graphql.parse)(text3, { noLocation: true });
  } catch (e) {
    return new Error(e);
  }
}
var DEFAULT_OPERATION = {
  kind: "OperationDefinition",
  operation: "query",
  variableDefinitions: [],
  name: { kind: "Name", value: "MyQuery" },
  directives: [],
  selectionSet: {
    kind: "SelectionSet",
    selections: []
  }
};
var DEFAULT_DOCUMENT = {
  kind: "Document",
  definitions: [DEFAULT_OPERATION]
};
var parseQueryMemoize = null;
function memoizeParseQuery(query) {
  if (parseQueryMemoize && parseQueryMemoize[0] === query) {
    return parseQueryMemoize[1];
  } else {
    var result2 = parseQuery(query);
    if (!result2) {
      return DEFAULT_DOCUMENT;
    } else if (result2 instanceof Error) {
      if (parseQueryMemoize) {
        return parseQueryMemoize[1];
      } else {
        return DEFAULT_DOCUMENT;
      }
    } else {
      parseQueryMemoize = [query, result2];
      return result2;
    }
  }
}
var defaultStyles = {
  buttonStyle: {
    fontSize: "1.2em",
    padding: "0px",
    backgroundColor: "white",
    border: "none",
    margin: "5px 0px",
    height: "40px",
    width: "100%",
    display: "block",
    maxWidth: "none"
  },
  actionButtonStyle: {
    padding: "0px",
    backgroundColor: "white",
    border: "none",
    margin: "0px",
    maxWidth: "none",
    height: "15px",
    width: "15px",
    display: "inline-block",
    fontSize: "smaller"
  },
  explorerActionsStyle: {
    margin: "4px -8px -8px",
    paddingLeft: "8px",
    bottom: "0px",
    width: "100%",
    textAlign: "center",
    background: "none",
    borderTop: "none",
    borderBottom: "none"
  }
};
var RootView = function(_React$PureComponent8) {
  _inherits(RootView2, _React$PureComponent8);
  function RootView2() {
    var _ref13;
    var _temp8, _this12, _ret10;
    _classCallCheck(this, RootView2);
    for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return _ret10 = (_temp8 = (_this12 = _possibleConstructorReturn(this, (_ref13 = RootView2.__proto__ || Object.getPrototypeOf(RootView2)).call.apply(_ref13, [this].concat(args))), _this12), _this12.state = { newOperationType: "query", displayTitleActions: false }, _this12._modifySelections = function(selections, options) {
      var operationDef = _this12.props.definition;
      if (operationDef.selectionSet.selections.length === 0 && _this12._previousOperationDef) {
        operationDef = _this12._previousOperationDef;
      }
      var newOperationDef = void 0;
      if (operationDef.kind === "FragmentDefinition") {
        newOperationDef = _extends({}, operationDef, {
          selectionSet: _extends({}, operationDef.selectionSet, {
            selections
          })
        });
      } else if (operationDef.kind === "OperationDefinition") {
        var cleanedSelections = selections.filter(function(selection) {
          return !(selection.kind === "Field" && selection.name.value === "__typename");
        });
        if (cleanedSelections.length === 0) {
          cleanedSelections = [{
            kind: "Field",
            name: {
              kind: "Name",
              value: "__typename ## Placeholder value"
            }
          }];
        }
        newOperationDef = _extends({}, operationDef, {
          selectionSet: _extends({}, operationDef.selectionSet, {
            selections: cleanedSelections
          })
        });
      }
      return _this12.props.onEdit(newOperationDef, options);
    }, _this12._onOperationRename = function(event) {
      return _this12.props.onOperationRename(event.target.value);
    }, _this12._handlePotentialRun = function(event) {
      if (isRunShortcut(event) && canRunOperation(_this12.props.definition.kind)) {
        _this12.props.onRunOperation(_this12.props.name);
      }
    }, _this12._rootViewElId = function() {
      var _this12$props = _this12.props, operationType = _this12$props.operationType, name2 = _this12$props.name;
      var rootViewElId = operationType + "-" + (name2 || "unknown");
      return rootViewElId;
    }, _temp8), _possibleConstructorReturn(_this12, _ret10);
  }
  _createClass(RootView2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var rootViewElId = this._rootViewElId();
      this.props.onMount(rootViewElId);
    }
  }, {
    key: "render",
    value: function render() {
      var _this13 = this;
      var _props7 = this.props, operationType = _props7.operationType, definition = _props7.definition, schema = _props7.schema, getDefaultFieldNames = _props7.getDefaultFieldNames, styleConfig = _props7.styleConfig;
      var rootViewElId = this._rootViewElId();
      var fields = this.props.fields || {};
      var operationDef = definition;
      var selections = operationDef.selectionSet.selections;
      var operationDisplayName = this.props.name || capitalize(operationType) + " Name";
      return React.createElement("div", {
        id: rootViewElId,
        tabIndex: "0",
        onKeyDown: this._handlePotentialRun,
        style: {
          borderBottom: this.props.isLast ? "none" : "1px solid #d6d6d6",
          marginBottom: "0em",
          paddingBottom: "1em"
        }
      }, React.createElement("div", {
        style: { color: styleConfig.colors.keyword, paddingBottom: 4 },
        className: "graphiql-operation-title-bar",
        onMouseEnter: function onMouseEnter() {
          return _this13.setState({ displayTitleActions: true });
        },
        onMouseLeave: function onMouseLeave() {
          return _this13.setState({ displayTitleActions: false });
        }
      }, operationType, " ", React.createElement("span", { style: { color: styleConfig.colors.def } }, React.createElement("input", {
        style: {
          color: styleConfig.colors.def,
          border: "none",
          borderBottom: "1px solid #888",
          outline: "none",
          width: Math.max(4, operationDisplayName.length) + "ch"
        },
        autoComplete: "false",
        placeholder: capitalize(operationType) + " Name",
        value: this.props.name,
        onKeyDown: this._handlePotentialRun,
        onChange: this._onOperationRename
      })), !!this.props.onTypeName ? React.createElement("span", null, React.createElement("br", null), "on " + this.props.onTypeName) : "", !!this.state.displayTitleActions ? React.createElement(React.Fragment, null, React.createElement("button", {
        type: "submit",
        className: "toolbar-button",
        onClick: function onClick() {
          return _this13.props.onOperationDestroy();
        },
        style: _extends({}, styleConfig.styles.actionButtonStyle)
      }, React.createElement("span", null, "\u2715")), React.createElement("button", {
        type: "submit",
        className: "toolbar-button",
        onClick: function onClick() {
          return _this13.props.onOperationClone();
        },
        style: _extends({}, styleConfig.styles.actionButtonStyle)
      }, React.createElement("span", null, "\u2398"))) : ""), Object.keys(fields).sort().map(function(fieldName) {
        return React.createElement(FieldView, {
          key: fieldName,
          field: fields[fieldName],
          selections,
          modifySelections: _this13._modifySelections,
          schema,
          getDefaultFieldNames,
          getDefaultScalarArgValue: _this13.props.getDefaultScalarArgValue,
          makeDefaultArg: _this13.props.makeDefaultArg,
          onRunOperation: _this13.props.onRunOperation,
          styleConfig: _this13.props.styleConfig,
          onCommit: _this13.props.onCommit,
          definition: _this13.props.definition,
          availableFragments: _this13.props.availableFragments
        });
      }));
    }
  }]);
  return RootView2;
}(React.PureComponent);
function Attribution() {
  return React.createElement("div", {
    style: {
      fontFamily: "sans-serif",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      margin: "1em",
      marginTop: 0,
      flexGrow: 1,
      justifyContent: "flex-end"
    }
  }, React.createElement("div", {
    style: {
      borderTop: "1px solid #d6d6d6",
      paddingTop: "1em",
      width: "100%",
      textAlign: "center"
    }
  }, "GraphiQL Explorer by ", React.createElement("a", { href: "https://www.onegraph.com" }, "OneGraph")), React.createElement("div", null, "Contribute on", " ", React.createElement("a", { href: "https://github.com/OneGraph/graphiql-explorer" }, "GitHub")));
}
var Explorer = function(_React$PureComponent9) {
  _inherits(Explorer2, _React$PureComponent9);
  function Explorer2() {
    var _ref14;
    var _temp9, _this14, _ret11;
    _classCallCheck(this, Explorer2);
    for (var _len9 = arguments.length, args = Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return _ret11 = (_temp9 = (_this14 = _possibleConstructorReturn(this, (_ref14 = Explorer2.__proto__ || Object.getPrototypeOf(Explorer2)).call.apply(_ref14, [this].concat(args))), _this14), _this14.state = {
      newOperationType: "query",
      operation: null,
      operationToScrollTo: null
    }, _this14._resetScroll = function() {
      var container = _this14._ref;
      if (container) {
        container.scrollLeft = 0;
      }
    }, _this14._onEdit = function(query) {
      return _this14.props.onEdit(query);
    }, _this14._setAddOperationType = function(value) {
      _this14.setState({ newOperationType: value });
    }, _this14._handleRootViewMount = function(rootViewElId) {
      if (!!_this14.state.operationToScrollTo && _this14.state.operationToScrollTo === rootViewElId) {
        var selector = ".graphiql-explorer-root #" + rootViewElId;
        var el2 = document.querySelector(selector);
        el2 && el2.scrollIntoView();
      }
    }, _temp9), _possibleConstructorReturn(_this14, _ret11);
  }
  _createClass(Explorer2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this._resetScroll();
    }
  }, {
    key: "render",
    value: function render() {
      var _this15 = this;
      var _props8 = this.props, schema = _props8.schema, query = _props8.query, makeDefaultArg = _props8.makeDefaultArg;
      if (!schema) {
        return React.createElement("div", { style: { fontFamily: "sans-serif" }, className: "error-container" }, "No Schema Available");
      }
      var styleConfig = {
        colors: this.props.colors || defaultColors,
        checkboxChecked: this.props.checkboxChecked || defaultCheckboxChecked,
        checkboxUnchecked: this.props.checkboxUnchecked || defaultCheckboxUnchecked,
        arrowClosed: this.props.arrowClosed || defaultArrowClosed,
        arrowOpen: this.props.arrowOpen || defaultArrowOpen,
        styles: this.props.styles ? _extends({}, defaultStyles, this.props.styles) : defaultStyles
      };
      var queryType = schema.getQueryType();
      var mutationType = schema.getMutationType();
      var subscriptionType = schema.getSubscriptionType();
      if (!queryType && !mutationType && !subscriptionType) {
        return React.createElement("div", null, "Missing query type");
      }
      var queryFields = queryType && queryType.getFields();
      var mutationFields = mutationType && mutationType.getFields();
      var subscriptionFields = subscriptionType && subscriptionType.getFields();
      var parsedQuery = memoizeParseQuery(query);
      var getDefaultFieldNames = this.props.getDefaultFieldNames || defaultGetDefaultFieldNames;
      var getDefaultScalarArgValue = this.props.getDefaultScalarArgValue || defaultGetDefaultScalarArgValue;
      var definitions = parsedQuery.definitions;
      var _relevantOperations = definitions.map(function(definition) {
        if (definition.kind === "FragmentDefinition") {
          return definition;
        } else if (definition.kind === "OperationDefinition") {
          return definition;
        } else {
          return null;
        }
      }).filter(Boolean);
      var relevantOperations = _relevantOperations.length === 0 ? DEFAULT_DOCUMENT.definitions : _relevantOperations;
      var renameOperation = function renameOperation2(targetOperation, name2) {
        var newName = name2 == null || name2 === "" ? null : { kind: "Name", value: name2, loc: void 0 };
        var newOperation = _extends({}, targetOperation, { name: newName });
        var existingDefs = parsedQuery.definitions;
        var newDefinitions = existingDefs.map(function(existingOperation) {
          if (targetOperation === existingOperation) {
            return newOperation;
          } else {
            return existingOperation;
          }
        });
        return _extends({}, parsedQuery, {
          definitions: newDefinitions
        });
      };
      var cloneOperation = function cloneOperation2(targetOperation) {
        var kind2 = void 0;
        if (targetOperation.kind === "FragmentDefinition") {
          kind2 = "fragment";
        } else {
          kind2 = targetOperation.operation;
        }
        var newOperationName = (targetOperation.name && targetOperation.name.value || "") + "Copy";
        var newName = {
          kind: "Name",
          value: newOperationName,
          loc: void 0
        };
        var newOperation = _extends({}, targetOperation, { name: newName });
        var existingDefs = parsedQuery.definitions;
        var newDefinitions = [].concat(_toConsumableArray(existingDefs), [newOperation]);
        _this15.setState({ operationToScrollTo: kind2 + "-" + newOperationName });
        return _extends({}, parsedQuery, {
          definitions: newDefinitions
        });
      };
      var destroyOperation = function destroyOperation2(targetOperation) {
        var existingDefs = parsedQuery.definitions;
        var newDefinitions = existingDefs.filter(function(existingOperation) {
          if (targetOperation === existingOperation) {
            return false;
          } else {
            return true;
          }
        });
        return _extends({}, parsedQuery, {
          definitions: newDefinitions
        });
      };
      var addOperation = function addOperation2(kind2) {
        var existingDefs = parsedQuery.definitions;
        var viewingDefaultOperation = parsedQuery.definitions.length === 1 && parsedQuery.definitions[0] === DEFAULT_DOCUMENT.definitions[0];
        var MySiblingDefs = viewingDefaultOperation ? [] : existingDefs.filter(function(def) {
          if (def.kind === "OperationDefinition") {
            return def.operation === kind2;
          } else {
            return false;
          }
        });
        var newOperationName = "My" + capitalize(kind2) + (MySiblingDefs.length === 0 ? "" : MySiblingDefs.length + 1);
        var firstFieldName = "__typename # Placeholder value";
        var selectionSet = {
          kind: "SelectionSet",
          selections: [{
            kind: "Field",
            name: {
              kind: "Name",
              value: firstFieldName,
              loc: null
            },
            arguments: [],
            directives: [],
            selectionSet: null,
            loc: null
          }],
          loc: null
        };
        var newDefinition = {
          kind: "OperationDefinition",
          operation: kind2,
          name: { kind: "Name", value: newOperationName },
          variableDefinitions: [],
          directives: [],
          selectionSet,
          loc: null
        };
        var newDefinitions = viewingDefaultOperation ? [newDefinition] : [].concat(_toConsumableArray(parsedQuery.definitions), [newDefinition]);
        var newOperationDef = _extends({}, parsedQuery, {
          definitions: newDefinitions
        });
        _this15.setState({ operationToScrollTo: kind2 + "-" + newOperationName });
        _this15.props.onEdit((0, _graphql.print)(newOperationDef));
      };
      var actionsOptions = [!!queryFields ? React.createElement("option", {
        key: "query",
        className: "toolbar-button",
        style: styleConfig.styles.buttonStyle,
        type: "link",
        value: "query"
      }, "Query") : null, !!mutationFields ? React.createElement("option", {
        key: "mutation",
        className: "toolbar-button",
        style: styleConfig.styles.buttonStyle,
        type: "link",
        value: "mutation"
      }, "Mutation") : null, !!subscriptionFields ? React.createElement("option", {
        key: "subscription",
        className: "toolbar-button",
        style: styleConfig.styles.buttonStyle,
        type: "link",
        value: "subscription"
      }, "Subscription") : null].filter(Boolean);
      var actionsEl = actionsOptions.length === 0 || this.props.hideActions ? null : React.createElement("div", {
        style: {
          minHeight: "50px",
          maxHeight: "50px",
          overflow: "none"
        }
      }, React.createElement("form", {
        className: "variable-editor-title graphiql-explorer-actions",
        style: _extends({}, styleConfig.styles.explorerActionsStyle, {
          display: "flex",
          flexDirection: "row",
          alignItems: "center",
          borderTop: "1px solid rgb(214, 214, 214)"
        }),
        onSubmit: function onSubmit(event) {
          return event.preventDefault();
        }
      }, React.createElement("span", {
        style: {
          display: "inline-block",
          flexGrow: "0",
          textAlign: "right"
        }
      }, "Add new", " "), React.createElement("select", {
        onChange: function onChange(event) {
          return _this15._setAddOperationType(event.target.value);
        },
        value: this.state.newOperationType,
        style: { flexGrow: "2" }
      }, actionsOptions), React.createElement("button", {
        type: "submit",
        className: "toolbar-button",
        onClick: function onClick() {
          return _this15.state.newOperationType ? addOperation(_this15.state.newOperationType) : null;
        },
        style: _extends({}, styleConfig.styles.buttonStyle, {
          height: "22px",
          width: "22px"
        })
      }, React.createElement("span", null, "+"))));
      var externalFragments = this.props.externalFragments && this.props.externalFragments.reduce(function(acc, fragment) {
        if (fragment.kind === "FragmentDefinition") {
          var fragmentTypeName = fragment.typeCondition.name.value;
          var existingFragmentsForType = acc[fragmentTypeName] || [];
          var newFragmentsForType = [].concat(_toConsumableArray(existingFragmentsForType), [fragment]).sort(function(a, b) {
            return a.name.value.localeCompare(b.name.value);
          });
          return _extends({}, acc, _defineProperty({}, fragmentTypeName, newFragmentsForType));
        }
        return acc;
      }, {});
      var documentFragments = relevantOperations.reduce(function(acc, operation) {
        if (operation.kind === "FragmentDefinition") {
          var fragmentTypeName = operation.typeCondition.name.value;
          var existingFragmentsForType = acc[fragmentTypeName] || [];
          var newFragmentsForType = [].concat(_toConsumableArray(existingFragmentsForType), [operation]).sort(function(a, b) {
            return a.name.value.localeCompare(b.name.value);
          });
          return _extends({}, acc, _defineProperty({}, fragmentTypeName, newFragmentsForType));
        }
        return acc;
      }, {});
      var availableFragments = _extends({}, documentFragments, externalFragments);
      var attribution = this.props.showAttribution ? React.createElement(Attribution, null) : null;
      return React.createElement("div", {
        ref: function ref(_ref15) {
          _this15._ref = _ref15;
        },
        style: {
          fontSize: 12,
          textOverflow: "ellipsis",
          whiteSpace: "nowrap",
          margin: 0,
          padding: 8,
          fontFamily: 'Consolas, Inconsolata, "Droid Sans Mono", Monaco, monospace',
          display: "flex",
          flexDirection: "column",
          height: "100%"
        },
        className: "graphiql-explorer-root"
      }, React.createElement("div", {
        style: {
          flexGrow: "1",
          overflow: "scroll"
        }
      }, relevantOperations.map(function(operation, index) {
        var operationName = operation && operation.name && operation.name.value;
        var operationType = operation.kind === "FragmentDefinition" ? "fragment" : operation && operation.operation || "query";
        var onOperationRename = function onOperationRename2(newName) {
          var newOperationDef = renameOperation(operation, newName);
          _this15.props.onEdit((0, _graphql.print)(newOperationDef));
        };
        var onOperationClone = function onOperationClone2() {
          var newOperationDef = cloneOperation(operation);
          _this15.props.onEdit((0, _graphql.print)(newOperationDef));
        };
        var onOperationDestroy = function onOperationDestroy2() {
          var newOperationDef = destroyOperation(operation);
          _this15.props.onEdit((0, _graphql.print)(newOperationDef));
        };
        var fragmentType = operation.kind === "FragmentDefinition" && operation.typeCondition.kind === "NamedType" && schema.getType(operation.typeCondition.name.value);
        var fragmentFields = fragmentType instanceof _graphql.GraphQLObjectType ? fragmentType.getFields() : null;
        var fields = operationType === "query" ? queryFields : operationType === "mutation" ? mutationFields : operationType === "subscription" ? subscriptionFields : operation.kind === "FragmentDefinition" ? fragmentFields : null;
        var fragmentTypeName = operation.kind === "FragmentDefinition" ? operation.typeCondition.name.value : null;
        var onCommit = function onCommit2(parsedDocument) {
          var textualNewDocument = (0, _graphql.print)(parsedDocument);
          _this15.props.onEdit(textualNewDocument);
        };
        return React.createElement(RootView, {
          key: index,
          isLast: index === relevantOperations.length - 1,
          fields,
          operationType,
          name: operationName,
          definition: operation,
          onOperationRename,
          onOperationDestroy,
          onOperationClone,
          onTypeName: fragmentTypeName,
          onMount: _this15._handleRootViewMount,
          onCommit,
          onEdit: function onEdit(newDefinition, options) {
            var commit = void 0;
            if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object" && typeof options.commit !== "undefined") {
              commit = options.commit;
            } else {
              commit = true;
            }
            if (!!newDefinition) {
              var newQuery = _extends({}, parsedQuery, {
                definitions: parsedQuery.definitions.map(function(existingDefinition) {
                  return existingDefinition === operation ? newDefinition : existingDefinition;
                })
              });
              if (commit) {
                onCommit(newQuery);
                return newQuery;
              } else {
                return newQuery;
              }
            } else {
              return parsedQuery;
            }
          },
          schema,
          getDefaultFieldNames,
          getDefaultScalarArgValue,
          makeDefaultArg,
          onRunOperation: function onRunOperation() {
            if (!!_this15.props.onRunOperation) {
              _this15.props.onRunOperation(operationName);
            }
          },
          styleConfig,
          availableFragments
        });
      }), attribution), actionsEl);
    }
  }]);
  return Explorer2;
}(React.PureComponent);
Explorer.defaultProps = {
  getDefaultFieldNames: defaultGetDefaultFieldNames,
  getDefaultScalarArgValue: defaultGetDefaultScalarArgValue
};
var ErrorBoundary = function(_React$Component) {
  _inherits(ErrorBoundary2, _React$Component);
  function ErrorBoundary2() {
    var _ref16;
    var _temp10, _this16, _ret12;
    _classCallCheck(this, ErrorBoundary2);
    for (var _len10 = arguments.length, args = Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return _ret12 = (_temp10 = (_this16 = _possibleConstructorReturn(this, (_ref16 = ErrorBoundary2.__proto__ || Object.getPrototypeOf(ErrorBoundary2)).call.apply(_ref16, [this].concat(args))), _this16), _this16.state = { hasError: false, error: null, errorInfo: null }, _temp10), _possibleConstructorReturn(_this16, _ret12);
  }
  _createClass(ErrorBoundary2, [{
    key: "componentDidCatch",
    value: function componentDidCatch(error2, errorInfo) {
      this.setState({ hasError: true, error: error2, errorInfo });
      console.error("Error in component", error2, errorInfo);
    }
  }, {
    key: "render",
    value: function render() {
      if (this.state.hasError) {
        return React.createElement("div", { style: { padding: 18, fontFamily: "sans-serif" } }, React.createElement("div", null, "Something went wrong"), React.createElement("details", { style: { whiteSpace: "pre-wrap" } }, this.state.error ? this.state.error.toString() : null, React.createElement("br", null), this.state.errorInfo ? this.state.errorInfo.componentStack : null));
      }
      return this.props.children;
    }
  }]);
  return ErrorBoundary2;
}(React.Component);
var ExplorerWrapper = function(_React$PureComponent10) {
  _inherits(ExplorerWrapper2, _React$PureComponent10);
  function ExplorerWrapper2() {
    _classCallCheck(this, ExplorerWrapper2);
    return _possibleConstructorReturn(this, (ExplorerWrapper2.__proto__ || Object.getPrototypeOf(ExplorerWrapper2)).apply(this, arguments));
  }
  _createClass(ExplorerWrapper2, [{
    key: "render",
    value: function render() {
      return React.createElement("div", {
        className: "docExplorerWrap",
        style: {
          height: "100%",
          width: this.props.width,
          minWidth: this.props.width,
          zIndex: 7,
          display: this.props.explorerIsOpen ? "flex" : "none",
          flexDirection: "column",
          overflow: "hidden"
        }
      }, React.createElement("section", {
        className: "doc-explorer"
      }, React.createElement("div", { className: "doc-explorer-title-bar" }, React.createElement("div", { className: "doc-explorer-title" }, this.props.title), React.createElement("div", { className: "doc-explorer-rhs" }, React.createElement("div", {
        className: "docExplorerHide",
        onClick: this.props.onToggleExplorer
      }, "\u2715"))), React.createElement("div", {
        className: "doc-explorer-contents",
        style: {
          padding: "0px",
          overflowY: "unset"
        }
      }, React.createElement(ErrorBoundary, null, React.createElement(Explorer, this.props)))));
    }
  }]);
  return ExplorerWrapper2;
}(React.PureComponent);
ExplorerWrapper.defaultValue = defaultValue;
ExplorerWrapper.defaultProps = {
  width: 320,
  title: "Explorer"
};
Explorer$1.default = ExplorerWrapper;
Object.defineProperty(dist, "__esModule", {
  value: true
});
dist.Explorer = void 0;
var _Explorer = Explorer$1;
var _Explorer2 = _interopRequireDefault(_Explorer);
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
dist.Explorer = _Explorer2.default;
var _default = dist.default = _Explorer2.default;
var graphiql = "";
var styles = "";
var darkMode = "";
const getOperationWithFragments = (document2, operationName) => {
  const definitions = document2.definitions.filter((definition) => {
    var _a2;
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      if (operationName) {
        if (((_a2 = definition.name) == null ? void 0 : _a2.value) !== operationName) {
          return false;
        }
      }
    }
    return true;
  });
  return {
    kind: Kind.DOCUMENT,
    definitions
  };
};
function YogaGraphiQL(props) {
  var _a2;
  const endpoint = (_a2 = props.endpoint) != null ? _a2 : "/graphql";
  const graphiqlRef = React$1.useRef(null);
  const [urlLoader] = React$1.useState(() => new UrlLoader());
  const fetcher = React$1.useMemo(() => {
    const options = {
      subscriptionsProtocol: SubscriptionProtocol.SSE,
      specifiedByUrl: true,
      directiveIsRepeatable: true,
      schemaDescription: true
    };
    const executor$ = urlLoader.getExecutorAsync(endpoint, options);
    return async (graphQLParams, opts) => {
      const document2 = getOperationWithFragments(parse$1(graphQLParams.query), graphQLParams.operationName);
      const executor = await executor$;
      return executor({
        document: document2,
        operationName: graphQLParams.operationName,
        variables: graphQLParams.variables,
        extensions: {
          headers: opts == null ? void 0 : opts.headers
        }
      });
    };
  }, []);
  const [showExplorer, setShowExplorer] = React$1.useState(false);
  const [schema, setSchema] = React$1.useState(null);
  const [query, setQuery] = React$1.useState("");
  const [showDocs, setShowDocs] = React$1.useState(false);
  return /* @__PURE__ */ React$1.createElement("div", {
    className: "graphiql-container"
  }, schema ? /* @__PURE__ */ React$1.createElement(_default, {
    schema,
    query,
    onEdit: (query2) => setQuery(query2),
    explorerIsOpen: showExplorer,
    onToggleExplorer: () => setShowExplorer((isOpen) => !isOpen),
    colors: {
      keyword: "#FF6D5D",
      def: "#9F51D9",
      property: "#0083c7",
      qualifier: "#008AED",
      attribute: "#00b8ff",
      number: "#97b1aa",
      string: "#00917D",
      string2: "#146574",
      builtin: "#da8aff",
      variable: "#FF6D5D",
      atom: "#ff9f4c"
    }
  }) : null, /* @__PURE__ */ React$1.createElement(GraphiQL, __spreadValues({
    ref: graphiqlRef,
    fetcher,
    headerEditorEnabled: true,
    defaultVariableEditorOpen: true,
    docExplorerOpen: showDocs,
    onToggleDocs: () => setShowDocs((isOpen) => !isOpen),
    toolbar: {
      additionalContent: /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement("button", {
        className: "toolbar-button",
        onClick: () => {
          var _a3;
          const state = (_a3 = graphiqlRef.current) == null ? void 0 : _a3.state;
          copyToClipboard(urlLoader.prepareGETUrl({
            baseUrl: window.location.href,
            query: (state == null ? void 0 : state.query) || "",
            variables: state == null ? void 0 : state.variables,
            operationName: state == null ? void 0 : state.operationName
          }));
        }
      }, "Copy Link"))
    },
    onSchemaChange: (schema2) => {
      setSchema(schema2);
    },
    query,
    onEditQuery: (query2) => typeof query2 === "string" && setQuery(query2),
    beforeTopBarContent: schema ? showExplorer ? null : /* @__PURE__ */ React$1.createElement("button", {
      className: "docExplorerShow docExplorerShowReverse",
      onClick: () => setShowExplorer((isOpen) => !isOpen)
    }, "Explorer") : null
  }, props), /* @__PURE__ */ React$1.createElement(GraphiQL.Logo, null, /* @__PURE__ */ React$1.createElement("div", {
    style: { display: "flex", alignItems: "center" }
  }, /* @__PURE__ */ React$1.createElement("div", {
    style: { width: 40, display: "flex" }
  }, /* @__PURE__ */ React$1.createElement("img", {
    src: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB3aWR0aD0iMjJweCIgaGVpZ2h0PSIyOHB4IiB2aWV3Qm94PSIwIDAgMjIgMjgiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CiAgICA8IS0tIEdlbmVyYXRvcjogU2tldGNoIDUyLjQgKDY3Mzc4KSAtIGh0dHA6Ly93d3cuYm9oZW1pYW5jb2RpbmcuY29tL3NrZXRjaCAtLT4KICAgIDx0aXRsZT5GaWxsIDE5PC90aXRsZT4KICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPgogICAgPGcgaWQ9IlN5bWJvbHMiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGlkPSJNZW51LS8tbm90LXNpZ25lZC1pbiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg4LjAwMDAwMCwgLTUyLjAwMDAwMCkiIGZpbGw9IiNGRkZGRkYiPgogICAgICAgICAgICA8cGF0aCBkPSJNOTcuMzMzMzAxOSw2Ny41NTU1MDMyIEM5My44OTY5NDk4LDY3LjU1NTUwMzIgOTEuMTExMTAwNiw2NC43Njk4NDI1IDkxLjExMTEwMDYsNjEuMzMzMzAxOSBDOTEuMTExMTAwNiw1Ny44OTY3NjEzIDkzLjg5Njk0OTgsNTUuMTExMTAwNiA5Ny4zMzMzMDE5LDU1LjExMTEwMDYgQzEwMC43Njk4NDMsNTUuMTExMTAwNiAxMDMuNTU1NTAzLDU3Ljg5Njc2MTMgMTAzLjU1NTUwMyw2MS4zMzMzMDE5IEMxMDMuNTU1NTAzLDY0Ljc2OTg0MjUgMTAwLjc2OTg0Myw2Ny41NTU1MDMyIDk3LjMzMzMwMTksNjcuNTU1NTAzMiBNOTcuMzMzMzAxOSw1MiBDMTAyLjQ4NzkyNCw1MiAxMDYuNjY2NjA0LDU2LjE3ODY3OTUgMTA2LjY2NjYwNCw2MS4zMzMzMDE5IEMxMDYuNjY2NjA0LDY2LjQ4NzkyNDMgMTAyLjQ4NzkyNCw3MC42NjY2MDM4IDk3LjMzMzMwMTksNzAuNjY2NjAzOCBDOTIuMTc4Njc5NSw3MC42NjY2MDM4IDg4LDY2LjQ4NzkyNDMgODgsNjEuMzMzMzAxOSBDODgsNTYuMTc4Njc5NSA5Mi4xNzg2Nzk1LDUyIDk3LjMzMzMwMTksNTIgWiBNMTA2LjIxMTA2Myw3MS4xMjIxNDQ0IEMxMDYuODE4NTc2LDcxLjcyOTY1NzUgMTA2LjgxODU3Niw3Mi43MTQ0NjIyIDEwNi4yMTEwNjMsNzMuMzIxOTc1MyBMOTkuOTg4NjczNCw3OS41NDQzNjUyIEM5OS4zODExNjAzLDgwLjE1MTg3ODMgOTguMzk2MzU1Niw4MC4xNTE4NzgzIDk3Ljc4ODg0MjUsNzkuNTQ0MzY1MiBDOTcuMTgxMzI5NCw3OC45MzY4NTIxIDk3LjE4MTMyOTQsNzcuOTUyMDQ3MyA5Ny43ODg4NDI1LDc3LjM0NDUzNDIgTDEwNC4wMTEyMzIsNzEuMTIyMTQ0NCBDMTA0LjYxODc0NSw3MC41MTQ2MzEzIDEwNS42MDM1NSw3MC41MTQ2MzEzIDEwNi4yMTEwNjMsNzEuMTIyMTQ0NCBaIE0xMDkuNzc3NzA0LDUzLjU1NTU1MDMgQzEwOS43Nzc3MDQsNTQuNDE0Nzc5NyAxMDkuMDgxMzg0LDU1LjExMTEwMDYgMTA4LjIyMjM0Myw1NS4xMTExMDA2IEMxMDcuMzYzMTEzLDU1LjExMTEwMDYgMTA2LjY2Njc5Miw1NC40MTQ3Nzk3IDEwNi42NjY3OTIsNTMuNTU1NTUwMyBDMTA2LjY2Njc5Miw1Mi42OTYzMjA5IDEwNy4zNjMxMTMsNTIgMTA4LjIyMjM0Myw1MiBDMTA5LjA4MTM4NCw1MiAxMDkuNzc3NzA0LDUyLjY5NjMyMDkgMTA5Ljc3NzcwNCw1My41NTU1NTAzIFoiIGlkPSJGaWxsLTE5Ij48L3BhdGg+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N2Zz4="
  })), /* @__PURE__ */ React$1.createElement("span", null, (props == null ? void 0 : props.title) ? props.title : /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, "The Graph", /* @__PURE__ */ React$1.createElement("em", null, "i"), "QL"))))));
}
function renderYogaGraphiQL(element, opts) {
  ReactDOM.render(/* @__PURE__ */ React$1.createElement(YogaGraphiQL, __spreadValues({}, opts)), element);
}
export { renderYogaGraphiQL };

var endpoint = window.location.pathname.substring(
  0,
  window.location.pathname.length - "/graphql".length
);

renderYogaGraphiQL(window.document.querySelector("#root"), {
  endpoint,
});
      
        </script>
    </body>
</html>

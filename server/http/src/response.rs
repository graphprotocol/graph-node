use http::status::StatusCode;
use hyper::{Body, Response};
use serde::ser::*;

use graph::components::server::query::GraphQLServerError;
use graph::data::query::QueryResult;
use graph::prelude::serde_json;
use graph::prelude::*;

/// Future for HTTP responses to GraphQL query requests.
pub struct GraphQLResponse {
    result: Result<QueryResult, GraphQLServerError>,
}

impl GraphQLResponse {
    /// Creates a new GraphQLResponse future based on the result generated by
    /// running a query.
    pub fn new(result: Result<QueryResult, GraphQLServerError>) -> Self {
        GraphQLResponse { result }
    }

    fn status_code_from_result(&self) -> StatusCode {
        match self.result {
            Ok(_) => StatusCode::OK,
            Err(GraphQLServerError::ClientError(_)) | Err(GraphQLServerError::QueryError(_)) => {
                StatusCode::BAD_REQUEST
            }
            Err(GraphQLServerError::Canceled(_)) | Err(GraphQLServerError::InternalError(_)) => {
                StatusCode::INTERNAL_SERVER_ERROR
            }
        }
    }
}

impl Serialize for GraphQLResponse {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self.result {
            Ok(ref result) => result.serialize(serializer),
            Err(ref e) => {
                let mut map = serializer.serialize_map(Some(1))?;
                let errors = vec![e];
                map.serialize_entry("errors", &errors)?;
                map.end()
            }
        }
    }
}

impl Future for GraphQLResponse {
    type Item = Response<Body>;
    type Error = GraphQLServerError;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        let status_code = self.status_code_from_result();
        let json =
            serde_json::to_string(self).expect("Failed to serialize GraphQL response to JSON");
        let response = Response::builder()
            .status(status_code)
            .header("Access-Control-Allow-Origin", "*")
            .header("Access-Control-Allow-Headers", "Content-Type, User-Agent")
            .header("Access-Control-Allow-Methods", "GET, OPTIONS, POST")
            .header("Content-Type", "application/json")
            .body(Body::from(json))
            .unwrap();
        Ok(Async::Ready(response))
    }
}

#[cfg(test)]
mod tests {
    use super::GraphQLResponse;
    use futures::sync::oneshot;
    use graph::components::server::query::GraphQLServerError;
    use graph::prelude::*;
    use graph_graphql::object;
    use graphql_parser::{self, query as q};
    use http::status::StatusCode;
    use std::collections::BTreeMap;

    use crate::test_utils;

    #[test]
    fn generates_500_for_internal_errors() {
        let future = GraphQLResponse::new(Err(GraphQLServerError::from("Some error")));
        let response = future.wait().expect("Should generate a response");
        test_utils::assert_error_response(response, StatusCode::INTERNAL_SERVER_ERROR);
    }

    #[test]
    fn generates_401_for_client_errors() {
        let error = GraphQLServerError::ClientError(String::from("foo"));
        let future = GraphQLResponse::new(Err(error));
        let response = future.wait().expect("Should generate a response");
        test_utils::assert_error_response(response, StatusCode::BAD_REQUEST);
    }

    #[test]
    fn generates_401_for_query_errors() {
        let parse_error = graphql_parser::parse_query("<>?><").unwrap_err();
        let query_error = QueryError::from(parse_error);
        let future = GraphQLResponse::new(Err(GraphQLServerError::from(query_error)));
        let response = future.wait().expect("Should generate a response");
        test_utils::assert_error_response(response, StatusCode::BAD_REQUEST);
    }

    #[test]
    fn generates_200_for_query_results() {
        let data = graphql_parser::query::Value::Object(BTreeMap::new());
        let query_result = QueryResult::new(Some(data));
        let future = GraphQLResponse::new(Ok(query_result));
        let response = future.wait().expect("Should generate a response");
        test_utils::assert_successful_response(response);
    }

    #[test]
    fn generates_valid_json_for_an_empty_result() {
        let data = graphql_parser::query::Value::Object(BTreeMap::new());
        let query_result = QueryResult::new(Some(data));
        let future = GraphQLResponse::new(Ok(query_result));
        let response = future.wait().expect("Should generate a response");
        let data = test_utils::assert_successful_response(response);
        assert!(data.is_empty());
    }

    #[test]
    fn generates_valid_json_when_canceled() {
        let err = GraphQLServerError::Canceled(oneshot::Canceled);
        let future = GraphQLResponse::new(Err(err));
        let response = future.wait().expect("Should generate a response");
        let errors = test_utils::assert_error_response(response, StatusCode::INTERNAL_SERVER_ERROR);
        assert_eq!(errors.len(), 1);

        let message = errors[0]
            .as_object()
            .expect("Cancellation error is not an object")
            .get("message")
            .expect("Error contains no message")
            .as_str()
            .expect("Error message is not a string");

        assert_eq!(message, "GraphQL server error (query was canceled)");
    }

    #[test]
    fn generates_valid_json_for_client_error() {
        let err = GraphQLServerError::ClientError(String::from("Something went wrong"));
        let future = GraphQLResponse::new(Err(err));
        let response = future.wait().expect("Should generate a response");
        let errors = test_utils::assert_error_response(response, StatusCode::BAD_REQUEST);
        assert_eq!(errors.len(), 1);

        let message = errors[0]
            .as_object()
            .expect("Client error is not an object")
            .get("message")
            .expect("Error contains no message")
            .as_str()
            .expect("Error message is not a string");

        assert_eq!(
            message,
            "GraphQL server error (client error): Something went wrong"
        );
    }

    #[test]
    fn generates_valid_json_for_query_error() {
        let parse_error =
            graphql_parser::parse_query("<><?").expect_err("Should fail parsing an invalid query");
        let query_error = QueryError::from(parse_error);
        let err = GraphQLServerError::QueryError(query_error);
        let future = GraphQLResponse::new(Err(err));
        let response = future.wait().expect("Should generate a response");
        let errors = test_utils::assert_error_response(response, StatusCode::BAD_REQUEST);
        assert_eq!(errors.len(), 1);

        let message = errors[0]
            .as_object()
            .expect("Query error is not an object")
            .get("message")
            .expect("Error contains no message")
            .as_str()
            .expect("Error message is not a string");

        assert_eq!(
            message,
            "Unexpected `unexpected character \
             \'<\'`\nExpected `{`, `query`, `mutation`, \
             `subscription` or `fragment`"
        );

        let locations = errors[0]
            .as_object()
            .expect("Query error is not an object")
            .get("locations")
            .expect("Query error contains not locations")
            .as_array()
            .expect("Query error \"locations\" field is not an array");

        let location = locations[0]
            .as_object()
            .expect("Query error location is not an object");

        let line = location
            .get("line")
            .expect("Query error location is missing a \"line\" field")
            .as_u64()
            .expect("Query error location \"line\" field is not a u64");

        assert_eq!(line, 1);

        let column = location
            .get("column")
            .expect("Query error location is missing a \"column\" field")
            .as_u64()
            .expect("Query error location \"column\" field is not a u64");

        assert_eq!(column, 1);
    }

    #[test]
    fn generates_valid_json_for_internal_error() {
        let err = GraphQLServerError::InternalError(String::from("Something went wrong"));
        let future = GraphQLResponse::new(Err(err));
        let response = future.wait().expect("Should generate a response");
        let errors = test_utils::assert_error_response(response, StatusCode::INTERNAL_SERVER_ERROR);
        assert_eq!(errors.len(), 1);

        let message = errors[0]
            .as_object()
            .expect("Client error is not an object")
            .get("message")
            .expect("Error contains no message")
            .as_str()
            .expect("Error message is not a string");

        assert_eq!(
            message,
            "GraphQL server error (internal error): Something went wrong"
        );
    }

    #[test]
    fn canonical_serialization() {
        macro_rules! assert_resp {
            ($exp: expr, $obj: expr) => {{
                {
                    // This match is solely there to make sure these tests
                    // get amended if q::Value ever gets more variants
                    // The order of the variants should be the same as the
                    // order of the tests below
                    use q::Value::*;
                    let _ = match $obj {
                        Variable(_) | Object(_) | List(_) | Enum(_) | Null | Int(_) | Float(_)
                        | String(_) | Boolean(_) => (),
                    };
                }
                let res = QueryResult::new(Some($obj));
                let resp = GraphQLResponse::new(Ok(res));
                assert_eq!($exp, serde_json::to_string(&resp).unwrap());
            }};
        }
        assert_resp!(r#"{"data":{"id":"12345"}}"#, object! { id: "12345" });

        // Value::Variable: nothing to check, not used in a response

        // Value::Object: Insertion order of keys does not matter
        let first_second = r#"{"data":{"first":"first","second":"second"}}"#;
        assert_resp!(first_second, object! { first: "first", second: "second" });
        assert_resp!(first_second, object! { second: "second", first: "first" });

        // Value::List
        assert_resp!(r#"{"data":{"ary":[1,2]}}"#, object! { ary: vec![1,2] });

        // Value::Enum
        assert_resp!(
            r#"{"data":{"enum_field":"enum"}}"#,
            object! { enum_field:  q::Value::Enum("enum".to_owned())}
        );

        // Value::Null
        assert_resp!(
            r#"{"data":{"nothing":null}}"#,
            object! { nothing:  q::Value::Null}
        );

        // Value::Int
        assert_resp!(
            r#"{"data":{"int32":17,"neg32":-314}}"#,
            object! { int32: 17, neg32: -314 }
        );

        // Value::Float
        assert_resp!(r#"{"data":{"float":3.14159}}"#, object! { float: 3.14159 });

        // Value::String
        assert_resp!(
            r#"{"data":{"text":"Ünïcödë with spaceß"}}"#,
            object! { text: "Ünïcödë with spaceß" }
        );

        // Value::Boolean
        assert_resp!(
            r#"{"data":{"no":false,"yes":true}}"#,
            object! { yes: true, no: false }
        );
    }
}

<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Adapters specific to `Result`-returning streams"><meta name="keywords" content="rust, rustlang, rust-lang, TryStreamExt"><title>graph::prelude::TryStreamExt - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc trait"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../graph/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Trait TryStreamExt</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#provided-methods">Provided Methods</a><div class="sidebar-links"><a href="#method.and_then">and_then</a><a href="#method.compat">compat</a><a href="#method.or_else">or_else</a><a href="#method.map_err">map_err</a><a href="#method.try_collect">try_collect</a><a href="#method.try_for_each">try_for_each</a><a href="#method.try_fold">try_fold</a><a href="#method.map_ok">map_ok</a><a href="#method.inspect_err">inspect_err</a><a href="#method.into_stream">into_stream</a><a href="#method.err_into">err_into</a><a href="#method.inspect_ok">inspect_ok</a><a href="#method.try_flatten">try_flatten</a><a href="#method.try_next">try_next</a><a href="#method.try_skip_while">try_skip_while</a><a href="#method.try_take_while">try_take_while</a><a href="#method.try_for_each_concurrent">try_for_each_concurrent</a><a href="#method.try_filter">try_filter</a><a href="#method.try_filter_map">try_filter_map</a><a href="#method.try_concat">try_concat</a><a href="#method.try_buffer_unordered">try_buffer_unordered</a><a href="#method.try_buffered">try_buffered</a><a href="#method.try_poll_next_unpin">try_poll_next_unpin</a><a href="#method.into_async_read">into_async_read</a></div><a class="sidebar-title" href="#implementors">Implementors</a></div><p class="location"><a href="../index.html">graph</a>::<wbr><a href="index.html">prelude</a></p><div id="sidebar-vars" data-name="TryStreamExt" data-ty="trait" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Trait <a href="../index.html">graph</a>::<wbr><a href="index.html">prelude</a>::<wbr><a class="trait" href="">TryStreamExt</a></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></span></h1><div class="docblock type-decl hidden-by-usual-hider"><pre class="rust trait">pub trait TryStreamExt: TryStream {
    pub fn <a href="#method.err_into" class="fnname">err_into</a>&lt;E&gt;(self) -&gt; ErrInto&lt;Self, E&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Error: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;E&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.map_ok" class="fnname">map_ok</a>&lt;T, F&gt;(self, f: F) -&gt; MapOk&lt;Self, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; T</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.map_err" class="fnname">map_err</a>&lt;E, F&gt;(self, f: F) -&gt; MapErr&lt;Self, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Error) -&gt; E</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.and_then" class="fnname">and_then</a>&lt;Fut, F&gt;(self, f: F) -&gt; AndThen&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Error = Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.or_else" class="fnname">or_else</a>&lt;Fut, F&gt;(self, f: F) -&gt; OrElse&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Error) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = Self::Ok&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.inspect_ok" class="fnname">inspect_ok</a>&lt;F&gt;(self, f: F) -&gt; InspectOk&lt;Self, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok)</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.inspect_err" class="fnname">inspect_err</a>&lt;F&gt;(self, f: F) -&gt; InspectErr&lt;Self, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Error)</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.into_stream" class="fnname">into_stream</a>(self) -&gt; IntoStream&lt;Self&gt; { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_next" class="fnname">try_next</a>(&amp;mut self) -&gt; TryNext&lt;'_, Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_for_each" class="fnname">try_for_each</a>&lt;Fut, F&gt;(self, f: F) -&gt; TryForEach&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, Error = Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_skip_while" class="fnname">try_skip_while</a>&lt;Fut, F&gt;(self, f: F) -&gt; TrySkipWhile&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, Error = Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_take_while" class="fnname">try_take_while</a>&lt;Fut, F&gt;(self, f: F) -&gt; TryTakeWhile&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, Error = Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_for_each_concurrent" class="fnname">try_for_each_concurrent</a>&lt;Fut, F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;limit: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; TryForEachConcurrent&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, Self::Error&gt;&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_collect" class="fnname">try_collect</a>&lt;C&gt;(self) -&gt; TryCollect&lt;Self, C&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;Self::Ok&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_filter" class="fnname">try_filter</a>&lt;Fut, F&gt;(self, f: F) -&gt; TryFilter&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_filter_map" class="fnname">try_filter_map</a>&lt;Fut, F, T&gt;(self, f: F) -&gt; TryFilterMap&lt;Self, Fut, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;, Error = Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_flatten" class="fnname">try_flatten</a>(self) -&gt; TryFlatten&lt;Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: TryStream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Self::Ok as TryStream&gt;::Error: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_fold" class="fnname">try_fold</a>&lt;T, Fut, F&gt;(self, init: T, f: F) -&gt; TryFold&lt;Self, Fut, T, F&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(T, Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = T, Error = Self::Error&gt;</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_concat" class="fnname">try_concat</a>(self) -&gt; TryConcat&lt;Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;&lt;Self::Ok as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a></span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_buffer_unordered" class="fnname">try_buffer_unordered</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; TryBufferUnordered&lt;Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: TryFuture,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Self::Ok as TryFuture&gt;::Error == Self::Error</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_buffered" class="fnname">try_buffered</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; TryBuffered&lt;Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: TryFuture,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;Self::Ok as TryFuture&gt;::Error == Self::Error</span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.try_poll_next_unpin" class="fnname">try_poll_next_unpin</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self::Ok, Self::Error&gt;&gt;&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.compat" class="fnname">compat</a>(self) -&gt; Compat&lt;Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a></span>,
    { ... }
<div class="item-spacer"></div>    pub fn <a href="#method.into_async_read" class="fnname">into_async_read</a>(self) -&gt; IntoAsyncRead&lt;Self&gt;<br>&nbsp;&nbsp;&nbsp; <span class="where">where<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="../../graph/prelude/trait.TryStreamExt.html" title="trait graph::prelude::TryStreamExt">TryStreamExt</a>&lt;Error = <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;</span>,
    { ... }
}</pre></div><div class="docblock"><p>Adapters specific to <code>Result</code>-returning streams</p>
</div><h2 id="provided-methods" class="small-section-header">Provided methods<a href="#provided-methods" class="anchor"></a></h2><div class="methods"><h3 id="method.err_into" class="method"><code>pub fn <a href="#method.err_into" class="fnname">err_into</a>&lt;E&gt;(self) -&gt; ErrInto&lt;Self, E&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Error: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;E&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Wraps the current stream in a new stream which converts the error type
into the one provided.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span>
    <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(()), <span class="prelude-val">Err</span>(<span class="number">5i32</span>)])
        .<span class="ident">err_into</span>::<span class="op">&lt;</span><span class="ident">i64</span><span class="op">&gt;</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(())));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Err</span>(<span class="number">5i64</span>));</pre></div>
</div><h3 id="method.map_ok" class="method"><code>pub fn <a href="#method.map_ok" class="fnname">map_ok</a>&lt;T, F&gt;(self, f: F) -&gt; MapOk&lt;Self, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; T,&nbsp;</span></code></h3><div class="docblock"><p>Wraps the current stream in a new stream which maps the success value
using the provided closure.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span>
    <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="number">5</span>), <span class="prelude-val">Err</span>(<span class="number">0</span>)])
        .<span class="ident">map_ok</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">+</span> <span class="number">2</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">7</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Err</span>(<span class="number">0</span>));</pre></div>
</div><h3 id="method.map_err" class="method"><code>pub fn <a href="#method.map_err" class="fnname">map_err</a>&lt;E, F&gt;(self, f: F) -&gt; MapErr&lt;Self, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Error) -&gt; E,&nbsp;</span></code></h3><div class="docblock"><p>Wraps the current stream in a new stream which maps the error value
using the provided closure.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span>
    <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="number">5</span>), <span class="prelude-val">Err</span>(<span class="number">0</span>)])
        .<span class="ident">map_err</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span> <span class="op">+</span> <span class="number">2</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(<span class="number">5</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Err</span>(<span class="number">2</span>));</pre></div>
</div><h3 id="method.and_then" class="method"><code>pub fn <a href="#method.and_then" class="fnname">and_then</a>&lt;Fut, F&gt;(self, f: F) -&gt; AndThen&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Error = Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Chain on a computation for when a value is ready, passing the successful
results to the provided closure <code>f</code>.</p>
<p>This function can be used to run a unit of work when the next successful
value on a stream is ready. The closure provided will be yielded a value
when ready, and the returned future will then be run to completion to
produce the next value on this stream.</p>
<p>Any errors produced by this stream will not be passed to the closure,
and will be passed through.</p>
<p>The returned value of the closure must implement the <code>TryFuture</code> trait
and can represent some more work to be done before the composed stream
is finished.</p>
<p>Note that this function consumes the receiving stream and returns a
wrapped version of it.</p>
<p>To process the entire stream and return a single future representing
success or error, use <code>try_for_each</code> instead.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">mpsc</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::<span class="ident">TryStreamExt</span>;

<span class="kw">let</span> (<span class="ident">_tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">channel</span>::<span class="op">&lt;</span><span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">i32</span>, ()<span class="op">&gt;</span><span class="op">&gt;</span>(<span class="number">1</span>);

<span class="kw">let</span> <span class="ident">rx</span> <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">and_then</span>(<span class="op">|</span><span class="ident">result</span><span class="op">|</span> {
    <span class="ident">future</span>::<span class="ident">ok</span>(<span class="kw">if</span> <span class="ident">result</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
        <span class="prelude-val">Some</span>(<span class="ident">result</span>)
    } <span class="kw">else</span> {
        <span class="prelude-val">None</span>
    })
});</pre></div>
</div><h3 id="method.or_else" class="method"><code>pub fn <a href="#method.or_else" class="fnname">or_else</a>&lt;Fut, F&gt;(self, f: F) -&gt; OrElse&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Error) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = Self::Ok&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Chain on a computation for when an error happens, passing the
erroneous result to the provided closure <code>f</code>.</p>
<p>This function can be used to run a unit of work and attempt to recover from
an error if one happens. The closure provided will be yielded an error
when one appears, and the returned future will then be run to completion
to produce the next value on this stream.</p>
<p>Any successful values produced by this stream will not be passed to the
closure, and will be passed through.</p>
<p>The returned value of the closure must implement the <a href="futures_core::future::TryFuture"><code>TryFuture</code></a> trait
and can represent some more work to be done before the composed stream
is finished.</p>
<p>Note that this function consumes the receiving stream and returns a
wrapped version of it.</p>
</div><h3 id="method.inspect_ok" class="method"><code>pub fn <a href="#method.inspect_ok" class="fnname">inspect_ok</a>&lt;F&gt;(self, f: F) -&gt; InspectOk&lt;Self, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok),&nbsp;</span></code></h3><div class="docblock"><p>Do something with the success value of this stream, afterwards passing
it on.</p>
<p>This is similar to the <code>StreamExt::inspect</code> method where it allows
easily inspecting the success value as it passes through the stream, for
example to debug what’s going on.</p>
</div><h3 id="method.inspect_err" class="method"><code>pub fn <a href="#method.inspect_err" class="fnname">inspect_err</a>&lt;F&gt;(self, f: F) -&gt; InspectErr&lt;Self, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Error),&nbsp;</span></code></h3><div class="docblock"><p>Do something with the error value of this stream, afterwards passing it on.</p>
<p>This is similar to the <code>StreamExt::inspect</code> method where it allows
easily inspecting the error value as it passes through the stream, for
example to debug what’s going on.</p>
</div><h3 id="method.into_stream" class="method"><code>pub fn <a href="#method.into_stream" class="fnname">into_stream</a>(self) -&gt; IntoStream&lt;Self&gt;</code></h3><div class="docblock"><p>Wraps a [<code>TryStream</code>] into a type that implements
<a href="futures_core::stream::Stream"><code>Stream</code></a></p>
<p>[<code>TryStream</code>]s currently do not implement the
<a href="futures_core::stream::Stream"><code>Stream</code></a> trait because of limitations
of the compiler.</p>
<h1 id="examples-4" class="section-header"><a href="#examples-4">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="ident">Stream</span>, <span class="ident">TryStream</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">fn</span> <span class="ident">make_try_stream</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="kw">impl</span> <span class="ident">TryStream</span><span class="op">&lt;</span><span class="prelude-val">Ok</span> <span class="op">=</span> <span class="ident">T</span>, <span class="ident">Error</span> <span class="op">=</span> <span class="ident">E</span><span class="op">&gt;</span> { <span class="comment">// ... }</span>
<span class="kw">fn</span> <span class="ident">take_stream</span>(<span class="ident">stream</span>: <span class="kw">impl</span> <span class="ident">Stream</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">T</span>, <span class="ident">E</span><span class="op">&gt;</span><span class="op">&gt;</span>) { <span class="comment">/* ... */</span> }

<span class="ident">take_stream</span>(<span class="ident">make_try_stream</span>().<span class="ident">into_stream</span>());</pre></div>
</div><h3 id="method.try_next" class="method"><code>pub fn <a href="#method.try_next" class="fnname">try_next</a>(&amp;mut self) -&gt; TryNext&lt;'_, Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code></h3><div class="docblock"><p>Creates a future that attempts to resolve the next item in the stream.
If an error is encountered before the next item, the error is returned
instead.</p>
<p>This is similar to the <code>Stream::next</code> combinator, but returns a
<code>Result&lt;Option&lt;T&gt;, E&gt;</code> rather than an <code>Option&lt;Result&lt;T, E&gt;&gt;</code>, making
for easy use with the <code>?</code> operator.</p>
<h1 id="examples-5" class="section-header"><a href="#examples-5">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(()), <span class="prelude-val">Err</span>(())]);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Ok</span>(<span class="prelude-val">Some</span>(())));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">try_next</span>().<span class="kw">await</span>, <span class="prelude-val">Err</span>(()));</pre></div>
</div><h3 id="method.try_for_each" class="method"><code>pub fn <a href="#method.try_for_each" class="fnname">try_for_each</a>&lt;Fut, F&gt;(self, f: F) -&gt; TryForEach&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, Error = Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Attempts to run this stream to completion, executing the provided
asynchronous closure for each element on the stream.</p>
<p>The provided closure will be called for each item this stream produces,
yielding a future. That future will then be executed to completion
before moving on to the next item.</p>
<p>The returned value is a <a href="futures_core::future::Future"><code>Future</code></a> where the
<a href="futures_core::future::Future::Output"><code>Output</code></a> type is
<code>Result&lt;(), Self::Error&gt;</code>. If any of the intermediate
futures or the stream returns an error, this future will return
immediately with an error.</p>
<h1 id="examples-6" class="section-header"><a href="#examples-6">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="number">0i32</span>;

{
    <span class="kw">let</span> <span class="ident">fut</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">repeat</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>)).<span class="ident">try_for_each</span>(<span class="op">|</span><span class="ident">item</span><span class="op">|</span> {
        <span class="ident">x</span> <span class="op">+</span><span class="op">=</span> <span class="ident">item</span>;
        <span class="ident">future</span>::<span class="ident">ready</span>(<span class="kw">if</span> <span class="ident">x</span> <span class="op">=</span><span class="op">=</span> <span class="number">3</span> { <span class="prelude-val">Err</span>(()) } <span class="kw">else</span> { <span class="prelude-val">Ok</span>(()) })
    });
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">fut</span>.<span class="kw">await</span>, <span class="prelude-val">Err</span>(()));
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="number">3</span>);</pre></div>
</div><h3 id="method.try_skip_while" class="method"><code>pub fn <a href="#method.try_skip_while" class="fnname">try_skip_while</a>&lt;Fut, F&gt;(self, f: F) -&gt; TrySkipWhile&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, Error = Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Skip elements on this stream while the provided asynchronous predicate
resolves to <code>true</code>.</p>
<p>This function is similar to
<a href="crate::stream::StreamExt::skip_while"><code>StreamExt::skip_while</code></a> but exits
early if an error occurs.</p>
<h1 id="examples-7" class="section-header"><a href="#examples-7">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">3</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>)]);
<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">try_skip_while</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">future</span>::<span class="ident">ready</span>(<span class="prelude-val">Ok</span>(<span class="kw-2">*</span><span class="ident">x</span> <span class="op">&lt;</span> <span class="number">3</span>)));

<span class="kw">let</span> <span class="ident">output</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">try_collect</span>().<span class="kw">await</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">output</span>, <span class="prelude-val">Ok</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">3</span>, <span class="number">2</span>]));</pre></div>
</div><h3 id="method.try_take_while" class="method"><code>pub fn <a href="#method.try_take_while" class="fnname">try_take_while</a>&lt;Fut, F&gt;(self, f: F) -&gt; TryTakeWhile&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>, Error = Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Take elements on this stream while the provided asynchronous predicate
resolves to <code>true</code>.</p>
<p>This function is similar to
<a href="crate::stream::StreamExt::take_while"><code>StreamExt::take_while</code></a> but exits
early if an error occurs.</p>
<h1 id="examples-8" class="section-header"><a href="#examples-8">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">3</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>)]);
<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">try_take_while</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="ident">future</span>::<span class="ident">ready</span>(<span class="prelude-val">Ok</span>(<span class="kw-2">*</span><span class="ident">x</span> <span class="op">&lt;</span> <span class="number">3</span>)));

<span class="kw">let</span> <span class="ident">output</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">try_collect</span>().<span class="kw">await</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">output</span>, <span class="prelude-val">Ok</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>]));</pre></div>
</div><h3 id="method.try_for_each_concurrent" class="method"><code>pub fn <a href="#method.try_for_each_concurrent" class="fnname">try_for_each_concurrent</a>&lt;Fut, F&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;limit: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt;, <br>&nbsp;&nbsp;&nbsp;&nbsp;f: F<br>) -&gt; TryForEachConcurrent&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, Self::Error&gt;&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Attempts to run this stream to completion, executing the provided asynchronous
closure for each element on the stream concurrently as elements become
available, exiting as soon as an error occurs.</p>
<p>This is similar to
<a href="crate::stream::StreamExt::for_each_concurrent"><code>StreamExt::for_each_concurrent</code></a>,
but will resolve to an error immediately if the underlying stream or the provided
closure return an error.</p>
<p>This method is only available when the <code>std</code> or <code>alloc</code> feature of this
library is activated, and it is activated by default.</p>
<h1 id="examples-9" class="section-header"><a href="#examples-9">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">oneshot</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> (<span class="ident">tx1</span>, <span class="ident">rx1</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();
<span class="kw">let</span> (<span class="ident">tx2</span>, <span class="ident">rx2</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();
<span class="kw">let</span> (<span class="ident">_tx3</span>, <span class="ident">rx3</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();

<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="ident">rx1</span>, <span class="ident">rx2</span>, <span class="ident">rx3</span>]);
<span class="kw">let</span> <span class="ident">fut</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">map</span>(<span class="prelude-val">Ok</span>).<span class="ident">try_for_each_concurrent</span>(
    <span class="comment">/* limit */</span> <span class="number">2</span>,
    <span class="op">|</span><span class="ident">rx</span><span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> {
        <span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">oneshot</span>::<span class="ident">Canceled</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">rx</span>.<span class="kw">await</span>;
        <span class="ident">res</span>
    }
);

<span class="ident">tx1</span>.<span class="ident">send</span>(()).<span class="ident">unwrap</span>();
<span class="comment">// Drop the second sender so that `rx2` resolves to `Canceled`.</span>
<span class="ident">drop</span>(<span class="ident">tx2</span>);

<span class="comment">// The final result is an error because the second future</span>
<span class="comment">// resulted in an error.</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Err</span>(<span class="ident">oneshot</span>::<span class="ident">Canceled</span>), <span class="ident">fut</span>.<span class="kw">await</span>);</pre></div>
</div><h3 id="method.try_collect" class="method"><code>pub fn <a href="#method.try_collect" class="fnname">try_collect</a>&lt;C&gt;(self) -&gt; TryCollect&lt;Self, C&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;C: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;Self::Ok&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to transform a stream into a collection,
returning a future representing the result of that computation.</p>
<p>This combinator will collect all successful results of this stream and
collect them into the specified collection type. If an error happens then all
collected elements will be dropped and the error will be returned.</p>
<p>The returned future will be resolved when the stream terminates.</p>
<h1 id="examples-10" class="section-header"><a href="#examples-10">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">mpsc</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::<span class="ident">TryStreamExt</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">1</span>..<span class="op">=</span><span class="number">5</span> {
        <span class="ident">tx</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="ident">i</span>)).<span class="ident">unwrap</span>();
    }
    <span class="ident">tx</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Err</span>(<span class="number">6</span>)).<span class="ident">unwrap</span>();
});

<span class="kw">let</span> <span class="ident">output</span>: <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, <span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">try_collect</span>().<span class="kw">await</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">output</span>, <span class="prelude-val">Err</span>(<span class="number">6</span>));</pre></div>
</div><h3 id="method.try_filter" class="method"><code>pub fn <a href="#method.try_filter" class="fnname">try_filter</a>&lt;Fut, F&gt;(self, f: F) -&gt; TryFilter&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(&amp;Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: <a class="trait" href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future">Future</a>&lt;Output = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to filter the values produced by this stream according to the
provided asynchronous closure.</p>
<p>As values of this stream are made available, the provided predicate <code>f</code>
will be run on them. If the predicate returns a <code>Future</code> which resolves
to <code>true</code>, then the stream will yield the value, but if the predicate
return a <code>Future</code> which resolves to <code>false</code>, then the value will be
discarded and the next value will be produced.</p>
<p>All errors are passed through without filtering in this combinator.</p>
<p>Note that this function consumes the stream passed into it and returns a
wrapped version of it, similar to the existing <code>filter</code> methods in
the standard library.</p>
<h1 id="examples-11" class="section-header"><a href="#examples-11">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="number">1i32</span>), <span class="prelude-val">Ok</span>(<span class="number">2i32</span>), <span class="prelude-val">Ok</span>(<span class="number">3i32</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;error&quot;</span>)]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">evens</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">try_filter</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> {
    <span class="ident">future</span>::<span class="ident">ready</span>(<span class="ident">x</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>)
});

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">evens</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">evens</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;error&quot;</span>)));</pre></div>
</div><h3 id="method.try_filter_map" class="method"><code>pub fn <a href="#method.try_filter_map" class="fnname">try_filter_map</a>&lt;Fut, F, T&gt;(self, f: F) -&gt; TryFilterMap&lt;Self, Fut, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = <a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;T&gt;, Error = Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to filter the values produced by this stream while
simultaneously mapping them to a different type according to the
provided asynchronous closure.</p>
<p>As values of this stream are made available, the provided function will
be run on them. If the future returned by the predicate <code>f</code> resolves to
<a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.Some"><code>Some(item)</code></a> then the stream will yield the value <code>item</code>, but if
it resolves to <a href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html#variant.None" title="None"><code>None</code></a> then the next value will be produced.</p>
<p>All errors are passed through without filtering in this combinator.</p>
<p>Note that this function consumes the stream passed into it and returns a
wrapped version of it, similar to the existing <code>filter_map</code> methods in
the standard library.</p>
<h1 id="examples-12" class="section-header"><a href="#examples-12">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">pin_mut</span>;

<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="number">1i32</span>), <span class="prelude-val">Ok</span>(<span class="number">6i32</span>), <span class="prelude-val">Err</span>(<span class="string">&quot;error&quot;</span>)]);
<span class="kw">let</span> <span class="ident">halves</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">try_filter_map</span>(<span class="op">|</span><span class="ident">x</span><span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> {
    <span class="kw">let</span> <span class="ident">ret</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">x</span> <span class="op">%</span> <span class="number">2</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> { <span class="prelude-val">Some</span>(<span class="ident">x</span> <span class="op">/</span> <span class="number">2</span>) } <span class="kw">else</span> { <span class="prelude-val">None</span> };
    <span class="prelude-val">Ok</span>(<span class="ident">ret</span>)
});

<span class="macro">pin_mut</span><span class="macro">!</span>(<span class="ident">halves</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">halves</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">3</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">halves</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;error&quot;</span>)));</pre></div>
</div><h3 id="method.try_flatten" class="method"><code>pub fn <a href="#method.try_flatten" class="fnname">try_flatten</a>(self) -&gt; TryFlatten&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: TryStream,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Self::Ok as TryStream&gt;::Error: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Flattens a stream of streams into just one continuous stream.</p>
<p>If this stream’s elements are themselves streams then this combinator
will flatten out the entire stream to one long chain of elements. Any
errors are passed through without looking at them, but otherwise each
individual stream will get exhausted before moving on to the next.</p>
<h1 id="examples-13" class="section-header"><a href="#examples-13">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">mpsc</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="kw">let</span> (<span class="ident">tx1</span>, <span class="ident">rx1</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>();
<span class="kw">let</span> (<span class="ident">tx2</span>, <span class="ident">rx2</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>();
<span class="kw">let</span> (<span class="ident">tx3</span>, <span class="ident">rx3</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">tx1</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>)).<span class="ident">unwrap</span>();
});
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">tx2</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>)).<span class="ident">unwrap</span>();
    <span class="ident">tx2</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Err</span>(<span class="number">3</span>)).<span class="ident">unwrap</span>();
});
<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="ident">tx3</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="ident">rx1</span>)).<span class="ident">unwrap</span>();
    <span class="ident">tx3</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="ident">rx2</span>)).<span class="ident">unwrap</span>();
    <span class="ident">tx3</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Err</span>(<span class="number">4</span>)).<span class="ident">unwrap</span>();
});

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">rx3</span>.<span class="ident">try_flatten</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">1</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">2</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">stream</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(<span class="number">3</span>)));</pre></div>
</div><h3 id="method.try_fold" class="method"><code>pub fn <a href="#method.try_fold" class="fnname">try_fold</a>&lt;T, Fut, F&gt;(self, init: T, f: F) -&gt; TryFold&lt;Self, Fut, T, F&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnMut.html" title="trait core::ops::function::FnMut">FnMut</a>(T, Self::Ok) -&gt; Fut,<br>&nbsp;&nbsp;&nbsp;&nbsp;Fut: TryFuture&lt;Ok = T, Error = Self::Error&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to execute an accumulating asynchronous computation over a
stream, collecting all the values into one final result.</p>
<p>This combinator will accumulate all values returned by this stream
according to the closure provided. The initial state is also provided to
this method and then is returned again by each execution of the closure.
Once the entire stream has been exhausted the returned future will
resolve to this value.</p>
<p>This method is similar to <a href="crate::stream::StreamExt::fold"><code>fold</code></a>, but will
exit early if an error is encountered in either the stream or the
provided closure.</p>
<h1 id="examples-14" class="section-header"><a href="#examples-14">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> <span class="ident">number_stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span>(<span class="number">1</span>), <span class="prelude-val">Ok</span>(<span class="number">2</span>)]);
<span class="kw">let</span> <span class="ident">sum</span> <span class="op">=</span> <span class="ident">number_stream</span>.<span class="ident">try_fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> { <span class="prelude-val">Ok</span>(<span class="ident">acc</span> <span class="op">+</span> <span class="ident">x</span>) });
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sum</span>.<span class="kw">await</span>, <span class="prelude-val">Ok</span>(<span class="number">3</span>));

<span class="kw">let</span> <span class="ident">number_stream_with_err</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>::<span class="op">&lt;</span><span class="ident">i32</span>, <span class="ident">i32</span><span class="op">&gt;</span>(<span class="number">1</span>), <span class="prelude-val">Err</span>(<span class="number">2</span>), <span class="prelude-val">Ok</span>(<span class="number">1</span>)]);
<span class="kw">let</span> <span class="ident">sum</span> <span class="op">=</span> <span class="ident">number_stream_with_err</span>.<span class="ident">try_fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">acc</span>, <span class="ident">x</span><span class="op">|</span> <span class="kw">async</span> <span class="kw">move</span> { <span class="prelude-val">Ok</span>(<span class="ident">acc</span> <span class="op">+</span> <span class="ident">x</span>) });
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">sum</span>.<span class="kw">await</span>, <span class="prelude-val">Err</span>(<span class="number">2</span>));</pre></div>
</div><h3 id="method.try_concat" class="method"><code>pub fn <a href="#method.try_concat" class="fnname">try_concat</a>(self) -&gt; TryConcat&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html" title="trait core::iter::traits::collect::Extend">Extend</a>&lt;&lt;Self::Ok as <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html#associatedtype.Item" title="type core::iter::traits::collect::IntoIterator::Item">Item</a>&gt;,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.IntoIterator.html" title="trait core::iter::traits::collect::IntoIterator">IntoIterator</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/default/trait.Default.html" title="trait core::default::Default">Default</a>,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to concatenate all items of a stream into a single
extendable destination, returning a future representing the end result.</p>
<p>This combinator will extend the first item with the contents of all
the subsequent successful results of the stream. If the stream is empty,
the default value will be returned.</p>
<p>Works with all collections that implement the <a href="https://doc.rust-lang.org/nightly/core/iter/traits/collect/trait.Extend.html"><code>Extend</code></a> trait.</p>
<p>This method is similar to <a href="crate::stream::StreamExt::concat"><code>concat</code></a>, but will
exit early if an error is encountered in the stream.</p>
<h1 id="examples-15" class="section-header"><a href="#examples-15">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">mpsc</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::<span class="ident">TryStreamExt</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">thread</span>;

<span class="kw">let</span> (<span class="ident">tx</span>, <span class="ident">rx</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>::<span class="op">&lt;</span><span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>, ()<span class="op">&gt;</span><span class="op">&gt;</span>();

<span class="ident">thread</span>::<span class="ident">spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
    <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> (<span class="number">0</span>..<span class="number">3</span>).<span class="ident">rev</span>() {
        <span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">i</span> <span class="op">*</span> <span class="number">3</span>;
        <span class="ident">tx</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="ident">n</span> <span class="op">+</span> <span class="number">1</span>, <span class="ident">n</span> <span class="op">+</span> <span class="number">2</span>, <span class="ident">n</span> <span class="op">+</span> <span class="number">3</span>])).<span class="ident">unwrap</span>();
    }
});

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">rx</span>.<span class="ident">try_concat</span>().<span class="kw">await</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="prelude-val">Ok</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));</pre></div>
</div><h3 id="method.try_buffer_unordered" class="method"><code>pub fn <a href="#method.try_buffer_unordered" class="fnname">try_buffer_unordered</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; TryBufferUnordered&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: TryFuture,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Self::Ok as TryFuture&gt;::Error == Self::Error,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to execute several futures from a stream concurrently (unordered).</p>
<p>This stream’s <code>Ok</code> type must be a <a href="futures_core::future::TryFuture"><code>TryFuture</code></a> with an <code>Error</code> type
that matches the stream’s <code>Error</code> type.</p>
<p>This adaptor will buffer up to <code>n</code> futures and then return their
outputs in the order in which they complete. If the underlying stream
returns an error, it will be immediately propagated.</p>
<p>The returned stream will be a stream of results, each containing either
an error or a future’s output. An error can be produced either by the
underlying stream itself or by one of the futures it yielded.</p>
<p>This method is only available when the <code>std</code> or <code>alloc</code> feature of this
library is activated, and it is activated by default.</p>
<h1 id="examples-16" class="section-header"><a href="#examples-16">Examples</a></h1>
<p>Results are returned in the order of completion:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">oneshot</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> (<span class="ident">send_one</span>, <span class="ident">recv_one</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();
<span class="kw">let</span> (<span class="ident">send_two</span>, <span class="ident">recv_two</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();

<span class="kw">let</span> <span class="ident">stream_of_futures</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="ident">recv_one</span>), <span class="prelude-val">Ok</span>(<span class="ident">recv_two</span>)]);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffered</span> <span class="op">=</span> <span class="ident">stream_of_futures</span>.<span class="ident">try_buffer_unordered</span>(<span class="number">10</span>);

<span class="ident">send_two</span>.<span class="ident">send</span>(<span class="number">2i32</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">2i32</span>)));

<span class="ident">send_one</span>.<span class="ident">send</span>(<span class="number">1i32</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">1i32</span>)));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">None</span>);</pre></div>
<p>Errors from the underlying stream itself are propagated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">mpsc</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> (<span class="ident">sink</span>, <span class="ident">stream_of_futures</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffered</span> <span class="op">=</span> <span class="ident">stream_of_futures</span>.<span class="ident">try_buffer_unordered</span>(<span class="number">10</span>);

<span class="ident">sink</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="kw">async</span> { <span class="prelude-val">Ok</span>(<span class="number">7i32</span>) }))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">7i32</span>)));

<span class="ident">sink</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;error in the stream&quot;</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;error in the stream&quot;</span>)));</pre></div>
</div><h3 id="method.try_buffered" class="method"><code>pub fn <a href="#method.try_buffered" class="fnname">try_buffered</a>(self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; TryBuffered&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: TryFuture,<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;Self::Ok as TryFuture&gt;::Error == Self::Error,&nbsp;</span></code></h3><div class="docblock"><p>Attempt to execute several futures from a stream concurrently.</p>
<p>This stream’s <code>Ok</code> type must be a <a href="futures_core::future::TryFuture"><code>TryFuture</code></a> with an <code>Error</code> type
that matches the stream’s <code>Error</code> type.</p>
<p>This adaptor will buffer up to <code>n</code> futures and then return their
outputs in the order. If the underlying stream returns an error, it will
be immediately propagated.</p>
<p>The returned stream will be a stream of results, each containing either
an error or a future’s output. An error can be produced either by the
underlying stream itself or by one of the futures it yielded.</p>
<p>This method is only available when the <code>std</code> or <code>alloc</code> feature of this
library is activated, and it is activated by default.</p>
<h1 id="examples-17" class="section-header"><a href="#examples-17">Examples</a></h1>
<p>Results are returned in the order of addition:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">oneshot</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>::<span class="ident">lazy</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> (<span class="ident">send_one</span>, <span class="ident">recv_one</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();
<span class="kw">let</span> (<span class="ident">send_two</span>, <span class="ident">recv_two</span>) <span class="op">=</span> <span class="ident">oneshot</span>::<span class="ident">channel</span>();

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffered</span> <span class="op">=</span> <span class="ident">lazy</span>(<span class="kw">move</span> <span class="op">|</span><span class="ident">cx</span><span class="op">|</span> {
    <span class="kw">let</span> <span class="ident">stream_of_futures</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="ident">recv_one</span>), <span class="prelude-val">Ok</span>(<span class="ident">recv_two</span>)]);

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffered</span> <span class="op">=</span> <span class="ident">stream_of_futures</span>.<span class="ident">try_buffered</span>(<span class="number">10</span>);

    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">try_poll_next_unpin</span>(<span class="ident">cx</span>).<span class="ident">is_pending</span>());

    <span class="ident">send_two</span>.<span class="ident">send</span>(<span class="number">2i32</span>)<span class="question-mark">?</span>;
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">try_poll_next_unpin</span>(<span class="ident">cx</span>).<span class="ident">is_pending</span>());
    <span class="prelude-val">Ok</span>::<span class="op">&lt;</span><span class="kw">_</span>, <span class="ident">i32</span><span class="op">&gt;</span>(<span class="ident">buffered</span>)
}).<span class="kw">await</span><span class="question-mark">?</span>;

<span class="ident">send_one</span>.<span class="ident">send</span>(<span class="number">1i32</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">1i32</span>)));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">2i32</span>)));

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">None</span>);</pre></div>
<p>Errors from the underlying stream itself are propagated:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">channel</span>::<span class="ident">mpsc</span>;
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="ident">StreamExt</span>, <span class="ident">TryStreamExt</span>};

<span class="kw">let</span> (<span class="ident">sink</span>, <span class="ident">stream_of_futures</span>) <span class="op">=</span> <span class="ident">mpsc</span>::<span class="ident">unbounded</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffered</span> <span class="op">=</span> <span class="ident">stream_of_futures</span>.<span class="ident">try_buffered</span>(<span class="number">10</span>);

<span class="ident">sink</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Ok</span>(<span class="kw">async</span> { <span class="prelude-val">Ok</span>(<span class="number">7i32</span>) }))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Ok</span>(<span class="number">7i32</span>)));

<span class="ident">sink</span>.<span class="ident">unbounded_send</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;error in the stream&quot;</span>))<span class="question-mark">?</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buffered</span>.<span class="ident">next</span>().<span class="kw">await</span>, <span class="prelude-val">Some</span>(<span class="prelude-val">Err</span>(<span class="string">&quot;error in the stream&quot;</span>)));</pre></div>
</div><h3 id="method.try_poll_next_unpin" class="method"><code>pub fn <a href="#method.try_poll_next_unpin" class="fnname">try_poll_next_unpin</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;mut self, <br>&nbsp;&nbsp;&nbsp;&nbsp;cx: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Context.html" title="struct core::task::wake::Context">Context</a>&lt;'_&gt;<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/task/poll/enum.Poll.html" title="enum core::task::poll::Poll">Poll</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self::Ok, Self::Error&gt;&gt;&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code></h3><div class="docblock"><p>A convenience method for calling [<code>TryStream::try_poll_next</code>] on <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a>
stream types.</p>
</div><h3 id="method.compat" class="method"><code>pub fn <a href="#method.compat" class="fnname">compat</a>(self) -&gt; Compat&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,&nbsp;</span></code></h3><div class="docblock"><p>Wraps a [<code>TryStream</code>] into a stream compatible with libraries using
futures 0.1 <code>Stream</code>. Requires the <code>compat</code> feature to be enabled.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">future</span>::{<span class="ident">FutureExt</span>, <span class="ident">TryFutureExt</span>};

<span class="kw">let</span> <span class="ident">future03</span> <span class="op">=</span> <span class="kw">async</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Running on the pool&quot;</span>);
    <span class="ident">tx</span>.<span class="ident">send</span>(<span class="number">42</span>).<span class="ident">unwrap</span>();
};

<span class="kw">let</span> <span class="ident">future01</span> <span class="op">=</span> <span class="ident">future03</span>
    .<span class="ident">unit_error</span>() <span class="comment">// Make it a TryFuture</span>
    .<span class="ident">boxed</span>()  <span class="comment">// Make it Unpin</span>
    .<span class="ident">compat</span>();

<span class="ident">tokio</span>::<span class="ident">run</span>(<span class="ident">future01</span>);</pre></div>
</div><h3 id="method.into_async_read" class="method"><code>pub fn <a href="#method.into_async_read" class="fnname">into_async_read</a>(self) -&gt; IntoAsyncRead&lt;Self&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;Self: <a class="trait" href="../../graph/prelude/trait.TryStreamExt.html" title="trait graph::prelude::TryStreamExt">TryStreamExt</a>&lt;Error = <a class="struct" href="https://doc.rust-lang.org/nightly/std/io/error/struct.Error.html" title="struct std::io::error::Error">Error</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a>,<br>&nbsp;&nbsp;&nbsp;&nbsp;Self::Ok: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">[</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.slice.html">]</a>&gt;,&nbsp;</span></code></h3><div class="docblock"><p>Adapter that converts this stream into an <a href="crate::io::AsyncRead"><code>AsyncRead</code></a>.</p>
<p>Note that because <code>into_async_read</code> moves the stream, the <a href="futures_core::stream::Stream"><code>Stream</code></a> type must be
<a href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="Unpin"><code>Unpin</code></a>. If you want to use <code>into_async_read</code> with a <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html"><code>!Unpin</code></a> stream, you’ll
first have to pin the stream. This can be done by boxing the stream using <a href="https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html#method.pin" title="Box::pin"><code>Box::pin</code></a>
or pinning it to the stack using the <code>pin_mut!</code> macro from the <code>pin_utils</code> crate.</p>
<p>This method is only available when the <code>std</code> feature of this
library is activated, and it is activated by default.</p>
<h1 id="examples-18" class="section-header"><a href="#examples-18">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">stream</span>::{<span class="self">self</span>, <span class="ident">TryStreamExt</span>};
<span class="kw">use</span> <span class="ident">futures</span>::<span class="ident">io</span>::<span class="ident">AsyncReadExt</span>;

<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">stream</span>::<span class="ident">iter</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="prelude-val">Ok</span>(<span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])]);
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">reader</span> <span class="op">=</span> <span class="ident">stream</span>.<span class="ident">into_async_read</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buf</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">reader</span>.<span class="ident">read_to_end</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">buf</span>).<span class="kw">await</span>.<span class="ident">is_ok</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">buf</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</pre></div>
</div></div><span class="loading-content">Loading content...</span><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor"></a></h2><div class="item-list" id="implementors-list"><h3 id="impl-TryStreamExt" class="impl"><code class="in-band">impl&lt;S&gt; <a class="trait" href="../../graph/prelude/trait.TryStreamExt.html" title="trait graph::prelude::TryStreamExt">TryStreamExt</a> for S <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;S: TryStream + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-TryStreamExt" class="anchor"></a></h3><div class="impl-items"></div></div><span class="loading-content">Loading content...</span><script type="text/javascript" src="../../implementors/futures_util/stream/try_stream/trait.TryStreamExt.js" async></script></section><section id="search" class="content hidden"></section><section class="footer"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="graph" data-search-js="../../search-index.js"></div>
    <script src="../../main.js"></script></body></html>
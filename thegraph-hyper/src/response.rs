use futures::prelude::*;
use hyper::{Body, Response};

use thegraph::common::query::QueryResult;
use thegraph::common::server::GraphQLServerError;

/// Future for HTTP responses to GraphQL query requests.
pub struct GraphQLResponse {
    result: Result<QueryResult, GraphQLServerError>,
}

impl GraphQLResponse {
    /// Creates a new GraphQLResponse future based on the result generated by
    /// running a query.
    pub fn new(result: Result<QueryResult, GraphQLServerError>) -> Self {
        GraphQLResponse { result }
    }
}

impl Future for GraphQLResponse {
    type Item = Response<Body>;
    type Error = GraphQLServerError;

    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        match self.result {
            // Query was successful -> return a mock response
            Ok(ref result) => Ok(Async::Ready({
                let data = format!("{:?}", result);
                Response::builder()
                    .status(200)
                    .body(Body::from(data))
                    .unwrap()
            })),

            // Query caused an error -> return a mock error response
            Err(ref e) => {
                let err = format!("{}", e);
                Ok(Async::Ready(
                    Response::builder()
                        .status(500)
                        .body(Body::from(err))
                        .unwrap(),
                ))
            }
        }
    }
}
